<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>请求库的安装</title>
      <link href="/2019/08/03/%E8%AF%B7%E6%B1%82%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2019/08/03/%E8%AF%B7%E6%B1%82%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>爬虫可以简单分为几步：抓取页面、分析页面和存储数据。</p><p>在抓取页面的过程中，我们需要模拟浏览器向服务器发出请求，所以需要用到一些Python库来实现HTTP请求操作。</p><p>我们要用到的第三方库有requests、Selenium和aiohttp等。</p><a id="more"></a><h2 id="requests库"><a href="#requests库" class="headerlink" title="requests库"></a>requests库</h2><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>Github：<a href="https://github.com/requests/requests" target="_blank" rel="noopener">https://github.com/requests/requests</a></li><li>PyPI：<a href="https://pypi.python.org/pypi/requests" target="_blank" rel="noopener">https://pypi.python.org/pypi/requests</a></li><li>官方文档：<a href="https://www.python-requests.org" target="_blank" rel="noopener">https://www.python-requests.org</a>  (需要科学上网)</li><li>中文文档：<a href="http://docs.python-requests.org/zh_CN/latest" target="_blank" rel="noopener">http://docs.python-requests.org/zh_CN/latest</a></li></ul><h3 id="pip安装-推荐"><a href="#pip安装-推荐" class="headerlink" title="pip安装(推荐)"></a>pip安装(推荐)</h3><p>在命令行界面中运行如下命令，即可完成requests库的安装。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip3 install requests<br></code></pre></td></tr></table></figure><h3 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h3><p>如果想要获取某一特定版本，可以选择下载源码安装。</p><p>requests项目的地址是：<a href="https://github.com/psf/requests" target="_blank" rel="noopener">https://github.com/psf/requests</a></p><p>可以通过Git来下载源代码：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/psf/requests.git<br></code></pre></td></tr></table></figure><p>下载完成后，进入目录，进行安装</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> requests<br>python3 setup.py install<br></code></pre></td></tr></table></figure><h3 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h3><p>进入Python命令行交互模式，导入requests包，如果没有报错，则证明安装成功：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python3<br>&gt;&gt;&gt; import requests<br></code></pre></td></tr></table></figure><h2 id="Selenium库"><a href="#Selenium库" class="headerlink" title="Selenium库"></a>Selenium库</h2><p>Selenium是一个自动化测试工具，利用它我们可以驱动浏览器执行特定的动作，如点击、下拉等操作。</p><p>对于一些JavaScript渲染的页面来说，这种抓取方式非常有效。</p><h3 id="相关链接-1"><a href="#相关链接-1" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>Github：<a href="https://github.com/SeleniumHQ/selenium/tree/master/py" target="_blank" rel="noopener">https://github.com/SeleniumHQ/selenium/tree/master/py</a></li><li>PyPI：<a href="https://pypi.org/project/selenium/" target="_blank" rel="noopener">https://pypi.org/project/selenium/</a></li><li>官方文档：<a href="https://selenium-python.readthedocs.io/" target="_blank" rel="noopener">https://selenium-python.readthedocs.io/</a></li><li>中文文档：<a href="https://selenium-python-zh.readthedocs.io/en/latest/" target="_blank" rel="noopener">https://selenium-python-zh.readthedocs.io/en/latest/</a></li></ul><h3 id="pip安装-推荐-1"><a href="#pip安装-推荐-1" class="headerlink" title="pip安装(推荐)"></a>pip安装(推荐)</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip3 install selenium<br></code></pre></td></tr></table></figure><h3 id="验证安装-1"><a href="#验证安装-1" class="headerlink" title="验证安装"></a>验证安装</h3><p>进入Python命令行交互模式，导入selenium包，如果没有报错，则证明安装成功：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python3<br>&gt;&gt;&gt; import selenium<br></code></pre></td></tr></table></figure><p>但是这样做还不够，还需要用浏览器(如Chrome、Firefox等)来配合Selenium工作。</p><h2 id="ChromeDriver的安装"><a href="#ChromeDriver的安装" class="headerlink" title="ChromeDriver的安装"></a>ChromeDriver的安装</h2><p>上一部已经安装好Selenium，但是它是一个自动化测试工具，需要浏览器来配合使用。</p><p>该节中我们就介绍一下Chrome浏览器及ChromeDriver驱动的配置。</p><h3 id="相关链接-2"><a href="#相关链接-2" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>官方网址：<a href="https://sites.google.com/a/chromium.org/chromedriver" target="_blank" rel="noopener">https://sites.google.com/a/chromium.org/chromedriver</a> (需要科学上网)</li><li>下载地址：<a href="https://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">https://chromedriver.storage.googleapis.com/index.html</a></li></ul><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>确保安装好Chrome浏览器并可以正常运行。</p><h3 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h3><p>点击Chrome菜单 “帮助” -&gt; “关于Google Chrome(G)”，即可查看Chrome的版本号，如下图所示。</p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E7%89%88%E6%9C%AC.png" width="70%"><p>这里我的版本号是 <em>75.0</em> ，这个版本号在选择ChromeDriver版本的时候会用到。</p><h3 id="下载ChromeDriver"><a href="#下载ChromeDriver" class="headerlink" title="下载ChromeDriver"></a>下载ChromeDriver</h3><p>打开<a href="https://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">下载链接</a>，选择对应的版本进行下载。</p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/ChromeDriver%E7%89%88%E6%9C%AC.png" width="70%"><h3 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h3><p>下载完成后，将ChromeDriver的可执行文件配置到环境变量下。</p><ul><li>在Windows下，建议直接将ChromeDriver.exe文件拖到Python的Scripts目录下。</li><li>在Linux和Mac下，需要将可执行文件配置到环境变量或将文件移动到属于环境变量的目录里。</li></ul><p>Mac配置：</p><p>方法一：</p><p>例如要移动文件到<code>/usr/bin</code>目录。首先需要在命令行模式下进入其所在路径，然后将其移动到<code>/usr/bin</code>：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo mv chromedriver /usr/bin<br></code></pre></td></tr></table></figure><p>另外，若系统为Mac OS X EI Capitan 10.11 及以上版本时，需要先关闭Rootless内核保护机制。具体操作如下：</p><ol><li>重启电脑后按住<code>command+R</code>进入恢复分区。</li><li>在<code>实用工具栏</code>找到<code>终端</code>启动运行。</li><li>输入：<code>csrutil disable; reboot</code>。</li><li>执行上述移动语句：<code>sudo mv chromedriver /usr/bin</code>。</li><li>重复执行1-2，在3中输入：<code>csrutil enable; reboot</code>，开启保护。</li></ol><p>方法二：</p><p>将ChromeDriver配置到<code>$PATH</code>：</p><ol><li><p>将可执行文件放到某一目录，目录可以任意选择。例如将当前可执行文件放在<code>/usr/local/chromedriver</code>目录下。</p></li><li><p>Linux修改<code>~/.profile</code>文件，mac修改<code>~/.bash_profile</code>文件，添加如下内容：</p><p> <code>export PATH=&quot;$PATH:/usr/local/chromedriver&quot;</code></p></li><li><p>保存后，</p><ul><li>在linux执行：<code>source ~/.profile</code></li><li>在mac执行：<code>source ~/.bash_profile</code></li></ul></li></ol><h3 id="验证安装-2"><a href="#验证安装-2" class="headerlink" title="验证安装"></a>验证安装</h3><p>配置完成后，可以在命令行中直接执行<code>chromedriver</code>命令了</p><p>如果输入控制台有如下所示的输出，则证明ChromeDriver的环境变量配置好了。</p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/chromedriver%E6%8E%A7%E5%88%B6%E5%8F%B0.png" width="70%"><p>随后再在程序中测试，执行如下Python代码：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br>browser = webdriver.Chrome()<br></code></pre></td></tr></table></figure><p>运行后，如果弹出一个空白的Chrome浏览器，则证明所有的配置都没有问题。如果没有弹出，则检查之前的每一步配置。</p><p>如果弹出后闪退，则可能是ChromeDriver版本和Chrome版本不兼容，请更换ChromeDriver版本。</p><h2 id="PhantomJS的安装"><a href="#PhantomJS的安装" class="headerlink" title="PhantomJS的安装"></a>PhantomJS的安装</h2><p>PhantomJS是一个无界面的、可脚本编程的WebKit浏览器引擎，它原生支持多种Web标准：DOM操作，CSS选择器，JSON，Canvas以及SVG。</p><p>Selenium支持PhantomJS，这样在运行的时候就不会再弹出一个浏览器了。而且PhantomJS的运行效率也很高，还支持各种参数配置，使用非常方便。</p><h3 id="相关链接-3"><a href="#相关链接-3" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>官方网站：<a href="http://phantomjs.org" target="_blank" rel="noopener">http://phantomjs.org</a></li><li>官方文档：<a href="https://phantomjs.org/quick-start.html" target="_blank" rel="noopener">https://phantomjs.org/quick-start.html</a></li><li>下载地址：<a href="https://phantomjs.org/download.html" target="_blank" rel="noopener">https://phantomjs.org/download.html</a></li><li>API接口说明：<a href="https://phantomjs.org/api/command-line.html" target="_blank" rel="noopener">https://phantomjs.org/api/command-line.html</a></li></ul><h3 id="下载PhantomJS"><a href="#下载PhantomJS" class="headerlink" title="下载PhantomJS"></a>下载PhantomJS</h3><p>在<a href="https://phantomjs.org/download.html" target="_blank" rel="noopener">下载页面</a>选择对应的操作系统版本进行下载，并将PhantomJS可执行文件所在的路径配置到环境变量里（与ChromeDriver安装一致）。</p><p>配置成功后，可以在命令行下测试，输入：<code>phantomjs</code></p><p>如果可以进入到PhantomJS的命令行，则证明配置完成。</p><h3 id="验证安装-3"><a href="#验证安装-3" class="headerlink" title="验证安装"></a>验证安装</h3><p>在Selenium中使用的话，只需要将Chrome切换成PhantomJS即可：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br>driver = webdriver.PhantomJS()<br>driver.get(<span class="hljs-string">"http://www.baidu.com/"</span>)<br>print(driver.current_url)<br></code></pre></td></tr></table></figure><p>运行之后就会发现没有浏览器弹出了，但实际上PhantomJS已经运行起来了。</p><p>这里我们访问了百度，然后将当前URL打印出来了。</p><p>控制台的输出为：<code>https://www.baidu.com</code></p><p>如此一来，我们便完成了PhantomJS的配置，后面可以利用它来完成一些页面的抓取。</p><h2 id="aiohttp库"><a href="#aiohttp库" class="headerlink" title="aiohttp库"></a>aiohttp库</h2><p>上述提到的requests库是一个阻塞式HTTP请求库。(当我们发出一个请求后，程序会一直等待服务器响应，直到得到响应后，程序才会进行下一步处理)。其实，这个过程比较耗费时间。</p><p>如果程序可以在这个等待过程中做一些其他事情，如进行请求的调度、响应的处理等，那么爬取的效率会大大提高。</p><p>aiohttp就是这样一个提供异步Web服务的库，从Python3.5版本开始，Python中加入了<code>async/await</code>关键字，使得回调的写法更加直观和人性化。aiohttp的异步操作借助于<code>async/await</code>关键字的写法变得更加简洁，架构更加清晰。使用异步请求库进行数据抓取时，会大大提高效率。</p><h3 id="相关链接-4"><a href="#相关链接-4" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>官方文档：<a href="http://aiohttp.readthedocs.io/en/stable" target="_blank" rel="noopener">http://aiohttp.readthedocs.io/en/stable</a></li><li>Github：<a href="https://github.com/aio-libs/aiohttp/" target="_blank" rel="noopener">https://github.com/aio-libs/aiohttp/</a></li><li>PyPI：<a href="https://pypi.org/project/aiohttp/3.5.4/" target="_blank" rel="noopener">https://pypi.org/project/aiohttp/3.5.4/</a></li></ul><h3 id="pip安装"><a href="#pip安装" class="headerlink" title="pip安装"></a>pip安装</h3><p>安装命令：<code>pip3 install aiohttp</code></p><p>另外，官方还推荐安装如下两个库：</p><ul><li>字符编码检测库<strong>cchardet</strong></li><li>加速DNS的解析库<strong>aiodns</strong></li></ul><p>安装命令：<code>pip3 install cchardet aiodns</code></p><h3 id="测试安装"><a href="#测试安装" class="headerlink" title="测试安装"></a>测试安装</h3><p>安装完成后，可以在Python命令行下测试：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python3<br>&gt;&gt;&gt;&gt; import aiohttp<br></code></pre></td></tr></table></figure><p>如果没有错误报出，则证明库已经安装好了。</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> 开发环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 开发环境配置 </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天一个linux命令(1): ls</title>
      <link href="/2019/08/03/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4-1-ls/"/>
      <url>/2019/08/03/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4-1-ls/</url>
      
        <content type="html"><![CDATA[<p>ls命令是linux下最常用的命令。ls命令就是list的缩写，缺省下ls用来打印出当前目录的清单，如果ls指定其他目录，那么就会显示指定目录里的文件及文件夹清单。</p><p>通过ls命令不仅可以查看linux文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限)、查看目录信息等等。ls命令在日常的linux操作中用的很多。</p><a id="more"></a><h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ls [选项] [目录名]<br></code></pre></td></tr></table></figure><h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p>列出目标目录中所有的子目录和文件。</p><h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-a,–all</td><td align="left">列出目录下的所有文件，包括以 . 开头的隐含文件</td></tr><tr><td align="left">-A</td><td align="left">同-a，但不列出“.”(表示当前目录)和“..”(表示当前目录的父目录)。</td></tr><tr><td align="left">-c  配合 -lt</td><td align="left">根据 ctime 排序及显示 ctime (文件状态最后更改的时间)配合 -lt：显示 ctime 但根据名称排序否则：根据 ctime 排序</td></tr><tr><td align="left">-C</td><td align="left">每栏由上至下列出项目</td></tr><tr><td align="left">-color[=WHEN]</td><td align="left">控制是否使用色彩分辨文件。WHEN 可以是’never’、’always’或’auto’其中之一</td></tr><tr><td align="left">-d,–directory</td><td align="left">将目录象文件一样显示，而不是显示其下的文件。</td></tr><tr><td align="left">-D,–dired</td><td align="left">产生适合 Emacs 的 dired 模式使用的结果</td></tr><tr><td align="left">-f</td><td align="left">对输出的文件不进行排序，-aU 选项生效，-lst 选项失效</td></tr><tr><td align="left">-g</td><td align="left">类似 -l,但不列出所有者</td></tr><tr><td align="left">-G, –no-group</td><td align="left">不列出任何有关组的信息</td></tr><tr><td align="left">-h,–human-readable</td><td align="left">以容易理解的格式列出文件大小 (例如 1K 234M 2G)</td></tr><tr><td align="left">–si</td><td align="left">类似 -h,但文件大小取 1000 的次方而不是 1024</td></tr><tr><td align="left">-H, –dereference-command-line</td><td align="left">使用命令列中的符号链接指示的真正目的地</td></tr><tr><td align="left">–indicator-style=&lt;方式&gt;</td><td align="left">指定在每个项目名称后加上指示符号&lt;方式&gt;：none (默认)，classify (-F)，file-type (-p)</td></tr><tr><td align="left">-i, –inode</td><td align="left">印出每个文件的 inode 号</td></tr><tr><td align="left">-I,–ignore=样式</td><td align="left">不印出任何符合 shell 万用字符&lt;样式&gt;的项目</td></tr><tr><td align="left">-k</td><td align="left">即 –block-size=1K,以 k 字节的形式表示文件的大小</td></tr><tr><td align="left">-l</td><td align="left">除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来。</td></tr><tr><td align="left">-L, –dereference</td><td align="left"></td></tr><tr><td align="left">-m</td><td align="left">所有项目以逗号分隔，并填满整行行宽</td></tr><tr><td align="left">-o</td><td align="left">类似 -l,显示文件的除组信息外的详细信息。</td></tr><tr><td align="left">-r, –reverse</td><td align="left">依相反次序排列</td></tr><tr><td align="left">-R, –recursive</td><td align="left">同时列出所有子目录层</td></tr><tr><td align="left">-s,–size</td><td align="left">以块大小为单位列出所有文件的大小</td></tr><tr><td align="left">-S</td><td align="left">根据文件大小排序</td></tr><tr><td align="left">–sort=WORD</td><td align="left">可选用的 WORD 和它们代表的相应选项： <br>extension -X status -c<br>none -U time -t<br>size -S atime -u<br>time -t access -u<br>version -v use -u</td></tr><tr><td align="left">-t</td><td align="left">以文件修改时间排序</td></tr><tr><td align="left">-u</td><td align="left">配合 -lt:显示访问时间而且依访问时间排序<br>配合 -l:显示访问时间但根据名称排序<br>否则：根据访问时间排序</td></tr><tr><td align="left">-U</td><td align="left">不进行排序;依文件系统原有的次序列出项目</td></tr><tr><td align="left">-v</td><td align="left">根据版本进行排序</td></tr><tr><td align="left">-w, –width=COLS</td><td align="left">自行指定屏幕宽度而不使用目前的数值</td></tr><tr><td align="left">-x</td><td align="left">逐行列出项目而不是逐栏列出</td></tr><tr><td align="left">-X</td><td align="left">根据扩展名排序</td></tr><tr><td align="left">-1</td><td align="left">每行只列出一个文件</td></tr><tr><td align="left">–help</td><td align="left">显示此帮助信息并离开</td></tr><tr><td align="left">–version</td><td align="left">显示版本信息并离开</td></tr></tbody></table><h2 id="常用范例"><a href="#常用范例" class="headerlink" title="常用范例"></a>常用范例</h2><p><code>例一</code>：<strong>列出/home/huben/ 文件夹下的所有文件和目录的详细信息</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ls -l -R /home/huben<br>$ ls -lR /home/huben<br></code></pre></td></tr></table></figure><p><code>例二</code>：<strong>列出当前目录中所有以“t”开头的目录的详细内容，可以使用如下命令</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ls -l t*<br></code></pre></td></tr></table></figure><p><code>例三</code>：<strong>只列出文件下的子目录</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ls -F /opt/soft |grep /$<br></code></pre></td></tr></table></figure><p><code>例四</code>：<strong>列出文件下的子目录详细情况</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ls -l /opt/soft | grep <span class="hljs-string">"^d"</span><br></code></pre></td></tr></table></figure><p><code>例五</code>：<strong>列出目前工作目录下所有名称是s 开头的文件，愈新的排愈后面，可以使用如下命令</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ls -ltr s*<br></code></pre></td></tr></table></figure><p><code>例六</code>：<strong>列出目前工作目录下所有档案及目录;目录于名称后加”/“, 可执行档于名称后加*</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ls -AF<br></code></pre></td></tr></table></figure><p><code>例七</code>：<strong>计算当前目录下的文件数和目录数</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ls -l * |grep <span class="hljs-string">"^-"</span>|wc -l    ---文件个数<br>$ ls -l * |grep <span class="hljs-string">"^d"</span>|wc -l    ---目录个数<br></code></pre></td></tr></table></figure><p><code>例八</code>：<strong>在ls中列出文件的绝对路径</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ls | sed <span class="hljs-string">"s:^:`pwd`/:"</span><br></code></pre></td></tr></table></figure><p><code>例九</code>：<strong>列出当前目录下的所有文件（包括隐藏文件）的绝对路径， 对目录不做递归</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ find <span class="hljs-variable">$PWD</span> -maxdepth 1 | xargs ls -ld<br></code></pre></td></tr></table></figure><p><code>例十</code>：<strong>列出当前目录下的所有文件（包括隐藏文件）的绝对路径， 对目录不做递归</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ find <span class="hljs-variable">$PWD</span> -maxdepth 1 | xargs ls -ld<br></code></pre></td></tr></table></figure><p><code>例十一</code>：<strong>递归列出当前目录下的所有文件（包括隐藏文件）的绝对路径</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ find <span class="hljs-variable">$PWD</span> | xargs ls -ld<br></code></pre></td></tr></table></figure><p><code>例十二</code>：<strong>指定文件时间输出格式</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ls -tl --time-style=full-iso<br>$ ls -ctl --time-style=long-iso<br><br>2016-08-05 22:17:06.020535551 +0800<br>2016-10-29 12:03<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> linux基础命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python多线程</title>
      <link href="/2019/08/03/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2019/08/03/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>本文主要介绍了以下内容:</strong></p><p>Python多线程相关基础</p><a id="more"></a><h2 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h2><p>Python中多线程用在IO密集型代码中。</p><ul><li>计算密集型：需要大量计算，绝大部分时间都消耗在CPU计算上，此时，无论开多少线程，所需要的时间就是那么多，甚至比原来时间还长，因为全局解释器锁(GIL)一个时刻只让跑一个线程，大部分计算密集型任务分了很多线程但是依然会按照代码顺序线性执行，甚至代码变得冗长了，反而使执行时间增加了。</li><li>IO密集型：90%以上的时间都花费在网络、硬盘、输入输出上，CPU执行完命令之后剩下的就不需要在CPU中跑了，就可以释放内存在跑下一条命令了。</li></ul><p>每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。</p><p>但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p><p>每个线程都有自己的一组CPU寄存器，称为线程的上下文，该上下文反映了线程上次运行该线程的CPU寄存器的状态。</p><p>指令指针和堆栈指针寄存器是线程上下文中两个最重要的寄存器，线程总是在进程得到上下文中运行的，这些地址都用于标志拥有线程的进程的进程地址空间中的内存。</p><ul><li>线程可以被抢断(中断)</li><li>在其他线程正在运行时，线程可以暂时搁置(也称为睡眠）— — 即线程的退让。</li></ul><p>线程可分为：</p><ul><li>内核线程：由操作系统内核创建和撤销。</li><li>用户线程：不需要内核支持而在用户程序中实现的线程。</li></ul><h2 id="Threading模块"><a href="#Threading模块" class="headerlink" title="Threading模块"></a>Threading模块</h2><h4 id="Threading模块对象"><a href="#Threading模块对象" class="headerlink" title="Threading模块对象"></a>Threading模块对象</h4><table><thead><tr><th align="center">对象</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Thread</td><td align="center">线程对象</td></tr><tr><td align="center">Lock</td><td align="center">互斥锁</td></tr><tr><td align="center">Condition</td><td align="center">条件变量</td></tr><tr><td align="center">Event</td><td align="center">事件，该事件发生后所有等待该事件的线程将被激活</td></tr><tr><td align="center">Semaphore</td><td align="center">信号量</td></tr><tr><td align="center">Timer</td><td align="center">定时器，运行前会等待一段时间</td></tr><tr><td align="center">Barrier</td><td align="center">创建一个障碍，必须达到指定数量的线程才开始运行</td></tr></tbody></table><h4 id="Threading模块的Thread类"><a href="#Threading模块的Thread类" class="headerlink" title="Threading模块的Thread类"></a>Threading模块的Thread类</h4><table><thead><tr><th align="center">对象</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">name</td><td align="center">线程名(属性)</td></tr><tr><td align="center">ident</td><td align="center">线程标识符(属性)</td></tr><tr><td align="center">daemon</td><td align="center">线程是否是守护线程(属性)</td></tr><tr><td align="center">_<em>init_</em>(group=None,tatget=None,name=None,args=(),kwargs={},verbose=None,daemon=None)</td><td align="center">实例化一个线程对象，需要有一个可调用的target，以及其参数args或kwargs。还可以传递name或group参数，不过后者还未实现。此外，verbose标志也是可接受的。而daemon的值将会设定thread.daemon属性/标志</td></tr><tr><td align="center">start()</td><td align="center">开启线程活动</td></tr><tr><td align="center">run()</td><td align="center">定义线程活动的方法(通常在子类中被应用开发者重写)</td></tr><tr><td align="center">join([time])</td><td align="center">等待至线程中止。阻塞调用线程直至线程的join()方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生</td></tr><tr><td align="center">Barrier</td><td align="center">创建一个障碍，必须达到指定数量线程才开始运行</td></tr><tr><td align="center">isAlive()</td><td align="center">返回线程是否活动的</td></tr><tr><td align="center">getName()</td><td align="center">返回线程名</td></tr><tr><td align="center">setName()</td><td align="center">设置线程名</td></tr></tbody></table><h5 id="Threading模块常用方法"><a href="#Threading模块常用方法" class="headerlink" title="Threading模块常用方法"></a>Threading模块常用方法</h5><ol><li>threading.Lock()</li></ol><p>如果多个线程共同对某个数据修改，则可能出现不可预料的结果，为了保证数据的正确性，需要对多个线程进行同步。</p><p>使用Thread对象的<code>Lock</code>和<code>RLock</code>可以实现简单的线程同步，这两个对象都有<code>acquire</code>方法和<code>release</code>方法，对于那些需要每次只允许一个线程操作的数据，可以将其放到<code>acquire</code>和<code>release</code>方法之间。</p><p>多个线程同时操作一个变量可能会把内容给改乱了</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><br><span class="hljs-keyword">import</span> time, threading<br><br><span class="hljs-comment"># 假定这是你的银行存款:</span><br>balance = <span class="hljs-number">0</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">change_it</span><span class="hljs-params">(n)</span>:</span><br>    <span class="hljs-comment"># 先存后取，结果应该为0:</span><br>    <span class="hljs-keyword">global</span> balance<br>    balance = balance + n<br>    balance = balance - n<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_thread</span><span class="hljs-params">(n)</span>:</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1000000</span>):<br>        change_it(n)<br><br><br>t1 = threading.Thread(target=run_thread, args=(<span class="hljs-number">5</span>,))<br>t2 = threading.Thread(target=run_thread, args=(<span class="hljs-number">8</span>,))<br>t1.start()<br>t2.start()<br>t1.join()<br>t2.join()<br>print(balance)<br></code></pre></td></tr></table></figure><p>上述代码中首先定义了一个共享变量<strong>balance</strong>，初始值为0，并且启动两个线程，先存后取，理论上结果应该为0。但是，由于线程的调度是由操作系统决定的，当<strong>t1</strong>,<strong>t2</strong>交替执行时，只要循环次数足够多，<strong>balance</strong>的结果就不一定是0了。</p><p>如果要确保balance计算争取，就要给<code>change_it()</code>上一把锁，当某个线程开始执行<code>change_it()</code>时，由于该进程获得了锁，因此其他线程不能同时执行<code>change_it()</code>，只能等待，直到锁被释放后，获得该锁以后才能改。</p><p>由于锁只有一个，无论多少线程，同一时刻最多只有一个线程持有该锁，所以，不会造成修改的冲突。</p><p>创建一个锁就是<code>threading.Lock()</code>来实现</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><br><span class="hljs-keyword">import</span> time, threading<br><br>balance = <span class="hljs-number">0</span><br>lock = threading.Lock()<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">change_it</span><span class="hljs-params">(n)</span>:</span><br>    <span class="hljs-comment"># 先存后取，结果应该为0:</span><br>    <span class="hljs-keyword">global</span> balance<br>    balance = balance + n<br>    balance = balance - n<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_thread</span><span class="hljs-params">(n)</span>:</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1000000</span>):<br>        <span class="hljs-comment"># 先要获取锁:</span><br>        lock.acquire()<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 放心地改吧:</span><br>            change_it(n)<br>        <span class="hljs-keyword">finally</span>:<br>            <span class="hljs-comment"># 改完了一定要释放锁:</span><br>            lock.release()<br><br><br>t1 = threading.Thread(target=run_thread, args=(<span class="hljs-number">5</span>,))<br>t2 = threading.Thread(target=run_thread, args=(<span class="hljs-number">8</span>,))<br>t1.start()<br>t2.start()<br>t1.join()<br>t2.join()<br>print(balance)<br></code></pre></td></tr></table></figure><p>当多个线程同时执行<code>lock.acquire()</code>时，只有一个线程能成功地获取锁，然后继续执行代码，其他线程就继续等待直到获得锁为止。</p><p>获得锁的线程用完后一定要释放锁，否则那些苦苦等待锁的线程将永远等待下去，成为死线程。此处可以用try…finally来确保锁一定会被释放。</p><p>锁的好处就是确保了某段关键代码只能由一个线程从头到尾完整地执行，坏处当然也有很多：</p><ul><li>首先是阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了。</li><li>其次，由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁，导致多个线程全部挂起，既不能执行，也无法结束，只能靠操作系统强制终止。</li></ul><ol start="2"><li>threading.RLock()</li></ol><p>RLock允许在同一线程中被多次<code>acquire</code>。而Lock却不允许这种情况。注意：如果使用RLock，那么<code>acquire</code>和<code>release</code>必须成对出现，即调用了n次<code>acquire</code>，必须调用n次的<code>release</code>才能真正释放所占用的锁。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br>lock = threading.Lock() <br><span class="hljs-comment">#Lock对象</span><br>lock.acquire()<br>lock.acquire() <br><span class="hljs-comment">#产生了死琐。</span><br>lock.release()<br>lock.release()<br>  <br><span class="hljs-keyword">import</span> threading<br>rLock = threading.RLock() <br><span class="hljs-comment">#RLock对象</span><br>rLock.acquire()<br>rLock.acquire() <br><span class="hljs-comment">#在同一线程内，程序不会堵塞。</span><br>rLock.release()<br>rLock.release()<br></code></pre></td></tr></table></figure><ol start="3"><li>threading.Condition()</li></ol><p>可以把Condition理解为一把高级的锁，它提供了比Lock，RLock更高级的功能，允许我们能够控制复杂的线程同步问题。threading.Condition在内部维护一个锁对象(默认是RLock)，可以在创建Condition对象的时候把锁对象作为参数传入。Condition也提供了<code>acquire</code>，<code>release</code>方法，其含义与锁的<code>acquire</code>，<code>release</code>方法一致，其实它只是简单的调用内部锁对象的对应的方法而已。Condition还提供<code>wait</code>方法、<code>notify</code>方法、<code>notifyAll</code>方法(特别要注意：这些方法只有在占用锁(<code>acquire</code>)之后才能调用，否则将会报<code>RuntimeError</code>异常。)</p><blockquote><p><code>acquire()</code>/<code>release()</code>：获得/释放 Lock</p><p><code>wait([timeout])</code>：线程挂起，直到收到一个<code>notify</code>通知或者超时(可选的，浮点数，单位是秒s)才会被唤醒继续执行。<strong><code>wait()</code>必须在已获得Lock前提下才能调用，否则会触发RuntimeError。调用<code>wait()</code>释放Lock，直至该线程被<code>Notify()</code>、<code>NotifyAll()</code>或者超时线程又重新获得Lock</strong>。</p></blockquote><blockquote><p><code>notify(n=1)</code>通知其他线程，那些挂起的线程接到这个通知之后会开始运行，默认是通知一个正等待该condition的线程，最多唤醒n个等待的线程。</p><p><strong><code>notify()</code>必须在已获得Lock前提下才能调用，否则会触发RuntimeError。<code>notify()</code>不会主动释放Lock</strong></p></blockquote><blockquote><p><code>notifyAll()</code>如果wait状态线程比较多，notifyAll的作用就是通知所有线程(这个一般用的比较少)</p></blockquote><p>捉迷藏游戏：</p><p>假设该游戏有两个人玩，一个藏(Hider)，一个找(Seeker)。</p><p>游戏规则如下：</p><ul><li>游戏开始后，Seeker先把自己眼睛蒙上，蒙上眼睛后，就通知Hider；</li><li>Hider接收到通知后开始找地方将自己藏起来，藏好之后，再通知Seeker可以找了；</li><li>Seeker就收到通知后，就开始找Hider</li></ul><p>Hider和Seeker都是独立的个体，在程序中用两个独立的线程表示，在游戏过程中，两者之间的行为有一定的时序关系，我们可以通过Condition来控制这种关系。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Seeker</span><span class="hljs-params">(cond, name)</span>:</span><br>    time.sleep(<span class="hljs-number">2</span>)<br>    cond.acquire()<br>    print(<span class="hljs-string">'%s :我已经把眼睛蒙上了！'</span> % name)<br>    cond.notify()<br>    cond.wait()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):<br>        print(<span class="hljs-string">'%s is finding!!!'</span> % name)<br>        time.sleep(<span class="hljs-number">2</span>)<br>    cond.notify()<br>    cond.release()<br>    print(<span class="hljs-string">'%s :我赢了！'</span> % name)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Hider</span><span class="hljs-params">(cond, name)</span>:</span><br>    cond.acquire()<br>    cond.wait()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>):<br>        print(<span class="hljs-string">'%s is hiding!!!'</span> % name)<br>        time.sleep(<span class="hljs-number">3</span>)<br>    print(<span class="hljs-string">'%s :我已经藏好了，你快来找我吧！'</span> % name)<br>    cond.notify()<br>    cond.wait()<br>    cond.release()<br>    print(<span class="hljs-string">'%s :被你找到了，唉~^~!'</span> % name)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    cond = threading.Condition()<br>    seeker = threading.Thread(target=Seeker, args=(cond, <span class="hljs-string">'seeker'</span>))<br>    hider = threading.Thread(target=Hider, args=(cond, <span class="hljs-string">'hider'</span>))<br>    seeker.start()<br>    hider.start()<br></code></pre></td></tr></table></figure><ol start="4"><li>threading.Semaphore和BoundedSemaphore</li></ol><p>Semaphore：Semaphore在内部管理者一个计数器。调用<code>acquire()</code>会使这个计数器-1，<code>release()</code>则是+1(可以多次<code>release()</code>，所以计数器的值理论上可以无限)，计数器的值永远不会小于0，当计数器到0时，再调用<code>acquire()</code>就会阻塞，直到其他线程来调用<code>release()</code></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(n)</span>:</span><br>    <span class="hljs-comment"># 获得信号量，信号量减一</span><br>    semaphore.acquire()<br>    time.sleep(<span class="hljs-number">1</span>)<br>    print(<span class="hljs-string">"run the thread: %s"</span> % n)<br><br>    <span class="hljs-comment"># 释放信号量，信号量加一</span><br>    semaphore.release()<br>    <span class="hljs-comment"># semaphore.release()    # 可以多次释放信号量，每次释放计数器+1</span><br>    <span class="hljs-comment"># semaphore.release()    # 可以多次释放信号量，每次释放计数器+1</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br><br>    num = <span class="hljs-number">0</span><br>    semaphore = threading.Semaphore(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 最多允许2个线程同时运行(即计数器值)；在多次释放信号量后，计数器值增加后每次可以运行的线程数也会增加</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">20</span>):<br>        t = threading.Thread(target=run, args=(i,))<br>        t.start()<br><br><span class="hljs-keyword">while</span> threading.active_count() != <span class="hljs-number">1</span>:<br>    <span class="hljs-keyword">pass</span>  <span class="hljs-comment"># print threading.active_count()</span><br><span class="hljs-keyword">else</span>:<br>    print(<span class="hljs-string">'----all threads done---'</span>)<br>    print(num)<br></code></pre></td></tr></table></figure><p>BoundedSemaphore：类似于Semaphore，不同在于BoundedSemaphore会检查内部计数器的值，并保证它不会大于初始值，如果超了，就引发一个ValueError。</p><p>多数情况下，semaphore用于守护限制(但不限于1)的资源，如果semaphore被<code>release()</code>过多次，这意味着存在bug</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(n)</span>:</span><br>    semaphore.acquire()<br>    time.sleep(<span class="hljs-number">1</span>)<br>    print(<span class="hljs-string">"run the thread: %s"</span> % n)<br>    semaphore.release()<br>    <span class="hljs-comment"># 如果再次释放信号量，信号量加一，这是超过限定的信号量数目，这时会报错ValueError: Semaphore released too many times</span><br>    <span class="hljs-comment"># semaphore.release()</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br><br>    num = <span class="hljs-number">0</span><br>    semaphore = threading.BoundedSemaphore(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 最多允许2个线程同时运行</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">20</span>):<br>        t = threading.Thread(target=run, args=(i,))<br>        t.start()<br><br><span class="hljs-keyword">while</span> threading.active_count() != <span class="hljs-number">1</span>:<br>    <span class="hljs-keyword">pass</span>  <span class="hljs-comment"># print threading.active_count()</span><br><span class="hljs-keyword">else</span>:<br>    print(<span class="hljs-string">'----all threads done---'</span>)<br>    print(num)<br></code></pre></td></tr></table></figure><ol start="5"><li>threading.Event</li></ol><p>时间处理的机制：全局定义了一个”Flag”，如果“Flag“值为False，那么当程序执行<code>event.wait</code>方法时就会阻塞；如果”Flag”值为True，那么执行<code>event.wait</code>方法时便不再阻塞。</p><ul><li>clear：将”Flag”设置为False</li><li>set：将”Flag”设置为True</li></ul><p>用threading.Event实现线程间通信，使用threading.Event可以使一个线程等待其他线程的通知，我们把这个Event传递到线程对象中。</p><p>Event默认内置了一个标志，初始值为False。一旦该线程通过<code>wait()</code>方法进入等待状态，知道另一个线程调用该Event的<code>set()</code>方法将内置标志设置为True时，该Event会通知所有等待状态的线程恢复运行。</p><p>通过Event来实现两个或多个线程间的交互，下面是一个红绿灯的例子，即启动一个线程做交通指挥灯，生成几个线程做车辆，车辆行驶按红灯停，绿灯行的规则。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time<br><span class="hljs-keyword">import</span> random<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">light</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> event.isSet():  <span class="hljs-comment"># 初始化evet的flag为真</span><br>        event.set()  <span class="hljs-comment"># wait就不阻塞 #绿灯状态</span><br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">if</span> count &lt; <span class="hljs-number">10</span>:<br>            print(<span class="hljs-string">'\033[42;1m---green light on---\033[0m'</span>)<br>        <span class="hljs-keyword">elif</span> count &lt; <span class="hljs-number">13</span>:<br>            print(<span class="hljs-string">'\033[43;1m---yellow light on---\033[0m'</span>)<br>        <span class="hljs-keyword">elif</span> count &lt; <span class="hljs-number">20</span>:<br>            <span class="hljs-keyword">if</span> event.isSet():<br>                event.clear()<br>            print(<span class="hljs-string">'\033[41;1m---red light on---\033[0m'</span>)<br>        <span class="hljs-keyword">else</span>:<br>            count = <span class="hljs-number">0</span><br>            event.set()  <span class="hljs-comment"># 打开绿灯</span><br>        time.sleep(<span class="hljs-number">1</span>)<br>        count += <span class="hljs-number">1</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">car</span><span class="hljs-params">(n)</span>:</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>        time.sleep(random.randrange(<span class="hljs-number">3</span>, <span class="hljs-number">10</span>))<br>        <span class="hljs-comment"># print(event.isSet())</span><br>        <span class="hljs-keyword">if</span> event.isSet():<br>            print(<span class="hljs-string">"car [%s] is running..."</span> % n)<br>        <span class="hljs-keyword">else</span>:<br>            print(<span class="hljs-string">'car [%s] is waiting for the red light...'</span> % n)<br>            event.wait()  <span class="hljs-comment"># 红灯状态下调用wait方法阻塞，汽车等待状态</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    car_list = [<span class="hljs-string">'BMW'</span>, <span class="hljs-string">'AUDI'</span>, <span class="hljs-string">'SANTANA'</span>]<br>    event = threading.Event()<br>    Light = threading.Thread(target=light)<br>    Light.start()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> car_list:<br>        t = threading.Thread(target=car, args=(i,))<br>        t.start()<br></code></pre></td></tr></table></figure><ol start="6"><li>threading.active_count()</li></ol><p>返回当前存活的线程对象数量；通过计算len(threading.enumerate())长度而来</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">()</span>:</span><br>    thread = threading.current_thread()<br>    print(<span class="hljs-string">'%s is running...'</span>% thread.getName())    <span class="hljs-comment">#返回线程名称</span><br>    time.sleep(<span class="hljs-number">10</span>)    <span class="hljs-comment">#休眠10S方便统计存活线程数量</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    <span class="hljs-comment">#print('The current number of threads is: %s' % threading.active_count())</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):<br>        print(<span class="hljs-string">'The current number of threads is: %s'</span> % threading.active_count())    <span class="hljs-comment">#返回当前存活线程数量</span><br>        thread_alive = threading.Thread(target=run, name=<span class="hljs-string">'Thread-***%s***'</span> % i)<br>        thread_alive.start()<br>    thread_alive.join()<br>    print(<span class="hljs-string">'\n%s thread is done...'</span>% threading.current_thread().getName())<br></code></pre></td></tr></table></figure><ol start="7"><li>threading.current_thread()</li></ol><p>返回当前线程对象</p><p>继承线程threading方法；通过help(threading.current_thread())查看</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(n)</span>:</span><br>    thread = threading.current_thread()<br>    thread.setName(<span class="hljs-string">'Thread-***%s***'</span> % n)  <span class="hljs-comment"># 自定义线程名称</span><br>    print(<span class="hljs-string">'-'</span> * <span class="hljs-number">30</span>)<br>    print(<span class="hljs-string">"Pid is :%s"</span> % thread.ident)  <span class="hljs-comment"># 返回线程pid</span><br>    <span class="hljs-comment"># print('ThreadName is :%s' % thread.name)  # 返回线程名称</span><br>    print(<span class="hljs-string">'ThreadName is :%s'</span> % thread.getName())  <span class="hljs-comment"># 返回线程名称</span><br>    time.sleep(<span class="hljs-number">2</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    <span class="hljs-comment"># print('The current number of threads is: %s' % threading.active_count())</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):<br>        <span class="hljs-comment"># print('The current number of threads is: %s' % threading.active_count())    #返回当前存活线程数量</span><br>        thread_alive = threading.Thread(target=run, args=(i,))<br>        thread_alive.start()<br>    thread_alive.join()<br>    print(<span class="hljs-string">'\n%s thread is done...'</span> % threading.current_thread().getName())<br></code></pre></td></tr></table></figure><ol start="8"><li>threading.enumerate()</li></ol><p>返回当前存在的所有线程对象的列表</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(n)</span>:</span><br>    thread = threading.current_thread()<br>    thread.setName(<span class="hljs-string">'Thread-***%s***'</span> % n)<br>    print(<span class="hljs-string">'-'</span> * <span class="hljs-number">30</span>)<br>    print(<span class="hljs-string">"Pid is :%s"</span> % thread.ident)  <span class="hljs-comment"># 返回线程pid</span><br>    <span class="hljs-comment"># print('ThreadName is :%s' % thread.name)  # 返回线程名称</span><br>    print(<span class="hljs-string">'ThreadName is :%s'</span> % threading.enumerate())  <span class="hljs-comment"># 返回所有线程对象列表</span><br>    time.sleep(<span class="hljs-number">2</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    <span class="hljs-comment"># print('The current number of threads is: %s' % threading.active_count())</span><br>    threading.main_thread().setName(<span class="hljs-string">'Chengd---python'</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):<br>        <span class="hljs-comment"># print('The current number of threads is: %s' % threading.active_count())    #返回当前存活线程数量</span><br>        thread_alive = threading.Thread(target=run, args=(i,))<br>        thread_alive.start()<br>    thread_alive.join()<br>    print(<span class="hljs-string">'\n%s thread is done...'</span> % threading.current_thread().getName())<br></code></pre></td></tr></table></figure><ol start="9"><li>threading.get_ident()</li></ol><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(n)</span>:</span><br>    print(<span class="hljs-string">'-'</span> * <span class="hljs-number">30</span>)<br>    print(<span class="hljs-string">"Pid is :%s"</span> % threading.get_ident())  <span class="hljs-comment"># 返回线程pid</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    threading.main_thread().setName(<span class="hljs-string">'Chengd---python'</span>)  <span class="hljs-comment"># 自定义线程名</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):<br>        thread_alive = threading.Thread(target=run, args=(i,))<br>        thread_alive.start()<br>    thread_alive.join()<br>    print(<span class="hljs-string">'\n%s thread is done...'</span> % threading.current_thread().getName())  <span class="hljs-comment"># 获取线程名</span><br></code></pre></td></tr></table></figure><ol start="10"><li>threading.main_thread()</li></ol><p>返回主线程对象，类似threading.current_thread()；只不过一个是返回当前线程对象，一个是返回主线程对象。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(n)</span>:</span><br>    print(<span class="hljs-string">'-'</span> * <span class="hljs-number">30</span>)<br>    print(<span class="hljs-string">"Now Pid is :%s"</span> % threading.current_thread().ident)  <span class="hljs-comment"># 返回当前线程pid</span><br>    print(<span class="hljs-string">"Main Pid is :%s"</span> % threading.main_thread().ident)  <span class="hljs-comment"># 返回主线程pid</span><br>    print(<span class="hljs-string">'Now thread is %s...'</span> % threading.current_thread().getName())  <span class="hljs-comment"># 获取当前线程名</span><br>    print(<span class="hljs-string">'Main thread is %s...'</span> % threading.main_thread().getName())  <span class="hljs-comment"># 获取主线程线程名</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    threading.main_thread().setName(<span class="hljs-string">'Chengd---python'</span>)  <span class="hljs-comment"># 自定义线程名</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):<br>        thread_alive = threading.Thread(target=run, args=(i,))<br>        thread_alive.start()<br>        time.sleep(<span class="hljs-number">2</span>)<br>    thread_alive.join()<br></code></pre></td></tr></table></figure><h4 id="Threading模块的Thread类方法"><a href="#Threading模块的Thread类方法" class="headerlink" title="Threading模块的Thread类方法"></a>Threading模块的Thread类方法</h4><table><thead><tr><th align="center">类方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">threading.currentThread()</td><td>返回当前的线程变量</td></tr><tr><td align="center">threading.enumerate()</td><td>返回一个包含正在运行的线程的list，正在运行指线程启动后、结束前，不包括启动前和终止后的线程</td></tr><tr><td align="center">threading.activeCount()</td><td>返回正在运行的线程数量，与len(threading.enumerate())有相同的结果</td></tr></tbody></table><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-comment"># 继承类threading.Thread</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(threading.Thread)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, n)</span>:</span><br>        <span class="hljs-comment"># 这里要继承构造函数</span><br>        super(MyThread, self).__init__()<br>        <span class="hljs-comment"># 可以定义自己的实例变量</span><br>        self.n = n<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span><br>        print(<span class="hljs-string">'running task'</span>, self.n)<br>        time.sleep(<span class="hljs-number">2</span>)<br><br><br>t1 = MyThread(<span class="hljs-string">'t1'</span>)<br>t2 = MyThread(<span class="hljs-string">'t2'</span>)<br><br>t1.start()<br>t2.start()<br></code></pre></td></tr></table></figure><p>这样就实现了通过继承父类的方式使用多线程，这里注意的几个点：</p><ul><li>继承类之后还要继承构造函数</li><li>这里的<code>run</code>函数时重写的，所以说<code>t1.start()</code>之后才会自动调用<code>run</code>函数</li><li>线程是通过start()函数激活，而不是对象建立时激活的！</li></ul><p>循环创建多个进程</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-comment"># 继承类threading.Thread</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(threading.Thread)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, n)</span>:</span><br>        <span class="hljs-comment"># 这里要继承构造函数</span><br>        super(MyThread, self).__init__()<br>        <span class="hljs-comment"># 可以定义自己的实例变量</span><br>        self.n = n<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span><br>        print(<span class="hljs-string">'running task'</span>, self.n)<br>        time.sleep(<span class="hljs-number">2</span>)<br><br><br><span class="hljs-comment"># t1 = MyThread('t1')</span><br><span class="hljs-comment"># t2 = MyThread('t2')</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">50</span>):<br>    t = MyThread(i)<br>    t.start()<br><br><span class="hljs-comment"># t1.start()</span><br><span class="hljs-comment"># t2.start()</span><br></code></pre></td></tr></table></figure><h4 id="计算这些线程执行所花费的时间join"><a href="#计算这些线程执行所花费的时间join" class="headerlink" title="计算这些线程执行所花费的时间join()"></a>计算这些线程执行所花费的时间<code>join()</code></h4><p>能够使主线程等待子线程的执行完毕才会继续主线程</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-comment"># 继承类threading.Thread</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(threading.Thread)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, n)</span>:</span><br>        <span class="hljs-comment"># 这里要继承构造函数</span><br>        super(MyThread, self).__init__()<br>        <span class="hljs-comment"># 可以定义自己的实例变量</span><br>        self.n = n<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span><br>        print(<span class="hljs-string">'running task'</span>, self.n)<br>        time.sleep(<span class="hljs-number">2</span>)<br><br><br><span class="hljs-comment"># 得到开始时间</span><br>start_time = time.time()<br><span class="hljs-comment"># 声明空列表</span><br>threads = []<br><br><span class="hljs-comment"># 循环开启50线程</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">50</span>):<br>    t = MyThread(i)<br>    t.start()<br>    <span class="hljs-comment"># 线程实例放入列表中</span><br>    threads.append(t)<br><br><span class="hljs-comment"># 对线程实例所在列表再循环</span><br><span class="hljs-keyword">for</span> res <span class="hljs-keyword">in</span> threads:<br>    <span class="hljs-comment"># 对每一个实例使用jion()方法</span><br>    res.join()<br><span class="hljs-comment"># 获得结束时间</span><br>end_time = time.time()<br><span class="hljs-comment"># 计算花费时间</span><br>spend_time = end_time - start_time<br><span class="hljs-comment"># 打印花费时间</span><br>print(spend_time)<br></code></pre></td></tr></table></figure><p>这里需要注意的点就是<code>join()</code>方法不能在线程启动之后就使用，这样的话50个线程就会变成串行，必须要等50个线程全部启动之后才能使用<code>join()</code>方法，这里就用到了一个小技巧新建了一个空列表，再将50个线程实例放进去，这样后面就可以实现对这50个线程使用<code>join()</code>方法了。</p><h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><p>多线程的优势在于可以同时运行多个任务(至少感觉起来是这样)。但是当线程需要共享数据时，可能存在数据不同步的问题。</p><p>使用Threading对象的Lock和Rlock可以实现简单的线程同步，这两个对象都有<code>acquire</code>方法和<code>release</code>方法，对于那些需要每次只允许一个线程操作的数据，可以将其操作放到acquire和release方法之间。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time<br><br><span class="hljs-comment"># 创建锁</span><br>threadLock = threading.Lock()<br><span class="hljs-comment"># 创建线程列表</span><br>threads = []<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myThread</span><span class="hljs-params">(threading.Thread)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, threadID, name, counter)</span>:</span><br>        threading.Thread.__init__(self)<br>        self.threadID = threadID<br>        self.name = name<br>        self.counter = counter<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span><br>        print(<span class="hljs-string">"Thread Start: "</span> + self.name)<br>        <span class="hljs-comment"># 获取锁，同步线程</span><br>        threadLock.acquire()<br>        print_time(self.name, self.counter, <span class="hljs-number">3</span>)<br>        <span class="hljs-comment"># 释放锁，开启下一个线程</span><br>        threadLock.release()<br>        print(<span class="hljs-string">"Thread Exit: "</span> + self.name)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_time</span><span class="hljs-params">(threadName, delay, counter)</span>:</span><br>    <span class="hljs-keyword">while</span> counter:<br>        time.sleep(delay)<br>        print(<span class="hljs-string">"&#123;&#125;: &#123;&#125;"</span>.format(threadName, time.ctime()))<br>        counter -= <span class="hljs-number">1</span><br><br><br><span class="hljs-comment"># 创建线程</span><br>thread1 = myThread(<span class="hljs-number">1001</span>, <span class="hljs-string">"Thread-1"</span>, <span class="hljs-number">1</span>)<br>thread2 = myThread(<span class="hljs-number">1002</span>, <span class="hljs-string">"Thread-2"</span>, <span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 开启线程</span><br>thread1.start()<br>thread2.start()<br><br><span class="hljs-comment"># 添加线程列表</span><br>threads.append(thread1)<br>threads.append(thread2)<br><br><span class="hljs-comment"># 等待所有线程完成</span><br><span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads:<br>    t.join()<br>print(<span class="hljs-string">"exit"</span>)<br></code></pre></td></tr></table></figure><h5 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h5><p>同一个进程下的线程数据之间可以共享，多线程中GIL锁，一个时刻只有一线程在运行，所以说就是有很多线程在修改这些共享数据。</p><p>当开启了很多个线程，当这些线程一起修改全局变量的时候，最后得出的结果可能跟期望的不太一样。</p><p>Python提供了另一把锁，给用户的锁，叫做<strong>线程锁</strong>，可以在多个线程操作共享数据时更加有规律，来防止操作数据失误的情况出现。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-comment"># 获取锁</span><br>    lock.acquire()<br>    <span class="hljs-comment"># 声明全局变量num</span><br>    <span class="hljs-keyword">global</span> num<br>    <span class="hljs-comment"># num+=1</span><br>    num += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 释放锁</span><br>    lock.release()<br><br><br><span class="hljs-comment"># 生成线程锁实例</span><br>lock = threading.Lock()<br>num = <span class="hljs-number">0</span><br><br><span class="hljs-comment"># 开启1000个线程</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1000</span>):<br>    t = threading.Thread(target=run)<br>    t.start()<br><br>print(<span class="hljs-string">"-----all thread has finshed"</span>)<br>print(<span class="hljs-string">"num:"</span>, num)<br></code></pre></td></tr></table></figure><p>注意获取锁与释放锁之间的这一段锁操作的数据量不是很大，如果数据量很大，需要的时间很多，那么程序就会变成串行。</p><h5 id="递归锁"><a href="#递归锁" class="headerlink" title="递归锁"></a>递归锁</h5><p>在我们分出一个线程，使用线程锁之后里面再调用别的函数，然后调用的这个函数中再使用线程锁的话就不能在使用Lock()实例了， 不然就会出现死循环错误，这是因为一把锁对应一个钥匙，锁里面再加一把锁就会导致程序分不清哪把钥匙开哪把锁，导致程序一直在锁中出不来，如下：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run1</span><span class="hljs-params">()</span>:</span><br>    print(<span class="hljs-string">"grab the first part data"</span>)<br>    <span class="hljs-comment"># 获取锁</span><br>    lock.acquire()<br>    <span class="hljs-keyword">global</span> num<br>    num += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 释放锁</span><br>    lock.release()<br>    <span class="hljs-keyword">return</span> num<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run2</span><span class="hljs-params">()</span>:</span><br>    print(<span class="hljs-string">"grab the second part data"</span>)<br>    <span class="hljs-comment"># 获取锁</span><br>    lock.acquire()<br>    <span class="hljs-keyword">global</span> num2<br>    num2 += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 释放锁</span><br>    lock.release()<br>    <span class="hljs-keyword">return</span> num2<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run3</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-comment"># 获取锁</span><br>    lock.acquire()<br>    <span class="hljs-comment"># 去跑run1</span><br>    res = run1()<br>    print(<span class="hljs-string">'--------between run1 and run2-----'</span>)<br>    <span class="hljs-comment"># 去跑run2</span><br>    res2 = run2()<br>    <span class="hljs-comment"># 释放锁</span><br>    lock.release()<br>    print(res, res2)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    <span class="hljs-comment"># 初始化两个为0的变量</span><br>    num, num2 = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 生成lock实例</span><br>    lock = threading.Lock()<br>    <span class="hljs-comment"># 开始10个线程</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):<br>        <span class="hljs-comment"># 线程跑的是run3</span><br>        t = threading.Thread(target=run3)<br>        t.start()<br><br><span class="hljs-comment"># 判读是否有多个线程，有多个就继续打印，只剩一个说明子线程都执行完了，只剩主线程了，然后跳出循环程序结束</span><br><span class="hljs-comment"># 可以用之前学到的join()方法来实现一样的效果</span><br><span class="hljs-keyword">while</span> threading.active_count() != <span class="hljs-number">1</span>:<br>    print(threading.active_count())<br><span class="hljs-keyword">else</span>:<br>    print(<span class="hljs-string">'----all threads done---'</span>)<br>    print(num, num2)<br></code></pre></td></tr></table></figure><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Iimage3.png" width="50%"><p>可以看到一直在打印线程数11，说明一直有11个线程在活跃，说明分出的10个线程一直在运行不结束，这个时候就不能使用<code>Lock()</code>了，而是使用<code>RLock()</code></p><p>修改后结果：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run1</span><span class="hljs-params">()</span>:</span><br>    print(<span class="hljs-string">"grab the first part data"</span>)<br>    <span class="hljs-comment"># 获取锁</span><br>    lock.acquire()<br>    <span class="hljs-keyword">global</span> num<br>    num += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 释放锁</span><br>    lock.release()<br>    <span class="hljs-keyword">return</span> num<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run2</span><span class="hljs-params">()</span>:</span><br>    print(<span class="hljs-string">"grab the second part data"</span>)<br>    <span class="hljs-comment"># 获取锁</span><br>    lock.acquire()<br>    <span class="hljs-keyword">global</span> num2<br>    num2 += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 释放锁</span><br>    lock.release()<br>    <span class="hljs-keyword">return</span> num2<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run3</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-comment"># 获取锁</span><br>    lock.acquire()<br>    <span class="hljs-comment"># 去跑run1</span><br>    res = run1()<br>    print(<span class="hljs-string">'--------between run1 and run2-----'</span>)<br>    <span class="hljs-comment"># 去跑run2</span><br>    res2 = run2()<br>    <span class="hljs-comment"># 释放锁</span><br>    lock.release()<br>    print(res, res2)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    <span class="hljs-comment"># 初始化两个为0的变量</span><br>    num, num2 = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 生成lock实例</span><br>    lock = threading.RLock()<br>    <span class="hljs-comment"># 开始10个线程</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):<br>        <span class="hljs-comment"># 线程跑的是run3</span><br>        t = threading.Thread(target=run3)<br>        t.start()<br><br><span class="hljs-comment"># 判读是否有多个线程，有多个就继续打印，只剩一个说明子线程都执行完了，只剩主线程了，然后跳出循环程序结束</span><br><span class="hljs-comment"># 可以用之前学到的join()方法来实现一样的效果</span><br><span class="hljs-keyword">while</span> threading.active_count() != <span class="hljs-number">1</span>:<br>    print(threading.active_count())<br><span class="hljs-keyword">else</span>:<br>    print(<span class="hljs-string">'----all threads done---'</span>)<br>    print(num, num2)<br></code></pre></td></tr></table></figure><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Iimage4.png" width="50%"><h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><p>信号量的用法和线程锁非常相似。</p><p>线程锁锁住一个线程在运行和修改数据，而信号量可以自己控制同一时刻运行几个线程和几个线程修改数据，也就是设置最大同时运行的线程数。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(n)</span>:</span><br>    <span class="hljs-comment"># 获取信号量</span><br>    semaphore.acquire()<br>    print(<span class="hljs-string">'task %s is running'</span> % n)<br>    <span class="hljs-comment"># 暂停1s方便看出一次运行几个线程</span><br>    time.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 释放信号量</span><br>    semaphore.release()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    <span class="hljs-comment"># 生成信号量实例并设置信号量为5</span><br>    semaphore = threading.BoundedSemaphore(<span class="hljs-number">5</span>)<br>    <span class="hljs-comment"># 开启50个线程</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">50</span>):<br>        t = threading.Thread(target=run, args=(i,))<br>        t.start()<br><br><span class="hljs-comment"># 线程没有运行完就不退出</span><br><span class="hljs-keyword">while</span> threading.active_count() != <span class="hljs-number">1</span>:<br>    <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">else</span>:<br>    print(<span class="hljs-string">'----all threads done---'</span>)<br></code></pre></td></tr></table></figure><p>虽然我们看到的是一次执行五个线程，但并不是五个一组五个一组分组执行的，因为这五个线程同时完成，所以我们看不出来，但是其中的过程是执行完一个线程放进去一个线程，加入这五个中有两个先完成，那么就会立刻再放进去两个，也就是说这五个线程之间不会互相等待，这个设置的信号量5不是按5来分组，而是同时运行的线程最大数，可以写多个执行时间不同的函数然后一次执行几个来证明这一点。</p><h4 id="区分主-子线程"><a href="#区分主-子线程" class="headerlink" title="区分主/子线程"></a>区分主/子线程</h4><p>子线程可能比较明白的看出来，而主线程有的时候是看不到的，主线程就是程序本身，但是跟子线程还是有区分的，而threading module提供给我们方法让我们可以知道当前线程是主线程还是子线程。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">threading.current_thread() <span class="hljs-comment"># 返回当前线程类型</span><br>threading.active_count()<span class="hljs-comment"># 返回当前活跃线程数</span><br></code></pre></td></tr></table></figure><p>实例</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-comment"># 继承类threading.Thread</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(threading.Thread)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, n)</span>:</span><br>        <span class="hljs-comment"># 这里要继承构造函数</span><br>        super(MyThread, self).__init__()<br>        <span class="hljs-comment"># 可以定义自己的实例变量</span><br>        self.n = n<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-comment"># 打印当前线程类型</span><br>        print(<span class="hljs-string">'running task'</span>, self.n, threading.current_thread())<br>        time.sleep(<span class="hljs-number">2</span>)<br><br><br><span class="hljs-comment"># 得到开始时间</span><br>start_time = time.time()<br><span class="hljs-comment"># 声明空列表</span><br>threads = []<br><br><span class="hljs-comment"># 循环开启50线程</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">50</span>):<br>    t = MyThread(i)<br>    t.start()<br>    <span class="hljs-comment"># 线程实例放入列表中</span><br>    threads.append(t)<br><span class="hljs-comment"># 打印当前活跃的线程数</span><br>print(threading.active_count())<br><span class="hljs-comment"># 对线程实例所在列表再循环</span><br><span class="hljs-keyword">for</span> res <span class="hljs-keyword">in</span> threads:<br>    <span class="hljs-comment"># 对每一个实例使用jion()方法</span><br>    res.join()<br><span class="hljs-comment"># 获得结束时间</span><br>end_time = time.time()<br><span class="hljs-comment"># 计算花费时间</span><br>spend_time = end_time - start_time<br><span class="hljs-comment"># 打印当前线程类型</span><br>print(<span class="hljs-string">'all thread has finished'</span>, threading.current_thread())<br><span class="hljs-comment"># 打印花费时间</span><br>print(spend_time)<br></code></pre></td></tr></table></figure><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Iimage1.png" width="50%"><p>可以看到在开启50个子线程后活跃线程数为51，这些线程的类型都为Thread(子线程)，而最后的则为Main Thread(主线程)</p><p>这样，我们就可以知道当前线程是主线程还是子线程了，甚至还可以知道当前活跃的线程数。</p><h4 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h4><p>顾名思义，守护进程就是用来守护主线程的，一旦主线程没了，那这些守护线程也就没有存在的意义了。</p><p>threading module提供<code>setDaemon(True)</code>来使子线程变为守护线程，守护线程就是一旦主线程结束了，即使子线程还在运行，也会跟着一起结束。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-comment"># 继承类threading.Thread</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(threading.Thread)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, n)</span>:</span><br>        <span class="hljs-comment"># 这里要继承构造函数</span><br>        super(MyThread, self).__init__()<br>        <span class="hljs-comment"># 可以定义自己的实例变量</span><br>        self.n = n<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-comment"># 打印当前线程类型</span><br>        print(<span class="hljs-string">'running task'</span>, self.n, threading.current_thread())<br>        time.sleep(<span class="hljs-number">2</span>)<br>        <span class="hljs-comment"># 线程结束打印一句话</span><br>        print(<span class="hljs-string">'done'</span>)<br><br><br><span class="hljs-comment"># 得到开始时间</span><br>start_time = time.time()<br><br><span class="hljs-comment"># 循环开启50线程</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">50</span>):<br>    t = MyThread(i)<br>    <span class="hljs-comment"># 设置这个线程为守护线程</span><br>    t.setDaemon(<span class="hljs-literal">True</span>)<br>    t.start()<br><span class="hljs-comment"># 打印当前活跃的线程数</span><br>print(threading.active_count())<br><br><span class="hljs-comment"># 获得结束时间</span><br>end_time = time.time()<br><span class="hljs-comment"># 计算花费时间</span><br>spend_time = end_time - start_time<br><span class="hljs-comment"># 打印当前线程类型</span><br>print(<span class="hljs-string">'all thread has finished'</span>, threading.current_thread())<br><span class="hljs-comment"># 打印花费时间</span><br>print(spend_time)<br></code></pre></td></tr></table></figure><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Iimage2.png" width="50%"><p>可以看到，直到程序结束都没有执行每一个线程中的打印<code>done</code>的这段代码，这是因为子线程变成了守护线程，一旦主线程结束，这些守护线程也会跟着结束。</p><p>这里也有注意的地方，就是设置子线程为守护线程时必须要在子线程开始之前也就是<code>start()</code>之前。</p><p>程序会等待主线程的完成，而不会等待守护线程</p><h2 id="queue模块-线程间通信"><a href="#queue模块-线程间通信" class="headerlink" title="queue模块(线程间通信)"></a>queue模块(线程间通信)</h2><p>Python的Queue模块中提供了同步的、线程安全的队列类，包括：</p><ul><li>FIFO队列Queue</li><li>LIFO队列LifoQueue</li><li>优先级队列PriorityQueue</li></ul><h4 id="Queue模块中常用方法"><a href="#Queue模块中常用方法" class="headerlink" title="Queue模块中常用方法"></a>Queue模块中常用方法</h4><table><thead><tr><th align="center">对象</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">Queue(maxsize=0)</td><td align="left">创建一个先入先出队列。如果给定最大值，则在队列没有空间时阻塞；否则(没有指定最大值)，为无限队列</td></tr><tr><td align="center">LifoQueue(maxsize=0)</td><td align="left">创建一个后入先出队列。如果给定最大值，则在队列没有空间时阻塞；否则(没有指定最大值)，为无限队列</td></tr><tr><td align="center">PriorityQueue(maxsize=0)</td><td align="left">创建一个优先级队列。如果给定最大值，则在队列没有空间时阻塞，否则(没有指定最大值)，为无限队列</td></tr><tr><td align="center">Empty</td><td align="left">当对空队列调用get*()方法时抛出异常</td></tr><tr><td align="center">Full</td><td align="left">当对已满的队列调用put*()方法时抛出异常</td></tr><tr><td align="center">qsize()</td><td align="left">返回队列大小</td></tr><tr><td align="center">empty()</td><td align="left">如果队列为空，则返回True；否则，返回False</td></tr><tr><td align="center">full()</td><td align="left">如果队列为满，则返回True；否则，返回False</td></tr><tr><td align="center">put(item,block=True,timeout=None)</td><td align="left">将item放入队列。如果block为True(默认)且timeout为None，则在有可用空间之前阻塞；如果timeout为正值，则最多阻塞timeout秒；如果block为False，则抛出Empty异常</td></tr><tr><td align="center">put_nowait(item)</td><td align="left">相当于put(item,False)</td></tr><tr><td align="center">get(blcok=True,timeout=None)</td><td align="left">获取队列。如果给定了block(非0)，则一直阻塞到有可用的元素为止</td></tr><tr><td align="center">get_nowait()</td><td align="left">相当于get(False)</td></tr><tr><td align="center">join()</td><td align="left">在队列中所有元素执行完毕并调用上面的task_done()信号之前，保持阻塞</td></tr></tbody></table><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> randint<br><span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> ctime, sleep<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mythread</span><span class="hljs-params">(threading.Thread)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, func, name=<span class="hljs-string">''</span>)</span>:</span><br>        threading.Thread.__init__(self)<br>        self.name = name<br>        self.func = func<br><br>    <span class="hljs-string">''' rewrite run() '''</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span><br>        self.func()<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, q, loops)</span>:</span><br>        self.q = q<br>        self.loops = loops<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">WriteQueue</span><span class="hljs-params">(self)</span>:</span><br>        self.q.put(<span class="hljs-string">'xxx'</span>, <span class="hljs-number">1</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ReadQueue</span><span class="hljs-params">(self)</span>:</span><br>        value = self.q.get(<span class="hljs-number">1</span>)<br>        print(<span class="hljs-string">'value: '</span> + str(value))<br>        <span class="hljs-keyword">return</span> value<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Writer</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(self.loops):<br>                self.WriteQueue()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Reader</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(self.loops):<br>                aaa = self.ReadQueue()<br>                print(<span class="hljs-string">"aaa = "</span> + str(aaa))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span><br>    que = Queue(<span class="hljs-number">32</span>)<br>    nloops = randint(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>)<br>    q = MyQueue(que, nloops)<br><br>    t1 = Mythread(q.Writer, q.Writer.__name__)<br><br>    t2 = Mythread(q.Reader, q.Reader.__name__)<br><br>    t1.start()<br>    t2.start()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    main()<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matplotlib基础</title>
      <link href="/2019/08/03/Matplotlib%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/08/03/Matplotlib%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p><strong>本文主要介绍了以下内容:</strong></p><p>Matplotlib的一些基础画图命令</p><a id="more"></a><h3 id="标准头文件"><a href="#标准头文件" class="headerlink" title="标准头文件"></a>标准头文件</h3><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>plt.rcParams[<span class="hljs-string">'font.sans-serif'</span>] = [<span class="hljs-string">'STHeiti'</span>]  <span class="hljs-comment"># 用来正常显示中文标签</span><br>plt.rcParams[<span class="hljs-string">'axes.unicode_minus'</span>] = <span class="hljs-literal">False</span>  <span class="hljs-comment"># 用来正常显示负号</span><br><br>plt.show()<br></code></pre></td></tr></table></figure><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h5 id="figure-函数，创建图表"><a href="#figure-函数，创建图表" class="headerlink" title="figure()函数，创建图表"></a><code>figure()</code>函数，创建图表</h5><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> matplotlib.patches <span class="hljs-keyword">import</span> Polygon<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>plt.figure(<span class="hljs-number">1</span>)   <span class="hljs-comment"># 创建图表1</span><br>plt.figure(<span class="hljs-number">2</span>)   <span class="hljs-comment"># 创建图表2</span><br><br>plt.show()<br></code></pre></td></tr></table></figure><h5 id="subplot-创建子图"><a href="#subplot-创建子图" class="headerlink" title="subplot()创建子图"></a><code>subplot()</code>创建子图</h5><p>子图序号排序顺序：从左到右，从上到下，逐次增加1</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> matplotlib.patches <span class="hljs-keyword">import</span> Polygon<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>plt.figure(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 创建图表1</span><br>plt.subplot(<span class="hljs-number">221</span>)  <span class="hljs-comment"># 创建2*2的图表矩阵，绘制的子图为矩阵中的1序号</span><br>plt.subplot(<span class="hljs-number">222</span>)  <span class="hljs-comment"># 创建2*2的图表矩阵，绘制的子图为矩阵中的2序号</span><br>plt.subplot(<span class="hljs-number">223</span>)  <span class="hljs-comment"># 创建2*2的图表矩阵，绘制的子图为矩阵中的3序号</span><br>plt.subplot(<span class="hljs-number">224</span>)  <span class="hljs-comment"># 创建2*2的图表矩阵，绘制的子图为矩阵中的4序号</span><br><br>plt.show()<br></code></pre></td></tr></table></figure><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Image1.png" width="50%"><h5 id="在多个表中创建子图"><a href="#在多个表中创建子图" class="headerlink" title="在多个表中创建子图"></a>在多个表中创建子图</h5><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> matplotlib.patches <span class="hljs-keyword">import</span> Polygon<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>plt.figure(<span class="hljs-number">1</span>, dpi=<span class="hljs-number">50</span>)  <span class="hljs-comment"># 创建图表1</span><br>plt.subplot(<span class="hljs-number">111</span>)  <span class="hljs-comment"># 在图表1中创建子图</span><br>plt.figure(<span class="hljs-number">2</span>, dpi=<span class="hljs-number">50</span>)  <span class="hljs-comment"># 创建图表2</span><br>plt.subplot(<span class="hljs-number">221</span>)  <span class="hljs-comment"># 在图表2中创建子图</span><br>plt.show()  <span class="hljs-comment"># 显示所有图表</span><br></code></pre></td></tr></table></figure><h5 id="plot-函数，画函数图像"><a href="#plot-函数，画函数图像" class="headerlink" title="plot()函数，画函数图像"></a><code>plot()</code>函数，画函数图像</h5><p><code>splot(x,y)</code>中<code>x</code>表示横坐标，<code>y</code>表示纵坐标</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>plt.figure(<span class="hljs-number">1</span>, dpi=<span class="hljs-number">100</span>)<br><span class="hljs-comment"># x轴的定义域为 -3.14~3.14，中间间隔100个元素</span><br>x = np.linspace(-np.pi, np.pi, <span class="hljs-number">100</span>) <br>plt.plot(x, np.sin(x))<br>plt.show()<br></code></pre></td></tr></table></figure><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Image2.png" width="50%"><h5 id="sca-函数，选择子图"><a href="#sca-函数，选择子图" class="headerlink" title="sca()函数，选择子图"></a><code>sca()</code>函数，选择子图</h5><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>plt.figure(<span class="hljs-number">1</span>, dpi=<span class="hljs-number">100</span>)<br>ax1 = plt.subplot(<span class="hljs-number">211</span>)  <span class="hljs-comment"># 创建子图 ax1</span><br>ax2 = plt.subplot(<span class="hljs-number">212</span>)  <span class="hljs-comment"># 创建子图 ax2</span><br><br>x = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>)  <span class="hljs-comment"># x轴定义域</span><br><br>plt.sca(ax1)  <span class="hljs-comment"># 选择子图ax1</span><br>plt.plot(x, np.exp(x))  <span class="hljs-comment"># 在子图ax1 中绘制函数 exp(x)</span><br><br>plt.sca(ax2)  <span class="hljs-comment"># 选择子图ax2</span><br>plt.plot(x, np.sin(x))  <span class="hljs-comment"># 在子图ax2 中绘制函数 sin(x)</span><br><br>plt.show()  <span class="hljs-comment"># 展示所有图表</span><br></code></pre></td></tr></table></figure><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Image3.png" width="50%"><h5 id="在一张图中画多条曲线"><a href="#在一张图中画多条曲线" class="headerlink" title="在一张图中画多条曲线"></a>在一张图中画多条曲线</h5><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pylab <span class="hljs-keyword">as</span> plt<br><br>x = np.linspace(-np.pi * <span class="hljs-number">2</span>, np.pi * <span class="hljs-number">2</span>, <span class="hljs-number">100</span>)  <span class="hljs-comment"># 定义域为： -2pi 到 2pi</span><br>plt.figure(<span class="hljs-number">1</span>, dpi=<span class="hljs-number">100</span>)  <span class="hljs-comment"># 创建图表1</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>):  <span class="hljs-comment"># 画四条线</span><br>    plt.plot(x, np.sin(x / i))<br><br>plt.show()<br></code></pre></td></tr></table></figure><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Image4.png" width="50%"><h3 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h3><p>使用<code>plot()</code>函数</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>x = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>y = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]<br><br>x1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>y1 = [<span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">12</span>, <span class="hljs-number">14</span>]<br><br>plt.plot(x, y, label=<span class="hljs-string">'line one'</span>)<br>plt.plot(x1, y1, label=<span class="hljs-string">'line two'</span>)<br><br>plt.xlabel(<span class="hljs-string">'x_data'</span>)<br>plt.ylabel(<span class="hljs-string">'y_data'</span>)<br>plt.title(<span class="hljs-string">'title is here!'</span>)<br><br>plt.legend(loc=<span class="hljs-number">0</span>)<br><br>plt.show()<br></code></pre></td></tr></table></figure><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Image9.png" width="50%"><h3 id="条形图"><a href="#条形图" class="headerlink" title="条形图"></a>条形图</h3><p>使用<code>bar()</code>函数</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>x = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>]<br>y = [<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]<br><br>plt.bar(x, y)<br><br>plt.axis([<span class="hljs-number">0</span>, <span class="hljs-number">12</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>])<br><br>plt.show()<br></code></pre></td></tr></table></figure><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Image10.png" width="50%"><h3 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h3><p>使用<code>hist()</code>函数</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>plt.figure(<span class="hljs-number">1</span>, dpi=<span class="hljs-number">100</span>)  <span class="hljs-comment"># 创建图表1</span><br>data = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>]<br>plt.hist(data)  <span class="hljs-comment"># 只要传入数据，直方图就会统计数据出现的次数</span><br><br>plt.show()<br></code></pre></td></tr></table></figure><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Image5.png" width="50%"><h3 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h3><p>散点图用<code>scatter(x,y)</code>绘制，x参数传入x轴的坐标，y参数传入y轴坐标</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># 产生测试数据</span><br>x = np.arange(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)<br>y = x<br>fig = plt.figure()<br>plt.scatter(x, y, c=<span class="hljs-string">'r'</span>, marker=<span class="hljs-string">'o'</span>)  <span class="hljs-comment"># c = 'r'表示散点的颜色为红色，marker 表示指定三点多形状为圆形</span><br><span class="hljs-comment"># 显示所画的图</span><br>plt.show()<br></code></pre></td></tr></table></figure><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Image6.png" width="50%"><h3 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h3><p>使用<code>pie()</code>函数</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>data = [<span class="hljs-number">100</span>, <span class="hljs-number">500</span>, <span class="hljs-number">300</span>]  <span class="hljs-comment"># 饼图中的数据</span><br>fig = plt.figure(dpi=<span class="hljs-number">100</span>)<br>plt.pie(data,  <span class="hljs-comment"># 每个饼块的实际数据，如果大于1，会进行归一化，计算percentage</span><br>        explode=[<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.1</span>],  <span class="hljs-comment"># 每个饼块离中心的距离</span><br>        colors=[<span class="hljs-string">'y'</span>, <span class="hljs-string">'r'</span>, <span class="hljs-string">'g'</span>],  <span class="hljs-comment"># 每个饼块的颜色,黄红绿</span><br>        labels=[<span class="hljs-string">'A part'</span>, <span class="hljs-string">'B part'</span>, <span class="hljs-string">'C part'</span>],  <span class="hljs-comment"># 每个饼块的标签</span><br>        labeldistance=<span class="hljs-number">1.2</span>,  <span class="hljs-comment"># 每个饼块标签到中心的距离</span><br>        autopct=<span class="hljs-string">'%1.1f%%'</span>,  <span class="hljs-comment"># 百分比的显示格式</span><br>        pctdistance=<span class="hljs-number">0.5</span>,  <span class="hljs-comment"># 百分比到中心的距离</span><br>        shadow=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 每个饼块是否显示阴影</span><br>        startangle=<span class="hljs-number">0</span>,  <span class="hljs-comment"># 默认从x轴正半轴逆时针起</span><br>        radius=<span class="hljs-number">1</span>  <span class="hljs-comment"># 饼块的半径</span><br>        )<br>plt.show()<br></code></pre></td></tr></table></figure><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Image7.png" width="50%"><h3 id="图标的注释与标识"><a href="#图标的注释与标识" class="headerlink" title="图标的注释与标识"></a>图标的注释与标识</h3><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>fig = plt.figure(dpi=<span class="hljs-number">100</span>)<br>x = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>)<br>plt.plot(x, np.sin(x), label=<span class="hljs-string">"sin(x)"</span>)  <span class="hljs-comment"># 先设置一个label用于显示图例</span><br>plt.xlabel(<span class="hljs-string">"X axe"</span>)  <span class="hljs-comment"># 设置X轴的文字</span><br>plt.ylabel(<span class="hljs-string">"Y axe"</span>)  <span class="hljs-comment"># 设置Y轴的文字</span><br><span class="hljs-comment"># 设置x轴y轴的起点和终点</span><br>plt.axis([np.min(x), np.max(x), np.min(np.sin(x)), np.max(np.sin(x))])<br>plt.title(<span class="hljs-string">"sin(x) function"</span>)  <span class="hljs-comment"># 设置图的标题</span><br>plt.legend()  <span class="hljs-comment"># 显示图例。</span><br>plt.show()<br></code></pre></td></tr></table></figure><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Image8.png" width="50%"><h3 id="插入Latex公式"><a href="#插入Latex公式" class="headerlink" title="插入Latex公式"></a>插入Latex公式</h3><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> matplotlib.patches <span class="hljs-keyword">import</span> Polygon<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>plt.rcParams[<span class="hljs-string">'font.sans-serif'</span>] = [<span class="hljs-string">'STHeiti'</span>]  <span class="hljs-comment"># 用来正常显示中文标签</span><br>plt.rcParams[<span class="hljs-string">'axes.unicode_minus'</span>] = <span class="hljs-literal">False</span>  <span class="hljs-comment"># 用来正常显示负号</span><br><br><br><span class="hljs-comment"># 定义一个求积分的函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(x)</span>:</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0.3</span> * (x ** <span class="hljs-number">2</span>) + (<span class="hljs-number">0.1</span> * x) + <span class="hljs-number">1</span><br><br><br><span class="hljs-comment"># 定义积分区间</span><br>a, b = <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br>x = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)<br>y = func(x)<br><br><span class="hljs-comment"># 绘制曲线</span><br>fig, ax = plt.subplots(figsize=(<span class="hljs-number">14</span>, <span class="hljs-number">8</span>))<br>plt.plot(x, y, <span class="hljs-string">'g'</span>)<br><br><span class="hljs-comment"># 使用Polygon生成阴影部分</span><br>Ix = np.linspace(a, b)<br>Iy = func(Ix)<br>verts = [(a, <span class="hljs-number">0</span>)] + list(zip(Ix, Iy)) + [(b, <span class="hljs-number">0</span>)]<br>ploy = Polygon(verts, facecolor=<span class="hljs-string">'0.7'</span>, edgecolor=<span class="hljs-string">'0.5'</span>)<br>ax.add_patch(ploy)<br><br><span class="hljs-comment"># 添加数学公式和坐标轴标签</span><br><span class="hljs-comment"># r" "中间为LaTex语法表示的公式</span><br>plt.text(<span class="hljs-number">0.5</span> * (a + b), <span class="hljs-number">1</span>, <span class="hljs-string">r"$\int_a^b f(x)\mathrm&#123;d&#125;x$"</span>,<br>         horizontalalignment=<span class="hljs-string">'center'</span>, fontsize=<span class="hljs-number">20</span>)<br><span class="hljs-comment"># 前两个参数是放置文本的坐标</span><br>plt.figtext(<span class="hljs-number">0.9</span>, <span class="hljs-number">0.075</span>, <span class="hljs-string">'$x$'</span>)<br>plt.figtext(<span class="hljs-number">0.075</span>, <span class="hljs-number">0.9</span>, <span class="hljs-string">'$f(x)$'</span>)<br><br>ax.set_xticks((a, b))<br>ax.set_xticklabels((<span class="hljs-string">'$a$'</span>, <span class="hljs-string">'$b$'</span>))<br>ax.set_yticks((func(a), func(b)))<br>ax.set_yticklabels((<span class="hljs-string">'$f(a)$'</span>, <span class="hljs-string">'$f(b)$'</span>))<br>plt.grid(<span class="hljs-literal">True</span>)<span class="hljs-comment"># 网格</span><br>plt.show()<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 画图 </tag>
            
            <tag> Python </tag>
            
            <tag> Matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTex学习</title>
      <link href="/2019/08/02/Latex%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/08/02/Latex%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><strong>本文主要介绍了以下内容:</strong></p><p>LaTex一些基础知识</p><a id="more"></a><h3 id="开始第一个LaTex文档"><a href="#开始第一个LaTex文档" class="headerlink" title="开始第一个LaTex文档"></a>开始第一个LaTex文档</h3><p>打开TeXstudio,新建一个TeX文件,写入以下内容</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass&#123;article&#125;<br>\begin&#123;document&#125;<br>Here comes \LaTeX!<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><p>​    此处的第一行<code>\documentclass{article}</code>中包含了一个控制序列(或称命令/标记).所谓控制序列,是以反斜杠<code>\</code>开头,以第一个空格或非字母的字符结束的一串文字.它们不能被输出,但是它们会影响输出文档的效果.这里的控制序列是<code>documentclass</code>,它后面紧跟着的<code>{article}</code>代表这个控制序列有一个必要的参数,该参数的值为<code>article</code>这个控制序列的作用,是调用名为<code>article</code>的文档类.</p><p>​    <strong>Tex对控制序列的大小写是敏感的</strong></p><ul><li><p>部分控制序列还有被方括号<code>[]</code>包括的可选参数</p></li><li><p>所谓文档类,即是Tex系统预设的(或是用户自定的)一些格式的集合.不同文档类在输出效果上会有差别.</p><p>  此处的第二行以<code>%</code>开头.Tex以<code>%</code>作为注释标记符.具体来说,Tex会忽略从<code>%</code>开始当当前行末尾的所有内容.这些内容不会被输出,也不影响最终的排版效果,只供人类阅读.若要输出<code>%</code>字符本身,则需要在<code>%</code>之前加上反斜杠<code>\</code>进行转义(escape).例如</p>  <figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">今年的净利润为20\%, 比去年高<br></code></pre></td></tr></table></figure><p>  此处<code>%</code>被当做正常的百分号来处理, 其后的文字也将被正常输出.</p><p>  在注释行之后出现了控制序列<code>begin</code>.这个控制序列总是与<code>end</code>成对出现.这两个控制序列以及它们中间的内容被称为[环境],它们之后的第一个必要参数总是一致,被称为环境名.</p><p>  只有在<code>document</code>环境中的内容,才会被正常输出到文档中去或是作为控制序列对文档产生影响.也就是说,在<code>\end{document}</code>之后插入任何内容都是无效的.</p><p>  从<code>\documentclass{article}</code>开始到<code>\begin{document}</code>之前的部分被称为导言区.你可以将导言区理解为时对整篇文档进行设置的区域——在导言区出现的控制序列,往往会影响整篇文档的格式.</p><p>  <strong>通常在导言区设置页面的大小,页眉页脚样式,章节标题等等</strong></p></li></ul><h3 id="实现中英文混排"><a href="#实现中英文混排" class="headerlink" title="实现中英文混排"></a>实现中英文混排</h3><p>​    <strong>关于LaTeX的中文支持,首先要说明的是:在现在,一切教你使用<code>CJK</code>宏包的模板,人,网页,书,都是糟糕的,有害的,恼人的,邪恶的和应该摒弃的</strong></p><p>​    成功编译出一个文档后,中国Tex用户面临的第二个普遍问题大概就是<strong>实现中英文混排</strong>了.</p><p>​    宏包,就是一系列控制序列的合集.这里控制序列太常用,以至于人们会觉得每次将他们写在导言区太过繁琐,于是将他们打包在同一个文件架中,称为所谓的宏包.<code>\usepackage{}</code>可以用来调用宏包</p><p>​    除去中文支持,中文的板式处理和标点禁则也是不小的挑战.好在由刘海洋,李清等人维护的<code>CTeX</code>宏集一次性解决了这些问题.<code>CTeX</code>宏集的优势在于,他能适配于多种编译方式,在内部处理好了中文和中文版式的支持,影藏了这些细节,并且提供了不少中文用户需要的功能接口.</p><figure class="hljs highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&gt;请注意,`CTeX`宏集和`CTeX`套装是两个不同的东西.`CTeX`宏集的本质是LaTeX宏的集合,包含若干文档类(`.cls`文件)和宏包(`.sty`文件).`CTeX`套装是一个过时的TeX系统.<br>&gt;<br>&gt;新版`CTeX`宏集默认能够自动检测用户的操作系统,并为之配置合适的字库.<br></code></pre></td></tr></table></figure><p>​    使用以下代码来完成对<code>CTeX</code>宏集的调用:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[UTF8]&#123;ctexart&#125;<br>\begin&#123;document&#125;<br>你好, world!<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><h3 id="组织你的文章"><a href="#组织你的文章" class="headerlink" title="组织你的文章"></a>组织你的文章</h3><h4 id="作者-标题-日期"><a href="#作者-标题-日期" class="headerlink" title="作者,标题,日期"></a>作者,标题,日期</h4><p>保存并用XeLaTeX编译如下文档:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[UTF8]&#123;ctexart&#125;<br>\title&#123;你好, world!&#125;<br>\author&#123;胡奔&#125;<br>\date&#123;\today&#125;<br>\begin&#123;document&#125;<br>\maketitle<br>你好, 胡奔<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><p>导言区复杂了很多,但和之前的文档区别只有一处: 定义了<strong>标题,作者,日期</strong></p><p>在<code>document</code>环境中,除了原本的<code>你好,world!</code>,还多了一个控制序列<code>\maketitle</code>,这个控制序列能将在导言区中定义的标题,作者,日期按照预定义的格式展现出来.</p><blockquote><p>使用<code>titling</code>红包可以修改上述默认格式,参考<a href="http://texdoc.net/texmf-dist/doc/latex/titling/titling.pdf" target="_blank" rel="noopener">TeXdoc</a>    </p></blockquote><h4 id="章节和段落"><a href="#章节和段落" class="headerlink" title="章节和段落"></a>章节和段落</h4><p>保存并用XeLaTeX编译如下文档,查看效果:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[UTF8]&#123;ctexart&#125;<br>\title&#123;你好,\LaTeX&#125;<br>\author&#123;Huris&#125;<br>\date&#123;\today&#125;<br>\begin&#123;document&#125;<br>\maketitle<br>\section&#123;你好中国&#125;<br>中国在East Asia.<br>\subsection&#123;Hello Beijing&#125;<br>北京是 captical of China<br>\subsubsection&#123;Hello Dongcheng District&#125;<br>\paragraph&#123;Tian&apos;anmen Square&#125;<br>is in the center of Beijing<br>\subparagraph&#123;Chairman Mao&#125;<br>is in the center of 天安门广场<br>\subsection&#123;Hello 山东&#125;<br>\paragraph&#123;山东大学&#125;<br>is one of the best university in 山东.<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><p>在文档类<code>article</code>/<code>ctexart</code>中,定义了五个控制序列(只有五个)来调整行文组织结构,他们分别是:</p><ul><li><code>\section{.}</code></li><li><code>\subsection{.}</code></li><li><code>\subsubsection{.}</code></li><li><code>\paragraph{.}</code></li><li><code>\subparagraph</code></li></ul><h4 id="插入目录"><a href="#插入目录" class="headerlink" title="插入目录"></a>插入目录</h4><p>在上一节文档中,找到<code>\maketitle</code>,在他的下面插入控制序列<code>\tableofcontents</code>,保存并用XeLaTeX编译两次,观察结果:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[UTF8]&#123;ctexart&#125;<br>\title&#123;你好,\LaTeX&#125;<br>\author&#123;Huris&#125;<br>\date&#123;\today&#125;<br>\begin&#123;document&#125;<br>\maketitle<br>\tableofcontents<br>\section&#123;你好中国&#125;<br>中国在East Asia.<br>\subsection&#123;Hello Beijing&#125;<br>北京是 captical of China<br>\subsubsection&#123;Hello Dongcheng District&#125;<br>\paragraph&#123;Tian&apos;anmen Square&#125;<br>is in the center of Beijing<br>\subparagraph&#123;Chairman Mao&#125;<br>is in the center of 天安门广场<br>\subsection&#123;Hello 山东&#125;<br>\paragraph&#123;山东大学&#125;<br>is one of the best university in 山东.<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意<code>\maketitle</code>与<code>\tableofcontents</code>位置不能交换</p></blockquote><p>另外,LaTeX中间一个换行当做是一个简单的空格来处理,如果需要换行另起一段,则需要使用两个换行(一个空行)来实现.</p><h4 id="插入数学公式"><a href="#插入数学公式" class="headerlink" title="插入数学公式"></a>插入数学公式</h4><p>为了使用AMS-LaTeX提供的数学功能,我们需要在导言区加载<code>amsmath</code>宏包</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\usepackage&#123;amsmath&#125;<br></code></pre></td></tr></table></figure><h5 id="数学模式"><a href="#数学模式" class="headerlink" title="数学模式"></a>数学模式</h5><p>LaTex的数学模式有两种: 行内模式(inline)和行间模式(display).前者在正文的行文中,插入数学公式;后者独立排列单独成行</p><p>在行文中,使用<code>$...$</code>可以插入行内公式,使用<code>\[...\]</code>可以插入行间公式,如果需要对行间公式进行编号,可以使用equation环境.</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex">\begin&#123;equation&#125;<br>...<br>\end&#123;equation&#125;<br></code></pre></td></tr></table></figure><h5 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h5><p>示例代码:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[UTF8]&#123;ctexart&#125;<br>\usepackage&#123;amsmath&#125;<br>\begin&#123;document&#125;<br>Einsten&apos;s $E=mc^2$.<br>\[E=mc^2.\]<br>\begin&#123;equation&#125;<br>E=mc^2.<br>\end&#123;equation&#125;<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><blockquote><p>标点公式使用的规范</p><p>行内公式: 应该放在数学模式限定符之外</p><p>行间公式: 应该放在数学模式限定符之内</p></blockquote><p><code>_{...}</code>表示下标,<code>^{...}</code>表示上标.它默认只作用于之后的一个字符,如果想对连续的几个字符起作用,请将这些字符用花括号<code>{}</code>括起来.</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\[ z = r\cdot e^&#123;2\pi i&#125;. \]<br></code></pre></td></tr></table></figure><h5 id="根式与分式"><a href="#根式与分式" class="headerlink" title="根式与分式"></a>根式与分式</h5><p>根式用<code>\sqrt{.}</code>表示,分式用<code>\frac{.}{.}</code>表示(第一个参数为分子,第二个参数为分母).</p><p>示例代码:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[UTF8]&#123;ctexart&#125;<br>\usepackage&#123;amsmath&#125;<br>\begin&#123;document&#125;<br>$\sqrt&#123;x&#125;$, $\frac&#123;1&#125;&#123;2&#125;$.<br><br>\[ \sqrt&#123;x&#125;, \]<br><br>\[ \frac&#123;1&#125;&#123;2&#125;. \]<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><p>可以发现,在行间公式和行内公式中,分式的输出效果是由差异的. 如果要强制行内模式的分式显示为行间模式的大小,可以使用<code>\dfrac</code>,反之可以使用<code>\tfrac</code></p><blockquote><p>在行内写分式,可能会喜欢<code>xfrac</code>宏包提供的<code>\sfrac</code>命令的效果</p><p>排版繁公式时,应该使用<code>\cfrac</code>命令</p></blockquote><h5 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h5><p>一些小的运算符,可以在数学模式下直接输入;另一些要用控制序列生成</p><blockquote><p>控制序列</p><p>凡是键盘不能够直接表示的符号或者起着特定作用的皆有命令,类似转义,叫做<strong>控制序列(control sequence)</strong>,比如求和符合$\sum$对应的命令为<code>\sum</code></p></blockquote><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex">\[ \pm\; \times \; \div\; \cdot\; \cap\; \cup\;<br>   \geq\; \leq\; \neq\; \approx\; \equiv \]<br></code></pre></td></tr></table></figure><p>连加,连乘,极限,积分符号等大型运算符分别用<code>\sum</code>,<code>\prod</code>,<code>\lim</code>,<code>\int</code>生成</p><p>他们的上下标在行内公式中被压缩,以适应行高.我们可以使用<code>\limits</code>和<code>\nolimits</code>来强制显示地指定是否压缩这些上下标.</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">$ \sum_&#123;i=1&#125;^n i\quad \prod_&#123;i=1&#125;^n $<br>$ \sum\limits _&#123;i=1&#125;^n i\quad \prod\limits _&#123;i=1&#125;^n $<br>\[ \lim_&#123;x\to0&#125;x^2 \quad \int_a^b x^2 dx \]<br>\[ \lim\nolimits _&#123;x\to0&#125;x^2\quad \int\nolimits_a^b x^2 dx \]<br></code></pre></td></tr></table></figure><p>多重积分可以使用<code>\iint</code>,<code>\iiint</code>,<code>\iiint</code>,<code>\idotsint</code>等命令输入</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\[ \iint\quad \iiint\quad \iiint\quad \idotsint \]<br></code></pre></td></tr></table></figure><h5 id="定界符"><a href="#定界符" class="headerlink" title="定界符"></a>定界符</h5><p>各种括号用<code>()</code>,<code>[]</code>,<code>\{\}</code>,<code>\langle\rangle</code>等命令表示</p><p>注意花括号通常用来输入命令和环境的参数,所以在数学公式中它们前面要加<code>\</code></p><p>因为LaTeX中<code>|</code>和<code>\|</code>的应用过于随意,amsmath宏包推荐用<code>\lvert\rvert</code>和<code>\lVert\rVert</code>取而代之.</p><p>为了调整这些定界符的大小,amsmath宏包推荐使用<code>\big</code>,<code>\Big</code>,<code>\bigg</code>,<code>\Bigg</code>等一系列命令放在上述括号前面调整大小</p><blockquote><p>有时候可能会觉得amsmath宏包提供的定界符放大命令不太够用.</p><p>通常这就意味着你的公式过于复杂</p><p>此时应当首先考虑将公式中的部分提出去,以字母符号代替以简化公式</p><p>如果真的想排版出如此复杂的公式,可以参考<a href="https://liam.page/2018/11/09/the-bigger-than-bigger-delimiter-in-LaTeX/" target="_blank" rel="noopener">这篇博文</a></p></blockquote><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs latex">\[ \Biggl(\biggl(\Bigl(\bigl((x)\bigr)\Bigr)\biggr)\Biggr) \]<br>\[ \Biggl[\biggl[\Bigl[\bigl[[x]\bigr]\Bigr]\biggr]\Biggr] \]<br>\[ \Biggl \&#123;\biggl \&#123;\Bigl \&#123;\bigl \&#123;\&#123;x\&#125;\bigr \&#125;\Bigr \&#125;\biggr \&#125;\Biggr\&#125; \]<br>\[ \Biggl\langle\biggl\langle\Bigl\langle\bigl\langle\langle x<br>\rangle\bigr\rangle\Bigr\rangle\biggr\rangle\Biggr\rangle \]<br>\[ \Biggl\lvert\biggl\lvert\Bigl\lvert\bigl\lvert\lvert x<br>\rvert\bigr\rvert\Bigr\rvert\biggr\rvert\Biggr\rvert \]<br>\[ \Biggl\lVert\biggl\lVert\Bigl\lVert\bigl\lVert\lVert x<br>\rVert\bigr\rVert\Bigr\rVert\biggr\rVert\Biggr\rVert \]<br></code></pre></td></tr></table></figure><h5 id="省略号"><a href="#省略号" class="headerlink" title="省略号"></a>省略号</h5><p>省略号用<code>\dots</code>,<code>\cdots</code>,<code>\vdots</code>,<code>\ddots</code>等命令表示.</p><p><code>\dots</code>和<code>\cdots</code>的纵向位置不同,前者一般用于有下标的序列.</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex">\[ x_1,x_2,\dots ,x_n\quad 1,2,\cdots ,n\quad<br>\vdots\quad \ddots \]<br></code></pre></td></tr></table></figure><h5 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h5><p><code>amsmath</code>的<code>pmatrix</code>,<code>bmatrix</code>,<code>Bmatrix</code>,<code>vmatrix</code>,<code>Vmatrix</code>等环境可以在矩阵两边加上各种分隔符.</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs latex">\[ \begin&#123;pmatrix&#125; a&amp;b\\c&amp;d \end&#123;pmatrix&#125; \quad<br>\begin&#123;bmatrix&#125; a&amp;b\\c&amp;d \end&#123;bmatrix&#125; \quad<br>\begin&#123;Bmatrix&#125; a&amp;b\\c&amp;d \end&#123;Bmatrix&#125; \quad<br>\begin&#123;vmatrix&#125; a&amp;b\\c&amp;d \end&#123;vmatrix&#125; \quad<br>\begin&#123;Vmatrix&#125; a&amp;b\\c&amp;d \end&#123;Vmatrix&#125; \]<br></code></pre></td></tr></table></figure><p>使用<code>smallmatrix</code>环境,可以生成行内公式的小矩阵</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">Marry has a little matrix $(\begin&#123;smallmatrix&#125; a&amp;b\\c&amp;d \end&#123;smallmatrix&#125; )$.<br></code></pre></td></tr></table></figure><h5 id="多行公式"><a href="#多行公式" class="headerlink" title="多行公式"></a>多行公式</h5><ul><li>有的公式特别长,需要手动为他们换行</li><li>有几个公式是一组,我们需要将他们放在一起</li><li>还有些类似分段函数,我们需要给他加上一个左边的花括号</li></ul><h6 id="长公式"><a href="#长公式" class="headerlink" title="长公式"></a>长公式</h6><h6 id="不对齐"><a href="#不对齐" class="headerlink" title="不对齐"></a>不对齐</h6><p>无须对齐的长公式可以使用<code>multline</code>环境.</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">\begin&#123;multline&#125;<br>x = a+b+c+&#123;&#125; \\<br>d+e+f+g<br>\end&#123;multline&#125;<br></code></pre></td></tr></table></figure><p>如果不需要编号,则可以使用<code>multline*</code>环境代替.</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[UTF8]&#123;ctexart&#125;<br>\usepackage&#123;amsmath&#125;<br>\begin&#123;document&#125;<br>\begin&#123;multline*&#125;<br>x = a+b+c+&#123;&#125; \\<br>d+e+f+g<br>\end&#123;multline*&#125;<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><h6 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h6><p>需要对齐公式,可以使用<code>aligned</code>次环境来实现,它必须包含在数学环境之内</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">\[\begin&#123;aligned&#125;<br>x =&#123;&#125;&amp; a+b+c+&#123;&#125; \\<br>&amp;d+e+f+g<br>\end&#123;aligned&#125;\]<br></code></pre></td></tr></table></figure><h6 id="公式组"><a href="#公式组" class="headerlink" title="公式组"></a>公式组</h6><p>无需对齐公式的公式组可以使用<code>gather</code>环境,需要对齐的公式组可以使用<code>align</code>环境</p><p>他们都带有编号,如果不需要编号可以使用待星花的版本.</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs latex">\begin&#123;gather&#125;<br>a=b+c+d \\<br>x=y+z<br>\end&#123;gather&#125;<br>\begin&#123;align&#125;<br>a &amp;= b+c+d \\<br>x &amp;= y+z<br>\end&#123;align&#125;<br></code></pre></td></tr></table></figure><h6 id="分段函数"><a href="#分段函数" class="headerlink" title="分段函数"></a>分段函数</h6><p>分段函数可以用<code>cases</code>次环境来实现,它必须包含在数学环境之内.</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">\[ y\begin&#123;cases&#125;<br>-x,\quad x\leq 0 \\<br>x,\quad x&gt;0<br>\end&#123;cases&#125; \]<br></code></pre></td></tr></table></figure><h4 id="插入图片和表格"><a href="#插入图片和表格" class="headerlink" title="插入图片和表格"></a>插入图片和表格</h4><h5 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h5><p>LaTeX中插入图片,有很多种方式.</p><p>最好用的应当属利用<code>graphicx</code>宏包提供的<code>\includegraphics</code>命令</p><p>比如,在TeX源文件同目录下,有名为<code>a.jpg</code>的图片,可以用这样的方式将他插入到输出文档中:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[UTF8]&#123;ctexart&#125;<br>\usepackage&#123;graphicx&#125;<br>\begin&#123;document&#125;<br>\includegraphics&#123;a.jpg&#125;<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><p>图片可能很大,超过了输出文件的纸张大小,或者输出效果不是很好</p><p>此时可以用<code>\includegraphics</code>控制序列的可选参数来控制.</p><p>比如:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\includegraphics[width = .8\textwidth]&#123;a.jpg&#125;<br></code></pre></td></tr></table></figure><p>这样图片的高度会缩小为原来的80%,图片的总高度会按比例缩放</p><p><code>\includegraphics</code>控制序列还有若干其他的可选参数,一般用不到,具体可以查看该宏包的<a href="http://texdoc.net/texmf-dist/doc/latex/graphics/graphicx.pdf" target="_blank" rel="noopener">参考文档</a></p><h5 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h5><p><code>tabular</code>环境提供了最简单的表格功能.它用<code>\hline</code>命令表示横线,在列格式中用<code>|</code>表示竖线,用<code>&amp;</code>来进行分列,用<code>\\</code>来换行,每列可以采用居左,居中,居右等横向对齐方式,分别用<code>l</code>,<code>c</code>,<code>r</code>来表示</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs latex">\begin&#123;tabular&#125;&#123;l|c|r&#125;<br>\hline<br>操作系统&amp;发行版&amp;编辑器\\<br>\hline<br>Windows &amp; MikTeX &amp;TexMakerX \\<br>\hline<br>Unix/Linux &amp; teTeX &amp; Kile \\<br>\hline<br>Mac OS &amp; MacTeX &amp; TeXShop \\<br>\hline<br>通用&amp; TeX Live &amp; TeXworks \\<br>\hline<br>\end&#123;tabular&#125;<br></code></pre></td></tr></table></figure><p>浮动体</p><p>插图和表格通常需要占据大块空间,所以在文字处理软件中我们经常需要调整他们的位置</p><p><code>figure</code>和<code>table</code>环境可以自动完成这样的任务</p><p>这种自动调整位置的环境称作浮动体(float)</p><p>以<code>figure</code>为例</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs latex">\begin&#123;figure&#125;[htbp]<br>\centering% 使插图居中<br>\includegraphics&#123;a.jpg&#125;<br>\caption&#123;有图有真相&#125;% 设置插图标题<br>\label&#123;fig:myphoto&#125;  <br>\end&#123;figure&#125;<br></code></pre></td></tr></table></figure><p><code>htbp</code>选项用来指定插图的理想位置,如下表所示:</p><table><thead><tr><th align="center">here</th><th align="center">top</th><th align="center">bottom</th><th align="center">float page(专门放浮动体的单独页面或芬兰)</th></tr></thead><tbody><tr><td align="center">这里</td><td align="center">页眉</td><td align="center">页尾</td><td align="center">浮动页</td></tr></tbody></table><h3 id="版面设置"><a href="#版面设置" class="headerlink" title="版面设置"></a>版面设置</h3><h4 id="页边距"><a href="#页边距" class="headerlink" title="页边距"></a>页边距</h4><p>设置页边距,推荐使用<code>geometry</code>宏包,可以看到<a href="http://texdoc.net/texmf-dist/doc/latex/geometry/geometry.pdf" target="_blank" rel="noopener">文档</a></p><p>将纸张的长度设置为20cm,宽度设置为15cm,左边距1cm,右边距2cm,上边距3cm,下边距4cm,可以在导言区加上这样的几行:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex">\usepackage&#123;geometry&#125;<br>\geometry&#123;papersize=&#123;20cm,15cm&#125;&#125;<br>\geometry&#123;left=1cm,right=2cm,top=3cm,bottom=4cm&#125;<br></code></pre></td></tr></table></figure><p>页眉页脚,推荐使用<code>fancyhdr</code>宏包,可以在这里查看它的<a href="http://texdoc.net/texmf-dist/doc/latex/fancyhdr/fancyhdr.pdf" target="_blank" rel="noopener">说明文档</a></p><p>页眉左边写上我的名字,中间写上今天的日期,右边写上我的电话</p><p>页脚的正中写上页码,页眉和正文之间有一道宽为0.4pt的横线分割,可以在导言区加上如下几行:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs latex">\usepackage&#123;fancyhdr&#125;<br>\pagestyle&#123;fancy&#125;<br>\lhead&#123;\author&#125;<br>\chead&#123;\date&#125;<br>\rhead&#123;18757479599&#125;<br>\lfoot&#123;&#125;<br>\cfoot&#123;\thepage&#125;<br>\rfoot&#123;&#125;<br>\renewcommand&#123;\headrulewidth&#125;&#123;0.4pt&#125;<br>\renewcommand&#123;\headwidth&#125;&#123;\textwidth&#125;<br>\renewcommand&#123;\footrulewidth&#125;&#123;0pt&#125;<br></code></pre></td></tr></table></figure><h4 id="首行缩进"><a href="#首行缩进" class="headerlink" title="首行缩进"></a>首行缩进</h4><p>CTeX宏集已经处理好了首行缩进的问题(自然段前空两格汉字宽度)</p><p>因此,使用CTeX宏集进行中西文混合排版时,不需要关注首行缩进的问题.</p><h4 id="行间距"><a href="#行间距" class="headerlink" title="行间距"></a>行间距</h4><p>可以通过<code>setspace</code>宏包提供的命令来调整行间距</p><p>在导言区添加如下内容,可以将行距设置为字号的1.5倍</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex">\usepackage&#123;setspace&#125;<br>\onehalfspacing<br></code></pre></td></tr></table></figure><p>注意用词的差别</p><ul><li>行距是字号的1.5倍</li><li>1.5倍行距</li></ul><p>事实上,这不是设置1.5倍行距的正确方法,具体可看<a href>此处</a></p><h4 id="段间距"><a href="#段间距" class="headerlink" title="段间距"></a>段间距</h4><p>可以通过修改长度<code>\parskip</code>的值来调整段间距.</p><p>在导言区添加如下内容:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\addtolength&#123;\parskip&#125;&#123;.4em&#125;<br></code></pre></td></tr></table></figure><h3 id="命令与环境"><a href="#命令与环境" class="headerlink" title="命令与环境"></a>命令与环境</h3><p>LaTeX中的命令通常是由一个反斜杠加上命令名称，再加上花括号内的参数构成的(有的命令不带参数，例如<code>\TeX</code>)</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass&#123;ctexart&#125;<br></code></pre></td></tr></table></figure><p>如果有一些选项是备选的，那么通常会在花括号前用方括号标出，比如：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[a4paper]&#123;ctexart&#125;<br></code></pre></td></tr></table></figure><p>还有一种重要指令叫做环境。它被定义于控制命令<code>\begin{environment}</code>和<code>\end{environment}</code>间的内容。比如：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex">\begin&#123;document&#125;<br>...内容...<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><p>环境如果有备选参数，只需要写在<code>\begin[...]{name}</code>这里就行。</p><p>注意：不带花括号的命令后面如果想打印空格，需加上<strong>一对内部为空的花括号</strong>再键入空格。否则空格会被忽略。例如<code>\LaTeX{}Studio</code></p><p><strong>有时候LaTeX编译出现异常，需要删除文件夹下除了tex以外的文件再编译。</strong></p><p><strong>另外，在某些独占程序打开了以上文件时(比如用Acrobat打开了pdf)，编译可能出现错误。在编译时确保关闭这些独占程序。</strong></p><h3 id="保留字符-共8个"><a href="#保留字符-共8个" class="headerlink" title="保留字符(共8个)"></a>保留字符(共8个)</h3><p>#：自定义命令时，用于标明参数序号</p><p>$： 数学环境命令符</p><p>%：注释符，在其后的该行命令都会视为注释。如果在回车前输入这个命令，可以防止行末LaTeX插入一些奇怪的空白符。</p><p>^：数学环境中的上标命令符。</p><p>&amp;：表格环境中的跳列符</p><p>_：数学环境中的下标命令符</p><p>{与}：花括号用于标记命令的必选参数，或者标记某一部分命令称为一个整体。</p><p>\：反斜杠用于开始各种LaTeX命令。</p><blockquote><p>以上命令除了反斜杠，均能在前加反斜杠的形式输出。</p></blockquote><p>反斜杠输出：<code>\texttt{\char92}</code></p><p>其中命令<code>\char[num]</code>是一个特殊的命令，使用环境需要是tt字体环境，用于输出USCII码对应的字符，92对应的即反斜杠。</p><p>也可以使用   <strong>\char`</strong>  后加字符的方式输出想要的命令，但需要包裹在<code>\texttt</code>或者<code>\ttfamily</code>内、如果想要输出的字符是保留字，则需要在前面加一个反斜杠。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex">\texttt&#123;\char`~&#125;% 输出一个波浪线<br>\texttt&#123;\char`\\&#125;% 输出保留字反斜杠<br>\texttt&#123;\char`@&#125;% 实际上可直接输入@<br></code></pre></td></tr></table></figure><p>另外上面说的波浪线<code>~</code>用来输出一个禁止在该处断行的空格，也不能能够直接输出。</p><p>尝试：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">a $\sim$ b<br>a\~b<br>a\~&#123;&#125; b<br>a\textasciitilde b<br></code></pre></td></tr></table></figure><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/image1.png" width="30%"><h3 id="导言区"><a href="#导言区" class="headerlink" title="导言区"></a>导言区</h3><p>任何一份LaTeX文档都应当包含如下结构：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[options]&#123;doc-class&#125;<br>% 导言区<br>\begin&#123;document&#125;<br>...<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><p>其中，在语句<code>\begin{document}</code>之前的内容称为<strong>导言区</strong>。导言区可以留空，以可以进行一些文档的准备操作。即，<strong>导言区即为模板定义</strong>。</p><p>文档类参数<strong>doc-class</strong>和可选选项<strong>options</strong>由表3.1取值。</p><table><thead><tr><th>doc-class</th><th>文档类</th></tr></thead><tbody><tr><td>article</td><td>科学期刊，演示文稿，段报告，邀请函</td></tr><tr><td>proc</td><td>基于article的会议论文集</td></tr><tr><td>report</td><td>多章节的长报告、博士论文、短篇书</td></tr><tr><td>book</td><td>书籍</td></tr><tr><td>slides</td><td>幻灯片，使用了大号Scans Serif字体</td></tr></tbody></table><table><thead><tr><th>options</th><th align="left">说明</th></tr></thead><tbody><tr><td>字体</td><td align="left">默认10pt，可选11pt和12pt</td></tr><tr><td>页面方向</td><td align="left">默认竖向protrait，可选横向landscape</td></tr><tr><td>纸张尺寸</td><td align="left">默认letterpaper，可选用a4paper，b5paper等</td></tr><tr><td>分栏</td><td align="left">默认onecolumn，还有twocolumn</td></tr><tr><td>双面打印</td><td align="left">有oneside/twoside两个选项，用于排版奇偶页。article/report默认单页</td></tr><tr><td>章节分页</td><td align="left">有openright/openany两个选项，决定是在奇数页开启新页或是任意页开启新页。注意article是没有chapter(“章”)命令的，默认任意页。</td></tr><tr><td>公式对齐</td><td align="left">默认居中，可改为左对齐fleqn，默认编号居中，可改为左对齐leqno</td></tr><tr><td>草稿选项</td><td align="left">默认final，可改为draft，使行溢出的部分显示为黑块。</td></tr></tbody></table><p>在导言区最常见的是<strong>宏包</strong>的加载工作，命令形如：<code>\usepackage{package}</code>。</p><p>宏包是一系列已经制作好的功能”模块”，在需要使用一些原生LaTeX不带有的功能时，只需要调用这些宏包就可以了。</p><h3 id="标点与强调"><a href="#标点与强调" class="headerlink" title="标点与强调"></a>标点与强调</h3><p>英文符号$|&lt;&gt;+=$一般用于数学环境中，如果在文本中使用，在两侧加上”$”</p><p>如果在LaTeX中直接输入大于，小于号而不把他们放在数学环境中，它们并不会被正确地打印。</p><p>应该使用<code>\textgreater</code>、<code>\textless</code>命令。</p><h4 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h4><p>英文单引号：左单引号是重音符`(键盘上1左侧)，右单引号是常用的引号符</p><p>英文双引号：左双引号是连续两个重音符``(键盘上1左侧)，右双引号是常用的引号符</p><p>英文下的引号嵌套需要借助<code>\thinspace</code>命令分隔，比如：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">``\thinspace`Max&apos; is here.&apos;&apos;<br></code></pre></td></tr></table></figure><p>中文下册单引号和双引号可用中文输入法直接输入。</p><h4 id="破折、省略号与短横"><a href="#破折、省略号与短横" class="headerlink" title="破折、省略号与短横"></a>破折、省略号与短横</h4><p>英文短横分为三种：</p><ul><li>连字符：输入一个短横：-，效果如daughter-in-law</li><li>数字起止符：输入链各个短横：- -，效果如：page 1-2</li><li>破折号：输入三个短横 - - -，效果如：Listen—I’m serious.</li></ul><p>中文的破折号可以直接使用日常的输入方式。中文的省略号同样。但是注意，英文的省略号使用<code>\ldots</code>这个命令而不是三个句点。</p><h4 id="强调：粗与斜"><a href="#强调：粗与斜" class="headerlink" title="强调：粗与斜"></a>强调：粗与斜</h4><p>LaTeX中专门有个叫做<code>\emph{text}</code>的命令，可以强调文本。对于通常的西文文本，上述命令的作用就是斜体。如果对一段已经这样转为斜体的文本再使用这个命令，他就会取消斜体，而成为正体。</p><p><strong>因为一般采用斜体强调的方式而不是粗体</strong></p><h4 id="下划线与删除线"><a href="#下划线与删除线" class="headerlink" title="下划线与删除线"></a>下划线与删除线</h4><p>建议使用<strong>ulem</strong>宏包中的uline命令代替原生的，<strong>ulem</strong>宏包还提供了一些实用命令：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[a4paper]&#123;ctexart&#125;<br>\usepackage[normalem]&#123;ulem&#125;<br><br>\begin&#123;document&#125;<br>\uline&#123;下划线&#125;<br>\uuline&#123;双下划线&#125;<br>\dashuline&#123;虚下划线&#125;<br>\dotuline&#123;点下划线&#125;<br>\uwave&#123;波浪线&#125;<br>\sout&#123;删除线&#125;<br>\xout&#123;斜删除线&#125;<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/image2.png" width="30%"><p>需要注意，<strong>ulem</strong>宏包冲定义了<code>\emph</code>命令，<strong>使得原来的加斜强调变成了下划线，原来的两次强调就取消强调变成了两次强调就双下划线。</strong></p><p>通过宏包的<strong>normalem</strong>选项可以取消这个更改：<code>\usepackage[normalem]{ulem}</code></p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>角度符号或者温度符号需要借助数学模式$…$输入：</li></ul><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex">$30\,^&#123;\circ&#125;$ 三角形<br>$37\,^&#123;\circ&#125;\mathrm&#123;C&#125;$<br></code></pre></td></tr></table></figure><ul><li>欧元符号可能需要用到<strong>textcomp</strong>宏包支持的<code>\texteuro</code>命令</li><li>千分位分隔符，如果不想它在中间断行，就在外侧再加上一个<code>\mbox</code>命令：<code>\mbox{1\,000\,000}</code></li><li>注音符号</li></ul><p><strong>hologo</strong>宏包，它允许输出许多TeX家族标志。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">\LaTeX<br>\TeX<br>\hologo&#123;XeLaTeX&#125;<br>\hologo&#123;BibTex&#125;<br></code></pre></td></tr></table></figure><h3 id="格式控制"><a href="#格式控制" class="headerlink" title="格式控制"></a>格式控制</h3><p>LaTeX的长度单位：</p><ul><li><strong>pt</strong>：point，磅</li><li><strong>pc</strong>：pica，1pc=12pt，四号字大小</li><li><strong>in</strong>：inch，英寸，1in=72.72pt</li><li><strong>bp</strong>：bigpoint，大点。1bp=$\tfrac1{12}$in</li><li><strong>cm</strong>：centimeter，厘米，1cm=$\tfrac1{2.54}$in</li><li><strong>mm</strong>：millimeter，毫米，1mm=$\tfrac1{10}$cm</li><li><strong>sp</strong>：scaled point，TeX的基本长度单位，1sp=$\tfrac1{65536}$pt</li><li><strong>em</strong>：当前字号下，大写字母的宽度</li><li><strong>ex</strong>：当前字号下，小写字母x的高度</li></ul><p>几个常用的长度宏：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex">\textwidth % 页面上文字的总宽度，即页宽减去两侧边距<br>\linewidth % 当前行允许的行宽<br></code></pre></td></tr></table></figure><p>有时候可以使用可变长度，比如”5pt plus 3pt minus 2pt”，表示一个能收缩到3pt也能伸长到8pt的长度，直接使用倍数也是允许的，例如：1.5<code>\parindent</code>等。</p><p>通常使用<code>\hspace{len}</code>和<code>\vspace{len}</code>这两个命令控制特殊的空格。</p><h4 id="空格、换行与分段"><a href="#空格、换行与分段" class="headerlink" title="空格、换行与分段"></a>空格、换行与分段</h4><p>在LaTeX中，多个空格会被视为一个，多个换行也会被视为一个，如果想要禁止LaTeX在某个空格处的换行，将空格用<del>命令替代即可，比如”Fig .</del>8”</p><p>通常的换行方法非常简单：LaTeX会自动转行，然后在每一段的末尾，只需要输入两个回车即可完成分段。如果需要一个空白段落(实质是一个空白行)，先输入两个回车，再输入<code>\mbox{}</code>，最后再输入两个回车即可。也可以用<code>\par</code>来产生一个带缩进的新段。</p><p><strong>正文中想要换行，直接使用两个回车。</strong></p><p>段落之间的距离由<code>\parskip</code>控制，默认”0pt plus 1pt”</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\setlength&#123;\parskip&#125;&#123;0pt&#125;<br></code></pre></td></tr></table></figure><p>宏包<strong>lettrine</strong>能够产生首字下沉的效果：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex">\lettrine&#123;T&#125;&#123;his&#125; is an example.<br>Hope you like this package,<br>and enjoy your \LaTeX\ trip!<br></code></pre></td></tr></table></figure><h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><p>用<code>\newpage</code>命令开始新的一页</p><p>用<code>\clearpage</code>命令清空浮动体队列，并开始新的一页</p><p>用<code>\cleardoublepage</code>命令清空浮动体队列，并在偶数页上开始新的一页</p><p>注意：以上命令都是基于<code>\vfill</code>的，如果要连续新开两页，在中间加上一个空的箱子(<code>\mbox{}</code>)，如<code>\newpage\mbox{}\newpage</code></p><h4 id="缩进、对齐与行距"><a href="#缩进、对齐与行距" class="headerlink" title="缩进、对齐与行距"></a>缩进、对齐与行距</h4><p>英文的段首不需要缩进，但是对中文而言，段首缩进需要借助<strong>indentfirst</strong>宏包来完成</p><p>可能还需要使用<code>\setlength\parindent{2em}</code>这样的命令来设置缩进距离</p><p>如果在行首强制取消缩进，可以在段首使用<code>\noindent</code>命令</p><p>LaTeX默认使用两端对齐的排版方式。也可以使用<code>flushleft</code>，<code>flushright</code>，<code>center</code>这三种环境来构造居左，居中，居右三种效果。</p><h4 id="字体与颜色"><a href="#字体与颜色" class="headerlink" title="字体与颜色"></a>字体与颜色</h4><p>字族：宋体，黑体，楷体，罗马体，等宽体</p><p>字系和字形：加粗，加斜</p><p>字号：五号，小四</p><p><strong>字族+字系和字形+字号=字体</strong></p><h5 id="原生字体命令"><a href="#原生字体命令" class="headerlink" title="原生字体命令"></a>原生字体命令</h5><p>LaTeX提供了基本的字体命令</p><p>字族</p><ul><li><code>\rmfamily</code>：把字体设置为Roman罗马字族</li><li><code>\saffamily</code>：把字体设置为Sans Serif无衬线字族</li><li><code>\ttfamily</code>：把字体设置为Typewriter等宽字族</li></ul><p>字系</p><ul><li><code>\bfseries</code>：粗体BoldSeries字系属性</li><li><code>\mdseries</code>：中粗体MiddleSeries字系属性</li></ul><p>字形</p><ul><li><code>\upshape</code>：竖直Upright字形</li><li><code>\slshape</code>：斜体Slant字形</li><li><code>\itshape</code>：强调体Italic字形</li><li><code>\scshape</code>：小号大写体SCAP字形</li></ul><p>如果临时改变字体，使用<code>\textrm</code>，<code>\textbf</code>这类命令</p><p>字族，字系，字形三种命令是相互独立的，可以任意组合使用。</p><p>但这种复合字体的效果有时候无法达到(因为没有对应的设计)，比如<code>\scshape</code>字形和<code>\bfseries</code>字系。</p><p>如果在文中多次使用某种字体变换，可以将其自定义成一个命令。</p><p>使用text系列的命令而不要使用family，series或shape系列的命令。</p><p>否则需要多加一组花括号防止”泄露”。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">􏲨􏲫􏱌􏲲􏲩􏰾􏲪􏲪􏲬􏲫􏰼􏲮􏲨􏲩􏰾􏲫􏲩􏱌􏱖􏰺􏲯􏳭􏰉􏳮􏲮􏲨􏰺􏱌􏱛􏰺􏲰􏲿􏲮􏸙􏰉􏲯􏲯􏲨􏲫􏱌􏲲􏲩􏰾􏲪􏲪􏲬􏲫􏰼􏲮􏲨􏲩􏰾􏲫􏲩􏱌􏱖􏰺􏲯􏳭􏰉􏳮􏲮􏲨􏰺􏱌􏱛􏰺􏲰􏲿􏲮􏸙􏰉􏲯􏲯􏲨􏲫􏱌􏲲􏲩􏰾􏲪􏲪􏲬􏲫􏰼􏲮􏲨􏲩􏰾􏲫􏲩􏱌􏱖􏰺􏲯􏳭􏰉􏳮􏲮􏲨􏰺􏱌􏱛􏰺􏲰􏲿􏲮􏸙􏰉\newcommand&#123;\concept&#125;[1]&#123;\textbf&#123;#1&#125;&#125;<br></code></pre></td></tr></table></figure><h6 id="字号命令"><a href="#字号命令" class="headerlink" title="字号命令"></a>字号命令</h6><p>在行文中会有一个默认的”标准”字号，比如在documentclass的选项中设置的12pt</p><p>在LaTeX中给出了一系列”相对字号命令”，此外，<strong>ctex</strong>宏包的<code>\zihao</code>命令，参数0-8以及-0–8表示初号到八号，小初到小八</p><p>日常使用的小四为12pt，五号为10.5pt</p><table><thead><tr><th>命令</th><th>10pt</th><th>11pt</th><th>12pt</th></tr></thead><tbody><tr><td>\tiny</td><td>5pt</td><td>6pt</td><td>6pt</td></tr><tr><td>\scriptsize</td><td>7pt</td><td>8pt</td><td>8pt</td></tr><tr><td>\footnotesize</td><td>8pt</td><td>9pt</td><td>10pt</td></tr><tr><td>\small</td><td>9pt</td><td>10pt</td><td>11pt</td></tr><tr><td>\normalsize</td><td>10pt</td><td>11pt</td><td>12pt</td></tr><tr><td>\large</td><td>12pt</td><td>12pt</td><td>14pt</td></tr><tr><td>\Large</td><td>14pt</td><td>14pt</td><td>17pt</td></tr><tr><td>\LARGE</td><td>17pt</td><td>17pt</td><td>20pt</td></tr><tr><td>\huge</td><td>20pt</td><td>20pt</td><td>25pt</td></tr><tr><td>\Huge</td><td>25pt</td><td>25pt</td><td>25pt</td></tr></tbody></table><p>如果想要设置特殊的字号，使用：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\fontsize&#123;font-size&#125;&#123;line-height&#125;&#123;\selectfont &lt;text&gt;&#125;<br></code></pre></td></tr></table></figure><p>其中<strong>font-size</strong>填数字，单位pt，一般而言，<strong>line-height</strong>填<code>\baselineskip</code></p><p>默认全文的字体使用<code>\rmfamily</code>族的字体。可以通过重定义的方式改变他，使<code>\rmfamily</code>，<code>\textrm</code>命令都指向新的字体。甚至把默认字体改为sf/tt字族。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs latex">\renewcommand&#123;\rmdefault&#125;&#123;font-name&#125;<br>% 默认字体改为sf字族，也可以用\ttdefault<br>\renewcommand&#123;\familydefault&#125;&#123;\sfdefault&#125;<br>\renewcommand&#123;\sfdefault&#125;&#123;font-name&#125;<br>% 如果你的排版CJK文档，还需要更改CJK默认字体<br>\renewcommand&#123;\CJKfamilydefault&#125;&#123;\CJKsfdefault&#125;<br></code></pre></td></tr></table></figure><h6 id="西文字体"><a href="#西文字体" class="headerlink" title="西文字体"></a>西文字体</h6><p>LaTeX预报含如下字体：</p><table><thead><tr><th>命令</th><th>字体名</th></tr></thead><tbody><tr><td>cmr</td><td>Computer Modern Roman(默认)</td></tr><tr><td>lmr</td><td>Latin Modern Roman</td></tr><tr><td>pbk</td><td>Bookman</td></tr><tr><td>ppl</td><td>Palatino</td></tr><tr><td>lmss</td><td>Latin Modern Roman Serif</td></tr><tr><td>phv</td><td>Helvetica</td></tr><tr><td>lmtt</td><td>Latin Modern</td></tr></tbody></table><p>以上可以这样使用</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">\newcommand&#123;\myfont&#125;[2]&#123;&#123;\fontfamily&#123;#1&#125;\selectfont #2&#125;&#125;<br>\renewcommand&#123;\rmdefault&#125;&#123;ptm&#125;% 可更改默认字体，同理可改sfdefault等<br>% 以上在导言区定义，在正文中：<br>Let&apos;s change font to \myfont&#123;pp1&#125;&#123;Palatino&#125;!<br></code></pre></td></tr></table></figure><h6 id="中文支持与CJK字体"><a href="#中文支持与CJK字体" class="headerlink" title="中文支持与CJK字体"></a>中文支持与CJK字体</h6><p>中文方面，<strong>ctex</strong>宏包直接定义了新的中文文档类ctexart，ctexrep，ctexbook，ctexbeamer</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[a4paper,zihao=-4,linespread=1]&#123;ctexrep&#125;<br>\renewcommand&#123;\CTEXthechapter&#125;&#123;\thechapter&#125;<br></code></pre></td></tr></table></figure><p> 以上设置字号为小四，行距因子为1(故行距为1x1.2=1.2倍，其中1.2是LaTeX默认的基线间距)</p><p>a4paper选项继承与原生文档类report，可见ctex文档类还是很好地保留了原生文档类的特征</p><p>值得注意的是，<strong>ctex文档类会用<code>\CTEX</code>开头的计数器命令代替原有的</strong></p><p><strong>除非使用scheme=plain来让ctex文档类仅支持中文而不做任何文档细节更改</strong></p><p><strong>ctex</strong>宏包支持一下字体命令：</p><ul><li>宋体：<code>\songti</code></li><li>黑体：<code>\heiti</code></li><li>仿宋：<code>\fangsong</code></li><li>楷书：<code>\kaishu</code></li><li>雅黑：<code>\yahei</code></li><li>隶书：<code>\lishu</code></li><li>幼圆：<code>\youyuan</code></li></ul><h5 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h5><p>使用<strong>xcolor</strong>宏包来方便地调用颜色</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs latex">\usepackage&#123;xcolor&#125;<br>\definecolor&#123;keywordcolor&#125;&#123;RGB&#125;&#123;34,34,250&#125;<br><br>% 指定颜色的text<br>&#123;\color&#123;color-name&#125;&#123;text&#125;&#125;<br></code></pre></td></tr></table></figure><p><strong>xcolor</strong>宏包预定义的颜色：</p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/image3.png" width="70%"><p>还可以通过”调色”做出新的效果</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex">&#123;\color&#123;red!70&#125;百分之70红色&#125;<br>&#123;\color&#123;blue!50!black!20!white!30&#125;50蓝20黑30白&#125;<br>&#123;\color&#123;-yellow&#125;黄色的互补色&#125;<br></code></pre></td></tr></table></figure><h3 id="引用与注释"><a href="#引用与注释" class="headerlink" title="引用与注释"></a>引用与注释</h3><p>电子文档最大优越性在于能够使用超链接，跳转标签、目录，甚至访问外部网站。这些功能都需要引用。</p><h4 id="标签和引用"><a href="#标签和引用" class="headerlink" title="标签和引用"></a>标签和引用</h4><p>使用<code>\label</code>命令插入标签(在MS Word中称为”题注”)，然后在其他地方用<code>\ref</code>或者<code>\pageref</code>命令进行引用，分别引用标签的序号、标签所在的页的页码。</p><figure class="hljs highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">\<span class="hljs-selector-tag">label</span>&#123;<span class="hljs-attribute">section</span>:this&#125;<br>\<span class="hljs-selector-tag">ref</span>&#123;<span class="hljs-attribute">section</span>:this&#125;<br>\<span class="hljs-selector-tag">pageref</span><br></code></pre></td></tr></table></figure><h3 id="中英文之间空格问题解决"><a href="#中英文之间空格问题解决" class="headerlink" title="中英文之间空格问题解决"></a>中英文之间空格问题解决</h3><p><code>&lt;\hspace{0em}变量\hspace{0em}&gt;</code></p><h3 id="空格设置"><a href="#空格设置" class="headerlink" title="空格设置"></a>空格设置</h3><p><code>\hspace{0em}</code></p><h3 id="空行距离"><a href="#空行距离" class="headerlink" title="空行距离"></a>空行距离</h3><p><code>\vspace{3mm}</code></p><h3 id="两端对齐"><a href="#两端对齐" class="headerlink" title="两端对齐"></a>两端对齐</h3><p><code>\usepackage{ragged2e}</code></p><p><code>\justifying</code></p><h3 id="分数"><a href="#分数" class="headerlink" title="分数"></a>分数</h3><p>分数小：$\tfrac{1}{2}$</p><p>分数大：$\dfrac{1}{2}$</p><h3 id="摄氏度"><a href="#摄氏度" class="headerlink" title="摄氏度"></a>摄氏度</h3><p>$^{\circ}$C</p><h3 id="max下面加限制范围"><a href="#max下面加限制范围" class="headerlink" title="max下面加限制范围"></a>max下面加限制范围</h3><p>$y_{N+1}=\arg \max \limits_{y_{N+1}} \hat{P}(y_{N+1}|x_{N+1})$</p><a herf="https://huris.oss-cn-hangzhou.aliyuncs.com/avatar.jpg"></a>]]></content>
      
      
      <categories>
          
          <category> 计算机工具 </category>
          
          <category> LaTex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matlab画图总结</title>
      <link href="/2019/08/02/Matlab%E7%94%BB%E5%9B%BE%E6%80%BB%E7%BB%93/"/>
      <url>/2019/08/02/Matlab%E7%94%BB%E5%9B%BE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-built_in">plot</span><br>数据点: . o x + * S(正方形) H(六角星) D(菱形) p(五角星) V(倒三角) ^(三角形) &gt;(右三角) &lt;(左三角)<br>线型:  -  -.  --  : <br>颜色:r-red，g-green，b-blue，w-white，k-black，<span class="hljs-built_in">i</span>-invisible(无色)，y-yellow<br><br><span class="hljs-built_in">legend</span>(<span class="hljs-string">'a'</span>)<br>title(<span class="hljs-string">'a'</span>)<br>xlabel(<span class="hljs-string">'T'</span>)<br>ylabel(<span class="hljs-string">'a'</span>)<br><br>set(gca, <span class="hljs-string">'Box'</span>, <span class="hljs-string">'off'</span>, <span class="hljs-string">'TickDir'</span>, <span class="hljs-string">'out'</span>, <span class="hljs-string">'TickLength'</span>, [<span class="hljs-number">.02</span> <span class="hljs-number">.02</span>], ...<br>    <span class="hljs-string">'XMinorTick'</span>, <span class="hljs-string">'on'</span>, <span class="hljs-string">'YMinorTick'</span>, <span class="hljs-string">'on'</span>, <span class="hljs-string">'XGrid'</span>, <span class="hljs-string">'on'</span>, <span class="hljs-string">'YGrid'</span>, <span class="hljs-string">'on'</span>,...<br>    <span class="hljs-string">'box'</span>,<span class="hljs-string">'on'</span>, <span class="hljs-string">'XColor'</span>, [<span class="hljs-number">.3</span> <span class="hljs-number">.3</span> <span class="hljs-number">.3</span>], <span class="hljs-string">'YColor'</span>, [<span class="hljs-number">.3</span> <span class="hljs-number">.3</span> <span class="hljs-number">.3</span>],<span class="hljs-string">'LineWidth'</span>, <span class="hljs-number">1</span>)<br><br>LineWidth    线宽,数值,如<span class="hljs-number">0.5</span>,<span class="hljs-number">1</span>等,单位为points<br>MarkerEdgeColor   标记点边框线条颜色,颜色字符,如’g’,’b’等<br>MarkerFaceColor   标记点内部区域填充颜色,颜色字符<br>MarkerSize   标记点大小,数值,单位为points<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
            <tag> 画图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim速查表</title>
      <link href="/2019/08/02/vim%E9%80%9F%E6%9F%A5%E8%A1%A8/"/>
      <url>/2019/08/02/vim%E9%80%9F%E6%9F%A5%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>本文主要介绍了以下内容:</strong></p><p>本文主要介绍了vim的一些快捷键，方便自己要用的时候查找。</p><a id="more"></a><h2 id="VIM使用说明与快捷键"><a href="#VIM使用说明与快捷键" class="headerlink" title="VIM使用说明与快捷键"></a>VIM使用说明与快捷键</h2><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/vim%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E4%B8%8E%E5%BF%AB%E6%8D%B7%E9%94%AE.jpg"><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><table><thead><tr><th align="center">移动方向</th><th align="center">快捷键</th></tr></thead><tbody><tr><td align="center">左</td><td align="center">h</td></tr><tr><td align="center">上</td><td align="center">j</td></tr><tr><td align="center">下</td><td align="center">k</td></tr><tr><td align="center">右</td><td align="center">l</td></tr></tbody></table><h3 id="进入插入模式"><a href="#进入插入模式" class="headerlink" title="进入插入模式"></a>进入插入模式</h3><table><thead><tr><th align="center">插入模式</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">i</td><td align="center">在光标前面插入</td></tr><tr><td align="center">I</td><td align="center">在光标所在行最前面插入</td></tr><tr><td align="center">a</td><td align="center">在光标后面插入</td></tr><tr><td align="center">A</td><td align="center">在光标所在行最后面插入</td></tr><tr><td align="center">o</td><td align="center">光标所在行的下一行插入</td></tr><tr><td align="center">O</td><td align="center">光标所在行的上一行插入</td></tr><tr><td align="center">s</td><td align="center">删除光标指向的字符并进入插入模式</td></tr><tr><td align="center">S</td><td align="center">删除光标所在的行并插入</td></tr></tbody></table><h3 id="操作范围"><a href="#操作范围" class="headerlink" title="操作范围"></a>操作范围</h3><table><thead><tr><th align="center">按键</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">将光标移到行首</td></tr><tr><td align="center">$</td><td align="center">将光标移到行尾</td></tr><tr><td align="center">b  (begin)</td><td align="center">将光标移到单词起始处</td></tr><tr><td align="center">e  (end)</td><td align="center">将光标移到单词末尾</td></tr><tr><td align="center">w</td><td align="center">将光标移到下一个单词的开头</td></tr><tr><td align="center">gg</td><td align="center">将光标移到文件的开头</td></tr><tr><td align="center">G</td><td align="center">将光标移到文件的末尾</td></tr></tbody></table><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><table><thead><tr><th align="center">按键</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">d0</td><td align="center">删除光标到行首的所有字符</td></tr><tr><td align="center">d$</td><td align="center">删除光标到行尾的所有字符</td></tr><tr><td align="center">db</td><td align="center">删除光标到该单词行首的所有字符</td></tr><tr><td align="center">de</td><td align="center">删除光标到该单词行尾的所有字符</td></tr><tr><td align="center">dw</td><td align="center">删除光标到下一个单词开头的所有字符</td></tr><tr><td align="center">dh</td><td align="center">删除光标所在字符的上一个字符</td></tr><tr><td align="center">dl</td><td align="center">删除光标所在字符</td></tr><tr><td align="center">dj</td><td align="center">删除光标所在行和下一行</td></tr><tr><td align="center">dk</td><td align="center">删除光标所在行和上一行</td></tr><tr><td align="center">dd</td><td align="center">删除光标所在行</td></tr><tr><td align="center">dgg</td><td align="center">删除光标所在行到文件开头所有字符</td></tr><tr><td align="center">dG</td><td align="center">删除光标所在行到文件末尾所有字符</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 计算机工具 </category>
          
          <category> vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
            <tag> 速查表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数阶乘</title>
      <link href="/2019/08/02/%E5%A4%A7%E6%95%B0%E9%98%B6%E4%B9%98/"/>
      <url>/2019/08/02/%E5%A4%A7%E6%95%B0%E9%98%B6%E4%B9%98/</url>
      
        <content type="html"><![CDATA[<p><strong>本文主要介绍了以下内容:</strong></p><p>求n!具体值c++实现</p><a id="more"></a><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;//大数N!  </span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;  </span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;  <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  <br></span>&#123;  <br>    <span class="hljs-keyword">int</span> n,a[<span class="hljs-number">100000</span>],i,j,wei,up;  <br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n)!=EOF)  <br>    &#123;  <br>        <span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(a));<span class="hljs-comment">//一定要清零  </span><br>        up=<span class="hljs-number">0</span>;  <br>        wei=<span class="hljs-number">1</span>;  <br>        a[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-comment">//当前结果的位数，便于相乘和最后输出   </span><br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>||n==<span class="hljs-number">0</span>)  <br>        &#123;  <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"1\n"</span>);  <br>            <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//如果为1!或0!则输出后直接进行下一个阶乘计算  </span><br>        &#125;  <br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>; i&lt;=n; i++)<span class="hljs-comment">//N!中的每个数  </span><br>        &#123;  <br>            <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>,up=<span class="hljs-number">0</span>; j&lt;=wei; j++)  <br>            &#123;  <br>                a[j]=a[j]*i+up; <span class="hljs-comment">//当前j数加 进位  </span><br>                up=a[j]/<span class="hljs-number">10</span>;<span class="hljs-comment">//进位整除10  </span><br>                a[j]=a[j]%<span class="hljs-number">10</span>;<span class="hljs-comment">//当前数取余存储  </span><br>            &#125;  <br>            <span class="hljs-keyword">while</span>(up&gt;<span class="hljs-number">0</span>)<span class="hljs-comment">//最后首位大于0则要取余进位  </span><br>            &#123;  <br>                a[j++]+=up%<span class="hljs-number">10</span>;<span class="hljs-comment">//j++的值为进位取余 注意 j++导致后面的j加了一  </span><br>                up=up/<span class="hljs-number">10</span>;  <br>            &#125;  <br>            wei=j<span class="hljs-number">-1</span>;<span class="hljs-comment">//减去上面的j++  </span><br>        &#125;  <br>        <span class="hljs-keyword">for</span>(i=wei; i&gt;=<span class="hljs-number">1</span>; i--)  <br>            (i!=<span class="hljs-number">1</span>)? <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,a[i]) : <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,a[i]);<span class="hljs-comment">//三目 判断是否为最后一位 则输出换行  </span><br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
          <category> 算法模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数 </tag>
            
            <tag> 算法模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++文件操作</title>
      <link href="/2018/05/11/c++%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/05/11/c++%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p><strong>本文主要介绍了以下内容:</strong></p><p>c++的读取文件/输入方式总结</p><a id="more"></a><p><strong>getline(istream &amp;in,string &amp;s)</strong></p><p>​    从输入流读入一行到string s</p><p>功能</p><ul><li>从输入流中读取字符，存到string 变量中</li><li>一直到出现以下情况为止<ul><li>读入了文件结束标志</li><li>读到了一个新行</li><li>达到字符串的最大长度</li></ul></li><li>如果getline没有读入字符，将返回false,可用于判断文件是否结束</li></ul><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;<br>    <span class="hljs-built_in">string</span> buff;<br>    ifstream infile;<br>    ofstream outfile;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Input file name: "</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;buff;<br>    infile.open(buff.c_str());<br><br>    <span class="hljs-keyword">if</span>(!infile)<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"error"</span>&lt;&lt;buff&lt;&lt;<span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Input outfile name: "</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;buff;<br>    outfile.open(buff.c_str());<br><br>    <span class="hljs-keyword">while</span>(getline(infile, buff))<br>        outfile&lt;&lt;buff&lt;&lt;<span class="hljs-built_in">endl</span>;<br><br>    infile.close();<br>    outfile.close();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab学习笔记(8)</title>
      <link href="/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-8/"/>
      <url>/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-8/</url>
      
        <content type="html"><![CDATA[<p><strong>本文主要介绍了以下内容:</strong></p><p>matlab程序流程控制:</p><ol><li>M文件的概念与基本操作</li><li>matlab程序控制结构</li><li>matlab函数文件</li><li>matlab程序调试与优化</li></ol><a id="more"></a><h1 id="M文件"><a href="#M文件" class="headerlink" title="M文件"></a>M文件</h1><p>用matlab语言编写的程序,称为M文件</p><p>M文件是由若干matlab命令组合在一起构成的,它可以完成某些操作,也可以实现某种算法</p><p>matlab提供的内部函数以及各种工具箱,都是利用matlab命令开发的M文件</p><p>用户可以根据自己的需要,开发具体的程序或工具箱</p><h2 id="M文件的分类"><a href="#M文件的分类" class="headerlink" title="M文件的分类"></a>M文件的分类</h2><p>通常,M文件可以根据调用方式的不同分为两类:<strong>命令文件(脚本文件)</strong>和<strong>函数文件</strong>,它们的扩展名均为<strong>.m</strong></p><p>主要区别:</p><ol><li><p>命令文件没有参数,也不会返回输出参数,而函数文件可以带参数,也可以返回输出参数</p></li><li><p>命令文件对matlab工作空间中的变量进行操作,文件中所有命令的执行结果也完全返回到工作空间中,而函数文件中定义的变量为<strong>局部变量</strong>,当函数文件执行完毕时,这些变量被清除</p></li><li><p>命令文件可以直接运行,在matlab命令行窗口输入命令文件的名字,就会顺序执行命令文件中的命令,而函数文件不能直接运行,要以函数调用的方式来调用</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab学习笔记(7)</title>
      <link href="/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-7/"/>
      <url>/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-7/</url>
      
        <content type="html"><![CDATA[<p><strong>本文主要介绍了以下内容:</strong></p><p>字符串</p><a id="more"></a><h3 id="字符串的表示"><a href="#字符串的表示" class="headerlink" title="字符串的表示"></a>字符串的表示</h3><p>在matlab中,字符串是用单撇号括起来的字符序列,例如:</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; s=<span class="hljs-string">'hello world'</span><br><br>s =<br><br>    <span class="hljs-string">'hello world'</span><br></code></pre></td></tr></table></figure><p>matlab将字符串当做一个行向量,每个元素对应一个字符,其标识方法和数值向量相同,也可以建立多行字符串矩阵,例如:</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; s=[<span class="hljs-string">'hello '</span>,<span class="hljs-string">'hu ben'</span>]<br><br>s =<br><br>    <span class="hljs-string">'hello hu ben'</span><br></code></pre></td></tr></table></figure><p>这里要求各行字符数要相等,为此,有时候必须添加几个空格来保证各行的长度相等</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; ch=<span class="hljs-string">'abcdefg1234567ABCDEFG'</span><br><br>ch =<br><br>    <span class="hljs-string">'abcdefg1234567ABCDEFG'</span><br><br>&gt;&gt; subch=ch(<span class="hljs-number">1</span>:<span class="hljs-number">5</span>)<span class="hljs-comment">%取子串</span><br><br>subch =<br><br>    <span class="hljs-string">'abcde'</span><br><br>&gt;&gt; revch=ch(<span class="hljs-keyword">end</span>:<span class="hljs-number">-1</span>:<span class="hljs-number">1</span>)<span class="hljs-comment">%反转字符串</span><br><br>revch =<br><br>    <span class="hljs-string">'GFEDCBA7654321gfedcba'</span><br> <br>&gt;&gt; k=<span class="hljs-built_in">find</span>(ch&gt;=<span class="hljs-string">'a'</span>&amp;ch&lt;=<span class="hljs-string">'z'</span>)<span class="hljs-comment">%找到特定字符</span><br><br>k =<br><br>     <span class="hljs-number">1</span>     <span class="hljs-number">2</span>     <span class="hljs-number">3</span>     <span class="hljs-number">4</span>     <span class="hljs-number">5</span>     <span class="hljs-number">6</span>     <span class="hljs-number">7</span><br><br>&gt;&gt; ch(k)=ch(k)-<span class="hljs-string">'a'</span>+<span class="hljs-string">'A'</span><span class="hljs-comment">%修改特定字符</span><br><br>ch =<br><br>    <span class="hljs-string">'ABCDEFG1234567ABCDEFG'</span><br><br>&gt;&gt; <span class="hljs-built_in">length</span>(ch)<span class="hljs-comment">%计算字符串ch的长度</span><br><br><span class="hljs-built_in">ans</span> =<br><br>    <span class="hljs-number">21</span><br></code></pre></td></tr></table></figure><h3 id="字符串的操作"><a href="#字符串的操作" class="headerlink" title="字符串的操作"></a>字符串的操作</h3><h4 id="字符串的执行"><a href="#字符串的执行" class="headerlink" title="字符串的执行"></a>字符串的执行</h4><p>与字符串有关的一个重要函数是<strong>eval</strong>,它的作用是把字符串的内容作为对应的matlab命令来执行,其调用格式为:<strong>eval(s)</strong></p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; t=<span class="hljs-built_in">pi</span><br><br>t =<br><br>   <span class="hljs-number">3.141592653589793</span><br><br>&gt;&gt; m=<span class="hljs-string">'[t,sin(t),cos(t)]'</span>;<br>&gt;&gt; y=eval(m)<br><br>y =<br><br>   <span class="hljs-number">3.141592653589793</span>   <span class="hljs-number">0.000000000000000</span>  <span class="hljs-number">-1.000000000000000</span><br></code></pre></td></tr></table></figure><h4 id="字符串与数值之间的转换"><a href="#字符串与数值之间的转换" class="headerlink" title="字符串与数值之间的转换"></a>字符串与数值之间的转换</h4><p>字符串是以ASCII码来保存的,<strong>abs</strong>和<strong>double</strong>函数都可以用来获取字符串矩阵对应的ASCII码数值矩阵</p><p>相反,<strong>char</strong>函数可以把ASCII码矩阵转换为字符串矩阵,例如:</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; s1=<span class="hljs-string">'matlab'</span><br><br>s1 =<br><br>    <span class="hljs-string">'matlab'</span><br><br>&gt;&gt; a=<span class="hljs-built_in">abs</span>(s1)<br><br>a =<br><br>   <span class="hljs-number">109</span>    <span class="hljs-number">97</span>   <span class="hljs-number">116</span>   <span class="hljs-number">108</span>    <span class="hljs-number">97</span>    <span class="hljs-number">98</span><br><br>&gt;&gt; char(a)<br><br><span class="hljs-built_in">ans</span> =<br><br>    <span class="hljs-string">'matlab'</span><br></code></pre></td></tr></table></figure><p>matlab还有很多用于字符串和数值数据之间转换的函数,例如,<strong>setstr</strong>函数将ASCII码值转换为对应的字符,<strong>str2num</strong>函数或<strong>str2double</strong>函数将数字字符串转换成数值,<strong>num2str</strong>函数将数值转换成字符串,<strong>int2str</strong>函数将整数转换成字符串</p><h4 id="字符串的连接"><a href="#字符串的连接" class="headerlink" title="字符串的连接"></a>字符串的连接</h4><p>用中括号将若干个字符串括起来,从而得到一个更大的字符串</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; a=<span class="hljs-string">'12345'</span>;<br>&gt;&gt; b=<span class="hljs-string">'4321'</span>;<br>&gt;&gt; [a,b]<br><br><span class="hljs-built_in">ans</span> =<br><br>    <span class="hljs-string">'123454321'</span><br></code></pre></td></tr></table></figure><h4 id="字符串的比较"><a href="#字符串的比较" class="headerlink" title="字符串的比较"></a>字符串的比较</h4><h5 id="利用关系运算符进行比较"><a href="#利用关系运算符进行比较" class="headerlink" title="利用关系运算符进行比较"></a>利用关系运算符进行比较</h5><p>当两个字符串长度相等时,可以<strong>直接</strong>利用关系运算符进行比较,比较的规则是按ASCII值大小进行比较的</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; a=<span class="hljs-string">'134567'</span>;<br>&gt;&gt; b=<span class="hljs-string">'213145'</span>;<br>&gt;&gt; a&gt;b<br><br><span class="hljs-built_in">ans</span> =<br><br>  <span class="hljs-number">1</span>×<span class="hljs-number">6</span> logical 数组<br><br>   <span class="hljs-number">0</span>   <span class="hljs-number">1</span>   <span class="hljs-number">1</span>   <span class="hljs-number">1</span>   <span class="hljs-number">1</span>   <span class="hljs-number">1</span><br><br>&gt;&gt; a&lt;b<br><br><span class="hljs-built_in">ans</span> =<br><br>  <span class="hljs-number">1</span>×<span class="hljs-number">6</span> logical 数组<br><br>   <span class="hljs-number">1</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span><br><br>&gt;&gt; a==b<br><br><span class="hljs-built_in">ans</span> =<br><br>  <span class="hljs-number">1</span>×<span class="hljs-number">6</span> logical 数组<br><br>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h5 id="利用字符串比较函数进行比较"><a href="#利用字符串比较函数进行比较" class="headerlink" title="利用字符串比较函数进行比较"></a>利用字符串比较函数进行比较</h5><ol><li><strong>strcmp(s1,s2)</strong>:比较s1和s2<strong>所有字符是否完全相等</strong></li><li><strong>strncmp(s1,s2)</strong>:比较s1和s2<strong>前n个字符是否完全相等</strong></li><li><strong>strcmpi(s1,s2)</strong>:<strong>在忽略字母大小写的情况下</strong>,比较s1和s2<strong>所有字符是否相等</strong></li><li><strong>strncmpi(s1,s2)</strong>:<strong>在忽略字母大小写的情况下</strong>,比较s1和s2<strong>前n个字符是否相等</strong></li></ol><h4 id="字符串的查找与替换"><a href="#字符串的查找与替换" class="headerlink" title="字符串的查找与替换"></a>字符串的查找与替换</h4><h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><p><strong>findstr(s1,s2)</strong>:返回短字符串s2在长字符串s1中出现的位置</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; a=<span class="hljs-string">'12321232123'</span>;<br>&gt;&gt; b=<span class="hljs-string">'123'</span>;<br>&gt;&gt; findstr(a,b)<br><br><span class="hljs-built_in">ans</span> =<br><br>     <span class="hljs-number">1</span>     <span class="hljs-number">5</span>     <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h5 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h5><p><strong>strrep(s1,s2,s3)</strong>:将字符串s1中<strong>所有</strong>子字符串s2替换为字符串s3</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; a=<span class="hljs-string">'12321232123'</span>;<br>&gt;&gt; b=<span class="hljs-string">'123'</span>;<br>&gt;&gt; findstr(a,b)<br><br><span class="hljs-built_in">ans</span> =<br><br>     <span class="hljs-number">1</span>     <span class="hljs-number">5</span>     <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab学习笔记(6)</title>
      <link href="/2018/04/30/matalb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6/"/>
      <url>/2018/04/30/matalb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6/</url>
      
        <content type="html"><![CDATA[<p><strong>matlab学习笔记(6)主要介绍了以下内容:</strong></p><p>矩阵分析</p><ol><li>对角阵与三角阵</li><li>矩阵的转置与旋转</li><li>矩阵的逆与伪逆</li><li>方阵的行列式</li><li>矩阵的秩与迹</li><li>向量和矩阵的范数</li><li>矩阵的条件数</li><li>矩阵的特征值与特征向量</li><li>矩阵的超越函数</li></ol><a id="more"></a><h3 id="对角阵与三角阵"><a href="#对角阵与三角阵" class="headerlink" title="对角阵与三角阵"></a>对角阵与三角阵</h3><h4 id="对角阵"><a href="#对角阵" class="headerlink" title="对角阵"></a>对角阵</h4><p>只有对角线上有非0元素的矩阵称为<strong>对角矩阵</strong>,对角线上的元素相等的对角矩阵称为<strong>数量矩阵</strong>,对角线上都为1的矩阵称为<strong>单位矩阵</strong></p><h5 id="提取矩阵的对角线元素"><a href="#提取矩阵的对角线元素" class="headerlink" title="提取矩阵的对角线元素"></a>提取矩阵的对角线元素</h5><p>调用函数diag(a)</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br><span class="hljs-built_in">diag</span>(a)=<br><span class="hljs-number">1.00</span><br><span class="hljs-number">5.00</span><br><span class="hljs-number">9.00</span><br></code></pre></td></tr></table></figure><ul><li>diag(a)函数还有一种形式diag(a,k),其功能是提取<strong>第k条对角线元素</strong></li><li>与主对角线平行,往上为第1条,第2条,…,第n条对角线,往下为第-1条,第-2条,…,第-n条</li><li>主对角线为第0条对角线</li></ul><h5 id="构造对角矩阵"><a href="#构造对角矩阵" class="headerlink" title="构造对角矩阵"></a>构造对角矩阵</h5><p>设<strong>V</strong>为具有m个元素的向量,diag(<strong>V</strong>)将产生一个m×m对角矩阵,其主对角线元素即为向量<strong>V</strong>的元素</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-built_in">diag</span>(<span class="hljs-number">1</span>:<span class="hljs-number">3</span>)=<br><span class="hljs-number">1.00</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span><br>   <span class="hljs-number">0</span>    <span class="hljs-number">2.00</span>       <span class="hljs-number">0</span><br>   <span class="hljs-number">0</span>       <span class="hljs-number">0</span>    <span class="hljs-number">3.00</span><br></code></pre></td></tr></table></figure><p>diag(<strong>V</strong>,k)创建一个矩阵,对角线向上或者向下移动k个单位,<strong>还是形成方阵</strong></p><h5 id="三角阵"><a href="#三角阵" class="headerlink" title="三角阵"></a>三角阵</h5><p>三角阵分为<strong>上三角阵</strong>(矩阵对角线以下的元素全为0的矩阵)和<strong>下三角阵</strong>(矩阵对角线以上的元素全为0的矩阵)</p><h6 id="上三角矩阵"><a href="#上三角矩阵" class="headerlink" title="上三角矩阵"></a>上三角矩阵</h6><p>调用函数<strong>triu(a)</strong></p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br><span class="hljs-built_in">triu</span>(a)=<br>          <span class="hljs-number">1.00</span>          <span class="hljs-number">2.00</span>          <span class="hljs-number">3.00</span><br>             <span class="hljs-number">0</span>          <span class="hljs-number">5.00</span>          <span class="hljs-number">6.00</span><br>             <span class="hljs-number">0</span>             <span class="hljs-number">0</span>          <span class="hljs-number">9.00</span><br></code></pre></td></tr></table></figure><p><strong>triu(a,k)</strong>求矩阵a的第k条对角线以上的元素</p><h6 id="下三角矩阵"><a href="#下三角矩阵" class="headerlink" title="下三角矩阵"></a>下三角矩阵</h6><p>调用函数<strong>tril(a)</strong></p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br><span class="hljs-built_in">tril</span>(a)=<br>          <span class="hljs-number">1.00</span>             <span class="hljs-number">0</span>             <span class="hljs-number">0</span><br>          <span class="hljs-number">4.00</span>          <span class="hljs-number">5.00</span>             <span class="hljs-number">0</span><br>          <span class="hljs-number">7.00</span>          <span class="hljs-number">8.00</span>          <span class="hljs-number">9.00</span><br></code></pre></td></tr></table></figure><p><strong>tril(a,k)</strong>求矩阵a的第k条对角线以下的元素</p><h3 id="矩阵的转置与旋转"><a href="#矩阵的转置与旋转" class="headerlink" title="矩阵的转置与旋转"></a>矩阵的转置与旋转</h3><h4 id="矩阵的转置"><a href="#矩阵的转置" class="headerlink" title="矩阵的转置"></a>矩阵的转置</h4><p>把源矩阵的第1行变成目标矩阵的第1列,第2行变成第2列,…,以此类推</p><p>转置运算符是  <strong>.’</strong></p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">71</span>,<span class="hljs-number">3</span>,<span class="hljs-number">-8</span>;<span class="hljs-number">2</span>,<span class="hljs-number">-9</span>,<span class="hljs-number">8</span>;<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br>a.'=<br>         <span class="hljs-number">71.00</span>          <span class="hljs-number">2.00</span>             <span class="hljs-number">0</span><br>          <span class="hljs-number">3.00</span>         <span class="hljs-number">-9.00</span>          <span class="hljs-number">4.00</span><br>         <span class="hljs-number">-8.00</span>          <span class="hljs-number">8.00</span>          <span class="hljs-number">5.00</span><br></code></pre></td></tr></table></figure><p>还有一种转置叫做共轭转置,其运算符是单个引号  <strong>‘</strong>  ,它在转置的基础上还要取每个数的复共轭</p><p>例如: <strong>b=a’</strong>得到的b就是a的共轭转置矩阵,等价于<strong>b=conj(a).’</strong>或者<strong>b=conj(a.’)</strong></p><p>如果矩阵元素都是实数,那么转置和共轭转置得到的结果是一样的</p><h4 id="矩阵的旋转"><a href="#矩阵的旋转" class="headerlink" title="矩阵的旋转"></a>矩阵的旋转</h4><p>调用函数<strong>rot90(a,k)</strong></p><p>将矩阵a逆时针旋转90的k倍,当k=1时可省略不写</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br><span class="hljs-built_in">rot90</span>(a,<span class="hljs-number">2</span>)=<br>          <span class="hljs-number">9.00</span>          <span class="hljs-number">8.00</span>          <span class="hljs-number">7.00</span><br>          <span class="hljs-number">6.00</span>          <span class="hljs-number">5.00</span>          <span class="hljs-number">4.00</span><br>          <span class="hljs-number">3.00</span>          <span class="hljs-number">2.00</span>          <span class="hljs-number">1.00</span><br></code></pre></td></tr></table></figure><h4 id="矩阵的左右翻"><a href="#矩阵的左右翻" class="headerlink" title="矩阵的左右翻"></a>矩阵的左右翻</h4><p>对矩阵实施左右翻转是将矩阵的第1列和最后1列调换,第2列和倒数第2列调换,…,依次类推</p><p>matlab对矩阵a实施左右翻转的函数是fliplr(a)</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br><span class="hljs-built_in">fliplr</span>(a)=<br>          <span class="hljs-number">3.00</span>          <span class="hljs-number">2.00</span>          <span class="hljs-number">1.00</span><br>          <span class="hljs-number">6.00</span>          <span class="hljs-number">5.00</span>          <span class="hljs-number">4.00</span><br>          <span class="hljs-number">9.00</span>          <span class="hljs-number">8.00</span>          <span class="hljs-number">7.00</span><br></code></pre></td></tr></table></figure><h4 id="矩阵的上下翻转"><a href="#矩阵的上下翻转" class="headerlink" title="矩阵的上下翻转"></a>矩阵的上下翻转</h4><p>对矩阵实施上下翻转是将矩阵的第1行和最后1行调换,第2行和倒数第2行调换,…,依次类推</p><p>matlab对矩阵a实施上下翻转的函数是flipud(a)</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br><span class="hljs-built_in">flipud</span>(a)=<br>          <span class="hljs-number">7.00</span>          <span class="hljs-number">8.00</span>          <span class="hljs-number">9.00</span><br>          <span class="hljs-number">4.00</span>          <span class="hljs-number">5.00</span>          <span class="hljs-number">6.00</span><br>          <span class="hljs-number">1.00</span>          <span class="hljs-number">2.00</span>          <span class="hljs-number">3.00</span><br></code></pre></td></tr></table></figure><h3 id="矩阵的逆与伪逆"><a href="#矩阵的逆与伪逆" class="headerlink" title="矩阵的逆与伪逆"></a>矩阵的逆与伪逆</h3><h4 id="矩阵的逆"><a href="#矩阵的逆" class="headerlink" title="矩阵的逆"></a>矩阵的逆</h4><p>对于一个方阵a,如果存在一个与其同阶的方阵b,使得<br>$$<br>a·b=b·a=I(I为单位矩阵)<br>$$<br>则称b为a的逆矩阵,当然,a也是b的逆矩阵</p><p>在matlab中求逆矩阵直接使用<strong>inv(a)</strong>即可</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>;<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>;<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br>inv(a)=<br>          <span class="hljs-number">5.22</span>          <span class="hljs-number">1.44</span>         <span class="hljs-number">-3.22</span><br>         <span class="hljs-number">-5.11</span>         <span class="hljs-number">-1.22</span>          <span class="hljs-number">3.11</span><br>          <span class="hljs-number">2.22</span>          <span class="hljs-number">0.44</span>         <span class="hljs-number">-1.22</span><br></code></pre></td></tr></table></figure><h4 id="矩阵的伪逆"><a href="#矩阵的伪逆" class="headerlink" title="矩阵的伪逆"></a>矩阵的伪逆</h4><p>如果矩阵a不是一个方阵,或者a是一个非满秩的方阵时,矩阵a没有逆矩阵,但可以找到一个与a的转置矩阵a’同型的矩阵b使得<br>$$<br>a·b·a=a\<br>b·a·b=b<br>$$<br>此时称矩阵b为矩阵a的伪逆,也称为广义逆矩阵,可以使用函数<strong>pinv(a)</strong>求解</p><figure class="hljs highlight Matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Matlab">a=[<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>];<br>pinv(a)=<br>          <span class="hljs-number">0.39</span>         <span class="hljs-number">-0.11</span>         <span class="hljs-number">-0.11</span><br>         <span class="hljs-number">-0.11</span>          <span class="hljs-number">0.39</span>         <span class="hljs-number">-0.11</span><br>         <span class="hljs-number">-0.11</span>         <span class="hljs-number">-0.11</span>          <span class="hljs-number">0.39</span><br>          <span class="hljs-number">0.04</span>          <span class="hljs-number">0.04</span>          <span class="hljs-number">0.04</span><br></code></pre></td></tr></table></figure><p>若a是一个奇异矩阵(行列式为0),无一般意义上的逆矩阵,但可以求a得伪逆矩阵,例如:</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>];<br>pinv(a)=<br>             <span class="hljs-number">0</span>             <span class="hljs-number">0</span>             <span class="hljs-number">0</span><br>             <span class="hljs-number">0</span>          <span class="hljs-number">1.00</span>             <span class="hljs-number">0</span><br>             <span class="hljs-number">0</span>             <span class="hljs-number">0</span>          <span class="hljs-number">1.00</span><br></code></pre></td></tr></table></figure><h3 id="方阵的行列式"><a href="#方阵的行列式" class="headerlink" title="方阵的行列式"></a>方阵的行列式</h3><p>调用函数det(a)求解</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>;<span class="hljs-number">-3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>];<br>det(a)=<br><span class="hljs-number">-10.00</span><br></code></pre></td></tr></table></figure><h3 id="矩阵的秩与迹"><a href="#矩阵的秩与迹" class="headerlink" title="矩阵的秩与迹"></a>矩阵的秩与迹</h3><h4 id="矩阵的秩"><a href="#矩阵的秩" class="headerlink" title="矩阵的秩"></a>矩阵的秩</h4><p>矩阵线性无关的行数与列数称为矩阵的秩</p><p>调用函数rank(a)</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>];<br>rank(a)=<br><span class="hljs-number">3.00</span><br></code></pre></td></tr></table></figure><h4 id="矩阵的迹"><a href="#矩阵的迹" class="headerlink" title="矩阵的迹"></a>矩阵的迹</h4><p>矩阵的迹等于矩阵的对角线元素之和,也等于矩阵的特征值之和</p><p>调用函数trace(a)</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>];<br>trace(a)=<br><span class="hljs-number">3.00</span><br></code></pre></td></tr></table></figure><h3 id="向量和矩阵范数"><a href="#向量和矩阵范数" class="headerlink" title="向量和矩阵范数"></a>向量和矩阵范数</h3><p>矩阵或向量的范数用来度量矩阵或向量在某种意义下的长度</p><p>范数有多种方法定义,其定义不同,范数值也就不同,因此,讨论范数时,一定要弄清是哪一种范数</p><h4 id="向量的三种常用范数及其计算函数"><a href="#向量的三种常用范数及其计算函数" class="headerlink" title="向量的三种常用范数及其计算函数"></a>向量的三种常用范数及其计算函数</h4><p>向量的1-范数:向量元素的绝对值之和     <strong>norm(V,1)</strong><br>$$<br>\left\| v\right\| _{1}=\sum ^{n}_{i=1}\left| v_{i}\right|<br>$$<br>向量的2-范数:向量元素平方和的平方根    <strong>norm(V,2)</strong><br>$$<br>\left\| v\right\|_{2} =\sqrt {\sum ^{n}_{i=1}v^{2}_{i}}<br>$$<br>向量的∞-范数:所有向量元素绝对值中的最大值     <strong>norm(V,inf)</strong><br>$$<br>\left\|v\right\|_{∞} =\max _{1\leq i\leq n}\left\{ \left| V_{i}\right| \right\}<br>$$</p><h4 id="矩阵的范数及其计算函数"><a href="#矩阵的范数及其计算函数" class="headerlink" title="矩阵的范数及其计算函数"></a>矩阵的范数及其计算函数</h4><p>设a是一个m×n的矩阵,V是一个含有n个元素的列向量,定义<br>$$<br>\left\| a\right\|=max\left\| a·V\right\| ,\left\| V\right\| =1<br>$$</p><p>矩阵a的1-范数:所有矩阵列元素绝对值之和的最大值  <strong>norm(a,1)</strong><br>$$<br>\left\| a\right\| _{1}=\max _{1\leq j\leq n}\left\{ \sum ^{m}_{i=1}\left| a_{ij}\right|  \right\}<br>$$<br>矩阵a的2-范数:a’a矩阵的最大特征值的平方根    <strong>norm(V,2)</strong><br>$$<br>\left\| a\right\|_{2} =\sqrt {\lambda _{1}}     (其中\lambda _{1}为a’a的最大特征值)<br>$$<br>向量的∞-范数:所有向量元素绝对值中的最大值     <strong>norm(V,inf)</strong><br>$$<br>\left\| a\right\|_{∞} =\max_{1\leq i\leq m}\left\{\sum ^{n}_{j=1}\left| a_{ij}\right|  \right\}<br>$$</p><h3 id="矩阵的条件数"><a href="#矩阵的条件数" class="headerlink" title="矩阵的条件数"></a>矩阵的条件数</h3><p>在求解线性方程组AX=B时,一般认为,系数矩阵A中个别元素的微小扰动不会引起解向量的很大变化</p><p>这样的假设在工程应用中非常重要,因为一般系数矩阵的数据是由实验数据获得的,并非精确值,但与精确值误差不大</p><p>由上面的假设可以得出如下结论:</p><p><strong>当参与运算的系数与实数精确值误差很小时,所获得的解与问题的准确解误差也很小</strong></p><p>遗憾的是,上述假设并非总是正确的</p><p>对于有的系数矩阵,个别元素的微小扰动会引起解的很大变化,在计算数学中,称这种矩阵为<strong>病态矩阵</strong>,而称解不因其系数矩阵的微小扰动而发生大的变化的矩阵为<strong>良性矩阵</strong></p><p>当然,<strong>良性</strong>与<strong>病态</strong>是相对的,需要一个参数来描述,条件数就是用来描述矩阵的这种性能的一个参数</p><p>矩阵a的条件数等于a的范数与a的逆矩阵的范数的乘积,这样定义的条件数总是大于1的</p><p>计算a的1-范数下的条件数    <strong>cond(a,1)</strong><br>$$<br>cond(a,1)=\left\| a\right\|_{1}·\left\| a^{-1}\right\|_{1}<br>$$<br>计算a的2-范数下的条件数    <strong>cond(a,2)</strong><br>$$<br>cond(a,2)=\left\| a\right\|_{2}·\left\| a^{-1}\right\|_{2}<br>$$<br>计算a的∞-范数下的条件数    <strong>cond(a,inf)</strong><br>$$<br>cond(a,∞)=\left\| a\right\|_{∞}·\left\| a^{-1}\right\|_{∞}<br>$$<br><strong>条件数越接近于1,矩阵的性能越好,反之,矩阵的性能越差</strong></p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">-6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br>b=[<span class="hljs-number">2</span>,<span class="hljs-number">-5</span>,<span class="hljs-number">4</span>;<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">-2</span>;<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>];<br>cond(a)=<br>         <span class="hljs-number">87.98</span><br>cond(b)=<br>          <span class="hljs-number">3.75</span><br></code></pre></td></tr></table></figure><h3 id="矩阵的特征值与特征向量"><a href="#矩阵的特征值与特征向量" class="headerlink" title="矩阵的特征值与特征向量"></a>矩阵的特征值与特征向量</h3><p>对于n阶方阵a,求数λ和向量ξ,使得等式aξ=λξ成立</p><p>满足等式的数λ称为a的特征值,向量ξ称为a的特征向量</p><p>实际上,方程aξ=λξ和(a-λE)ξ=0是两个等价方程</p><p>要使方程(a-λE)ξ=0有非零解ξ,必须使其系数行列式为0,即|a-λE|=0</p><p>线性代数中已经证明,行列式|a-λE|是一个关于λ的n阶多项式,因而|a-λE|=0是一个n次方程,有n个根(含重根),就是矩阵a的n个特征值每一个特征值对应无穷多个特征向量</p><p><strong>矩阵的特征值问题有确定解,但特征向量问题没有确定解</strong></p><p>在matlab中,计算矩阵a的特征值和特征向量的函数是<strong>eig(a)</strong>,常用的调用格式有三种:</p><ol><li><strong>e=eig(a)</strong>:求矩阵a的全部特征值,构成<strong>向量e</strong></li><li><strong>[V,D]=eig(a)</strong>:求矩阵a的全部特征值,构成<strong>对角阵D</strong>,并求a得特征向量构成<strong>V</strong>的列向量</li><li><strong>[V,D]=eig(a,’nobalance’)</strong>:与2功能类似,第2种方法是先对a做相似变换后求矩阵a的特征值和特征向量,而第3种方法是直接求矩阵a的特征值和特征向量</li></ol><p>一个矩阵的特征向量有无穷多个,eig函数只找其中的n个,a的其他特征向量,均可由这n个特征向量的线性组合表示,例如:</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0.5</span>;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0.25</span>;<span class="hljs-number">0.5</span>,<span class="hljs-number">0.25</span>,<span class="hljs-number">2</span>];<br>[V,D]=eig(a)<br>V =<br>   <span class="hljs-number">0.721207129830347</span>   <span class="hljs-number">0.444281058188505</span>   <span class="hljs-number">0.531483411986466</span><br>  <span class="hljs-number">-0.686349287710169</span>   <span class="hljs-number">0.562109420455869</span>   <span class="hljs-number">0.461473352095774</span><br>  <span class="hljs-number">-0.093727963498713</span>  <span class="hljs-number">-0.697601133004864</span>   <span class="hljs-number">0.710329309608377</span><br>D =<br>  <span class="hljs-number">-0.016647283606310</span>                   <span class="hljs-number">0</span>                   <span class="hljs-number">0</span><br>                   <span class="hljs-number">0</span>   <span class="hljs-number">1.480121423189129</span>                   <span class="hljs-number">0</span><br>                   <span class="hljs-number">0</span>                   <span class="hljs-number">0</span>   <span class="hljs-number">2.536525860417180</span><br></code></pre></td></tr></table></figure><p>求得的三个特征值是-0.0166,1.4801和2.5365,各特征值对应的特征向量为V的各列构成的向量</p><h3 id="矩阵的超越函数"><a href="#矩阵的超越函数" class="headerlink" title="矩阵的超越函数"></a>矩阵的超越函数</h3><p>matlab的数学函数,如sqrt,exp,log等都是作用在矩阵的各元素上的</p><p>matlab还提供了一些直接作用于矩阵的超越函数,其函数名都是上述数学函数名之后缀以m,并规定输入参数a必须是方阵</p><h4 id="矩阵平方根sqrtm"><a href="#矩阵平方根sqrtm" class="headerlink" title="矩阵平方根sqrtm"></a>矩阵平方根sqrtm</h4><p><strong>sqrtm(a)</strong>计算矩阵a的平方根,这是在矩阵意义下的平方根,它与sqrt(a)的结果是不同的</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; a=[<span class="hljs-number">4</span>,<span class="hljs-number">2</span>;<span class="hljs-number">3</span>,<span class="hljs-number">6</span>];<br>&gt;&gt; b1=sqrtm(a)<br><br>b1 =<br><br>   <span class="hljs-number">1.917137824293506</span>   <span class="hljs-number">0.465175638988947</span><br>   <span class="hljs-number">0.697763458483421</span>   <span class="hljs-number">2.382313463282453</span><br><br>&gt;&gt; b1*b1<br><br><span class="hljs-built_in">ans</span> =<br><br>   <span class="hljs-number">4.000000000000000</span>   <span class="hljs-number">2.000000000000000</span><br>   <span class="hljs-number">3.000000000000000</span>   <span class="hljs-number">6.000000000000000</span><br><br>&gt;&gt; b2=<span class="hljs-built_in">sqrt</span>(a)<br><br>b2 =<br><br>   <span class="hljs-number">2.000000000000000</span>   <span class="hljs-number">1.414213562373095</span><br>   <span class="hljs-number">1.732050807568877</span>   <span class="hljs-number">2.449489742783178</span><br><br>&gt;&gt; b2*b2<br><br><span class="hljs-built_in">ans</span> =<br><br>   <span class="hljs-number">6.449489742783179</span>   <span class="hljs-number">6.292528739883945</span><br>   <span class="hljs-number">7.706742302257039</span>   <span class="hljs-number">8.449489742783177</span><br><br>&gt;&gt; b2.*b2<br><br><span class="hljs-built_in">ans</span> =<br><br>   <span class="hljs-number">4.000000000000000</span>   <span class="hljs-number">2.000000000000000</span><br>   <span class="hljs-number">3.000000000000000</span>   <span class="hljs-number">5.999999999999999</span><br></code></pre></td></tr></table></figure><p>若a为实对称<a href="https://en.wikipedia.org/wiki/Positive-definite_matrix" target="_blank" rel="noopener">正定矩阵</a>或复<a href="https://en.wikipedia.org/wiki/Hermitian_matrix" target="_blank" rel="noopener">埃尔米特(Hermitian)</a>正定阵,则一定能算出它的平方根</p><p><strong>但某些矩阵,如a=[0,1;0,0]就得不到平方根</strong></p><p>如果矩阵a含有负的特征值,则sqrtm(a)将会得到一个复矩阵,例如:</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; a=[<span class="hljs-number">4</span>,<span class="hljs-number">9</span>;<span class="hljs-number">16</span>,<span class="hljs-number">25</span>];<br>&gt;&gt; eig(a)<br><br><span class="hljs-built_in">ans</span> =<br><br>  <span class="hljs-number">-1.445218719101973</span><br>  <span class="hljs-number">30.445218719101973</span><br><br>&gt;&gt; b=sqrtm(a)<br><br>b =<br><br>  <span class="hljs-number">0.942137741124329</span> + <span class="hljs-number">0.996904315125749</span><span class="hljs-built_in">i</span>  <span class="hljs-number">1.557189914222098</span> - <span class="hljs-number">0.339272627367266</span><span class="hljs-built_in">i</span><br>  <span class="hljs-number">2.768337625283729</span> - <span class="hljs-number">0.603151337541807</span><span class="hljs-built_in">i</span>  <span class="hljs-number">4.575580874309223</span> + <span class="hljs-number">0.205268184602128</span><span class="hljs-built_in">i</span><br></code></pre></td></tr></table></figure><h4 id="矩阵对数logm"><a href="#矩阵对数logm" class="headerlink" title="矩阵对数logm"></a>矩阵对数logm</h4><p><strong>logm(a)</strong>计算矩阵a的自然对数</p><p>此函数输入参数的条件与输出结果间的关系和函数<strong>sqrtm(a)</strong>完全一样,例如:</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; a=[<span class="hljs-number">4</span>,<span class="hljs-number">9</span>;<span class="hljs-number">1</span>,<span class="hljs-number">5</span>];<br>&gt;&gt; l=logm(a)<br><br>l =<br><br>   <span class="hljs-number">1.063900819033590</span>   <span class="hljs-number">2.430842712580726</span><br>   <span class="hljs-number">0.270093634731192</span>   <span class="hljs-number">1.333994453764781</span><br></code></pre></td></tr></table></figure><h4 id="矩阵指数expm"><a href="#矩阵指数expm" class="headerlink" title="矩阵指数expm"></a>矩阵指数expm</h4><p><strong>expm(a)</strong>的功能就是求矩阵指数e^a^,例如,对上面计算所得到的a的自然对数l,求其矩阵指数b=e^l^</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; a=[<span class="hljs-number">4</span>,<span class="hljs-number">9</span>;<span class="hljs-number">1</span>,<span class="hljs-number">5</span>];<br>l=logm(a)<br><br>l =<br><br>   <span class="hljs-number">1.063900819033590</span>   <span class="hljs-number">2.430842712580726</span><br>   <span class="hljs-number">0.270093634731192</span>   <span class="hljs-number">1.333994453764781</span><br><br>&gt;&gt; expm(l)<br><br><span class="hljs-built_in">ans</span> =<br><br>   <span class="hljs-number">4.000000000000001</span>   <span class="hljs-number">9.000000000000002</span><br>   <span class="hljs-number">1.000000000000000</span>   <span class="hljs-number">5.000000000000000</span><br></code></pre></td></tr></table></figure><p>从这个结果可以看出,这里所得到的结果恰好和a相同,即<strong>expm函数</strong>和<strong>logm函数</strong>是互逆的</p><h4 id="普通矩阵函数funm"><a href="#普通矩阵函数funm" class="headerlink" title="普通矩阵函数funm"></a>普通矩阵函数funm</h4><p><strong>funm(a,@fun)</strong>对方阵a计算由fun定义的函数的矩阵函数值</p><p>例如,当fun取exp时,<strong>funm(a,@exp)</strong>可以计算矩阵a的指数,与<strong>expm(a)</strong>的计算结果是一样的</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; a=[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>;<span class="hljs-number">2</span>,<span class="hljs-number">-1</span>];<br>&gt;&gt; funm(a,@<span class="hljs-built_in">exp</span>)<br><br><span class="hljs-built_in">ans</span> =<br><br>   <span class="hljs-number">2.718281828459046</span>                   <span class="hljs-number">0</span><br>   <span class="hljs-number">2.350402387287603</span>   <span class="hljs-number">0.367879441171442</span><br><br>&gt;&gt; expm(a)<br><br><span class="hljs-built_in">ans</span> =<br><br>   <span class="hljs-number">2.718281828459046</span>                   <span class="hljs-number">0</span><br>   <span class="hljs-number">2.350402387287603</span>   <span class="hljs-number">0.367879441171442</span><br></code></pre></td></tr></table></figure><p><strong>funm函数</strong>可以用于<strong>exp</strong>,<strong>log</strong>,<strong>sin</strong>,<strong>cos</strong>,<strong>sinh</strong>和<strong>cosh</strong>等函数,但求矩阵的平方根只能使用<strong>sqrtm函数</strong></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab学习笔记(5)</title>
      <link href="/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/"/>
      <url>/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/</url>
      
        <content type="html"><![CDATA[<p><strong>matlab学习笔记(5)主要介绍了以下内容:</strong></p><ol><li>基本算术运算</li><li>点运算</li></ol><a id="more"></a><h4 id="基本算术运算"><a href="#基本算术运算" class="headerlink" title="基本算术运算"></a>基本算术运算</h4><p>matlab的基本算数运算有:+(加),-(减),*(乘),/(右除),\(左除),^(乘方)</p><h5 id="矩阵加减运算"><a href="#矩阵加减运算" class="headerlink" title="矩阵加减运算"></a>矩阵加减运算</h5><p>a和b必须同型(即大小相同)</p><h5 id="矩阵乘法运算"><a href="#矩阵乘法运算" class="headerlink" title="矩阵乘法运算"></a>矩阵乘法运算</h5><p>a为n×m矩阵,b为m×p矩阵才能进行乘法运算</p><h5 id="矩阵除法运算"><a href="#矩阵除法运算" class="headerlink" title="矩阵除法运算"></a>矩阵除法运算</h5><ul><li>在matlab中,有两种矩阵除法运算:/和\,分别表示左除和右除</li><li>只有矩阵a的行列式不为零(即矩阵a为非奇异矩阵)才能进行实现</li><li>a\b等效于a的逆左乘b矩阵,即inv(a)*b</li><li>b/a等效于a的逆右乘b矩阵,即b*inv(a)</li><li>对于标量的运算,两种除法运算的结果都相等</li><li>对于矩阵来说,左除和右除代表两种不同的除数矩阵和被除数矩阵的关系</li><li>对于矩阵来说,一般a\b不等于b/a</li></ul><h5 id="矩阵的乘方"><a href="#矩阵的乘方" class="headerlink" title="矩阵的乘方"></a>矩阵的乘方</h5><ul><li><p>a^x</p></li><li><p>要求a为方阵,x为标量</p></li><li><p>可以计算一个矩阵的方根,例如:</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br>a^<span class="hljs-number">0.1</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="点运算"><a href="#点运算" class="headerlink" title="点运算"></a>点运算</h4><p>在matlab中,有一种特殊的运算,因为其运算符是在有关算术运算符前面加点,所以叫点运算</p><p>点运算符有  .*  ,  ./  ,  .\  ,  .^</p><p>两矩阵进行点运算是指他们对应的对应元素进行相关运算,要求两矩阵的维数相同</p><h5 id="a-b"><a href="#a-b" class="headerlink" title="a.*b"></a>a.*b</h5><p>表示a和b单个元素之间对应相乘,例如</p><figure class="hljs highlight Matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br>b=[<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>;<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>;<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>];<br>a.*b=<br><span class="hljs-number">9</span> <span class="hljs-number">16</span> <span class="hljs-number">21</span><br><span class="hljs-number">24</span> <span class="hljs-number">25</span> <span class="hljs-number">24</span><br><span class="hljs-number">21</span> <span class="hljs-number">16</span> <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h5 id="a-b与b-a"><a href="#a-b与b-a" class="headerlink" title="a./b与b.\a"></a>a./b与b.\a</h5><p>a./b等价于b.\a,例如</p><figure class="hljs highlight Matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];<br>b=[<span class="hljs-number">-2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>;<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>];<br>a./b=<br><span class="hljs-number">-0.5</span> <span class="hljs-number">2.0</span> <span class="hljs-number">1.0</span><br><span class="hljs-number">-4.0</span> <span class="hljs-number">5.0</span> <span class="hljs-number">1.5</span><br>b.\a=<br><span class="hljs-number">-0.5</span> <span class="hljs-number">2.0</span> <span class="hljs-number">1.0</span><br><span class="hljs-number">-4.0</span> <span class="hljs-number">5.0</span> <span class="hljs-number">1.5</span><br></code></pre></td></tr></table></figure><h5 id="a-b-1"><a href="#a-b-1" class="headerlink" title="a.^b"></a>a.^b</h5><p>若两个矩阵同型,则<strong>a.^b</strong>表示两矩阵对应元素进行乘方运算,例如:</p><figure class="hljs highlight Matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>b=[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];<br>a.^b=<br><span class="hljs-number">1</span> <span class="hljs-number">32</span> <span class="hljs-number">729</span><br></code></pre></td></tr></table></figure><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>a.^<span class="hljs-number">2</span>=<br><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><figure class="hljs highlight Matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>b=[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];<br><span class="hljs-number">2.</span>^[a b]=<br><span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">8</span> <span class="hljs-number">16</span> <span class="hljs-number">32</span> <span class="hljs-number">64</span><br></code></pre></td></tr></table></figure><figure class="hljs highlight Matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Matlab"><span class="hljs-comment">%当x分别为0.1,0.4,0.7,1时,分别求y=sin(x)cos(x)的值</span><br>x=[<span class="hljs-number">0.1</span>,<span class="hljs-number">0.4</span>,<span class="hljs-number">0.7</span>,<span class="hljs-number">1</span>];<br><span class="hljs-built_in">sin</span>(x).*<span class="hljs-built_in">cos</span>(x)=<br> <span class="hljs-number">0.10</span>          <span class="hljs-number">0.36</span>          <span class="hljs-number">0.49</span>          <span class="hljs-number">0.45</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab学习笔记(4)</title>
      <link href="/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4/"/>
      <url>/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4/</url>
      
        <content type="html"><![CDATA[<p><strong>matlab学习笔记(4)主要介绍了以下内容:</strong></p><p>矩阵</p><a id="more"></a><h3 id="矩阵的建立"><a href="#矩阵的建立" class="headerlink" title="矩阵的建立"></a>矩阵的建立</h3><h4 id="直接输入法建立矩阵"><a href="#直接输入法建立矩阵" class="headerlink" title="直接输入法建立矩阵"></a>直接输入法建立矩阵</h4><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]<br></code></pre></td></tr></table></figure><h4 id="冒号表达式建立一个向量"><a href="#冒号表达式建立一个向量" class="headerlink" title="冒号表达式建立一个向量"></a>冒号表达式建立一个向量</h4><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=<span class="hljs-number">0</span>:<span class="hljs-number">1</span>:<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>如果冒号表达式中省略第二个冒号,则默认步长为1</p><h4 id="用linspace函数产生行向量"><a href="#用linspace函数产生行向量" class="headerlink" title="用linspace函数产生行向量"></a>用linspace函数产生行向量</h4><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-built_in">linspace</span>(l,r,n)<br></code></pre></td></tr></table></figure><p>其中l,r是生成向量的第一个元素和最后一个元素,n是元素总数,当n省略时,自动产生100个元素</p><h4 id="利用已建好的小矩阵拼接成大矩阵"><a href="#利用已建好的小矩阵拼接成大矩阵" class="headerlink" title="利用已建好的小矩阵拼接成大矩阵"></a>利用已建好的小矩阵拼接成大矩阵</h4><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>:<span class="hljs-number">2</span>:<span class="hljs-number">6</span>;<span class="hljs-number">2</span>:<span class="hljs-number">2</span>:<span class="hljs-number">6</span>];<br>b=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];<br>c=[a;b]<br></code></pre></td></tr></table></figure><h3 id="矩阵的拆分"><a href="#矩阵的拆分" class="headerlink" title="矩阵的拆分"></a>矩阵的拆分</h3><h4 id="直接通过下标来引用"><a href="#直接通过下标来引用" class="headerlink" title="直接通过下标来引用"></a>直接通过下标来引用</h4><p>如<code>a(3,2)</code>表示a矩阵第3行第2列元素,通常情况下,是对矩阵的单个元素进行赋值或其他操作</p><p><strong>如果给出的行下标或者列下标大于原矩阵的行数和列数,则matlab将自动扩展原来的矩阵,并将扩展后未赋值的元素置为0</strong></p><h4 id="通过冒号表达式获得子矩阵"><a href="#通过冒号表达式获得子矩阵" class="headerlink" title="通过冒号表达式获得子矩阵"></a>通过冒号表达式获得子矩阵</h4><ol><li>可以直接用单个的冒号来作为行下标或列下标<ul><li><strong>a(i,:)</strong>表示a矩阵第i行的全部元素</li><li><strong>a(:,j)</strong>表示a矩阵第j列的全部元素</li><li><strong>a(i:i+m,j:j+k)</strong>表示a矩阵第i~i+m行,第j ~j+k列所有的元素</li></ul></li><li>速度比循环结构快</li><li>此外还可以用<strong>end</strong>关键字来表示某一维的末尾元素下标</li></ol><h4 id="利用空矩阵删除矩阵的元素"><a href="#利用空矩阵删除矩阵的元素" class="headerlink" title="利用空矩阵删除矩阵的元素"></a>利用空矩阵删除矩阵的元素</h4><p>在matlab中,定义[]为空矩阵,给变量x赋空矩阵的语句为</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">x=[]<br></code></pre></td></tr></table></figure><p><strong>x=[]与clear x不同,clear是将x从工作空间中删除,而空矩阵则存在于工作空间中,只是维数为0</strong></p><p>将矩阵中的某些元素删除,可以采用空矩阵的方法,例如:</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>;<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>;<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>];<br>a(:,<span class="hljs-number">2</span>:<span class="hljs-number">4</span>)=[]       <span class="hljs-comment">%删除a的第2~4列元素</span><br>a(:,[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>])=[]      <span class="hljs-comment">%删除a的第2列和第4列元素</span><br></code></pre></td></tr></table></figure><h4 id="改变矩阵的形状"><a href="#改变矩阵的形状" class="headerlink" title="改变矩阵的形状"></a>改变矩阵的形状</h4><p>reshape(a,m,n)函数在矩阵总元素保持不变的前提下,将矩阵a重新排成m*n的二维矩阵</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab">x=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br>y=<span class="hljs-built_in">reshape</span>(a,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>);<br>y =<br><br>          <span class="hljs-number">1.00</span>          <span class="hljs-number">4.00</span>          <span class="hljs-number">7.00</span><br>          <span class="hljs-number">2.00</span>          <span class="hljs-number">5.00</span>          <span class="hljs-number">8.00</span><br>          <span class="hljs-number">3.00</span>          <span class="hljs-number">6.00</span>          <span class="hljs-number">9.00</span><br></code></pre></td></tr></table></figure><ol><li>在matlab中,矩阵元素<strong>按列存储</strong>,即首先存储矩阵第1列元素,然后存储第2列元素,…一直到矩阵的最后一列元素</li><li>reshape函数只是改变原矩阵的行数和列数,即改变其逻辑结构,但并不改变原矩阵元素的个数及其存储结构</li></ol><h3 id="特殊矩阵"><a href="#特殊矩阵" class="headerlink" title="特殊矩阵"></a>特殊矩阵</h3><h4 id="通用的特殊矩阵"><a href="#通用的特殊矩阵" class="headerlink" title="通用的特殊矩阵"></a>通用的特殊矩阵</h4><table><thead><tr><th align="center">函数名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">zeros</td><td align="center">产生全0矩阵(零矩阵)</td></tr><tr><td align="center">ones</td><td align="center">产生全1矩阵(幺矩阵)</td></tr><tr><td align="center">eye</td><td align="center">产生单位矩阵</td></tr><tr><td align="center">rand</td><td align="center">产生(0,1)区间均匀分布的随机矩阵</td></tr><tr><td align="center">randn</td><td align="center">产生均值为0,方差为1的标准正态分布随机矩阵</td></tr></tbody></table><p><strong>调用方式</strong></p><ol><li><strong>zeros(m)</strong>:产生m×m零矩阵</li><li><strong>zeros(n,m)</strong>:产生n×m零矩阵</li><li><strong>zeros(size(a))</strong>:产生与矩阵a同样大小的零矩阵</li><li><strong>20+(50-20)*rand(4,5)</strong>:产生4行5列在区间[20,50]内均匀分布的随机矩阵</li><li><strong>0.6+sqrt(0.1)*randn(4,5)</strong>:产生4行5列均值为0.6,方差为0.1的正态分布随机矩阵</li></ol><h4 id="用于专门学科的特殊矩阵"><a href="#用于专门学科的特殊矩阵" class="headerlink" title="用于专门学科的特殊矩阵"></a>用于专门学科的特殊矩阵</h4><ol><li><p>魔方矩阵</p><ul><li>调用函数magic(n)</li><li>每行每列及两条对角线上的元素之和都相等</li><li>其元素由1,2,3,…,n^2^共n^2^个元素组成</li></ul></li><li><p>范德蒙矩阵</p><ul><li>调用函数vander(<strong>V</strong>)</li><li>范德蒙矩阵最后一列全为1,倒数第2列为一个指定的向量,其它各列是其后一列与倒数第2列对应元素的乘积</li><li><strong>V</strong>为一个指定的向量</li></ul></li><li><p>希尔伯特矩阵</p><ul><li>调用函数hilb(n)</li><li>求希尔伯特逆矩阵的函数 invhilb(n)</li><li>希尔伯特矩阵是一种数学变换矩阵,它的每个元素h<del>ij</del>=1/(i+j-1)</li><li>希尔伯特矩阵是一个高度病态的矩阵,即任何一个元素发生微小变动,整个矩阵的值和逆矩阵都会发生很大的变化,病态程度和阶数有关</li></ul></li><li><p>托普利兹矩阵</p><ul><li>调用函数toeplitz(x,y)</li><li>托普利兹矩阵除第1行和第1列外,其他每个元素都与左上角的元素相同</li><li>toeplitz(1:6)用向量[1:6]生成一个对称的托普利兹矩阵</li></ul></li><li><p>伴随矩阵</p><p>设多项式p(x)为:<br>$$<br>p\left( x\right) =a_{n}x^{n}+a_{n-1}x^{n-1}+…a_{1}x+a_{0}<br>$$</p><ul><li>调用函数compan(p)</li><li>其中p是系数向量,高次幂系数排在前,低次幂排在后</li></ul></li><li><p>帕斯卡矩阵</p><ul><li>调用函数pascal(n)</li><li>杨辉三角形组成的矩阵称为帕斯卡矩阵</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab学习笔记(3)</title>
      <link href="/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3/"/>
      <url>/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3/</url>
      
        <content type="html"><![CDATA[<p><strong>matlab学习笔记(3)注意介绍了以下内容:</strong></p><ol><li>常用函数</li><li>常用数学函数</li><li>数据的输出格式</li><li>常用快捷键(mac系统)</li><li>预定义变量</li><li>注意点</li></ol><a id="more"></a><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><ol><li><p>画图函数</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-built_in">plot</span>(自变量,函数,自变量,函数)<br></code></pre></td></tr></table></figure></li><li><p>求根函数</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">roots(p)<br></code></pre></td></tr></table></figure></li></ol><ol start="3"><li>求积分<br>$$<br>\int ^{1}_{0}x\ln \left( 1+x\right) dx<br>$$</li></ol><ul><li><p>方法一</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">f=@(x)x.*<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>+x);<br>integral(f,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></li><li><p>方法二</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">syms x<br>int(x*<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>+x),<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure></li></ul><ol start="4"><li>求解线性方程组</li></ol><p>$$<br>\begin{cases}2x-3y+z=4\<br>8x+3y+2z=2\<br>45x+y-9z=17\end{cases}<br>$$</p><ul><li><p>方法一</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">2</span>,<span class="hljs-number">-3</span>,<span class="hljs-number">1</span>;<span class="hljs-number">8</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>;<span class="hljs-number">45</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-9</span>];<br>b=[<span class="hljs-number">4</span>;<span class="hljs-number">2</span>;<span class="hljs-number">17</span>];<br>x=inv(a)*b<br></code></pre></td></tr></table></figure></li><li><p>方法二</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">syms x y z<br>[x,y,z]=solve(<span class="hljs-number">2</span>*x<span class="hljs-number">-3</span>*y+z<span class="hljs-number">-4</span>,<span class="hljs-number">8</span>*x+<span class="hljs-number">3</span>*y+<span class="hljs-number">2</span>*z<span class="hljs-number">-2</span>,<span class="hljs-number">45</span>*x+y<span class="hljs-number">-9</span>*z<span class="hljs-number">-17</span>)<br></code></pre></td></tr></table></figure></li></ul><h2 id="常用数学函数"><a href="#常用数学函数" class="headerlink" title="常用数学函数"></a>常用数学函数</h2><table><thead><tr><th align="center">函数名</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">sin/sind</td><td align="center">正弦函数,输入值为弧度/角度</td></tr><tr><td align="center">cos/cosd</td><td align="center">余弦函数,输入值为弧度/角度</td></tr><tr><td align="center">tan/tand</td><td align="center">正切函数,输入值为弧度/角度</td></tr><tr><td align="center">asin/asind</td><td align="center">反正弦函数,输入值为弧度/角度</td></tr><tr><td align="center">acos/acosd</td><td align="center">反余弦函数,输入值为弧度/角度</td></tr><tr><td align="center">atan/atand</td><td align="center">反正切函数,输入值为弧度/角度</td></tr><tr><td align="center">sinh/asinh</td><td align="center">双曲正弦函数/反双曲正弦函数</td></tr><tr><td align="center">cosh/acosh</td><td align="center">双曲余弦函数/反双曲余弦函数</td></tr><tr><td align="center">tanh/atanh</td><td align="center">双曲正切函数/反双曲正切函数</td></tr><tr><td align="center">sqrt</td><td align="center">平方根函数</td></tr><tr><td align="center">log</td><td align="center">自然对数函数</td></tr><tr><td align="center">log10</td><td align="center">以10为底的对数函数</td></tr><tr><td align="center">log2</td><td align="center">以2为底的对数函数</td></tr><tr><td align="center">exp</td><td align="center">自然指数函数</td></tr><tr><td align="center">pow2</td><td align="center">2的幂</td></tr><tr><td align="center">abs</td><td align="center">绝对值函数</td></tr><tr><td align="center">rem</td><td align="center">求余</td></tr><tr><td align="center">mod</td><td align="center">求模</td></tr><tr><td align="center">fix</td><td align="center">向零方向取整</td></tr><tr><td align="center">floor</td><td align="center">向下取整</td></tr><tr><td align="center">ceil</td><td align="center">向上取整</td></tr><tr><td align="center">round</td><td align="center">四舍五入到最邻近的整数</td></tr><tr><td align="center">sign</td><td align="center">符号函数</td></tr><tr><td align="center">gcd</td><td align="center">最大公约数</td></tr><tr><td align="center">lcm</td><td align="center">最小公倍数</td></tr><tr><td align="center">factorial</td><td align="center">阶乘</td></tr><tr><td align="center">isprime</td><td align="center">判断是否为素数</td></tr><tr><td align="center">primes</td><td align="center">生成素数序列</td></tr><tr><td align="center">perms</td><td align="center">生成所有排列</td></tr><tr><td align="center">randperm</td><td align="center">生成任意排列</td></tr></tbody></table><h2 id="数据的输出格式"><a href="#数据的输出格式" class="headerlink" title="数据的输出格式"></a>数据的输出格式</h2><p><strong>format命令只影响数据输出格式,而不影响数据的计算和存储</strong></p><p>format命令格式为:</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">format 格式符<br></code></pre></td></tr></table></figure><table><thead><tr><th align="center">格式符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">short</td><td align="center">输出小数点后4位,最多不超过7位有效数字<br>对于大于1000的实数,用5位有效数字的科学记数形式输出</td></tr><tr><td align="center">long</td><td align="center">15位有效数字形式输出</td></tr><tr><td align="center">short e</td><td align="center">5位有效数字的科学记数形式输出</td></tr><tr><td align="center">long e</td><td align="center">15位有效数字的科学记数形式输出</td></tr><tr><td align="center">short g</td><td align="center">从short到short e中自动选择最佳输出方式</td></tr><tr><td align="center">long g</td><td align="center">从long到long e中自动选择最佳输出方式</td></tr><tr><td align="center">rat</td><td align="center">近似有理数表示</td></tr><tr><td align="center">hex</td><td align="center">十六进制表示</td></tr><tr><td align="center">+</td><td align="center">正数,负数,零分别用+,-,空格表示</td></tr><tr><td align="center">bank</td><td align="center">银行格式,用元角分表示</td></tr><tr><td align="center">compact</td><td align="center">输出变量之间没有空行</td></tr><tr><td align="center">loose</td><td align="center">输出变量之间有空行</td></tr></tbody></table><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><table><thead><tr><th align="center">组合键</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">⌘ +k</td><td align="center">清除命令行窗口</td></tr><tr><td align="center">esc</td><td align="center">删除当前行命令</td></tr><tr><td align="center">control+c</td><td align="center">中断当前任务</td></tr><tr><td align="center">tab</td><td align="center">代码补全</td></tr></tbody></table><h2 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h2><table><thead><tr><th align="center">预定义变量</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">ans</td><td align="center">计算结果的默认赋值变量</td></tr><tr><td align="center">eps</td><td align="center">机器零阈值</td></tr><tr><td align="center">pi</td><td align="center">圆周率π的近似值</td></tr><tr><td align="center">i,j</td><td align="center">虚数单位</td></tr><tr><td align="center">inf,Inf</td><td align="center">无穷大</td></tr><tr><td align="center">NaN,nan</td><td align="center">非数</td></tr><tr><td align="center">nargin</td><td align="center">函数输入参数个数</td></tr><tr><td align="center">nargout</td><td align="center">函数输出参数个数</td></tr><tr><td align="center">realmax</td><td align="center">最大正实数</td></tr><tr><td align="center">realmin</td><td align="center">最小正实数</td></tr><tr><td align="center">lasterr</td><td align="center">存放最新的错误信息</td></tr><tr><td align="center">lastwarn</td><td align="center">存放最新的警告信息</td></tr></tbody></table><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ol><li><p>matlab变量名</p><p>变量名<strong>只能以字母开头</strong>,后接字母,数字或下划线,变量名区分大小写</p></li><li><p>注释</p><p>使用<strong>%</strong>进行注释</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab学习笔记(2)</title>
      <link href="/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/"/>
      <url>/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/</url>
      
        <content type="html"><![CDATA[<p><strong>matlab学习笔记(2)主要介绍了以下内容:</strong></p><ol><li>数值类型<ul><li>整数类型</li><li>浮点数类型</li><li>复数</li><li>无穷量和非数值量</li></ul></li><li>逻辑类型</li><li>字符和字符串</li><li>函数句柄</li><li>结构体</li><li>数组类型</li><li>单元数组类型</li></ol><a id="more"></a><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><table><thead><tr><th align="center">数据格式</th><th align="center">示例</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">int8,uint8<br>int16,uint16<br>int32,uint32<br>int64,uint64</td><td align="center">int8(20)</td><td align="left">有符号和无符号的整数类型<br>相同数值的整数类型比浮点数占更少内存<br>除了int64和uint64类型外的所有整数类型,都可以进行数学运算</td></tr><tr><td align="center">single</td><td align="center">single(128.1)</td><td align="left">单精度浮点数<br>相同数值的单精度浮点数比双精度浮点数占更少内存<br>单精度浮点数类型能够表示的范围和精度都比双精度浮点数少</td></tr><tr><td align="center">double</td><td align="center">333.77<br>1.000-1.000i</td><td align="left">双精度浮点数<br>matlab中默认的数值类型</td></tr></tbody></table><p><strong>说明</strong></p><ol><li>matlab中数值类型的数据包括<strong>有符号</strong>和<strong>无符号</strong>整数,<strong>单精度浮点数</strong>和<strong>双精度浮点数</strong></li><li>在未加说明与特殊定义时,<strong>matlab对所有数值按照双精度浮点数类型进行存储和操作</strong></li><li>相对于双精度浮点数,整数和单精度浮点数的优点在于节省变量占用的内存空间</li><li>matlab会自动进行记忆体的使用和回收,而不像c语言那样,必须由使用者一一指定</li></ol><h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><table><thead><tr><th align="center">转换函数</th><th align="center">数值范围</th></tr></thead><tbody><tr><td align="center">int8</td><td align="center">-2^7^~2^7^-1</td></tr><tr><td align="center">uint8</td><td align="center">0~2^8^-1</td></tr><tr><td align="center">int16</td><td align="center">-2^15^~2^15^-1</td></tr><tr><td align="center">uint16</td><td align="center">0~2^16^-1</td></tr><tr><td align="center">int32</td><td align="center">-2^31^~2^31^-1</td></tr><tr><td align="center">uint32</td><td align="center">0~2^32^-1</td></tr><tr><td align="center">int64</td><td align="center">-2^63^~2^63^-1</td></tr><tr><td align="center">uint64</td><td align="center">0~2^64^-1</td></tr></tbody></table><p><strong>注意</strong></p><ol><li>由于<strong>matlab默认是double类型</strong>,将数值转化为整数时,遵循四舍六入,当小数部分为0.5时,则会转化为绝对值较大的那个整数</li><li>这些转换函数也可以将其他数据类型转换为指定的整数类型</li><li>在不超过数值范围的情况下,任意两个整数类型之间也可以通过转换函数进行互相转换</li><li>由于不同的整数类型能够表示的数值范围不同,因此当结果超出相应的整数类型能够表示的范围时,就会出现一处错误,运算结果被置为该整数能够表示的最大值或最小值</li></ol><h5 id="取整函数"><a href="#取整函数" class="headerlink" title="取整函数"></a>取整函数</h5><table><thead><tr><th align="center">函数</th><th align="center">运算法则</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">floor(x)</td><td align="center">向下取整</td><td align="center">floor(1.2)=1<br>floor(-1.2)=-2</td></tr><tr><td align="center">ceil(x)</td><td align="center">向上取整</td><td align="center">ceil(1.2)=2<br>ceil(-1.2)=-1</td></tr><tr><td align="center">round(x)</td><td align="center">取最接近的整数<br>如果小数部分是0.5,则向绝对值大的方向取整</td><td align="center">round(1.2)=1<br>round(1.6)=2<br>round(-1.2)=-1<br>round(-1.6)=-2<br>round(-1.5)=-2</td></tr><tr><td align="center">fix(x)</td><td align="center">向0取整</td><td align="center">fix(1.2)=1<br>fix(1.6)=1<br>fix(-1.2)=-1<br>fix(-1.6)=-1</td></tr></tbody></table><h4 id="浮点数类型"><a href="#浮点数类型" class="headerlink" title="浮点数类型"></a>浮点数类型</h4><table><thead><tr><th align="center">浮点类型</th><th align="center">存储位宽</th><th align="center">各数位的含义</th><th align="center">数值范围</th><th align="center">转换函数</th></tr></thead><tbody><tr><td align="center">单精度</td><td align="center">32</td><td align="center">0<del>22位表示小数部分 <br>23</del>30位表示指数部分<br>31位表示符号(0正1负)</td><td align="center">-3.40282e+038 ~ -1.17549e-038<br>1.17549e-038 ~ 3.40282e+038</td><td align="center">single</td></tr><tr><td align="center">双精度</td><td align="center">64</td><td align="center">0<del>51位表示小数部分 <br>52</del>62位表示指数部分<br>63位表示符号(0正1负)</td><td align="center">-1.79769e+308 ~ -2.22507e-308<br>2.22507e-308 ~ 1.79769+308</td><td align="center">Double</td></tr></tbody></table><p><strong>注意</strong></p><ol><li>matlab中默认数值类型为双精度浮点类型,因此与创建整数类型数值一样,也可以通过转换函数来实现创建单精度浮点类型</li><li>双精度浮点数参与运算时,返回值得类型依赖于参与运算的其他数据类型<ul><li>参与运算的其他数据为<strong>逻辑型</strong>,<strong>字符型</strong>时,返回<strong>双精度浮点型</strong></li><li>参与运算的其他数据为<strong>整数型</strong>时,返回相应的<strong>整数类型</strong></li><li>参与运算的其他数据为<strong>单精度浮点型</strong>时,返回相应的<strong>单精度浮点型</strong></li></ul></li><li><strong>matlab中,单精度浮点型不能与整数进行算数运算</strong></li><li>由于浮点数只占用一定的存储位宽,其中只有有限位分别用来存储指数部分和小数部分,因此,浮点类型能够表示的实际数值是有限且离散的,任何两个最近相邻的浮点数之间都有微小间隙,而处在间隙中的数值都只能用这两个相邻的浮点数之中的一个来表示(matlab中提供eps函数:可以获得一个数值和最接近该数值的浮点数之间的间隙)</li></ol><h4 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h4><p>复数包括<strong>实部和虚部</strong>两部分,matlab中<strong>默认使用字符i或j作为虚部标志</strong>,创建复数时,可以直接按照复数形式进行输入或者利用complex函数</p><table><thead><tr><th align="center">函数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">real(z)</td><td align="center">返回复数z的实部</td></tr><tr><td align="center">imag(z)</td><td align="center">返回复数z的虚部</td></tr><tr><td align="center">abs(z)</td><td align="center">返回复数z的模</td></tr><tr><td align="center">angle(z)</td><td align="center">返回复数z的辐角</td></tr><tr><td align="center">conj(z)</td><td align="center">返回复数z的共轭复数</td></tr><tr><td align="center">complex(a,b)</td><td align="center">以a为实部,b为虚部创建复数</td></tr></tbody></table><h4 id="无穷量-Inf-和非数值量-NaN"><a href="#无穷量-Inf-和非数值量-NaN" class="headerlink" title="无穷量(Inf)和非数值量(NaN)"></a>无穷量(Inf)和非数值量(NaN)</h4><table><thead><tr><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Inf</td><td align="center">正无穷量</td></tr><tr><td align="center">-Inf</td><td align="center">负无穷量</td></tr><tr><td align="center">NaN</td><td align="center">非数值量</td></tr></tbody></table><p><strong>注意</strong></p><ol><li>正负无穷量一般都是由于运算溢出,产生了超出双精度浮点数数值范围的结果</li><li>非数值量一般都是由于0/0,Inf/Inf或者Inf-Inf造成的,这三个NaN彼此不相等</li><li>除了异常运算结果外,matlab还提供了特定函数Inf和NaN来创建指定数值类型的无穷量和非数值量,生成结果默认为双精度浮点类型中还有一种特殊的指数类型的数据叫做非数,通常表示运算得到的数值结果超出了运算范围,非数的实部用NaN表示,虚部用Inf表示</li></ol><h3 id="逻辑类型"><a href="#逻辑类型" class="headerlink" title="逻辑类型"></a>逻辑类型</h3><p>matlab把任何非零数值当做真,把零当做假.</p><p>所有关系和逻辑表达式的输出:对于真,输出1;对于假,输出0</p><table><thead><tr><th align="center">关系操作符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">&lt;</td><td align="center">小于</td></tr><tr><td align="center">&lt;=</td><td align="center">小于等于</td></tr><tr><td align="center">&gt;</td><td align="center">大于</td></tr><tr><td align="center">&gt;=</td><td align="center">大于等于</td></tr><tr><td align="center">==</td><td align="center">等于</td></tr><tr><td align="center">~=</td><td align="center">不等于</td></tr></tbody></table><p>matlab关系操作符能用来比较两个同样大小的数组,或用来比较一个数组和一个标量,在后一种情况中,标量和数组中的每一个元素相比较,结果与数组大小一样</p><table><thead><tr><th align="center">逻辑运算符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">&amp;</td><td align="center">与</td></tr><tr><td align="center">丨</td><td align="center">或</td></tr><tr><td align="center">~</td><td align="center">非</td></tr><tr><td align="center">xor(x,y)</td><td align="center">异或</td></tr><tr><td align="center">any(x)</td><td align="center">判断是否为零向量或者零矩阵</td></tr></tbody></table><h3 id="字符和字符串"><a href="#字符和字符串" class="headerlink" title="字符和字符串"></a>字符和字符串</h3><ol><li>在matlab中,<strong>文本</strong>当做特征字符串或简单地当做字符串</li><li>字符串能够<strong>显示在屏幕上</strong>,也可以<strong>用来构成一些命令</strong>,这些命令在其他的命令中用于求值或者被执行</li><li>一个字符串是存储在一个行向量中的文本,这个行向量中的每一个元素代表一个字符,实际上,元素中存放的是字符的ASCII码</li><li>在屏幕上显示字符变量的值时,显示出来的是文本,而不是ASCII数字</li><li>由于字符串是以向量的形式来存储的,因此可以通过它的下标对字符串中的任何一个元素进行访问,字符矩阵也可以通过下标索引进行访问,但是矩阵的每行字符数必须相同</li><li>一个字符串是由<strong>单引号</strong>括起来的简单文本</li><li>在字符串里的每个字符是数组里的一个元素,字符串的存储要求<strong>每个字符占8个字节</strong></li><li>字符串基本操作(以s=‘123456789’ 为例)</li></ol><table><thead><tr><th align="center">操作</th><th align="left">输出</th></tr></thead><tbody><tr><td align="center">u=abs(s)</td><td align="left">u =[49,50,51,52,53,54,55,56,57]</td></tr><tr><td align="center">s=s+0</td><td align="left">s =[49,50,51,52,53,54,55,56,57]</td></tr><tr><td align="center">u=s(4:9)</td><td align="left">u=‘456789’</td></tr><tr><td align="center">u=s(9:-2:3)</td><td align="left">u=‘9753’</td></tr><tr><td align="center">输入s=I’’am Bob.</td><td align="left">s=I’m Bob</td></tr><tr><td align="center">u=[s ‘87654321’]</td><td align="left">u=‘12345678987654321’</td></tr></tbody></table><h3 id="函数句柄"><a href="#函数句柄" class="headerlink" title="函数句柄"></a>函数句柄</h3><p>在matlab中调用函数分为直接调用和间接调用</p><ul><li><p>直接调用</p><ul><li>被调函数被称为子函数</li><li>子函数只能被与其M文件同名的主函数或在M文件中的其他函数所调用</li><li>在一个文件中只能有一个主函数</li></ul></li><li><p>间接调用(函数句柄)</p><ul><li>避免了直接调用的限制(第二条)</li><li>创建函数句柄时需要用到操作符@</li><li>对任意函数都可以创造函数句柄</li><li>创建函数句柄的一般语法格式<ul><li>Function_Handle = @Function_Filename</li><li>Function_Filename是函数所对应的M文件的名称或matlab内部函数的名称</li><li>@是句柄创建操作符</li><li>Function_Handle变量保存了这一函数句柄,并在后续的运算中作为数据流进行传递</li><li>例:F_Handle=@cos 就创建了matlab内部函数cos的句柄,并将其保存在F_Handle变量中,后续的运算过程中就可以通过F_Handle(x)来实现cos(x)的功能</li><li>通过函数句柄调用函数时,也需要指定函数的输入参数(跟原来的那个函数调用一致)</li></ul></li></ul></li><li><p>函数句柄的操作函数</p></li></ul><table><thead><tr><th align="center">函数名称</th><th align="left">函数功能</th></tr></thead><tbody><tr><td align="center">functions(funhandle)</td><td align="left">返回一个结构体<br>包含函数的名称(function),函数类型(type),以及函数M文件的位置(file)</td></tr><tr><td align="center">func2str(funhandle)</td><td align="left">将函数句柄转换为函数名称的字符串</td></tr><tr><td align="center">str2func(str)</td><td align="left">将字符串代表的函数转换为函数句柄</td></tr><tr><td align="center">save filename.mat funhandle</td><td align="left">将函数句柄保存在*.mat文件中</td></tr><tr><td align="center">load filename.mat funhandle</td><td align="left">把*.mat文件中存储的函数句柄加载到工作区</td></tr><tr><td align="center">isa(var,’function_handle’)</td><td align="left">检测变量var是否是函数句柄</td></tr><tr><td align="center">isequal(funhandle1,funhandle2)</td><td align="left">检测两个函数句柄是否对应于同一个函数</td></tr></tbody></table><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><ul><li><p>创建结构体</p><ul><li><p>直接通过赋值语句给结构体的字段赋值</p><figure class="hljs highlight Matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Matlab">student.name=<span class="hljs-string">'sam'</span>;<br>student.grade=<span class="hljs-number">6</span>;<br>student.subject=&#123;<span class="hljs-string">'Chinese'</span>,<span class="hljs-string">'Math'</span>,<span class="hljs-string">'English'</span>&#125;;<br>student.result=&#123;<span class="hljs-number">99</span>,<span class="hljs-number">99</span>,<span class="hljs-number">99</span>&#125;;<br></code></pre></td></tr></table></figure><p><strong>注意</strong></p></li></ul><ol><li>在进行字段赋值时,没有明确赋值的字段,matlab默认赋值为空数组</li><li>通过圆括号索引进行字段赋值,还可以创建任意尺寸的结构体数组</li><li>同一个结构体数组中所有结构体对象具有相同的字段组合</li></ol><ul><li>利用struct函数创建结构体<ul><li>node = struct(‘field1’,var1,’field2’,var2,…,’fieldn’,varn)</li><li>数组  node(2) =struct(‘field1’,var1,’field2’,var2,…,’fieldn’,varn)</li><li>重复写入node = repmat(struct(‘day’,’thursday’,’time’),==1,2==)</li></ul></li></ul></li></ul><h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><p>matlab中进行运算的所有数据类型,都是按照数组及矩阵的形式进行存储和运算的,而二者在matlab中的基本运算性质不同,陈列强调元素对元素的运算,而矩阵则采用线性代数的运算方式</p><ul><li>数组定义 a=[1 2 3 4 5]</li><li>冒号定义<ul><li>a=1:10<br>a=[1 2 3 4 5 6 7 8 9 10]</li><li>a=1:2:10<br>a=[1 3 5 7 9]</li><li>a=linspace(a,b,100)<br>在区间[a,b]上创建一个有100个元素的向量,这100个数把整个区间线性分隔</li></ul></li></ul><h3 id="单元数组类型"><a href="#单元数组类型" class="headerlink" title="单元数组类型"></a>单元数组类型</h3><p>单元(cell)数组是一种无所不包的广义矩阵,组成单元数组的每一个元素称为一个单元,每一个单元可以包括一个任意数组,如数值数组,字符串数组,结构体数组或另外一个单元数组,因而每一个单元可以具有不同的尺寸和内存占用空间.</p><p><strong>注意</strong>:<strong>和一般的数值数组一样,单元数组的维数不受限制,可以是一维,二维或多维</strong></p><h4 id="单元数组的创建"><a href="#单元数组的创建" class="headerlink" title="单元数组的创建"></a>单元数组的创建</h4><ol><li><p>使用赋值语句创建单元数组</p><p>单元数组使用花括号”{}”来创建,使用逗号”,”或空格来分隔每一个单元,使用”;”来分行</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">c=&#123;<span class="hljs-string">'haha'</span>,[<span class="hljs-number">1</span>;<span class="hljs-number">2</span>;<span class="hljs-number">3</span>];<span class="hljs-number">10</span>,<span class="hljs-built_in">pi</span>&#125;<br></code></pre></td></tr></table></figure></li><li><p>利用cell函数创建空单元数组</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">cellname=cell(m,n)<br></code></pre></td></tr></table></figure><p>该函数创建一个m*n的空单元数组,其每一个单元均为空矩阵</p></li></ol><h4 id="单元数组的寻访"><a href="#单元数组的寻访" class="headerlink" title="单元数组的寻访"></a>单元数组的寻访</h4><p>在单元数组中,单元和单元中的内容是两个不同范畴的东西,因此,寻访单元和单元中的内容是两个不同的操作,matlab为上述两种操作设计了相对应的操作对象:单元外标识(Cell Indexing)和单元内编址(Content Addressing)</p><p>对于单元数组c,c(m,n)指的是单元数组中第m行第n列的单元,而c{m,n}指的是单元数组中第m行第n列单元中的内容</p><h4 id="单元数组的操作"><a href="#单元数组的操作" class="headerlink" title="单元数组的操作"></a>单元数组的操作</h4><ol><li><p>单元数组的合并</p><p><code>c={a b}</code></p></li><li><p>单元数组的删除</p><p>如果要删除单元数组中指定的某个单元,只需把空矩阵赋给该单元即可</p><p><code>c{m,n}=[]</code></p></li><li><p>使用reshape函数改变单元数组的形状</p><p><code>trimc = reshape(c,M,N)</code></p><p>该函数将单元数组c改变成一个具有M行N列的新单元数组</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab学习笔记(1)</title>
      <link href="/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/"/>
      <url>/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</url>
      
        <content type="html"><![CDATA[<p><strong>matlab学习笔记(1)主要介绍了以下内容</strong></p><ol><li>matlab的命令行通用命令</li><li>如何设置matlab调用文件的搜索路径</li><li>matlab的帮助系统</li></ol><a id="more"></a><h2 id="命令行通用命令"><a href="#命令行通用命令" class="headerlink" title="命令行通用命令"></a>命令行通用命令</h2><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><table><thead><tr><th align="center">命令</th><th align="center">命令说明</th></tr></thead><tbody><tr><td align="center">cd</td><td align="center">显示或改变当前文件夹的地址</td></tr><tr><td align="center">dir</td><td align="center">显示当前文件夹或指定目录下的文件</td></tr><tr><td align="center">clc</td><td align="center">清除命令行中命令</td></tr><tr><td align="center">home</td><td align="center">将当前输入放到最上面</td></tr><tr><td align="center">clf</td><td align="center">清除图形窗口</td></tr><tr><td align="center">type</td><td align="center">显示文件内容</td></tr><tr><td align="center">clear</td><td align="center">清理工作区变量</td></tr><tr><td align="center">load</td><td align="center">加载指定文件的变量</td></tr><tr><td align="center">diary</td><td align="center">日志文件命令</td></tr><tr><td align="center">!</td><td align="center">调用dos命令</td></tr><tr><td align="center">exit</td><td align="center">退出matlab</td></tr><tr><td align="center">pack</td><td align="center">收集内存碎片</td></tr><tr><td align="center">hold</td><td align="center">图形保持开关</td></tr><tr><td align="center">path</td><td align="center">显示搜索目录</td></tr><tr><td align="center">save</td><td align="center">保存工作区变量到指定文件</td></tr></tbody></table><h3 id="标点"><a href="#标点" class="headerlink" title="标点"></a>标点</h3><table><thead><tr><th align="center">标点</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">:</td><td align="center">冒号,具有多种应用功能</td></tr><tr><td align="center">;</td><td align="center">分号,区分行及取消运行结果显示</td></tr><tr><td align="center">,</td><td align="center">逗号,区分列及函数参数分隔符</td></tr><tr><td align="center">()</td><td align="center">括号,指定运算的优先级</td></tr><tr><td align="center">[]</td><td align="center">方括号,定义矩阵</td></tr><tr><td align="center">{}</td><td align="center">大括号,构造单元数组</td></tr><tr><td align="center">%</td><td align="center">百分号,注释</td></tr><tr><td align="center">!</td><td align="center">感叹号,赋值标记</td></tr><tr><td align="center">=</td><td align="center">等号,赋值标记</td></tr><tr><td align="center">‘</td><td align="center">单引号,字符串的标识符</td></tr><tr><td align="center">.</td><td align="center">小数点及对象域访问</td></tr><tr><td align="center">…</td><td align="center">续行符号</td></tr></tbody></table><h2 id="设置matlab调用文件的搜索路径"><a href="#设置matlab调用文件的搜索路径" class="headerlink" title="设置matlab调用文件的搜索路径"></a>设置matlab调用文件的搜索路径</h2><ol><li><p>为什么要设置</p><p>一般情况下,matlab系统的函数,包括工具箱函数,都是在系统默认的搜索路径之中的,但是用户设计的函数有可能没有保存到搜索路径下,很多情况容易造成matlab误认为该函数不存在,因此需要把程序所在的目录扩展成matlab的搜索路径即可.</p></li><li><p>如何设置</p><p>点击主页窗口的<code>设置路径</code>,点击<code>添加文件夹</code>,然后选择你的函数文件夹即可,建议建立一个大的文件夹,把所有的函数都放进去.</p><p><strong>注意:只有在matlab搜索路径中的函数才能被识别(可以调用path命令来查看搜索路径).并且当某一文件夹的父文件夹在搜索路径中而其本身不在搜索路径中时,则此文件夹不会被搜索到.</strong></p></li></ol><h2 id="帮助系统"><a href="#帮助系统" class="headerlink" title="帮助系统"></a>帮助系统</h2><ol><li><p>help命令</p><p>调用格式(以sin函数作为例子)</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">help <span class="hljs-built_in">sin</span><br></code></pre></td></tr></table></figure><p>调用后会显示简洁用法,以及详细的参考页,可以调用的不单单只是函数,还可以调用<code>pi</code>等常数</p></li><li><p>demos帮助</p><p>直接在命令行中输入<code>demo</code>,用户可以更加直观,快速地学习matlab实用知识.</p></li><li><p>帮助导航浏览器</p><p>帮助导航浏览器是matlab专门提供的一个独立的帮助子系统,该系统包含的所有帮助文件都存储在matlab安装目录下的help子目录下</p><p>打开方式:命令行中直接输入<code>doc</code></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
