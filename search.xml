<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python+OpenCV教程8：绘图功能</title>
      <link href="/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B8%EF%BC%9A%E7%BB%98%E5%9B%BE%E5%8A%9F%E8%83%BD/"/>
      <url>/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B8%EF%BC%9A%E7%BB%98%E5%9B%BE%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>学习画线、圆和矩形等多种几何形状，给图片添加文字。</p><p>目标：</p><ul><li>绘制各种几何形状、添加文字</li><li>OpenCV函数<ul><li><code>cv2.line()</code>：直线</li><li><code>cv2.circle()</code>：圆</li><li><code>cv2.rectangle()</code>：矩形</li><li><code>cv2.ellipse()</code>：椭圆</li><li><code>cv2.polylines()</code>：多边形</li><li><code>cv2.putText()</code>：添加文字</li></ul></li></ul><p>画多条直线时，<code>cv2.polylines()</code>要比<code>cv2.line()</code>高效很多。</p><p><strong>所有绘图函数均会直接影响原图片，这点要注意。</strong></p><a id="more"></a><h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><p>绘制形状的函数有一些共同的参数，提前说明一下：</p><ul><li>img：要绘制形状的图片</li><li>color：绘制的颜色<ul><li>彩色图就传入BGR的一组值，如蓝色就是(255,0,0)</li><li>灰度图，传入一个灰度值就行</li></ul></li><li>thickness：线宽，默认为1；<strong>对于矩形/圆之类的封闭形状而言，传入-1表示填充形状</strong></li></ul><p>需要导入的模块和显示图片的通用代码：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>cv2.imshow(<span class="hljs-string">'img'</span>, img)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_drawing_functions.jpg"></p><p>上图就是本教程绘制的最终效果，下面一步步来看：</p><h3 id="画线"><a href="#画线" class="headerlink" title="画线"></a>画线</h3><p>画直线只需指定起点和终点的坐标就行：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 画一条线宽为5的蓝色直线</span><br><span class="hljs-comment"># 参数1：图片，参数2：起点，参数3：终点，参数4：BGR颜色，参数5：线宽</span><br>cv2.line(img, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">512</span>, <span class="hljs-number">512</span>), (<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><h3 id="画矩形"><a href="#画矩形" class="headerlink" title="画矩形"></a>画矩形</h3><p>画矩形需要知道左上角和右下角的坐标：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 画一个绿色边框的矩形</span><br><span class="hljs-comment"># 参数1：图片，参数2：左上角坐标，参数3：右下角坐标，参数4：BGR颜色，参数5：线宽（负数为填充）</span><br>cv2.rectangle(img, (<span class="hljs-number">384</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">510</span>, <span class="hljs-number">128</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>), <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><h3 id="画圆"><a href="#画圆" class="headerlink" title="画圆"></a>画圆</h3><p>画圆需要指定圆心和半径，注意下面的例子中线宽=-1代表填充：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 画一个填充红色的圆</span><br><span class="hljs-comment"># 参数1：图片，参数2：圆心坐标，参数3：半径，参数4：BGR颜色，参数5：线宽（负数为填充）</span><br>cv2.circle(img, (<span class="hljs-number">447</span>, <span class="hljs-number">63</span>), <span class="hljs-number">63</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">-1</span>)<br></code></pre></td></tr></table></figure><h3 id="画椭圆"><a href="#画椭圆" class="headerlink" title="画椭圆"></a>画椭圆</h3><p>画椭圆需要的参数比较多，请对照后面的代码理解这几个参数：</p><ul><li>参数2：椭圆中心(x,y)</li><li>参数3：x/y轴的长度</li><li>参数4：angle—椭圆的旋转角度（顺时针计算）</li><li>参数5：startAngle—椭圆的起始角度</li><li>参数6：endAngle—椭圆的结束角度</li></ul><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在图中心画一个填充的半圆</span><br><span class="hljs-comment"># 参数1：图片，参数2：椭圆中心，参数3：x/y轴长度，参数4：旋转角度</span><br><span class="hljs-comment"># 参数5：椭圆起始角度，参数6：椭圆结束角度，参数7：BGR颜色，参数8：线宽（负数为填充）</span><br>cv2.ellipse(img, (<span class="hljs-number">256</span>, <span class="hljs-number">256</span>), (<span class="hljs-number">100</span>, <span class="hljs-number">50</span>), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">180</span>, (<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">-1</span>)<br></code></pre></td></tr></table></figure><h3 id="画多边形"><a href="#画多边形" class="headerlink" title="画多边形"></a>画多边形</h3><p>画多边形需要指定一系列多边形的顶点坐标，相当于从第一个点到第二个点画直线，再从第二个点到第三个点画直线….</p><p>OpenCV中需要先将多边形的顶点坐标需要变成顶点数×1×2维的矩阵，再来绘制：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 画一个闭合的四边形</span><br><span class="hljs-comment"># 定义四个顶点坐标</span><br>pts = np.array([[<span class="hljs-number">10</span>, <span class="hljs-number">5</span>],  [<span class="hljs-number">50</span>, <span class="hljs-number">10</span>], [<span class="hljs-number">70</span>, <span class="hljs-number">20</span>], [<span class="hljs-number">20</span>, <span class="hljs-number">30</span>]], np.int32)<br><span class="hljs-comment"># 顶点个数：4，矩阵变成顶点数*1*2维（注意numpy中-1的用法）</span><br>pts = pts.reshape((<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br><span class="hljs-comment"># 参数1：图片，参数2：顶点集合，参数3：是否闭合，参数4：BGR颜色</span><br>cv2.polylines(img, [pts], <span class="hljs-literal">True</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>))<br></code></pre></td></tr></table></figure><p><code>cv2.polylines()</code>的参数3如果是False的话，多边形就不闭合，即<strong>最后一个点与第一个点不连</strong>。</p><blockquote><p>经验之谈：如果需要绘制多条直线，使用cv2.polylines()要比cv2.line()高效很多，例如：</p></blockquote><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用cv2.polylines()画多条直线</span><br>line1 = np.array([[<span class="hljs-number">100</span>, <span class="hljs-number">20</span>],  [<span class="hljs-number">300</span>, <span class="hljs-number">20</span>]], np.int32).reshape((<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br>line2 = np.array([[<span class="hljs-number">100</span>, <span class="hljs-number">60</span>],  [<span class="hljs-number">300</span>, <span class="hljs-number">60</span>]], np.int32).reshape((<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br>line3 = np.array([[<span class="hljs-number">100</span>, <span class="hljs-number">100</span>],  [<span class="hljs-number">300</span>, <span class="hljs-number">100</span>]], np.int32).reshape((<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br>cv2.polylines(img, [line1, line2, line3], <span class="hljs-literal">True</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>))<br></code></pre></td></tr></table></figure><h3 id="添加文字"><a href="#添加文字" class="headerlink" title="添加文字"></a>添加文字</h3><p>使用<code>cv2.putText()</code>添加文字，它的参数也比较多，同样请对照后面的代码理解这几个参数：</p><ul><li>参数2：要添加的文本</li><li>参数3：文字的起始坐标（左下角为起点）</li><li>参数4：字体</li><li>参数5：文字大小（缩放比例）</li></ul><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 添加文字</span><br>font = cv2.FONT_HERSHEY_SIMPLEX<br><span class="hljs-comment"># 参数1：图片，参数2：添加的文本内容，参数3：文字起始坐标，参数4：字体类型</span><br><span class="hljs-comment"># 参数5：字体大小，参数6：字体颜色，参数7：线宽，参数8：线型</span><br>cv2.putText(img, <span class="hljs-string">'ex2tron'</span>, (<span class="hljs-number">10</span>, <span class="hljs-number">500</span>), font,<br>            <span class="hljs-number">4</span>, (<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>), <span class="hljs-number">2</span>, lineType=cv2.LINE_AA)<br></code></pre></td></tr></table></figure><p>字体可参考：<a href="https://docs.opencv.org/4.0.0/d6/d6e/group__imgproc__draw.html#ga0f9314ea6e35f99bb23f29567fc16e11" target="_blank" rel="noopener">HersheyFonts</a>。另外，这里有个线型lineType参数，LINE_AA表示抗锯齿线型，具体可见<a href="https://docs.opencv.org/3.3.1/d0/de1/group__core.html#gaf076ef45de481ac96e0ab3dc2c29a777" target="_blank" rel="noopener">LineTypes</a>。</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>能用已学的绘图功能画出OpenCV的logo。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>img = np.zeros((<span class="hljs-number">200</span>, <span class="hljs-number">200</span>, <span class="hljs-number">3</span>), np.uint8)<br><br><span class="hljs-comment"># 画OpenCV的logo，其实很简单</span><br><span class="hljs-comment"># 1.先画一个0°到300°的圆</span><br><span class="hljs-comment"># 2.再在中心画一个跟背景颜色一样的小圆</span><br><span class="hljs-comment"># 3.重复前两部，并且旋转一定的角度即可</span><br><br><span class="hljs-comment"># 画绿色的部分</span><br>cv2.ellipse(img, (<span class="hljs-number">43</span>, <span class="hljs-number">125</span>), (<span class="hljs-number">45</span>, <span class="hljs-number">45</span>), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">300</span>,<br>            (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>), <span class="hljs-number">-1</span>, lineType=cv2.LINE_AA)<br>cv2.circle(img, (<span class="hljs-number">43</span>, <span class="hljs-number">125</span>), <span class="hljs-number">15</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">-1</span>, lineType=cv2.LINE_AA)<br><br><span class="hljs-comment"># 画红色的部分</span><br>cv2.ellipse(img, (<span class="hljs-number">90</span>, <span class="hljs-number">40</span>), (<span class="hljs-number">45</span>, <span class="hljs-number">45</span>), <span class="hljs-number">120</span>, <span class="hljs-number">0</span>, <span class="hljs-number">300</span>,<br>            (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">-1</span>, lineType=cv2.LINE_AA)<br>cv2.circle(img, (<span class="hljs-number">90</span>, <span class="hljs-number">40</span>), <span class="hljs-number">15</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">-1</span>, lineType=cv2.LINE_AA)<br><br><span class="hljs-comment"># 画蓝色的部分</span><br>cv2.ellipse(img, (<span class="hljs-number">137</span>, <span class="hljs-number">125</span>), (<span class="hljs-number">45</span>, <span class="hljs-number">45</span>), <span class="hljs-number">-60</span>, <span class="hljs-number">0</span>, <span class="hljs-number">300</span>,<br>            (<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">-1</span>, lineType=cv2.LINE_AA)<br>cv2.circle(img, (<span class="hljs-number">137</span>, <span class="hljs-number">125</span>), <span class="hljs-number">15</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">-1</span>, lineType=cv2.LINE_AA)<br><br>cv2.imshow(<span class="hljs-string">'img'</span>, img)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_draw_opencv_logo.jpg"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><ul><li><a href="https://docs.opencv.org/4.0.0/d6/d6e/group__imgproc__draw.html#ga7078a9fae8c7e7d13d24dac2520ae4a2" target="_blank" rel="noopener">cv2.line()</a></li><li><a href="https://docs.opencv.org/4.0.0/d6/d6e/group__imgproc__draw.html#gaf10604b069374903dbd0f0488cb43670" target="_blank" rel="noopener">cv2.circle()</a></li><li><a href="https://docs.opencv.org/4.0.0/d6/d6e/group__imgproc__draw.html#ga07d2f74cadcf8e305e810ce8eed13bc9" target="_blank" rel="noopener">cv2.rectangle()</a></li><li><a href="https://docs.opencv.org/4.0.0/d6/d6e/group__imgproc__draw.html#ga28b2267d35786f5f890ca167236cbc69" target="_blank" rel="noopener">cv2.ellipse()</a></li><li><a href="https://docs.opencv.org/4.0.0/d6/d6e/group__imgproc__draw.html#ga5126f47f883d730f633d74f07456c576" target="_blank" rel="noopener">cv2.putText()</a></li><li><a href="https://docs.opencv.org/4.0.0/d6/d6e/group__imgproc__draw.html#ga1ea127ffbbb7e0bfc4fd6fd2eb64263c" target="_blank" rel="noopener">cv2.polylines()</a></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="https://docs.opencv.org/3.3.1/d0/de1/group__core.html#gaf076ef45de481ac96e0ab3dc2c29a777" target="_blank" rel="noopener">LineTypes</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_drawing_functions/py_drawing_functions.html" target="_blank" rel="noopener">Drawing Functions in OpenCV</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 绘图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-OpenCV教程番外篇5：仿射变换与透视变换</title>
      <link href="/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%875%EF%BC%9A%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2%E4%B8%8E%E9%80%8F%E8%A7%86%E5%8F%98%E6%8D%A2/"/>
      <url>/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%875%EF%BC%9A%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2%E4%B8%8E%E9%80%8F%E8%A7%86%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>常见的2D图像变换从原理上讲主要包括基于2×3矩阵的<a href="https://baike.baidu.com/item/仿射变换" target="_blank" rel="noopener">仿射变换</a>和基于3×3矩阵<a href="https://baike.baidu.com/item/透视变换" target="_blank" rel="noopener">透视变换</a>。</p><a id="more"></a><h2 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h2><p>基本的图像变换就是二维坐标的变换：从一种二维坐标(x,y)到另一种二维坐标(u,v)的线性变换：</p><script type="math/tex; mode=display">u=a_1x+b_1y+c_1\\v=a_2x+b_2y+c_2</script><p>如果写成矩阵的形式，就是：</p><script type="math/tex; mode=display">\begin{bmatrix}u\\v\end{bmatrix}=\begin{bmatrix}a_1 & b_1\\a_2 & b_2\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}+\begin{bmatrix}c_1\\c_2\end{bmatrix}</script><p>作如下定义：</p><script type="math/tex; mode=display">R=\begin{bmatrix}a_1&b_1\\a_2&b_2\end{bmatrix},t=\begin{bmatrix}c_1\\c_2\end{bmatrix},T=\begin{bmatrix}R&t\end{bmatrix}</script><p>矩阵T(2×3)就称为<strong>仿射变换的变换矩阵</strong>，R为<strong>线性变换矩阵</strong>，t为<strong>平移矩阵</strong>。</p><p>简单来说，<strong>仿射变换就是线性变换+平移</strong>。变换后直线依然是直线，平行线依然是平行线，直线间的相对位置关系不变，因此<strong>非共线的三个对应点便可确定唯一的一个仿射变换</strong>，<em>线性变换4个自由度+平移2个自由度</em>→<strong>仿射变换自由度为6</strong>。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_warp_affine_image_sample_introduction2.jpg"></p><p>来看下OpenCV中如何实现仿射变换：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>img = cv2.imread(<span class="hljs-string">'drawing.jpg'</span>)<br>rows, cols = img.shape[:<span class="hljs-number">2</span>]<br><br><span class="hljs-comment"># 仿射变换</span><br><br><span class="hljs-comment"># 变换前的三个点</span><br>pts1 = np.float32([[<span class="hljs-number">50</span>, <span class="hljs-number">65</span>], [<span class="hljs-number">150</span>, <span class="hljs-number">65</span>], [<span class="hljs-number">210</span>, <span class="hljs-number">210</span>]])<br><span class="hljs-comment"># 变换后的三个点</span><br>pts2 = np.float32([[<span class="hljs-number">50</span>, <span class="hljs-number">100</span>], [<span class="hljs-number">150</span>, <span class="hljs-number">65</span>], [<span class="hljs-number">100</span>, <span class="hljs-number">250</span>]])<br><br><span class="hljs-comment"># 生成变换矩阵，维数：2*3</span><br>M = cv2.getAffineTransform(pts1, pts2)<br>dst = cv2.warpAffine(img, M, (cols, rows))<br><br>plt.subplot(<span class="hljs-number">121</span>), plt.imshow(img), plt.title(<span class="hljs-string">'input'</span>)<br>plt.subplot(<span class="hljs-number">122</span>), plt.imshow(dst), plt.title(<span class="hljs-string">'output'</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_affine_transformation_drawing.jpg"></p><p>其实平移、旋转、缩放和翻转等变换就是对应了不同的仿射变换矩阵，下面分别来看下。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_image_transformation_sample.jpg"></p><h3 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h3><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_warp_affine_shift_sample.jpg"></p><p>平移就是x和y方向上的直接移动，可以上下/左右移动，自由度为2，变换矩阵可以表示为：</p><script type="math/tex; mode=display">\begin{bmatrix}u\\v\end{bmatrix}=\begin{bmatrix}1&0\\0&1\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}+\begin{bmatrix}t_x\\t_y\end{bmatrix}</script><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_warp_affine_rotation_sample.jpg"></p><p>旋转是坐标轴方向饶原点旋转一定的角度$\theta$，自由度为1，不包含平移，如顺时针旋转可以表示为：</p><script type="math/tex; mode=display">\begin{bmatrix}u\\v\end{bmatrix}=\begin{bmatrix}\cos{\theta}&-\sin{\theta}\\\sin{\theta}&\cos{\theta}\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}+\begin{bmatrix}0\\0\end{bmatrix}</script><blockquote><p>思考：如果不是绕原点，而是可变点，自由度是多少呢？（请看下文刚体变换）</p></blockquote><h3 id="翻转"><a href="#翻转" class="headerlink" title="翻转"></a>翻转</h3><p>翻转是x或y某个方向或全部方向上取反，自由度为2，比如这里以垂直翻转为例：</p><script type="math/tex; mode=display">\begin{bmatrix}u\\v\end{bmatrix}=\begin{bmatrix}1&0\\0&-1\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}+\begin{bmatrix}0\\0\end{bmatrix}</script><h3 id="刚体变换"><a href="#刚体变换" class="headerlink" title="刚体变换"></a>刚体变换</h3><p>旋转+平移也称刚体变换（Rigid Transform），就是说如果<strong>图像变换前后两点间的距离仍然保持不变</strong>，那么这种变化就称为刚体变换。刚体变换包括了平移、旋转和翻转，自由度为3。变换矩阵可以表示为：</p><script type="math/tex; mode=display">\begin{bmatrix}u\\v\end{bmatrix}=\begin{bmatrix}\cos{\theta}&-\sin{\theta}\\\sin{\theta}&\cos{\theta}\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}+\begin{bmatrix}t_x\\t_y\end{bmatrix}</script><p>由于只是旋转和平移，刚体变换保持了直线间的长度不变，所以也称欧式变换（变化前后保持欧氏距离）。</p><h3 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h3><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_warp_affine_scale_sampel.jpg"></p><p>缩放是x和y方向的尺度（倍数）变换，在有些资料上非等比例的缩放也称为拉伸/挤压，等比例缩放自由度为1，非等比例缩放自由度为2，矩阵可以表示为：</p><script type="math/tex; mode=display">\begin{bmatrix}u\\v\end{bmatrix}=\begin{bmatrix}s_x&0\\0&s_y\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}+\begin{bmatrix}0\\0\end{bmatrix}</script><h3 id="相似变换"><a href="#相似变换" class="headerlink" title="相似变换"></a>相似变换</h3><p>相似变换又称缩放旋转，相似变换包含了旋转、等比例缩放和平移等变换，自由度为4。在OpenCV中，旋转就是用相似变换实现的：</p><p>若<strong>缩放比例为scale</strong>，<strong>旋转角度为$\theta$</strong>，<strong>旋转中心是$(center_x,center_y)$</strong>，则仿射变换可以表示为：</p><script type="math/tex; mode=display">\begin{bmatrix}u\\v\end{bmatrix}=\begin{bmatrix}\alpha&\beta\\-\beta&\alpha\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}+\begin{bmatrix}(1-\alpha)center_x-\beta center_y\\\beta center_x+(1-\alpha)center_y\end{bmatrix}</script><p>其中：</p><script type="math/tex; mode=display">\alpha=scale\cdot{\cos\theta},\beta=scale\cdot\sin{\theta}</script><p><strong>相似变换相比刚体变换加了缩放，所以并不会保持欧氏距离不变，但直线间的夹角依然不变。</strong></p><blockquote><p>经验之谈：OpenCV中默认按照逆时针旋转噢~</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_transformation_matrix_dof_summary.jpg" width="70%"></p><div class="table-container"><table><thead><tr><th style="text-align:center">变换</th><th style="text-align:center">矩阵</th><th style="text-align:center">自由度</th><th style="text-align:center">保持性质</th></tr></thead><tbody><tr><td style="text-align:center">平移</td><td style="text-align:center">[I, t]（2×3）</td><td style="text-align:center">2</td><td style="text-align:center">方向/长度/夹角/平行性/直线性</td></tr><tr><td style="text-align:center">刚体</td><td style="text-align:center">[R, t]（2×3）</td><td style="text-align:center">3</td><td style="text-align:center">长度/夹角/平行性/直线性</td></tr><tr><td style="text-align:center">相似</td><td style="text-align:center">[sR, t]（2×3）</td><td style="text-align:center">4</td><td style="text-align:center">夹角/平行性/直线性</td></tr><tr><td style="text-align:center">仿射</td><td style="text-align:center">[T]（2×3）</td><td style="text-align:center">6</td><td style="text-align:center">平行性/直线性</td></tr><tr><td style="text-align:center">透视</td><td style="text-align:center">[T]（3×3）</td><td style="text-align:center">8</td><td style="text-align:center">直线性</td></tr></tbody></table></div><h3 id="透视变换"><a href="#透视变换" class="headerlink" title="透视变换"></a>透视变换</h3><p>前面仿射变换后依然是平行四边形，并不能做到任意的变换。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_warp_perspective_image_sample4.jpg"></p><p><a href="https://baike.baidu.com/item/透视变换" target="_blank" rel="noopener">透视变换</a>（Perspective Transformation）是将二维的图片投影到一个三维视平面上，然后再转换到二维坐标下，所以也称为投影映射（Projective Mapping）。简单来说就是二维→三维→二维的一个过程。</p><script type="math/tex; mode=display">X=a_1x+b_1y+c_1\\Y=a_2x+b_2y+c_2\\Z=a_3x+b_3y+c_3</script><p>可以写成齐次矩阵的形式：</p><script type="math/tex; mode=display">\begin{bmatrix}X\\Y\\Z\end{bmatrix}=\begin{bmatrix}a_1&b_1&c_1\\a_2&b_2&c_2\\a_3&b_3&c_3\end{bmatrix}\begin{bmatrix}x\\y\\1\end{bmatrix}</script><p>其中，$\begin{bmatrix}a_1&amp;b_1\\a_2&amp;b_2\end{bmatrix}$表示线性变换，$\begin{bmatrix}a_3&amp;b_3\end{bmatrix}$产生透视变换，其余表示平移变换，因此<strong>仿射变换是透视变换的子集</strong>。接下来再通过除以Z轴转换成二维坐标：</p><script type="math/tex; mode=display">x'=\frac{X}{Z}=\frac{a_1x+b_1y+c_1}{a_3x+b_3y+c_3}\\y'=\frac{Y}{Z}=\frac{a_2x+b_2y+c_2}{a_3x+b_3y+c_3}</script><p>透视变换相比仿射变换更加灵活，变换后会产生一个新的四边形，但不一定是平行四边形，所以需要<strong>非共线的四个点才能唯一确定</strong>，原图中的直线变换后依然是直线。</p><p>因为四边形包括了所有的平行四边形，所以透视变换包括了所有的仿射变换。</p><p>OpenCV中首先根据变换前后的四个点用<code>cv2.getPerspectiveTransform()</code>生成3×3的变换矩阵，然后再用<code>cv2.warpPerspective()</code>进行透视变换。实战演练一下：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_perspective_transformations_inm.jpg"></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># 透视变换</span><br>img = cv2.imread(<span class="hljs-string">'card.jpg'</span>)<br><br><span class="hljs-comment"># 原图中卡片的四个角点</span><br>pts1 = np.float32([[<span class="hljs-number">148</span>, <span class="hljs-number">80</span>], [<span class="hljs-number">437</span>, <span class="hljs-number">114</span>], [<span class="hljs-number">94</span>, <span class="hljs-number">247</span>], [<span class="hljs-number">423</span>, <span class="hljs-number">288</span>]])<br><span class="hljs-comment"># 变换后分别在左上、右上、左下、右下四个点</span><br>pts2 = np.float32([[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">320</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">178</span>], [<span class="hljs-number">320</span>, <span class="hljs-number">178</span>]])<br><br><span class="hljs-comment"># 生成透视变换矩阵</span><br>M = cv2.getPerspectiveTransform(pts1, pts2)<br><span class="hljs-comment"># 进行透视变换，参数3是目标图像大小</span><br>dst = cv2.warpPerspective(img, M, (<span class="hljs-number">320</span>, <span class="hljs-number">178</span>))<br><br><span class="hljs-comment"># matplotlib默认以RGB通道显示，所以需要用[:, :, ::-1]翻转一下</span><br>plt.subplot(<span class="hljs-number">121</span>), plt.imshow(img[:, :, ::<span class="hljs-number">-1</span>]), plt.title(<span class="hljs-string">'input'</span>)<br>plt.subplot(<span class="hljs-number">122</span>), plt.imshow(dst[:, :, ::<span class="hljs-number">-1</span>]), plt.title(<span class="hljs-string">'output'</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p>当然，<strong>我们后面学习了特征提取之后，就可以自动识别角点了。</strong>透视变换是一项很酷的功能。比如我们经常会用手机去拍身份证和文件，无论你怎么拍，貌似都拍不正或者有边框。如果你使用过手机上面一些扫描类软件，比如”<a href="https://baike.baidu.com/item/扫描全能王" target="_blank" rel="noopener">扫描全能王</a>“，”<a href="https://baike.baidu.com/item/Office Lens" target="_blank" rel="noopener">Office Lens</a>“，它们能很好地矫正图片，这些软件就是应用透视变换实现的。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="http://pic.ex2tron.top/Computer Vision：Algorithms and Applications.pdf" target="_blank" rel="noopener">计算机视觉：算法与应用</a></li><li><a href="https://zh.wikipedia.org/wiki/仿射变换" target="_blank" rel="noopener">维基百科：仿射变换</a></li><li><a href="https://www.zhihu.com/question/20666664" target="_blank" rel="noopener">如何通俗地讲解「仿射变换」这个概念？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 几何变换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程7：图像几何变换</title>
      <link href="/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B7%EF%BC%9A%E5%9B%BE%E5%83%8F%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2/"/>
      <url>/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B7%EF%BC%9A%E5%9B%BE%E5%83%8F%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>学习如何旋转、平移、缩放和翻转图片。</p><p>目标：</p><ul><li>实现旋转、平移、缩放和翻转图片</li><li>OpenCV函数：<ul><li><code>cv2.resize()</code>：缩放图片，可以按指定大小缩放，也可以按比例缩放。</li><li><code>cv2.flip()</code>：翻转图片，可以指定水平、垂直、水平垂直翻转三种方式。</li><li><code>cv2.warpAffine()</code>：仿射变换，可以实现平移和旋转。</li></ul></li></ul><blockquote><p>图像的几何变换从原理上看主要包括两种：基于2×3矩阵的仿射变换（平移、缩放、旋转和翻转等）、基于3×3矩阵的透视变换，感兴趣的小伙伴可参考<a href="[http://huris.xyz/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%875%EF%BC%9A%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2%E4%B8%8E%E9%80%8F%E8%A7%86%E5%8F%98%E6%8D%A2/](http://huris.xyz/2019/08/14/Python-OpenCV教程番外篇5：仿射变换与透视变换/">番外篇：仿射变换与透视变换</a>)。</p></blockquote><a id="more"></a><h2 id="缩放图片"><a href="#缩放图片" class="headerlink" title="缩放图片"></a>缩放图片</h2><p>缩放就是调整图片的大小，使用<code>cv2.resize()</code>函数实现缩放。可以按照比例缩放，也可以按照指定的大小缩放：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br>img = cv2.imread(<span class="hljs-string">'drawing.jpg'</span>)<br><br><span class="hljs-comment"># 1.按照指定的宽度、高度缩放图片</span><br>res = cv2.resize(img, (<span class="hljs-number">132</span>, <span class="hljs-number">150</span>))<br><br><span class="hljs-comment"># 按照比例缩放，如x,y轴均放大一倍</span><br>res2 = cv2.resize(img, <span class="hljs-literal">None</span>, fx=<span class="hljs-number">2</span>, fy=<span class="hljs-number">2</span>, interpolation=cv2.INTER_LINEAR)<br><br>cv2.imshow(<span class="hljs-string">'shrink'</span>, res), cv2.imshow(<span class="hljs-string">'zoom'</span>, res2)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>我们也可以指定缩放方法<code>interpolation</code>，更专业点叫插值方法，默认是<code>INTER_LINEAR</code>，全部可以参考：<a href="https://docs.opencv.org/4.0.0/da/d54/group__imgproc__transform.html#ga5bb5a1fea74ea38e1a5445ca803ff121" target="_blank" rel="noopener">InterpolationFlags</a></p><h2 id="翻转图片"><a href="#翻转图片" class="headerlink" title="翻转图片"></a>翻转图片</h2><p>镜像翻转图片，可以用<code>cv2.flip()</code>函数：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">dst = cv2.flip(img, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>其中，参数2 = 0：垂直翻转(沿x轴)，参数2 &gt; 0: 水平翻转(沿y轴)，参数2 &lt; 0: 水平垂直翻转。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_flip_image_sample.jpg"></p><h2 id="平移图片"><a href="#平移图片" class="headerlink" title="平移图片"></a>平移图片</h2><p>要平移图片，我们需要定义下面这样一个矩阵，$t_x$，$t_y$是向$x$和$y$方向平移的距离：</p><script type="math/tex; mode=display">M=\begin{bmatrix} 0 & -1 & t_x \\ 1 & 0 & t_y\end{bmatrix}</script><p>平移是用仿射变换函数<code>cv2.warpAffine()</code>实现的：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>img = cv2.imread(<span class="hljs-string">'drawing.jpg'</span>)<br><br><span class="hljs-comment"># 平移图片</span><br>rows, cols = img.shape[:<span class="hljs-number">2</span>]<br><span class="hljs-comment"># 定义平移矩阵，需要是numpy的float32类型</span><br><span class="hljs-comment"># x轴平移100，y轴平移50</span><br>M = np.float32([[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">50</span>]])<br>dst = cv2.warpAffine(img, M, (cols, rows))<br><br>cv2.imshow(<span class="hljs-string">'shift'</span>, dst)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_translation_100_50.jpg"></p><h2 id="旋转图片"><a href="#旋转图片" class="headerlink" title="旋转图片"></a>旋转图片</h2><p>旋转同平移一样，也是用仿射变换实现的，因此也需要定义一个变换矩阵。OpenCV直接提供了 <code>cv2.getRotationMatrix2D()</code>函数来生成这个矩阵，该函数有三个参数：</p><ul><li>参数1：图片的旋转中心</li><li>参数2：旋转角度(正：逆时针，负：顺时针)</li><li>参数3：缩放比例，0.5表示缩小一半</li></ul><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 45°顺时针旋转图片并缩小一半</span><br>M = cv2.getRotationMatrix2D((cols / <span class="hljs-number">2</span>, rows / <span class="hljs-number">2</span>), <span class="hljs-number">-45</span>, <span class="hljs-number">0.5</span>)<br>dst = cv2.warpAffine(img, M, (cols, rows))<br><br>cv2.imshow(<span class="hljs-string">'rotation'</span>, dst)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_rotation_45_degree.jpg"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><ul><li><a href="https://docs.opencv.org/4.0.0/da/d54/group__imgproc__transform.html#ga47a974309e9102f5f08231edc7e7529d" target="_blank" rel="noopener">cv2.resize()</a></li><li><a href="https://docs.opencv.org/4.0.0/d2/de8/group__core__array.html#gaca7be533e3dac7feb70fc60635adf441" target="_blank" rel="noopener">cv2.filp()</a></li><li><a href="https://docs.opencv.org/4.0.0/da/d54/group__imgproc__transform.html#ga0203d9ee5fcd28d40dbc4a1ea4451983" target="_blank" rel="noopener">cv2.warpAffine()</a></li><li><a href="https://docs.opencv.org/4.0.0/da/d54/group__imgproc__transform.html#gafbbc470ce83812914a70abfb604f4326" target="_blank" rel="noopener">cv2.getRotationMatrix2D()</a></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_geometric_transformations/py_geometric_transformations.html" target="_blank" rel="noopener">Geometric Transformations of Images</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 几何变换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程番外篇4：Otsu阈值法</title>
      <link href="/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%874%EF%BC%9AOtsu%E9%98%88%E5%80%BC%E6%B3%95/"/>
      <url>/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%874%EF%BC%9AOtsu%E9%98%88%E5%80%BC%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>大部分图像处理任务都需要先进行二值化操作，阈值的选取很关键，Otsu阈值法会自动计算阈值。</p><p><a href="https://baike.baidu.com/item/otsu/16252828" target="_blank" rel="noopener">Otsu阈值法</a>（日本人大津展之提出的，也可称大津算法）非常适用于双峰图片，啥意思呢？</p><a id="more"></a><h2 id="双峰图片"><a href="#双峰图片" class="headerlink" title="双峰图片"></a>双峰图片</h2><p>双峰图片就是指图片的灰度直方图上有两个峰值，直方图就是每个值（0~255）的像素点个数统计，后面会详细介绍。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_bimodal_image_two_peaks.jpg"></p><p>Otsu算法假设这副图片由前景色和背景色组成，通过统计学方法（最大类间方差）选取一个阈值，将前景和背景尽可能分开，我们先来看下代码，然后详细说明下算法原理。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>下面这段代码对比了使用固定阈值和Otsu阈值后的不同结果：</p><p>另外，对含噪点的图像，先进行滤波操作效果会更好。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><br>img = cv2.imread(<span class="hljs-string">'noisy.jpg'</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 固定阈值法</span><br>ret1, th1 = cv2.threshold(img, <span class="hljs-number">100</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY)<br><br><span class="hljs-comment"># Otsu阈值法</span><br>ret2, th2 = cv2.threshold(img, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)<br><br><span class="hljs-comment"># 先进行高斯滤波，再使用Otsu阈值法</span><br>blur = cv2.GaussianBlur(img, (<span class="hljs-number">5</span>, <span class="hljs-number">5</span>), <span class="hljs-number">0</span>)<br>ret3, th3 = cv2.threshold(blur, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)<br></code></pre></td></tr></table></figure><p>下面我们用Matplotlib把原图、直方图和阈值图都显示出来：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python">images = [img, <span class="hljs-number">0</span>, th1,<br>          img, <span class="hljs-number">0</span>, th2,<br>          blur, <span class="hljs-number">0</span>, th3]<br><br>titles = [<span class="hljs-string">'Original'</span>, <span class="hljs-string">'Histogram'</span>, <span class="hljs-string">'Global(v=100)'</span>,<br>          <span class="hljs-string">'Original'</span>, <span class="hljs-string">'Histogram'</span>, <span class="hljs-string">"Otsu's"</span>,<br>          <span class="hljs-string">'Gaussian filtered Image'</span>, <span class="hljs-string">'Histogram'</span>, <span class="hljs-string">"Otsu's"</span>]<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):<br>    <span class="hljs-comment"># 绘制原图</span><br>    plt.subplot(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, i * <span class="hljs-number">3</span> + <span class="hljs-number">1</span>)<br>    plt.imshow(images[i * <span class="hljs-number">3</span>], <span class="hljs-string">'gray'</span>)<br>    plt.title(titles[i * <span class="hljs-number">3</span>], fontsize=<span class="hljs-number">8</span>)<br>    plt.xticks([]), plt.yticks([])<br><br>    <span class="hljs-comment"># 绘制直方图plt.hist，ravel函数将数组降成一维</span><br>    plt.subplot(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, i * <span class="hljs-number">3</span> + <span class="hljs-number">2</span>)<br>    plt.hist(images[i * <span class="hljs-number">3</span>].ravel(), <span class="hljs-number">256</span>)<br>    plt.title(titles[i * <span class="hljs-number">3</span> + <span class="hljs-number">1</span>], fontsize=<span class="hljs-number">8</span>)<br>    plt.xticks([]), plt.yticks([])<br><br>    <span class="hljs-comment"># 绘制阈值图</span><br>    plt.subplot(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, i * <span class="hljs-number">3</span> + <span class="hljs-number">3</span>)<br>    plt.imshow(images[i * <span class="hljs-number">3</span> + <span class="hljs-number">2</span>], <span class="hljs-string">'gray'</span>)<br>    plt.title(titles[i * <span class="hljs-number">3</span> + <span class="hljs-number">2</span>], fontsize=<span class="hljs-number">8</span>)<br>    plt.xticks([]), plt.yticks([])<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_otsu_vs_simple_thresholding.jpg"></p><p>可以看到，Otsu阈值明显优于固定阈值，省去了不断尝试阈值判断效果好坏的过程。其中，绘制直方图时，使用了numpy中的<a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ravel.html" target="_blank" rel="noopener">ravel()</a>函数，它会将原矩阵压缩成一维数组，便于画直方图。</p><h2 id="Otsu算法"><a href="#Otsu算法" class="headerlink" title="Otsu算法"></a>Otsu算法</h2><p>Otsu阈值法将整幅图分为前景（目标）和背景，以下是一些符号规定：</p><ul><li>$T$：分割阈值</li><li>$N_0$：前景像素点数</li><li>$N_1$：背景像素点数</li><li>$w_0$：前景的像素点数占整幅图像的比例</li><li>$w_1$：背景的像素点数占整幅图像的比例</li><li>$\mu_0$：前景的平均像素值</li><li>$\mu_1$：背景的平均像素值</li><li>$μ$：整幅图的平均像素值</li><li>$rows×cols$：图像的行数和列数</li></ul><p>结合下图会更容易理解一些，有一副大小为4×4的图片，假设阈值T为1，那么：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_otsu_theory_sample.jpg"></p><p>其实很好理解，$N_0+N_1$就是总的像素点个数，也就是行数乘列数：</p><script type="math/tex; mode=display">N_0 + N_1 = rows \times cols</script><p>$w_0$和$w_1$是前/背景所占的比例，也就是：</p><script type="math/tex; mode=display">w_0 = \frac{N_0}{rows\times{cols}}</script><script type="math/tex; mode=display">w_1 = \frac{N_1}{rows\times{cols}}</script><script type="math/tex; mode=display">w_0+w_1=1</script><p>整幅图的平均像素值就是：</p><script type="math/tex; mode=display">\mu=w_0\times{\mu_0}+w_1\times{\mu_1}</script><p>此时，我们定义一个前景$\mu_0$与背景$\mu_1$的方差$g$：</p><script type="math/tex; mode=display">g=w_0(\mu_0-\mu)^{2}+w_1(\mu_1-\mu)^{2}</script><p>将前述的(4)、(5)、(6)公式整合在一起，便是：</p><script type="math/tex; mode=display">g=w_0w_1(\mu_0-\mu_1)^{2}</script><p><strong>$g$就是前景与背景两类之间的方差，这个值越大，说明前景和背景的差别也就越大，效果越好。Otsu算法便是遍历阈值T，使得$g$最大，所以又称为最大类间方差法。</strong>基本上双峰图片的阈值T在两峰之间的谷底。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><ul><li><a href="https://docs.opencv.org/4.0.0/d7/d1b/group__imgproc__misc.html#gaa9e58d2860d4afa658ef70a9b1115576" target="_blank" rel="noopener">cv2.ThresholdTypes</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#gaabe8c836e97159a9193fb0b11ac52cf1" target="_blank" rel="noopener">cv2.GaussianBlur()</a></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ravel.html" target="_blank" rel="noopener">numpy.ravel</a></li><li><a href="https://en.wikipedia.org/wiki/Otsu&#39;s_method" target="_blank" rel="noopener">Otsu’s Method(wikipedia)</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_thresholding/py_thresholding.html" target="_blank" rel="noopener">Image Thresholding</a></li><li><a href="https://blog.csdn.net/u011776903/article/details/73274802" target="_blank" rel="noopener">一维OTSU法、最小交叉熵法、二维OTSU法及C++源码</a></li><li><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4310076" target="_blank" rel="noopener">Otsu N. A threshold selection method from gray-level histograms[J\]. IEEE transactions on systems, man, and cybernetics, 1979, 9(1): 62-66.</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 阈值 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程6：阈值分割</title>
      <link href="/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B6%EF%BC%9A%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/"/>
      <url>/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B6%EF%BC%9A%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/</url>
      
        <content type="html"><![CDATA[<p>学习使用不同的阈值方法”二值化”图像。</p><p>目标：</p><ul><li>使用固定阈值、自适应阈值和Otsu阈值法“二值化”图像</li><li>二值化跟阈值分割并不等同。针对不同的图片，可以采用不同的阈值方法。</li><li>OpenCV函数：<ul><li><code>cv2.threshould()</code>：用来进行固定阈值分割。</li><li><code>cv2.adaptiveThreshold()</code>：固定阈值不适用于光线不均匀的图片，所以用该函数进行自适应阈值分割。</li></ul></li></ul><a id="more"></a><h2 id="固定阈值分割"><a href="#固定阈值分割" class="headerlink" title="固定阈值分割"></a>固定阈值分割</h2><p>固定阈值分割很直接，一句话说就是像素点值大于阈值变成一类值，小于阈值变成另一类值。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_threshold_binary_demo.jpg"></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br><span class="hljs-comment"># 灰度图读入</span><br>img = cv2.imread(<span class="hljs-string">'gradient.jpg'</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 阈值分割，ret：return value缩写，代表当前的阈值，暂时不用理会</span><br>ret, th = cv2.threshold(img, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY)<br>cv2.imshow(<span class="hljs-string">'thresh'</span>, th)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><code>cv2.threshold()</code>用来实现阈值分割，ret是return value缩写，代表当前的阈值，暂时不用理会。函数有4个参数：</p><ul><li>参数1：要处理的原图，<strong>一般是灰度图</strong></li><li>参数2：设定的阈值</li><li>参数3：最大阈值，一般为255</li><li>参数4：阈值的方式，主要有5种，详情：<a href="https://docs.opencv.org/4.0.0/d7/d1b/group__imgproc__misc.html#gaa9e58d2860d4afa658ef70a9b1115576" target="_blank" rel="noopener">ThresholdTypes</a></li></ul><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># 灰度图读入</span><br>img = cv2.imread(<span class="hljs-string">'gradient.jpg'</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 应用5种不同的阈值方法</span><br>ret, th1 = cv2.threshold(img, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY)<br>ret, th2 = cv2.threshold(img, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY_INV)<br>ret, th3 = cv2.threshold(img, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_TRUNC)<br>ret, th4 = cv2.threshold(img, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_TOZERO)<br>ret, th5 = cv2.threshold(img, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_TOZERO_INV)<br><br>titles = [<span class="hljs-string">'Original'</span>, <span class="hljs-string">'BINARY'</span>, <span class="hljs-string">'BINARY_INV'</span>, <span class="hljs-string">'TRUNC'</span>, <span class="hljs-string">'TOZERO'</span>, <span class="hljs-string">'TOZERO_INV'</span>]<br>images = [img, th1, th2, th3, th4, th5]<br><br><span class="hljs-comment"># 使用Matplotlib显示</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">6</span>):<br>    plt.subplot(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, i + <span class="hljs-number">1</span>)<br>    plt.imshow(images[i], <span class="hljs-string">'gray'</span>)<br>    plt.title(titles[i], fontsize=<span class="hljs-number">8</span>)<br>    plt.xticks([]), plt.yticks([])  <span class="hljs-comment"># 隐藏坐标轴</span><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_different_threshold_demo.jpg"></p><blockquote><p>经验之谈：很多人误以为阈值分割就是<a href="https://baike.baidu.com/item/二值化" target="_blank" rel="noopener">二值化</a>。从上图中可以发现，两者并不等同，阈值分割结果是两类值，而不是两个值，所以教程开头我把二值化加了引号。</p></blockquote><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_different_thresholds_theory.jpg" width="70%"></p><h2 id="自适应阈值"><a href="#自适应阈值" class="headerlink" title="自适应阈值"></a>自适应阈值</h2><p>看得出来固定阈值是在整幅图片上应用一个阈值进行分割，<em>它并不适用于明暗分布不均的图片</em>。 <code>cv2.adaptiveThreshold()</code>自适应阈值会每次取图片的一小部分计算阈值，这样图片不同区域的阈值就不尽相同。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br><span class="hljs-comment"># 自适应阈值对比固定阈值</span><br>img = cv2.imread(<span class="hljs-string">'sudoku.jpg'</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 固定阈值</span><br>ret, th1 = cv2.threshold(img, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY)<br><br><span class="hljs-comment"># 自适应阈值</span><br>th2 = cv2.adaptiveThreshold(<br>    img, <span class="hljs-number">255</span>, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, <span class="hljs-number">11</span>, <span class="hljs-number">4</span>)<br><br>th3 = cv2.adaptiveThreshold(<br>    img, <span class="hljs-number">255</span>, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, <span class="hljs-number">17</span>, <span class="hljs-number">6</span>)<br><br>titles = [<span class="hljs-string">'Original'</span>, <span class="hljs-string">'Global(v = 127)'</span>, <span class="hljs-string">'Adaptive Mean'</span>, <span class="hljs-string">'Adaptive Gaussian'</span>]<br>images = [img, th1, th2, th3]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">4</span>):<br>    plt.subplot(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, i + <span class="hljs-number">1</span>), plt.imshow(images[i], <span class="hljs-string">'gray'</span>)<br>    plt.title(titles[i], fontsize=<span class="hljs-number">8</span>)<br>    plt.xticks([]), plt.yticks([])<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_adaptive_vs_global_thresholding.jpg"></p><p><code>cv2.adaptiveThreshold()</code>有5个参数，其实很好理解：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">th2 = cv2.adaptiveThreshold(<br>    img, <span class="hljs-number">255</span>, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, <span class="hljs-number">11</span>, <span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><ul><li>参数1：要处理的原图</li><li>参数2：最大阈值，一般为255</li><li>参数3：小区域阈值的计算方式<ul><li><code>ADAPTIVE_THRESH_MEAN_C</code>：小区域内取均值</li><li><code>ADAPTIVE_THRESH_GAUSSIAN_C</code>：小区域内加权求和，权重是个高斯核</li></ul></li><li>参数4：阈值方式（跟前面讲的那5种相同）</li><li>参数5：小区域的面积，如11就是11*11的小块</li><li>参数6：最终阈值等于小区域计算出的阈值再减去此值</li></ul><p>如果你没看懂上面的参数也不要紧，暂时会用就行，当然我建议你调整下参数看看不同的结果。</p><h2 id="Otsu阈值"><a href="#Otsu阈值" class="headerlink" title="Otsu阈值"></a>Otsu阈值</h2><p>在前面固定阈值中，我们是随便选了一个阈值如127，那如何知道我们选的这个阈值效果好不好呢？答案是：不断尝试，所以这种方法在很多文献中都被称为经验阈值。</p><p><a href="https://baike.baidu.com/item/otsu/16252828" target="_blank" rel="noopener">Otsu阈值法</a>就提供了一种自动高效的二值化方法，不过我们直方图还没学，这里暂时略过。</p><p>具体可以参考<a href="[http://huris.xyz/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%874%EF%BC%9AOtsu%E9%98%88%E5%80%BC%E6%B3%95/](http://huris.xyz/2019/08/14/Python-OpenCV教程番外篇4：Otsu阈值法/">Python+OpenCV教程番外篇4：Otsu阈值法</a>)</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><p><a href="https://docs.opencv.org/4.0.0/d7/d1b/group__imgproc__misc.html#gae8a4a146d1ca78c626a53577199e9c57" target="_blank" rel="noopener"><br>cv2.threshold()</a></p><p><a href="https://docs.opencv.org/4.0.0/d7/d1b/group__imgproc__misc.html#ga72b913f352e4a1b1b397736707afcde3" target="_blank" rel="noopener">cv2.adaptiveThreshold()</a></p><p><a href="https://docs.opencv.org/4.0.0/d7/d1b/group__imgproc__misc.html#gaa9e58d2860d4afa658ef70a9b1115576" target="_blank" rel="noopener">cv2.ThresholdTypes()</a></p><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><ul><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_thresholding/py_thresholding.html" target="_blank" rel="noopener">Image Thresholding</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 阈值 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程5：颜色空间转换</title>
      <link href="/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B5%EF%BC%9A%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2/"/>
      <url>/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B5%EF%BC%9A%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>学习如何进行图片的颜色空间转换，视频中追踪特定颜色的物体。</p><p>目标：</p><ul><li><p>颜色空间转换，如BGR↔Gray，BGR↔HSV等</p></li><li><p>追踪视频中特定颜色的物体</p></li><li><p>HSV颜色模型常用于颜色识别。要想知道某种颜色在HSV下的值，可以将它的BGR值用<code>cvtColor()</code>转换得到。</p></li><li><p>OpenCV函数：</p><ul><li><p><code>cv2.cvtColor()</code>：用来进行颜色空间转换，常用BGR↔Gray，BGR↔HSV。</p><p>  <code>hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)</code></p></li><li><p><code>cv2.inRange()</code>：指定颜色范围。</p><p> <code>mask = cv2.inRange(hsv, lower_blue, upper_blue)</code></p></li></ul></li></ul><a id="more"></a><h2 id="颜色空间转换"><a href="#颜色空间转换" class="headerlink" title="颜色空间转换"></a>颜色空间转换</h2><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br>img = cv2.imread(<span class="hljs-string">'lena.jpg'</span>)<br><br><span class="hljs-comment"># 转成灰度图</span><br><span class="hljs-comment"># cv2.cvtColor()用来进行颜色模型转换</span><br><span class="hljs-comment"># 参数1是要转换的图片</span><br><span class="hljs-comment"># 参数2是转换模式</span><br>img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br><br>cv2.imshow(<span class="hljs-string">'img'</span>, img)<br>cv2.imshow(<span class="hljs-string">'gray'</span>, img_gray)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><code>COLOR_BGR2GRAY</code>表示BGR→Gray，可用下面的代码显示所有的转换模式：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">flags = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> dir(cv2) <span class="hljs-keyword">if</span> i.startswith(<span class="hljs-string">'COLOR_'</span>)]<br>print(flags)<br><br>**************************************************************************<br><br>运行结果：<br>[<span class="hljs-string">'COLOR_BAYER_BG2BGR'</span>, <span class="hljs-string">'COLOR_BAYER_BG2BGRA'</span>, <span class="hljs-string">'COLOR_BAYER_BG2BGR_EA'</span>, <span class="hljs-string">'COLOR_BAYER_BG2BGR_VNG'</span>, <span class="hljs-string">'COLOR_BAYER_BG2GRAY'</span>, <span class="hljs-string">'COLOR_BAYER_BG2RGB'</span>, <span class="hljs-string">'COLOR_BAYER_BG2RGBA'</span>, <span class="hljs-string">'COLOR_BAYER_BG2RGB_EA'</span>, <span class="hljs-string">'COLOR_BAYER_BG2RGB_VNG'</span>, <span class="hljs-string">'COLOR_BAYER_GB2BGR'</span>, <span class="hljs-string">'COLOR_BAYER_GB2BGRA'</span>, <span class="hljs-string">'COLOR_BAYER_GB2BGR_EA'</span>, <span class="hljs-string">'COLOR_BAYER_GB2BGR_VNG'</span>, <span class="hljs-string">'COLOR_BAYER_GB2GRAY'</span>, <span class="hljs-string">'COLOR_BAYER_GB2RGB'</span>, <span class="hljs-string">'COLOR_BAYER_GB2RGBA'</span>, <span class="hljs-string">'COLOR_BAYER_GB2RGB_EA'</span>, <span class="hljs-string">'COLOR_BAYER_GB2RGB_VNG'</span>, <span class="hljs-string">'COLOR_BAYER_GR2BGR'</span>, <span class="hljs-string">'COLOR_BAYER_GR2BGRA'</span>, <span class="hljs-string">'COLOR_BAYER_GR2BGR_EA'</span>, <span class="hljs-string">'COLOR_BAYER_GR2BGR_VNG'</span>, <span class="hljs-string">'COLOR_BAYER_GR2GRAY'</span>, <span class="hljs-string">'COLOR_BAYER_GR2RGB'</span>, <span class="hljs-string">'COLOR_BAYER_GR2RGBA'</span>, <span class="hljs-string">'COLOR_BAYER_GR2RGB_EA'</span>, <span class="hljs-string">'COLOR_BAYER_GR2RGB_VNG'</span>, <span class="hljs-string">'COLOR_BAYER_RG2BGR'</span>, <span class="hljs-string">'COLOR_BAYER_RG2BGRA'</span>, <span class="hljs-string">'COLOR_BAYER_RG2BGR_EA'</span>, <span class="hljs-string">'COLOR_BAYER_RG2BGR_VNG'</span>, <span class="hljs-string">'COLOR_BAYER_RG2GRAY'</span>, <span class="hljs-string">'COLOR_BAYER_RG2RGB'</span>, <span class="hljs-string">'COLOR_BAYER_RG2RGBA'</span>, <span class="hljs-string">'COLOR_BAYER_RG2RGB_EA'</span>, <span class="hljs-string">'COLOR_BAYER_RG2RGB_VNG'</span>, <span class="hljs-string">'COLOR_BGR2BGR555'</span>, <span class="hljs-string">'COLOR_BGR2BGR565'</span>, <span class="hljs-string">'COLOR_BGR2BGRA'</span>, <span class="hljs-string">'COLOR_BGR2GRAY'</span>, <span class="hljs-string">'COLOR_BGR2HLS'</span>, <span class="hljs-string">'COLOR_BGR2HLS_FULL'</span>, <span class="hljs-string">'COLOR_BGR2HSV'</span>, <span class="hljs-string">'COLOR_BGR2HSV_FULL'</span>, <span class="hljs-string">'COLOR_BGR2LAB'</span>, <span class="hljs-string">'COLOR_BGR2LUV'</span>, <span class="hljs-string">'COLOR_BGR2Lab'</span>, <span class="hljs-string">'COLOR_BGR2Luv'</span>, <span class="hljs-string">'COLOR_BGR2RGB'</span>, <span class="hljs-string">'COLOR_BGR2RGBA'</span>, <span class="hljs-string">'COLOR_BGR2XYZ'</span>, <span class="hljs-string">'COLOR_BGR2YCR_CB'</span>, <span class="hljs-string">'COLOR_BGR2YCrCb'</span>, <span class="hljs-string">'COLOR_BGR2YUV'</span>, <span class="hljs-string">'COLOR_BGR2YUV_I420'</span>, <span class="hljs-string">'COLOR_BGR2YUV_IYUV'</span>, <span class="hljs-string">'COLOR_BGR2YUV_YV12'</span>, <span class="hljs-string">'COLOR_BGR5552BGR'</span>, <span class="hljs-string">'COLOR_BGR5552BGRA'</span>, <span class="hljs-string">'COLOR_BGR5552GRAY'</span>, <span class="hljs-string">'COLOR_BGR5552RGB'</span>, <span class="hljs-string">'COLOR_BGR5552RGBA'</span>, <span class="hljs-string">'COLOR_BGR5652BGR'</span>, <span class="hljs-string">'COLOR_BGR5652BGRA'</span>, <span class="hljs-string">'COLOR_BGR5652GRAY'</span>, <span class="hljs-string">'COLOR_BGR5652RGB'</span>, <span class="hljs-string">'COLOR_BGR5652RGBA'</span>, <span class="hljs-string">'COLOR_BGRA2BGR'</span>, <span class="hljs-string">'COLOR_BGRA2BGR555'</span>, <span class="hljs-string">'COLOR_BGRA2BGR565'</span>, <span class="hljs-string">'COLOR_BGRA2GRAY'</span>, <span class="hljs-string">'COLOR_BGRA2RGB'</span>, <span class="hljs-string">'COLOR_BGRA2RGBA'</span>, <span class="hljs-string">'COLOR_BGRA2YUV_I420'</span>, <span class="hljs-string">'COLOR_BGRA2YUV_IYUV'</span>, <span class="hljs-string">'COLOR_BGRA2YUV_YV12'</span>, <span class="hljs-string">'COLOR_BayerBG2BGR'</span>, <span class="hljs-string">'COLOR_BayerBG2BGRA'</span>, <span class="hljs-string">'COLOR_BayerBG2BGR_EA'</span>, <span class="hljs-string">'COLOR_BayerBG2BGR_VNG'</span>, <span class="hljs-string">'COLOR_BayerBG2GRAY'</span>, <span class="hljs-string">'COLOR_BayerBG2RGB'</span>, <span class="hljs-string">'COLOR_BayerBG2RGBA'</span>, <span class="hljs-string">'COLOR_BayerBG2RGB_EA'</span>, <span class="hljs-string">'COLOR_BayerBG2RGB_VNG'</span>, <span class="hljs-string">'COLOR_BayerGB2BGR'</span>, <span class="hljs-string">'COLOR_BayerGB2BGRA'</span>, <span class="hljs-string">'COLOR_BayerGB2BGR_EA'</span>, <span class="hljs-string">'COLOR_BayerGB2BGR_VNG'</span>, <span class="hljs-string">'COLOR_BayerGB2GRAY'</span>, <span class="hljs-string">'COLOR_BayerGB2RGB'</span>, <span class="hljs-string">'COLOR_BayerGB2RGBA'</span>, <span class="hljs-string">'COLOR_BayerGB2RGB_EA'</span>, <span class="hljs-string">'COLOR_BayerGB2RGB_VNG'</span>, <span class="hljs-string">'COLOR_BayerGR2BGR'</span>, <span class="hljs-string">'COLOR_BayerGR2BGRA'</span>, <span class="hljs-string">'COLOR_BayerGR2BGR_EA'</span>, <span class="hljs-string">'COLOR_BayerGR2BGR_VNG'</span>, <span class="hljs-string">'COLOR_BayerGR2GRAY'</span>, <span class="hljs-string">'COLOR_BayerGR2RGB'</span>, <span class="hljs-string">'COLOR_BayerGR2RGBA'</span>, <span class="hljs-string">'COLOR_BayerGR2RGB_EA'</span>, <span class="hljs-string">'COLOR_BayerGR2RGB_VNG'</span>, <span class="hljs-string">'COLOR_BayerRG2BGR'</span>, <span class="hljs-string">'COLOR_BayerRG2BGRA'</span>, <span class="hljs-string">'COLOR_BayerRG2BGR_EA'</span>, <span class="hljs-string">'COLOR_BayerRG2BGR_VNG'</span>, <span class="hljs-string">'COLOR_BayerRG2GRAY'</span>, <span class="hljs-string">'COLOR_BayerRG2RGB'</span>, <span class="hljs-string">'COLOR_BayerRG2RGBA'</span>, <span class="hljs-string">'COLOR_BayerRG2RGB_EA'</span>, <span class="hljs-string">'COLOR_BayerRG2RGB_VNG'</span>, <span class="hljs-string">'COLOR_COLORCVT_MAX'</span>, <span class="hljs-string">'COLOR_GRAY2BGR'</span>, <span class="hljs-string">'COLOR_GRAY2BGR555'</span>, <span class="hljs-string">'COLOR_GRAY2BGR565'</span>, <span class="hljs-string">'COLOR_GRAY2BGRA'</span>, <span class="hljs-string">'COLOR_GRAY2RGB'</span>, <span class="hljs-string">'COLOR_GRAY2RGBA'</span>, <span class="hljs-string">'COLOR_HLS2BGR'</span>, <span class="hljs-string">'COLOR_HLS2BGR_FULL'</span>, <span class="hljs-string">'COLOR_HLS2RGB'</span>, <span class="hljs-string">'COLOR_HLS2RGB_FULL'</span>, <span class="hljs-string">'COLOR_HSV2BGR'</span>, <span class="hljs-string">'COLOR_HSV2BGR_FULL'</span>, <span class="hljs-string">'COLOR_HSV2RGB'</span>, <span class="hljs-string">'COLOR_HSV2RGB_FULL'</span>, <span class="hljs-string">'COLOR_LAB2BGR'</span>, <span class="hljs-string">'COLOR_LAB2LBGR'</span>, <span class="hljs-string">'COLOR_LAB2LRGB'</span>, <span class="hljs-string">'COLOR_LAB2RGB'</span>, <span class="hljs-string">'COLOR_LBGR2LAB'</span>, <span class="hljs-string">'COLOR_LBGR2LUV'</span>, <span class="hljs-string">'COLOR_LBGR2Lab'</span>, <span class="hljs-string">'COLOR_LBGR2Luv'</span>, <span class="hljs-string">'COLOR_LRGB2LAB'</span>, <span class="hljs-string">'COLOR_LRGB2LUV'</span>, <span class="hljs-string">'COLOR_LRGB2Lab'</span>, <span class="hljs-string">'COLOR_LRGB2Luv'</span>, <span class="hljs-string">'COLOR_LUV2BGR'</span>, <span class="hljs-string">'COLOR_LUV2LBGR'</span>, <span class="hljs-string">'COLOR_LUV2LRGB'</span>, <span class="hljs-string">'COLOR_LUV2RGB'</span>, <span class="hljs-string">'COLOR_Lab2BGR'</span>, <span class="hljs-string">'COLOR_Lab2LBGR'</span>, <span class="hljs-string">'COLOR_Lab2LRGB'</span>, <span class="hljs-string">'COLOR_Lab2RGB'</span>, <span class="hljs-string">'COLOR_Luv2BGR'</span>, <span class="hljs-string">'COLOR_Luv2LBGR'</span>, <span class="hljs-string">'COLOR_Luv2LRGB'</span>, <span class="hljs-string">'COLOR_Luv2RGB'</span>, <span class="hljs-string">'COLOR_M_RGBA2RGBA'</span>, <span class="hljs-string">'COLOR_RGB2BGR'</span>, <span class="hljs-string">'COLOR_RGB2BGR555'</span>, <span class="hljs-string">'COLOR_RGB2BGR565'</span>, <span class="hljs-string">'COLOR_RGB2BGRA'</span>, <span class="hljs-string">'COLOR_RGB2GRAY'</span>, <span class="hljs-string">'COLOR_RGB2HLS'</span>, <span class="hljs-string">'COLOR_RGB2HLS_FULL'</span>, <span class="hljs-string">'COLOR_RGB2HSV'</span>, <span class="hljs-string">'COLOR_RGB2HSV_FULL'</span>, <span class="hljs-string">'COLOR_RGB2LAB'</span>, <span class="hljs-string">'COLOR_RGB2LUV'</span>, <span class="hljs-string">'COLOR_RGB2Lab'</span>, <span class="hljs-string">'COLOR_RGB2Luv'</span>, <span class="hljs-string">'COLOR_RGB2RGBA'</span>, <span class="hljs-string">'COLOR_RGB2XYZ'</span>, <span class="hljs-string">'COLOR_RGB2YCR_CB'</span>, <span class="hljs-string">'COLOR_RGB2YCrCb'</span>, <span class="hljs-string">'COLOR_RGB2YUV'</span>, <span class="hljs-string">'COLOR_RGB2YUV_I420'</span>, <span class="hljs-string">'COLOR_RGB2YUV_IYUV'</span>, <span class="hljs-string">'COLOR_RGB2YUV_YV12'</span>, <span class="hljs-string">'COLOR_RGBA2BGR'</span>, <span class="hljs-string">'COLOR_RGBA2BGR555'</span>, <span class="hljs-string">'COLOR_RGBA2BGR565'</span>, <span class="hljs-string">'COLOR_RGBA2BGRA'</span>, <span class="hljs-string">'COLOR_RGBA2GRAY'</span>, <span class="hljs-string">'COLOR_RGBA2M_RGBA'</span>, <span class="hljs-string">'COLOR_RGBA2RGB'</span>, <span class="hljs-string">'COLOR_RGBA2YUV_I420'</span>, <span class="hljs-string">'COLOR_RGBA2YUV_IYUV'</span>, <span class="hljs-string">'COLOR_RGBA2YUV_YV12'</span>, <span class="hljs-string">'COLOR_RGBA2mRGBA'</span>, <span class="hljs-string">'COLOR_XYZ2BGR'</span>, <span class="hljs-string">'COLOR_XYZ2RGB'</span>, <span class="hljs-string">'COLOR_YCR_CB2BGR'</span>, <span class="hljs-string">'COLOR_YCR_CB2RGB'</span>, <span class="hljs-string">'COLOR_YCrCb2BGR'</span>, <span class="hljs-string">'COLOR_YCrCb2RGB'</span>, <span class="hljs-string">'COLOR_YUV2BGR'</span>, <span class="hljs-string">'COLOR_YUV2BGRA_I420'</span>, <span class="hljs-string">'COLOR_YUV2BGRA_IYUV'</span>, <span class="hljs-string">'COLOR_YUV2BGRA_NV12'</span>, <span class="hljs-string">'COLOR_YUV2BGRA_NV21'</span>, <span class="hljs-string">'COLOR_YUV2BGRA_UYNV'</span>, <span class="hljs-string">'COLOR_YUV2BGRA_UYVY'</span>, <span class="hljs-string">'COLOR_YUV2BGRA_Y422'</span>, <span class="hljs-string">'COLOR_YUV2BGRA_YUNV'</span>, <span class="hljs-string">'COLOR_YUV2BGRA_YUY2'</span>, <span class="hljs-string">'COLOR_YUV2BGRA_YUYV'</span>, <span class="hljs-string">'COLOR_YUV2BGRA_YV12'</span>, <span class="hljs-string">'COLOR_YUV2BGRA_YVYU'</span>, <span class="hljs-string">'COLOR_YUV2BGR_I420'</span>, <span class="hljs-string">'COLOR_YUV2BGR_IYUV'</span>, <span class="hljs-string">'COLOR_YUV2BGR_NV12'</span>, <span class="hljs-string">'COLOR_YUV2BGR_NV21'</span>, <span class="hljs-string">'COLOR_YUV2BGR_UYNV'</span>, <span class="hljs-string">'COLOR_YUV2BGR_UYVY'</span>, <span class="hljs-string">'COLOR_YUV2BGR_Y422'</span>, <span class="hljs-string">'COLOR_YUV2BGR_YUNV'</span>, <span class="hljs-string">'COLOR_YUV2BGR_YUY2'</span>, <span class="hljs-string">'COLOR_YUV2BGR_YUYV'</span>, <span class="hljs-string">'COLOR_YUV2BGR_YV12'</span>, <span class="hljs-string">'COLOR_YUV2BGR_YVYU'</span>, <span class="hljs-string">'COLOR_YUV2GRAY_420'</span>, <span class="hljs-string">'COLOR_YUV2GRAY_I420'</span>, <span class="hljs-string">'COLOR_YUV2GRAY_IYUV'</span>, <span class="hljs-string">'COLOR_YUV2GRAY_NV12'</span>, <span class="hljs-string">'COLOR_YUV2GRAY_NV21'</span>, <span class="hljs-string">'COLOR_YUV2GRAY_UYNV'</span>, <span class="hljs-string">'COLOR_YUV2GRAY_UYVY'</span>, <span class="hljs-string">'COLOR_YUV2GRAY_Y422'</span>, <span class="hljs-string">'COLOR_YUV2GRAY_YUNV'</span>, <span class="hljs-string">'COLOR_YUV2GRAY_YUY2'</span>, <span class="hljs-string">'COLOR_YUV2GRAY_YUYV'</span>, <span class="hljs-string">'COLOR_YUV2GRAY_YV12'</span>, <span class="hljs-string">'COLOR_YUV2GRAY_YVYU'</span>, <span class="hljs-string">'COLOR_YUV2RGB'</span>, <span class="hljs-string">'COLOR_YUV2RGBA_I420'</span>, <span class="hljs-string">'COLOR_YUV2RGBA_IYUV'</span>, <span class="hljs-string">'COLOR_YUV2RGBA_NV12'</span>, <span class="hljs-string">'COLOR_YUV2RGBA_NV21'</span>, <span class="hljs-string">'COLOR_YUV2RGBA_UYNV'</span>, <span class="hljs-string">'COLOR_YUV2RGBA_UYVY'</span>, <span class="hljs-string">'COLOR_YUV2RGBA_Y422'</span>, <span class="hljs-string">'COLOR_YUV2RGBA_YUNV'</span>, <span class="hljs-string">'COLOR_YUV2RGBA_YUY2'</span>, <span class="hljs-string">'COLOR_YUV2RGBA_YUYV'</span>, <span class="hljs-string">'COLOR_YUV2RGBA_YV12'</span>, <span class="hljs-string">'COLOR_YUV2RGBA_YVYU'</span>, <span class="hljs-string">'COLOR_YUV2RGB_I420'</span>, <span class="hljs-string">'COLOR_YUV2RGB_IYUV'</span>, <span class="hljs-string">'COLOR_YUV2RGB_NV12'</span>, <span class="hljs-string">'COLOR_YUV2RGB_NV21'</span>, <span class="hljs-string">'COLOR_YUV2RGB_UYNV'</span>, <span class="hljs-string">'COLOR_YUV2RGB_UYVY'</span>, <span class="hljs-string">'COLOR_YUV2RGB_Y422'</span>, <span class="hljs-string">'COLOR_YUV2RGB_YUNV'</span>, <span class="hljs-string">'COLOR_YUV2RGB_YUY2'</span>, <span class="hljs-string">'COLOR_YUV2RGB_YUYV'</span>, <span class="hljs-string">'COLOR_YUV2RGB_YV12'</span>, <span class="hljs-string">'COLOR_YUV2RGB_YVYU'</span>, <span class="hljs-string">'COLOR_YUV420P2BGR'</span>, <span class="hljs-string">'COLOR_YUV420P2BGRA'</span>, <span class="hljs-string">'COLOR_YUV420P2GRAY'</span>, <span class="hljs-string">'COLOR_YUV420P2RGB'</span>, <span class="hljs-string">'COLOR_YUV420P2RGBA'</span>, <span class="hljs-string">'COLOR_YUV420SP2BGR'</span>, <span class="hljs-string">'COLOR_YUV420SP2BGRA'</span>, <span class="hljs-string">'COLOR_YUV420SP2GRAY'</span>, <span class="hljs-string">'COLOR_YUV420SP2RGB'</span>, <span class="hljs-string">'COLOR_YUV420SP2RGBA'</span>, <span class="hljs-string">'COLOR_YUV420p2BGR'</span>, <span class="hljs-string">'COLOR_YUV420p2BGRA'</span>, <span class="hljs-string">'COLOR_YUV420p2GRAY'</span>, <span class="hljs-string">'COLOR_YUV420p2RGB'</span>, <span class="hljs-string">'COLOR_YUV420p2RGBA'</span>, <span class="hljs-string">'COLOR_YUV420sp2BGR'</span>, <span class="hljs-string">'COLOR_YUV420sp2BGRA'</span>, <span class="hljs-string">'COLOR_YUV420sp2GRAY'</span>, <span class="hljs-string">'COLOR_YUV420sp2RGB'</span>, <span class="hljs-string">'COLOR_YUV420sp2RGBA'</span>, <span class="hljs-string">'COLOR_mRGBA2RGBA'</span>]<br></code></pre></td></tr></table></figure><blockquote><p>经验之谈：颜色转换其实是数学运算，如灰度化最常用的是：<code>gray=R*0.299+G*0.587+B*0.114</code>。</p></blockquote><h2 id="视频中特定颜色物体追踪"><a href="#视频中特定颜色物体追踪" class="headerlink" title="视频中特定颜色物体追踪"></a>视频中特定颜色物体追踪</h2><p><a href="https://baike.baidu.com/item/HSV/547122" target="_blank" rel="noopener">HSV</a>是一个常用于颜色识别的模型，相比BGR更易区分颜色，转换模式用<code>COLOR_BGR2HSV</code>表示。</p><blockquote><p>经验之谈：OpenCV中色调H范围为[0,179]，饱和度S是[0,255]，明度V是[0,255]。虽然H的理论数值是0°~360°，但8位图像像素点的最大值是255，所以OpenCV中除以了2，某些软件可能使用不同的尺度表示，所以同其他软件混用时，记得归一化。</p></blockquote><p>现在，我们实现一个使用HSV来只显示视频中蓝色物体的例子，步骤如下：</p><ol><li>捕获视频中的一帧</li><li>从BGR转换到HSV</li><li>提取蓝色范围的物体</li><li>只显示蓝色物体</li></ol><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_blue_object_tracking.jpg"></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>capture = cv2.VideoCapture(<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 蓝色的范围，不同光照条件下不一样，可灵活调整</span><br>lower_blue = np.array([<span class="hljs-number">100</span>, <span class="hljs-number">110</span>, <span class="hljs-number">110</span>])<br>upper_blue = np.array([<span class="hljs-number">130</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>])<br><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">True</span>):<br>    <span class="hljs-comment"># 1.捕获视频中的一帧</span><br>    ret, frame = capture.read()<br>    <span class="hljs-comment"># 2.从BGR转换到HSV</span><br>    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)<br>    <span class="hljs-comment"># 3.inRange()：介于lower/upper之间的为白色，其余黑色</span><br>    mask = cv2.inRange(hsv, lower_blue, upper_blue)<br>    <span class="hljs-comment"># 4.只保留原图中的蓝色部分</span><br>    res = cv2.bitwise_and(frame, frame, mask=mask)<br>    cv2.imshow(<span class="hljs-string">'frame'</span>, frame)<br>    cv2.imshow(<span class="hljs-string">'mask'</span>, mask)<br>    cv2.imshow(<span class="hljs-string">'res'</span>, res)<br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">1</span>) == ord(<span class="hljs-string">'q'</span>):<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p>蓝色的HSV值的上下限lower和upper范围是怎么得到的呢？其实很简单，我们先把标准蓝色的BGR值用<code>cvtColor()</code>转换下：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 蓝色的HSV值</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>blue = np.uint8([[[<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]]])<br>hsv_blue = cv2.cvtColor(blue, cv2.COLOR_BGR2HSV)<br>print(hsv_blue)  <span class="hljs-comment"># [[[120 255 255]]]</span><br></code></pre></td></tr></table></figure><p>结果是[120, 255, 255]，所以，我们把蓝色的范围调整成了上面代码那样。</p><p><strong>除了HSV，<a href="https://baike.baidu.com/item/Lab/1514615" target="_blank" rel="noopener">Lab</a>颜色空间也经常用来做颜色识别。</strong></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>尝试在视频中同时提取红色、蓝色、绿色的物体。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_exercise_tracking_three_colors.jpg"></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># HSV中</span><br><span class="hljs-comment"># Blue：[[[120 255 255]]]</span><br><span class="hljs-comment"># Green：[[[ 60 255 255]]]</span><br><span class="hljs-comment"># Red：[[[  0 255 255]]]</span><br><br>capture = cv2.VideoCapture(<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 蓝色的范围</span><br>lower_blue = np.array([<span class="hljs-number">100</span>, <span class="hljs-number">110</span>, <span class="hljs-number">110</span>])<br>upper_blue = np.array([<span class="hljs-number">130</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>])<br><br><span class="hljs-comment"># 绿色的范围</span><br>lower_green = np.array([<span class="hljs-number">40</span>, <span class="hljs-number">90</span>, <span class="hljs-number">90</span>])<br>upper_green = np.array([<span class="hljs-number">70</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>])<br><br><span class="hljs-comment"># 红色的范围</span><br>lower_red = np.array([<span class="hljs-number">160</span>, <span class="hljs-number">120</span>, <span class="hljs-number">120</span>])<br>upper_red = np.array([<span class="hljs-number">179</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>])<br><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">True</span>):<br>    <span class="hljs-comment"># 1.捕获视频中的一帧</span><br>    ret, frame = capture.read()<br><br>    <span class="hljs-comment"># 2.从BGR转换到HSV</span><br>    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)<br><br>    mask_blue = cv2.inRange(hsv, lower_blue, upper_blue)<br>    mask_green = cv2.inRange(hsv, lower_green, upper_green)<br>    mask_red = cv2.inRange(hsv, lower_red, upper_red)<br><br>    <span class="hljs-comment"># 3.将所有的mask相加，就可以同时显示了</span><br>    mask = mask_blue + mask_green + mask_red<br><br>    <span class="hljs-comment"># 4.保留原图中的三种颜色部分</span><br>    res = cv2.bitwise_and(frame, frame, mask=mask)<br><br>    cv2.imshow(<span class="hljs-string">'frame'</span>, frame)<br>    cv2.imshow(<span class="hljs-string">'mask'</span>, mask)<br>    cv2.imshow(<span class="hljs-string">'res'</span>, res)<br><br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">1</span>) == ord(<span class="hljs-string">'q'</span>):<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><ul><li><a href="https://docs.opencv.org/4.0.0/d8/d01/group__imgproc__color__conversions.html#ga397ae87e1288a81d2363b61574eb8cab" target="_blank" rel="noopener">cv2.cvtColor()</a></li><li><a href="https://docs.opencv.org/4.0.0/d2/de8/group__core__array.html#ga48af0ab51e36436c5d04340e036ce981" target="_blank" rel="noopener">cv2.inRange()</a></li><li><a href="https://docs.opencv.org/4.0.0/d2/de8/group__core__array.html#ga60b4d04b251ba5eb1392c34425497e14" target="_blank" rel="noopener">cv2.bitwise_and()</a></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_colorspaces/py_colorspaces.html" target="_blank" rel="noopener">Changing Colorspaces</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> HSV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程4：图像基本操作</title>
      <link href="/2019/08/13/Python-OpenCV%E6%95%99%E7%A8%8B4%EF%BC%9A%E5%9B%BE%E5%83%8F%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/08/13/Python-OpenCV%E6%95%99%E7%A8%8B4%EF%BC%9A%E5%9B%BE%E5%83%8F%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>学习<strong>获取和修改像素点的值</strong>，<strong>ROI感兴趣区域</strong>，<strong>通道分离合并</strong>等基本操作。</p><p>目标：</p><ul><li>访问和修改图片像素点的值</li><li>获取图片的宽、高、通道数等属性</li><li>了解感兴趣区域ROI</li><li>分离和合并图像通道</li></ul><p>小结：</p><ul><li><code>img[y,x]</code>获取/设置像素点值，<code>img.shape</code>：图片的形状（行数、列数、通道数）,<code>img.dtype</code>：图像的数据类型。</li><li><code>img[y1:y2,x1:x2]</code>进行ROI截取，<code>cv2.split()/cv2.merge()</code>通道分割/合并。更推荐的获取单通道方式：<code>b = img[:, :, 0]</code>。</li></ul><a id="more"></a><h2 id="获取和修改像素点值"><a href="#获取和修改像素点值" class="headerlink" title="获取和修改像素点值"></a>获取和修改像素点值</h2><p>先读取一张图片，通过行列的坐标来获取某像素点的值。</p><p>对于彩色图，结果是B, G, R三个值的列表。</p><p>对于灰度图或单通道，只有一个值。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br>img = cv2.imread(<span class="hljs-string">'lena.jpg'</span>)<br><br><span class="hljs-comment"># 获取像素的值</span><br>px = img[<span class="hljs-number">100</span>, <span class="hljs-number">90</span>]<span class="hljs-comment"># 行对应y，列对应x，所以其实是img[y, x]</span><br>print(px)  <span class="hljs-comment"># [103 98 197]</span><br><br><span class="hljs-comment"># 只获取蓝色blue通道的值</span><br>px_blue = img[<span class="hljs-number">100</span>, <span class="hljs-number">90</span>, <span class="hljs-number">0</span>]<br>print(px_blue)  <span class="hljs-comment"># 103</span><br></code></pre></td></tr></table></figure><p>修改像素的值也是同样的方式：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">img[<span class="hljs-number">100</span>, <span class="hljs-number">90</span>] = [<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>]<br>print(img[<span class="hljs-number">100</span>, <span class="hljs-number">90</span>])  <span class="hljs-comment"># [255 255 255]</span><br></code></pre></td></tr></table></figure><blockquote><p>经验之谈：还有一种性能更好的方式，获取：<code>img.item(100,100,0)</code>，修改：<code>img.itemset((100,100,0),255)</code>，但这种方式只能B,G,R逐一进行。</p></blockquote><p><strong>注意：这步操作只是内存中的img像素点值变了，因为没有保存，所以原图并没有更改。</strong></p><h2 id="图片属性"><a href="#图片属性" class="headerlink" title="图片属性"></a>图片属性</h2><p><code>img.shape</code>获取图像的形状，图片是彩色的话，返回一个包含<strong>行数（高度）、列数（宽度）和通道数</strong>的元组，灰度图只返回行数和列数：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">print(img.shape)  <span class="hljs-comment"># (263, 247, 3)</span><br><span class="hljs-comment"># 形状中包括行数、列数和通道数</span><br>height, width, channels = img.shape<br><span class="hljs-comment"># img是灰度图的话：height, width = img.shape</span><br></code></pre></td></tr></table></figure><p><code>img.size</code>获取图像总像素：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">print(img.size)  <span class="hljs-comment"># 263*247*3=194883</span><br></code></pre></td></tr></table></figure><p><code>img.dtype</code>获取图像数据类型：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">print(img.dtype)  <span class="hljs-comment"># uint8</span><br></code></pre></td></tr></table></figure><blockquote><p>经验之谈：多数错误是因为数据类型不对导致的，所以健壮的代码应该对这个属性加以判断。</p></blockquote><h2 id="ROI"><a href="#ROI" class="headerlink" title="ROI"></a>ROI</h2><p><a href="https://baike.baidu.com/item/ROI/1125333#viewPageContent" target="_blank" rel="noopener">ROI</a>：Region of Interest，感兴趣区域。</p><p>例如：我们要检测眼睛，因为眼睛肯定在脸上，所以我们感兴趣的只有脸这部分，其他都不care，所以可以单独把脸截取出来，这样就可以大大节省计算量，提高运行速度。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_lena_face_roi_crop.jpg"></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ROI截取</span><br>face = img[<span class="hljs-number">100</span>:<span class="hljs-number">200</span>, <span class="hljs-number">115</span>:<span class="hljs-number">188</span>]<br>cv2.imshow(<span class="hljs-string">'face'</span>, face)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h2 id="通道分割与合并"><a href="#通道分割与合并" class="headerlink" title="通道分割与合并"></a>通道分割与合并</h2><p>彩色图的BGR三个通道是可以分开单独访问的，也可以将单独的三个通道合并成一副图像。分别使用<code>cv2.split()</code>和<code>cv2.merge()</code>：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 通道分割与合并</span><br>b, g, r = cv2.split(img)<br>img = cv2.merge((b, g, r))<br></code></pre></td></tr></table></figure><p><code>split()</code>函数比较耗时，<strong>更高效的方式是用numpy中的索引</strong>，如提取B通道：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">b = img[:, :, <span class="hljs-number">0</span>]<br>cv2.imshow(<span class="hljs-string">'blue'</span>, b)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>打开lena.jpg，将帽子部分（高：25~120，宽：50~220）的红色通道截取出来并显示。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br>img = cv2.imread(<span class="hljs-string">'lena.jpg'</span>)<br><br><span class="hljs-comment"># 帽子ROI的红色通道</span><br>hat_r = img[<span class="hljs-number">25</span>:<span class="hljs-number">120</span>, <span class="hljs-number">50</span>:<span class="hljs-number">220</span>, <span class="hljs-number">2</span>]<br>cv2.imshow(<span class="hljs-string">'hat'</span>, hat_r)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><ul><li><a href="https://docs.opencv.org/4.0.0/d2/de8/group__core__array.html#ga0547c7fed86152d7e9d0096029c8518a" target="_blank" rel="noopener">cv2.split()</a></li><li><a href="https://docs.opencv.org/4.0.0/d2/de8/group__core__array.html#ga7d7b4d6c6ee504b30a20b1680029c7b4" target="_blank" rel="noopener">cv2.merge()</a></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_core/py_basic_ops/py_basic_ops.html#basic-ops" target="_blank" rel="noopener">Basic Operations on Images</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> ROI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程番外篇3：滑动条</title>
      <link href="/2019/08/13/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%873%EF%BC%9A%E6%BB%91%E5%8A%A8%E6%9D%A1/"/>
      <url>/2019/08/13/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%873%EF%BC%9A%E6%BB%91%E5%8A%A8%E6%9D%A1/</url>
      
        <content type="html"><![CDATA[<p>学习使用滑动条动态调整参数。</p><p>使用方式：</p><ul><li><code>cv2.createTrackbar(&#39;R&#39;, &#39;image&#39;, 0, 255, nothing)</code>：创建滑动条</li><li><code>r = cv2.getTrackbarPos(&#39;R&#39;, &#39;image&#39;)</code>：得到滑块位置</li><li>另外在回调函数中也可以获取滑块位置</li></ul><a id="more"></a><h2 id="滑动条的使用"><a href="#滑动条的使用" class="headerlink" title="滑动条的使用"></a>滑动条的使用</h2><p>首先我们需要创建一个滑动条，如<code>cv2.createTrackbar(&#39;R&#39;,&#39;image&#39;,0,255,call_back)</code>，其中</p><ul><li>参数1：滑动条的名称</li><li>参数2：所在窗口的名称</li><li>参数3：当前的值</li><li>参数4：最大值</li><li>参数5：回调函数名称，回调函数默认有一个表示当前值的参数</li></ul><p>创建好之后，可以在回调函数中获取滑动条的值。</p><p>也可以用：<code>cv2.getTrackbarPos()</code>得到，其中，参数1是滑动条的名称，参数2是窗口的名称。</p><h2 id="实例：RGB调色板"><a href="#实例：RGB调色板" class="headerlink" title="实例：RGB调色板"></a>实例：RGB调色板</h2><p>下面我们实现一个RGB的调色板，理解下滑动条的用法：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nothing</span><span class="hljs-params">(x)</span>:</span><br>    <span class="hljs-string">"""<br>    ### 回调函数,x表示滑块的位置,输出x<br>    """</span><br>    print(x)<br><br><br><span class="hljs-comment"># 创建一副300×512的纯黑色图</span><br>img = np.zeros((<span class="hljs-number">300</span>, <span class="hljs-number">512</span>, <span class="hljs-number">3</span>), np.uint8)<br>cv2.namedWindow(<span class="hljs-string">'image'</span>)<br><br><span class="hljs-comment"># 创建RGB三个滑动条</span><br>cv2.createTrackbar(<span class="hljs-string">'R'</span>, <span class="hljs-string">'image'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, nothing)<br>cv2.createTrackbar(<span class="hljs-string">'G'</span>, <span class="hljs-string">'image'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, nothing)<br>cv2.createTrackbar(<span class="hljs-string">'B'</span>, <span class="hljs-string">'image'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, nothing)<br><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">True</span>):<br>    cv2.imshow(<span class="hljs-string">'image'</span>, img)<br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">1</span>) == ord(<span class="hljs-string">'q'</span>):<br>        <span class="hljs-keyword">break</span><br><br>    <span class="hljs-comment"># 获取滑块的值</span><br>    r = cv2.getTrackbarPos(<span class="hljs-string">'R'</span>, <span class="hljs-string">'image'</span>)<br>    g = cv2.getTrackbarPos(<span class="hljs-string">'G'</span>, <span class="hljs-string">'image'</span>)<br>    b = cv2.getTrackbarPos(<span class="hljs-string">'B'</span>, <span class="hljs-string">'image'</span>)<br>    <span class="hljs-comment"># 设定img的颜色</span><br>    img[:] = [b, g, r]<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/%E8%B0%83%E8%89%B2%E6%9D%BF.png" width="70%"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><ul><li><a href="https://docs.opencv.org/4.0.0/d7/dfc/group__highgui.html#gaf78d2155d30b728fc413803745b67a9b" target="_blank" rel="noopener">cv2.createTrackbar()</a></li><li><a href="https://docs.opencv.org/4.0.0/d7/dfc/group__highgui.html#ga122632e9e91b9ec06943472c55d9cda8" target="_blank" rel="noopener">cv2.getTrackbarPos()</a></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_trackbar/py_trackbar.html" target="_blank" rel="noopener">Trackbar as the Color Palette</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程3：打开摄像头</title>
      <link href="/2019/08/13/Python-OpenCV%E6%95%99%E7%A8%8B3%EF%BC%9A%E6%89%93%E5%BC%80%E6%91%84%E5%83%8F%E5%A4%B4/"/>
      <url>/2019/08/13/Python-OpenCV%E6%95%99%E7%A8%8B3%EF%BC%9A%E6%89%93%E5%BC%80%E6%91%84%E5%83%8F%E5%A4%B4/</url>
      
        <content type="html"><![CDATA[<p>学习打开摄像头捕获照片、播放本地视频、录制视频等。</p><p>目标：</p><ul><li>打开摄像头并捕获照片</li><li>播放本地视频，录制视频</li><li>OpenCV函数：<code>cv2.VideoCapture()</code>、<code>cv2.VideoWriter()</code></li></ul><a id="more"></a><h2 id="打开摄像头"><a href="#打开摄像头" class="headerlink" title="打开摄像头"></a>打开摄像头</h2><p>要使用摄像头，需要使用<code>cv2.VideoCapture(0)</code>创建VideoCapture对象，参数0指的是摄像头的编号，如果你电脑上有两个摄像头的话，访问第2个摄像头就可以传入1，依此类推。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 打开摄像头并灰度化显示</span><br><span class="hljs-keyword">import</span> cv2<br><br>capture = cv2.VideoCapture(<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 获取捕获的分辨率</span><br><span class="hljs-comment"># propId可以直接写数字，也可以用OpenCV的符号表示</span><br>width, height = capture.get(<span class="hljs-number">3</span>), capture.get(<span class="hljs-number">4</span>)<br>print(width, height)<br><br><span class="hljs-comment"># 以原分辨率的一倍来捕获</span><br>capture.set(cv2.CAP_PROP_FRAME_WIDTH, width * <span class="hljs-number">5</span>)<br>capture.set(cv2.CAP_PROP_FRAME_HEIGHT, height * <span class="hljs-number">2</span>)<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment"># 获取一帧</span><br>    <span class="hljs-comment"># ret(return value):布尔值，表示当前这一帧是否获取正确</span><br>    ret, frame = capture.read()<br>    <span class="hljs-comment"># cv2.cvtColor()用来转换颜色，这里将这帧彩色图转化为灰度图</span><br>    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)<br><br>    cv2.imshow(<span class="hljs-string">'frame'</span>, gray)<br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">1</span>) == ord(<span class="hljs-string">'q'</span>):<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><blockquote><p>经验之谈：某些摄像头设定分辨率等参数时会无效，因为它有固定的分辨率大小支持，一般可在摄像头的资料页中找到。</p></blockquote><h2 id="播放本地视频"><a href="#播放本地视频" class="headerlink" title="播放本地视频"></a>播放本地视频</h2><p>跟打开摄像头一样，如果把摄像头的编号换成视频的路径就可以播放本地视频了。回想一下<code>cv2.waitKey()</code>，它的参数表示暂停时间，所以这个值越大，视频播放速度越慢，反之，播放速度越快，通常设置为25或30</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br><span class="hljs-comment"># 播放本地视频</span><br>capture = cv2.VideoCapture(<span class="hljs-string">'demo_video.mp4'</span>)<br><br><span class="hljs-keyword">while</span> capture.isOpened():<br>    ret, frame = capture.read()<br>    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)<br><br>    cv2.imshow(<span class="hljs-string">'frame'</span>, gray)<br>    <span class="hljs-comment"># cv2.waitKey(),参数表示暂停时间,值越大,播放速度越慢,一般设为25或30</span><br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">30</span>) == ord(<span class="hljs-string">'q'</span>):<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h2 id="录制视频"><a href="#录制视频" class="headerlink" title="录制视频"></a>录制视频</h2><p>之前我们保存图片用的是<code>cv2.imwrite()</code>，要保存视频，我们需要创建一个<code>VideoWriter</code>的对象，需要给它传入四个参数：</p><ul><li>输出的文件名，如<strong>output.avi</strong></li><li>编码方式<a href="https://baike.baidu.com/item/fourcc/6168470?fr=aladdin" target="_blank" rel="noopener">FourCC</a>码</li><li>帧率<a href="https://baike.baidu.com/item/FPS/3227416" target="_blank" rel="noopener">FPS</a></li><li>要保存的分辨率大小</li></ul><p>FourCC是用来指定视频编码方式的四字节码，所有的编码可参考<a href="http://www.fourcc.org/codecs.php" target="_blank" rel="noopener">Video Codecs</a>。如MJPG编码可以这样写： <code>cv2.VideoWriter_fourcc(*&#39;MJPG&#39;)</code>或<code>cv2.VideoWriter_fourcc(&#39;M&#39;,&#39;J&#39;,&#39;P&#39;,&#39;G&#39;)</code></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br>capture = cv2.VideoCapture(<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 定义编码方式并创建VideoWriter对象</span><br>fourcc = cv2.VideoWriter_fourcc(*<span class="hljs-string">'MJPG'</span>)<br>outfile = cv2.VideoWriter(<span class="hljs-string">'output.avi'</span>, fourcc, <span class="hljs-number">25.</span>, (<span class="hljs-number">640</span>, <span class="hljs-number">480</span>))<br><br><span class="hljs-keyword">while</span> capture.isOpened():<br>    ret, frame = capture.read()<br><br>    <span class="hljs-keyword">if</span> ret:<br>        <span class="hljs-comment"># 写入文件</span><br>        outfile.write(frame)<br><br>        cv2.imshow(<span class="hljs-string">'frame'</span>, frame)<br>        <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">1</span>) == ord(<span class="hljs-string">'q'</span>):<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>实现一个可以拖动滑块播放视频的功能。（提示：需要用到 <code>cv2.CAP_PROP_FRAME_COUNT</code>和<code>cv2.CAP_PROP_POS_FRAMES</code>两个属性）</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">track_back</span><span class="hljs-params">(x)</span>:</span><br>    <span class="hljs-string">'''<br>    ### 回调函数，x表示滑块的位置<br>    '''</span><br>    <span class="hljs-comment"># 更改视频的帧位置</span><br>    capture.set(cv2.CAP_PROP_POS_FRAMES, x)<br><br><br>cv2.namedWindow(<span class="hljs-string">'window'</span>)<br><br>capture = cv2.VideoCapture(<span class="hljs-string">'demo_video.mp4'</span>)<br><span class="hljs-comment"># 获取视频总共多少帧</span><br>frames = capture.get(cv2.CAP_PROP_FRAME_COUNT)<br><span class="hljs-comment"># 创建滑动条</span><br>cv2.createTrackbar(<span class="hljs-string">'process'</span>, <span class="hljs-string">'window'</span>, <span class="hljs-number">1</span>, int(frames), track_back)<br><br><span class="hljs-keyword">while</span> (capture.isOpened()):<br>    ret, frame = capture.read()<br><br>    cv2.imshow(<span class="hljs-string">'window'</span>, frame)<br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">30</span>) == ord(<span class="hljs-string">'q'</span>):<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><ul><li><a href="https://docs.opencv.org/4.0.0/d8/dfe/classcv_1_1VideoCapture.html" target="_blank" rel="noopener">VideoCapture Object</a></li><li><a href="https://docs.opencv.org/4.0.0/dd/d9e/classcv_1_1VideoWriter.html" target="_blank" rel="noopener">VideoWriter Object</a></li><li><a href="https://docs.opencv.org/4.0.0/d8/d01/group__imgproc__color__conversions.html#ga397ae87e1288a81d2363b61574eb8cab" target="_blank" rel="noopener">cv2.cvtColor()</a></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="http://www.fourcc.org/codecs.php" target="_blank" rel="noopener">Video Codecs by FOURCC</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_video_display/py_video_display.html" target="_blank" rel="noopener">Getting Started with Videos</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python字符串切片(slice)</title>
      <link href="/2019/08/13/Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E7%89%87-slice/"/>
      <url>/2019/08/13/Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E7%89%87-slice/</url>
      
        <content type="html"><![CDATA[<p>切片操作（slice）可以从一个字符串中获取子字符串（字符串的一部分）。我们使用<strong>一对方括号、起始偏移量start、终止偏移量end 以及可选的步长step 来定义一个分片</strong>。</p><p>格式： <code>[start:end:step]</code></p><ul><li><code>[:]</code> 提取从开头（默认位置0）到结尾（默认位置-1）的整个字符串</li><li><code>[start:]</code> 从start 提取到结尾</li><li><code>[:end]</code> 从开头提取到end - 1</li><li><code>[start:end]</code> 从start 提取到end - 1</li><li><code>[start:end:step]</code> 从start 提取到end - 1，每step 个字符提取一个</li><li>左侧第一个字符的位置偏移量为0，右侧最后一个字符的位置偏移量为-1</li></ul><a id="more"></a><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="提取最后N个字符"><a href="#提取最后N个字符" class="headerlink" title="提取最后N个字符"></a>提取最后N个字符</h3><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>letter = <span class="hljs-string">'abcdefghijklmnopqrstuvwxyz'</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>letter[<span class="hljs-number">-3</span>:]<br><span class="hljs-string">'xyz'</span><br></code></pre></td></tr></table></figure><h3 id="从开头到结尾，step为N："><a href="#从开头到结尾，step为N：" class="headerlink" title="从开头到结尾，step为N："></a>从开头到结尾，step为N：</h3><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>letter[::<span class="hljs-number">5</span>]<br><span class="hljs-string">'afkpuz'</span><br></code></pre></td></tr></table></figure><h3 id="将字符串倒转-reverse-，-通过设置步长为负数："><a href="#将字符串倒转-reverse-，-通过设置步长为负数：" class="headerlink" title="将字符串倒转(reverse)， 通过设置步长为负数："></a>将字符串倒转(reverse)， 通过设置步长为负数：</h3><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>letter[::<span class="hljs-number">-1</span>]<br><span class="hljs-string">'zyxwvutsrqponmlkjihgfedcba'</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程番外篇2：无损保存和Matplotlib使用</title>
      <link href="/2019/08/13/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%872%EF%BC%9A%E6%97%A0%E6%8D%9F%E4%BF%9D%E5%AD%98%E5%92%8CMatplotlib%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/08/13/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%872%EF%BC%9A%E6%97%A0%E6%8D%9F%E4%BF%9D%E5%AD%98%E5%92%8CMatplotlib%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>了解常用图片格式和OpenCV高质量保存图片的方式，学习如何使用Matplotlib显示OpenCV图像。</p><a id="more"></a><h2 id="无损保存"><a href="#无损保存" class="headerlink" title="无损保存"></a>无损保存</h2><p>事实上，我们日常看到的大部分图片都是压缩过的，那么都有哪些常见的图片格式呢？</p><h3 id="图片格式"><a href="#图片格式" class="headerlink" title="图片格式"></a>图片格式</h3><h4 id="格式分类"><a href="#格式分类" class="headerlink" title="格式分类"></a>格式分类</h4><ul><li>无压缩。无压缩的图片格式不对图片数据进行压缩处理，能准确地呈现原图片。BMP格式就是其中之一。</li><li>无损压缩。压缩算法对图片的所有的数据进行编码压缩，能在保证图片的质量的同时降低图片的尺寸。png是其中的代表。</li><li>有损压缩。压缩算法不会对图片所有的数据进行编码压缩，而是在压缩的时候，去除了人眼无法识别的图片细节。因此有损压缩可以在同等图片质量的情况下大幅降低图片的尺寸。其中的代表是jpg。</li></ul><h4 id="常见图片格式"><a href="#常见图片格式" class="headerlink" title="常见图片格式"></a>常见图片格式</h4><ul><li><strong>bmp：</strong>全称Bitmap，不压缩</li><li><strong>jpg：</strong>全称Joint Photographic Experts Group，有损压缩</li><li><strong>png：</strong>全称Portable Network Graphics，无损压缩</li></ul><p>简单来说，同一个文件保存成不同的格式后，<strong>文件大小上bmp肯定是最大的</strong>，而png和jpg，不同的压缩比结果会有所不同。可以用画图工具新建一副100×100的图像，分别保存成这三种格式来验证：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_high_save_mspaint_format.jpg"></p><h3 id="高质量保存"><a href="#高质量保存" class="headerlink" title="高质量保存"></a>高质量保存</h3><p>用<code>cv2.imwrite()</code>保存图片时，可以传入第三个参数（请参考<a href="https://docs.opencv.org/4.0.0/d4/da8/group__imgcodecs.html#gabbc7ef1aa2edfaa87772f1202d67e0ce" target="_blank" rel="noopener">接口文档</a>），用于控制保存质量：</p><ul><li><code>cv2.IMWRITE_JPEG_QUALITY</code>：jpg质量控制，取值0~100，值越大，质量越好，默认为95</li><li><code>cv2.IMWRITE_PNG_COMPRESSION</code>：png质量控制，取值0~9，值越大，压缩比越高，默认为1</li></ul><p>还有诸如<code>CV_IMWRITE_WEBP_QUALITY</code>的参量，不常用，请参考：<a href="https://docs.opencv.org/4.0.0/d4/da8/group__imgcodecs.html#ga292d81be8d76901bff7988d18d2b42ac" target="_blank" rel="noopener">ImwriteFlags</a>。</p><p>举例来说，原图lena.jpg的分辨率是350×350，大小49.7KB。我们把它转成不同格式看下：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>new_img = cv2.imread(<span class="hljs-string">'lena.jpg'</span>)<br><span class="hljs-comment"># new_img = np.zeros((100,100,3)) # 新建一副纯黑色图</span><br><br><span class="hljs-comment"># bmp</span><br>cv2.imwrite(<span class="hljs-string">'img_bmp.bmp'</span>, new_img)  <span class="hljs-comment"># 文件大小：359KB</span><br><br><span class="hljs-comment"># jpg 100%质量</span><br>cv2.imwrite(<span class="hljs-string">'img_jpg100.jpg'</span>, new_img, [int(cv2.IMWRITE_JPEG_QUALITY), <span class="hljs-number">100</span>])  <span class="hljs-comment"># 文件大小：82.5KB</span><br><span class="hljs-comment"># jpg 默认95%质量</span><br>cv2.imwrite(<span class="hljs-string">'img_jpg95.jpg'</span>, new_img)  <span class="hljs-comment"># 文件大小：52.3KB</span><br><span class="hljs-comment"># jpg 20%质量</span><br>cv2.imwrite(<span class="hljs-string">'img_jpg20.jpg'</span>, new_img, [int(cv2.IMWRITE_JPEG_QUALITY), <span class="hljs-number">20</span>])  <span class="hljs-comment"># 文件大小：8.01KB</span><br><br><span class="hljs-comment"># png 默认1压缩比</span><br>cv2.imwrite(<span class="hljs-string">'img_png1.png'</span>, new_img)  <span class="hljs-comment"># 文件大小：240KB</span><br><span class="hljs-comment"># png 9压缩比</span><br>cv2.imwrite(<span class="hljs-string">'img_png9.png'</span>, new_img, [int(cv2.IMWRITE_PNG_COMPRESSION), <span class="hljs-number">9</span>])  <span class="hljs-comment"># 文件大小：207KB</span><br></code></pre></td></tr></table></figure><p>可以看到：</p><ul><li>bmp文件是最大的，没有任何压缩（1个像素点1byte，3通道的彩色图总大小：350×350×3/1024 ≈ 359 KB）</li><li>jpg/png本身就有压缩的，所以就算是100%的质量保存，体积也比bmp小很多</li><li>jpg的容量优势很明显，这也是它为什么如此流行的原因</li></ul><blockquote><p>思考：为什么原图49.7KB，保存成bmp或其他格式反而大了呢？</p><p>原因：这里需要明确的是保存新格式时，<strong>容量大小跟原图的容量没有直接关系，而是取决于原图的分辨率大小和原图本身的内容（压缩方式）</strong>，所以lena.jpg保存成不压缩的bmp格式时，容量大小就是固定的350×350×3/1024 ≈ 359 KB；另外，容量变大不代表画质提升噢，不然就逆天了~~~</p></blockquote><h2 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h2><p>Matplotlib是Python的一个很常用的绘图库。</p><h3 id="显示灰度图"><a href="#显示灰度图" class="headerlink" title="显示灰度图"></a>显示灰度图</h3><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>img = cv2.imread(<span class="hljs-string">'lena.jpg'</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 显示灰度图</span><br>plt.imshow(img, cmap=<span class="hljs-string">'gray'</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><h3 id="显示彩色图"><a href="#显示彩色图" class="headerlink" title="显示彩色图"></a>显示彩色图</h3><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>img = cv2.imread(<span class="hljs-string">'lena.jpg'</span>)<br><br>img2 = img[:, :, ::<span class="hljs-number">-1</span>]<br><span class="hljs-comment"># 或使用</span><br><span class="hljs-comment"># img2 = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</span><br><span class="hljs-comment"># 显示不正确的图</span><br>plt.subplot(<span class="hljs-number">121</span>)<br>plt.imshow(img) <br><br><span class="hljs-comment"># 显示正确的图</span><br>plt.subplot(<span class="hljs-number">122</span>)<br>plt.xticks([]), plt.yticks([]) <span class="hljs-comment"># 隐藏x和y轴</span><br>plt.imshow(img2)<br><br>plt.show()<br></code></pre></td></tr></table></figure><blockquote><p><code>img[:,:,0]</code>表示图片的蓝色通道，<code>img[:,:,::-1]</code>就表示BGR翻转，变成RGB，说明一下：</p><p>熟悉Python的童鞋应该知道，对一个字符串s翻转可以这样写：<code>s[::-1]</code>，<strong>abc</strong>变成<strong>cba</strong>，-1表示逆序。图片是二维的，所以完整地复制一副图像就是：</p><p><code>img2 = img[:,:]  # 写全就是：img2 = img[0:height,0:width]</code></p><p>而图片是有三个通道，相当于一个长度为3的字符串，所以通道翻转与图片复制组合起来便是<code>img[:,:,::-1]</code>。</p></blockquote><h3 id="加载和保存图片"><a href="#加载和保存图片" class="headerlink" title="加载和保存图片"></a>加载和保存图片</h3><p>不使用OpenCV，Matplotlib也可以加载和保存图片：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 加载和保存图片</span><br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> matplotlib.image <span class="hljs-keyword">as</span> pli<br><br>img = pli.imread(<span class="hljs-string">'lena.jpg'</span>)<br>plt.imshow(img)<br><br><span class="hljs-comment"># 保存图片，需放在show()函数之前</span><br>plt.savefig(<span class="hljs-string">'lena2.jpg'</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><ul><li><a href="https://docs.opencv.org/4.0.0/d4/da8/group__imgcodecs.html#gabbc7ef1aa2edfaa87772f1202d67e0ce" target="_blank" rel="noopener">cv2.imwrite()</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/da8/group__imgcodecs.html#ga292d81be8d76901bff7988d18d2b42ac" target="_blank" rel="noopener">ImwriteFlags</a></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="https://segmentfault.com/a/1190000013589397" target="_blank" rel="noopener">聊一聊几种常用web图片格式</a></li><li><a href="http://ex2tron.wang/opencv-python-extra-high-quality-save-and-using-matplotlib/www.matplotlib.org/" target="_blank" rel="noopener">Matplotlib官网</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Matplotlib </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程2：基本元素-图片</title>
      <link href="/2019/08/13/Python-OpenCV%E6%95%99%E7%A8%8B2%EF%BC%9A%E5%9F%BA%E6%9C%AC%E5%85%83%E7%B4%A0-%E5%9B%BE%E7%89%87/"/>
      <url>/2019/08/13/Python-OpenCV%E6%95%99%E7%A8%8B2%EF%BC%9A%E5%9F%BA%E6%9C%AC%E5%85%83%E7%B4%A0-%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p>学习如何加载图片，显示并保存图片。</p><p>目标：</p><ul><li>加载图片，显示图片，保存图片</li><li>OpenCV函数：<code>cv2.imread()</code>加载图片、<code>cv2.imshow()</code>显示图片、<code>cv2.imwrite()</code>保存图片</li></ul><a id="more"></a><p>大部分人可能都知道电脑上的彩色图是以RGB(红-绿-蓝，Red-Green-Blue)颜色模式显示的，但OpenCV中彩色图是以<strong>B-G-R</strong>通道顺序存储的，灰度图只有一个通道。</p><p>图像坐标的起始点是在左上角，所以行对应的是y，列对应的是x：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/%E5%9F%BA%E6%9C%AC%E5%85%83%E7%B4%A0%E5%9B%BE%E7%89%87.jpg"></p><h2 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h2><p>使用<code>cv2.imread()</code>读取一张图片：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br><span class="hljs-comment"># 灰度图加载一张彩色图</span><br>img = cv2.imread(<span class="hljs-string">'lena.jpg'</span>, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><ul><li>参数1：图片的文件名<ul><li>如果图片放在当前文件夹下，直接写文件名就行了，如’lena.jpg’</li><li>否则需要给出绝对路径，如’D:\OpenCVSamples\lena.jpg’</li></ul></li><li>参数2：读入方式，省略即采用默认值<ul><li><code>cv2.IMREAD_COLOR</code>：彩色图，默认值(1)</li><li><code>cv2.IMREAD_GRAYSCALE</code>：灰度图(0)</li><li><code>cv2.IMREAD_UNCHANGED</code>：包含透明通道的彩色图(-1)</li></ul></li></ul><blockquote><p>经验之谈：路径中不能有中文噢，并且没有加载成功的话是不会报错的，<code>print(img)</code>的结果为None，后面处理才会报错，算是个小坑。</p></blockquote><h2 id="显示图片"><a href="#显示图片" class="headerlink" title="显示图片"></a>显示图片</h2><p>使用<code>cv2.imshow()</code>显示图片，窗口会自适应图片的大小：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 显示图片</span><br>cv2.imshow(<span class="hljs-string">'lena'</span>, img)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><code>cv2.waitKey()</code>是让程序暂停的意思，参数是等待时间(毫秒ms)。</p><p>时间一到，会继续执行接下来的程序，传入0的话表示一直等待。</p><p>等待期间可以获取用户的按键输入：<code>k=cv2.waitKey(0)</code></p><p>我们也可以先用<code>cv2.namedWindow()</code>创建一个窗口，之后再显示图片：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 先定义窗口，后显示图片</span><br>cv2.namedWindow(<span class="hljs-string">'lena2'</span>, cv2.WINDOW_NORMAL)<br>cv2.imshow(<span class="hljs-string">'lena2'</span>, img)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>参数1依旧是窗口的名字，参数2默认是<code>cv2.WINDOW_AUTOSIZE</code>，表示窗口大小自适应图片，也可以设置为<code>cv2.WINDOW_NORMAL</code>，表示窗口大小可调整。图片比较大的时候，可以考虑用后者。</p><h2 id="保存图片"><a href="#保存图片" class="headerlink" title="保存图片"></a>保存图片</h2><p>使用<code>cv2.imwrite()</code>保存图片，参数1是包含后缀名的文件名：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 保存图片</span><br>cv2.imwrite(<span class="hljs-string">'lena_gray.jpg'</span>, img)<br></code></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br><span class="hljs-comment"># 1.灰度图加载一张彩色图</span><br>img = cv2.imread(<span class="hljs-string">'lena.jpg'</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 2.显示图片</span><br>cv2.imshow(<span class="hljs-string">'lena'</span>, img)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 先定义窗口，后显示图片</span><br>cv2.namedWindow(<span class="hljs-string">'lena2'</span>, cv2.WINDOW_NORMAL)<br>cv2.imshow(<span class="hljs-string">'lena2'</span>, img)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 3.保存图片</span><br>cv2.imwrite(<span class="hljs-string">'lena_gray.jpg'</span>, img)<br></code></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>打开<strong>lena.jpg</strong>并显示，如果按下<strong>s</strong>，就保存图片为<strong>lena_save.bmp</strong>，否则就结束程序。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br>img = cv2.imread(<span class="hljs-string">'lena.jpg'</span>)<br>cv2.imshow(<span class="hljs-string">'lena'</span>, img)<br><br>k = cv2.waitKey(<span class="hljs-number">0</span>)<br><span class="hljs-comment"># ord()用来获取某个字符的编码</span><br><span class="hljs-keyword">if</span> k == ord(<span class="hljs-string">'s'</span>):<br>    cv2.imwrite(<span class="hljs-string">'lena_save.bmp'</span>, img)<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><ul><li><a href="https://docs.opencv.org/4.0.0/d3/d63/classcv_1_1Mat.html" target="_blank" rel="noopener">Mat Object</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/da8/group__imgcodecs.html#ga288b8b3da0892bd651fce07b3bbd3a56" target="_blank" rel="noopener">cv2.imread()</a></li><li><a href="https://docs.opencv.org/4.0.0/d7/dfc/group__highgui.html#ga453d42fe4cb60e5723281a89973ee563" target="_blank" rel="noopener">cv2.imshow()</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/da8/group__imgcodecs.html#gabbc7ef1aa2edfaa87772f1202d67e0ce" target="_blank" rel="noopener">cv2.imwrite()</a></li><li><a href="https://docs.opencv.org/4.0.0/d7/dfc/group__highgui.html#ga5afdf8410934fd099df85c75b2e0888b" target="_blank" rel="noopener">cv.namedWindow()</a></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_image_display/py_image_display.html" target="_blank" rel="noopener">Getting Started with Images</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程番外篇1：代码性能优化</title>
      <link href="/2019/08/13/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%871%EF%BC%9A%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2019/08/13/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%871%EF%BC%9A%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>完成一项任务很重要，高效地完成更重要。图像处理是对矩阵的操作，数据量巨大。如果代码写的不好，性能差距将很大，所以这节我们来了解下如何评估和提升代码性能。</p><a id="more"></a><h2 id="评估代码运行时间"><a href="#评估代码运行时间" class="headerlink" title="评估代码运行时间"></a>评估代码运行时间</h2><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br>start = cv2.getTickCount()<br><span class="hljs-comment"># 这里写测试代码...</span><br>end = cv2.getTickCount()<br>print((end - start) / cv2.getTickFrequency())<br></code></pre></td></tr></table></figure><p>这段代码就是用来测量程序运行时间的（单位：s），其中<code>cv2.getTickCount()</code>函数得到电脑启动以来的时钟周期数，<code>cv2.getTickFrequency()</code>返回你电脑的主频，前后相减再除以主频就是你代码的运行时间（这样解释并不完全准确，但能理解就行）。另外，也可以用Python中的time模块计时：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br>start = time.clock()<br><span class="hljs-comment"># 这里写测试代码...</span><br>end = time.clock()<br>print(end - start)<br></code></pre></td></tr></table></figure><h2 id="优化原则"><a href="#优化原则" class="headerlink" title="优化原则"></a>优化原则</h2><p>数据元素少时用Python语法，数据元素多时用Numpy：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> time<br><br>x = <span class="hljs-number">10</span><br>z = np.uint8([<span class="hljs-number">10</span>])<br><br><span class="hljs-comment"># 尝试比较下面三句话各自的运行时间</span><br>s1 = time.clock()<br>y1 = x * x * x<br>e1 = time.clock()<br>print(e1 - s1)  <span class="hljs-comment"># 1.2000000000012001e-05</span><br><br>s2 = time.clock()<br>y2 = x ** <span class="hljs-number">3</span><br>e2 = time.clock()<br>print(e2 - s2)  <span class="hljs-comment"># 8.999999999925734e-06</span><br><br>s3 = time.clock()<br>y3 = z * z * z<br>e3 = time.clock()<br>print(e3 - s3)  <span class="hljs-comment"># 0.003105999999999942</span><br></code></pre></td></tr></table></figure><p>所以Numpy的运行速度并不一定比Python本身语法快，元素数量较少时，请用Python本身格式。</p><ul><li>尽量避免使用循环，尤其嵌套循环，因为极其慢！！！</li><li>优先使用OpenCV/Numpy中封装好的函数</li><li>尽量将数据向量化，变成Numpy的数据格式</li><li>尽量避免数组的复制操作</li></ul><h2 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h2><ul><li><a href="https://docs.opencv.org/4.0.0/db/de0/group__core__utils.html#gae73f58000611a1af25dd36d496bf4487" target="_blank" rel="noopener">cv2.getTickCount()</a></li><li><a href="https://docs.opencv.org/4.0.0/db/de0/group__core__utils.html#ga705441a9ef01f47acdc55d87fbe5090c" target="_blank" rel="noopener">cv2.getTickFrequency()</a></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://wiki.python.org/moin/PythonSpeed/PerformanceTips" target="_blank" rel="noopener">Python Optimization Techniques</a></li><li><a href="http://pynash.org/2013/03/06/timing-and-profiling/" target="_blank" rel="noopener">Timing and Profiling in IPython</a></li><li><a href="http://www.scipy-lectures.org/advanced/advanced_numpy/index.html#advanced-numpy" target="_blank" rel="noopener">Advanced Numpy</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程1：简介与安装</title>
      <link href="/2019/08/13/Python+OpenCV%E6%95%99%E7%A8%8B1%EF%BC%9A%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85/"/>
      <url>/2019/08/13/Python+OpenCV%E6%95%99%E7%A8%8B1%EF%BC%9A%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>相信大部分人知道的OpenCV都是用C++来开发的，那为什么我推荐使用Python呢？</p><a id="more"></a><h2 id="Python照样快！"><a href="#Python照样快！" class="headerlink" title="Python照样快！"></a>Python照样快！</h2><p>众所周知，虽然Python语法简洁，编写高效，但相比C/C++运行慢很多。然而Python还有个重要的特性：它是一门胶水语言！Python可以很容易地扩展C/C++。<strong>OpenCV-Python</strong>就是用Python包装了C++的实现，背后实际就是C++的代码在跑，所以代码的运行速度跟原生C/C++速度一样快。</p><p>我举两个简单的例子就一目了然了：一个是读入图片，另一个是调整图片的对比度和亮度：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_python_vs_cplus_speed.jpg"></p><p><strong>可以看到某些情况下Python的运行速度甚至好于C++，代码行数也直接少一半多！</strong>另外，图像是矩阵数据，OpenCV-Python原生支持<a href="https://baike.baidu.com/item/numpy" target="_blank" rel="noopener">Numpy</a>，相当于Python中的Matlab，为矩阵运算、科学计算提供了极大的便利性。</p><h2 id="人工智能浪潮"><a href="#人工智能浪潮" class="headerlink" title="人工智能浪潮"></a>人工智能浪潮</h2><p>近些年，人工智能相关技术的快速发展大家有目共睹，不必多说。在编程语言方面，更多人希望的是具备高效开发效率、跨平台、高度扩展性的语言，尤其是一些AI巨头优先推出支持Python语言的深度学习框架，如Facebook的<a href="https://pytorch.org/" target="_blank" rel="noopener">PyTorch</a>、Google的<a href="https://tensorflow.google.cn/" target="_blank" rel="noopener">Tensorflow</a>等，可以说Python是名副其实的“网红语言”了。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_ai_ml_dl2.jpg"></p><p>从<a href="https://www.tiobe.com/tiobe-index/" target="_blank" rel="noopener">TIOBE编程语言排行榜</a>也可以看到，Python发展迅猛，已经逼近C++的份额。这个排行榜每月更新，我就不截图了，编写时TOP5：Java/C/Python/C++/C#。</p><h2 id="人生苦短，我用Python"><a href="#人生苦短，我用Python" class="headerlink" title="人生苦短，我用Python"></a>人生苦短，我用Python</h2><ul><li>如果你搞科研用，果断放弃C++（Matlab？出门左拐）</li><li>如果你是快速原型开发，验证方案，果断放弃C++</li><li>如果你懒的配置OpenCV环境，果断放弃C++</li><li>如果你的程序是在支持Python的较高硬件环境下运行，果断放弃C++</li><li>如果你担心Python写不了界面，那是你的问题o_o ….</li><li>除非你的程序是MFC或已经用C++编写其他模块或是嵌入式设备，那就用C++吧</li></ul><p><strong>“人生苦短，我用Python！！！”</strong></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>要安装OpenCV，只需执行指令：<code>pip install opencv-python</code></p><p>安装完成后，输入：<code>import cv2</code>，如果运行没有报错说明一切正常。</p><p>如果要查看OpenCV的版本，可以：<code>print(cv2.__version__)</code></p><h2 id="网络资料"><a href="#网络资料" class="headerlink" title="网络资料"></a>网络资料</h2><ul><li><a href="https://docs.opencv.org/" target="_blank" rel="noopener"><strong>OpenCV Docs官方文档</strong></a></li><li><a href="https://github.com/opencv/opencv" target="_blank" rel="noopener">OpenCV 官方Github</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_tutorials.html" target="_blank" rel="noopener">官方英文教程：OpenCV-Python Tutorials</a></li><li><a href="http://www.learnopencv.com/" target="_blank" rel="noopener">LearnOpenCV</a>、<a href="https://github.com/spmallick/learnopencv" target="_blank" rel="noopener">LearnOpenCV Github</a></li><li><a href="https://docs.scipy.org/doc/numpy-dev/user/quickstart.html" target="_blank" rel="noopener">Numpy Quickstart Tutorial</a></li><li><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/tutorials.html" target="_blank" rel="noopener">OpenCV 中文教程</a></li></ul><h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><ul><li><a href="http://programmingcomputervision.com/" target="_blank" rel="noopener">Programming Computer Vision with Python</a>、<a href="https://www.amazon.cn/dp/B00L3Y3NEM/ref=sr_1_1?ie=UTF8&amp;qid=1543929834&amp;sr=8-1&amp;keywords=Python+计算机视觉" target="_blank" rel="noopener">中文书</a></li><li><a href="https://www.pyimagesearch.com/practical-python-opencv/" target="_blank" rel="noopener">https://www.pyimagesearch.com/practical-python-opencv/</a></li></ul><h2 id="名校视觉研究所-课程"><a href="#名校视觉研究所-课程" class="headerlink" title="名校视觉研究所/课程"></a>名校视觉研究所/课程</h2><ul><li><a href="http://graphics.cs.cmu.edu/" target="_blank" rel="noopener">卡内基梅隆大学</a></li><li><a href="https://www.cs.toronto.edu/~guerzhoy/320/" target="_blank" rel="noopener">多伦多大学</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k-近邻算法</title>
      <link href="/2019/08/13/k-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/"/>
      <url>/2019/08/13/k-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NearestNeighbor</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">train</span><span class="hljs-params">(self, X, y)</span>:</span><br>        <span class="hljs-string">"""X is N x D where each row is an example. Y is 1-dimension of sizee N"""</span><br>        self.Xtr = X<br>        self.ytr = y<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">predict</span><span class="hljs-params">(self, X)</span>:</span><br>        <span class="hljs-string">"""X is N x D where each row is an example we wish to predict label for"""</span><br>        num_test = X.shape[<span class="hljs-number">0</span>]<br>        <span class="hljs-comment"># lets make sure that the output type matches the input type</span><br>        Ypred = np.zeros(num_test, dtype=self.ytr.dtype)<br><br>        <span class="hljs-comment"># loop over all test rows</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(num_test):<br>            <span class="hljs-comment"># find the nearest training image to the i'th test image</span><br>            <span class="hljs-comment"># using the L1 distance(sum of absolute value differences)</span><br>            distances = np.sum(np.abs(self.Xtr - X[i, :]), axis=<span class="hljs-number">1</span>)<br>            min_index = np.argmin(distances)  <span class="hljs-comment"># get the index with smallest distance</span><br>            Ypred[i] = self.ytr[min_index]  <span class="hljs-comment"># predict the label of the nearest example</span><br><br>        <span class="hljs-keyword">return</span> Ypred<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
          <category> 监督学习 </category>
          
          <category> 分类算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> k-近邻算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解析库的使用</title>
      <link href="/2019/08/11/%E8%A7%A3%E6%9E%90%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/08/11/%E8%A7%A3%E6%9E%90%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>对于网页节点来说，它可以定义<code>id</code>，<code>class</code>或其他属性。节点之间还有层次关系，在网页中可以通过<strong>XPath</strong>或<strong>CSS选择器</strong>来定位一个或多个节点。</p><a id="more"></a><h2 id="XPath"><a href="#XPath" class="headerlink" title="XPath"></a>XPath</h2><p>XPath(XML Path Language，XML路径语言)，它是一门在XML文档中查找信息的语言。</p><p>它最初是用来搜寻XML文档的，但是它同样适用于HTML文档的搜索。</p><h3 id="XPath简介"><a href="#XPath简介" class="headerlink" title="XPath简介"></a>XPath简介</h3><p>XPath的选择功能十分强大，它提供了非常简洁明了的<strong>路径选择表达式</strong>。另外，它还提供100个内建函数，用于字符串、数值、时间的匹配以及节点、序列的处理等。<strong>几乎所有我们想要定位的节点，都可以用XPath来选择。</strong></p><p>XPath于1999年11月16日成为W3C的标准，它被设计为供XSLT、XPointer以及其他XML解析软件使用。</p><h3 id="XPath规则"><a href="#XPath规则" class="headerlink" title="XPath规则"></a>XPath规则</h3><div class="table-container"><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>nodename</td><td>选取此节点的所有子节点</td></tr><tr><td>/</td><td>从当前节点选取直接子节点</td></tr><tr><td>//</td><td>从当前节点选取子孙节点</td></tr><tr><td>.</td><td>选取当前节点</td></tr><tr><td>..</td><td>选取当前节点的父节点</td></tr><tr><td>@</td><td>选取属性</td></tr></tbody></table></div><p>举个例子：<code>//title[@lang=&#39;eng&#39;]</code></p><p>它代表选择所有名称为<strong>title</strong>，同时属性<strong>lang</strong>的值为<strong>eng</strong>的节点。</p><h3 id="实例引入"><a href="#实例引入" class="headerlink" title="实例引入"></a>实例引入</h3><p>通过实例来感受一下使用XPath对网页进行解析的过程。</p><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python">from lxml import etree  # 导入lxml库的etree模块<br><br># 申明一段HTML文本<br>text = '''<br>&lt;div&gt;<br>&lt;ul&gt;<br>&lt;li class="item-0"&gt;&lt;a href="link1.html"&gt;first item&lt;/a&gt;&lt;/li&gt;<br>&lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt;<br>&lt;li class="item-inactive"&gt;&lt;a href="link3.html"&gt;third item&lt;/a&gt;&lt;/li&gt;<br>&lt;li class="item-1"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt;<br>&lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt;<br>&lt;/ul&gt;<br>&lt;/div&gt;<br>'''<br><br># 调用HTML类进行初始化,这样就可以成功构造一个XPath解析对象<br>html = etree.HTML(text)<br># 通过调用tostring()方法可以输出修正后的HTML代码,但是结果是bytes类型<br>result = etree.tostring(html)   <br># 利用decode()方法可以将其转成str类型<br>print(result.decode('utf-8'))<br><br>***************************************************************<br><br>运行结果：<br>&lt;html&gt;&lt;body&gt;&lt;div&gt;<br>&lt;ul&gt;<br>&lt;li class="item-0"&gt;&lt;a href="link1.html"&gt;first item&lt;/a&gt;&lt;/li&gt;<br>&lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt;<br>&lt;li class="item-inactive"&gt;&lt;a href="link3.html"&gt;third item&lt;/a&gt;&lt;/li&gt;<br>&lt;li class="item-1"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt;<br>&lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt;<br>&lt;/ul&gt;<br>&lt;/div&gt;<br>&lt;/body&gt;&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>另外也可以直接读取文本文件进行解析，如下：</p><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python">from lxml import etree  # 导入lxml库的etree模块<br><br># 调用HTML类进行初始化,这样就可以成功构造一个XPath解析对象<br># test.html存放HTML代码<br>html = etree.parse('./test.html', etree.HTMLParser())<br># 通过调用tostring()方法可以输出修正后的HTML代码,但是结果是bytes类型<br>result = etree.tostring(html)<br># 利用decode()方法可以将其转成str类型<br>print(result.decode('utf-8'))<br><br>***************************************************************<br><br>运行结果：<br>&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"&gt;<br>&lt;html&gt;&lt;body&gt;&lt;div&gt;<br>&lt;ul&gt;<br>&lt;li class="item-0"&gt;&lt;a href="link1.html"&gt;first item&lt;/a&gt;&lt;/li&gt;<br>&lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt;<br>&lt;li class="item-inactive"&gt;&lt;a href="link3.html"&gt;third item&lt;/a&gt;&lt;/li&gt;<br>&lt;li class="item-1"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt;<br>&lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt;<br>&lt;/ul&gt;<br>&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>虽然输出多了一个DOCTYPE的声明，不过对解析无影响。</p><h3 id="所有结点"><a href="#所有结点" class="headerlink" title="所有结点"></a>所有结点</h3><p>我们一般会用<code>//</code>开头的XPath规则来选取所有符合要求的节点。</p><p>以上面的HTML文本为例，如果要选取所有节点，则可以这样实现：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree  <span class="hljs-comment"># 导入lxml库的etree模块</span><br><br><span class="hljs-comment"># 调用HTML类进行初始化,这样就可以成功构造一个XPath解析对象</span><br>html = etree.parse(<span class="hljs-string">'./test.html'</span>, etree.HTMLParser())<br><span class="hljs-comment"># 这里*代表匹配所有节点,即整个HTML文本中的所有节点都会被获取</span><br>result = html.xpath(<span class="hljs-string">'//*'</span>)<br>print(result)<br><br>***************************************************************<br><br>运行结果：<br>[&lt;Element html at <span class="hljs-number">0x1078e2b48</span>&gt;, &lt;Element body at <span class="hljs-number">0x1078e2c48</span>&gt;, &lt;Element div at <span class="hljs-number">0x1078e2c88</span>&gt;, &lt;Element ul at <span class="hljs-number">0x1078e2cc8</span>&gt;, &lt;Element li at <span class="hljs-number">0x1078e2d08</span>&gt;, &lt;Element a at <span class="hljs-number">0x1078e2d48</span>&gt;, &lt;Element li at <span class="hljs-number">0x1078e2d88</span>&gt;, &lt;Element a at <span class="hljs-number">0x1078e2dc8</span>&gt;, &lt;Element li at <span class="hljs-number">0x1078e2e08</span>&gt;, &lt;Element a at <span class="hljs-number">0x1078e2e48</span>&gt;, &lt;Element li at <span class="hljs-number">0x1078e2e88</span>&gt;, &lt;Element a at <span class="hljs-number">0x1078e2ec8</span>&gt;, &lt;Element li at <span class="hljs-number">0x1078e2f08</span>&gt;, &lt;Element a at <span class="hljs-number">0x1078e2f48</span>&gt;]<br></code></pre></td></tr></table></figure><p>可以看到运行结果是一个列表，每个元素是<strong>Element类型</strong>，其后跟了节点的名称，如html、body、div、ul、li、a等，所有节点都包含在列表中了。</p><p>当然，我们也可以通过匹配指定节点名称。如果想要获取所有li节点，可以做如下选择：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree  <span class="hljs-comment"># 导入lxml库的etree模块</span><br><br><span class="hljs-comment"># 调用HTML类进行初始化,这样就可以成功构造一个XPath解析对象</span><br>html = etree.parse(<span class="hljs-string">'./test.html'</span>, etree.HTMLParser())<br><span class="hljs-comment"># 这里使用"//li"选取所有li节点</span><br>result = html.xpath(<span class="hljs-string">'//li'</span>)<br>print(result)<br><span class="hljs-comment"># 如果要取出其中的一个对象，可以直接用中括号加索引，如[0]</span><br>print(result[<span class="hljs-number">0</span>])<br><br>***************************************************************<br><br>运行结果：<br>[&lt;Element li at <span class="hljs-number">0x1067c9c48</span>&gt;, &lt;Element li at <span class="hljs-number">0x1067c9c88</span>&gt;, &lt;Element li at <span class="hljs-number">0x1067c9cc8</span>&gt;, &lt;Element li at <span class="hljs-number">0x1067c9d08</span>&gt;, &lt;Element li at <span class="hljs-number">0x1067c9d48</span>&gt;]<br>&lt;Element li at <span class="hljs-number">0x1067c9c48</span>&gt;<br></code></pre></td></tr></table></figure><p>可以看到提取结果是一个列表形式，其中每个元素都是一个<strong>Element对象</strong>。</p><h3 id="子节点"><a href="#子节点" class="headerlink" title="子节点"></a>子节点</h3><p>我们通过<code>/</code>或<code>//</code>即可查找元素的子节点或子孙节点。</p><p>假如现在想要选择li节点的所有直接a子节点，可以这样实现：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree  <span class="hljs-comment"># 导入lxml库的etree模块</span><br><br><span class="hljs-comment"># 调用HTML类进行初始化,这样就可以成功构造一个XPath解析对象</span><br>html = etree.parse(<span class="hljs-string">'./test.html'</span>, etree.HTMLParser())<br><span class="hljs-comment"># 这里通过追加"/a"即选择了所有li节点的所有直接a子节点</span><br>result = html.xpath(<span class="hljs-string">'//li/a'</span>)<br>print(result)<br><br>***************************************************************<br><br>运行结果：<br>[&lt;Element a at <span class="hljs-number">0x1065c2c48</span>&gt;, &lt;Element a at <span class="hljs-number">0x1065c2c88</span>&gt;, &lt;Element a at <span class="hljs-number">0x1065c2cc8</span>&gt;, &lt;Element a at <span class="hljs-number">0x1065c2d08</span>&gt;, &lt;Element a at <span class="hljs-number">0x1065c2d48</span>&gt;]<br></code></pre></td></tr></table></figure><p>此处的<code>/</code>用于选取直接子节点，如果要获取所有子孙节点，就可以使用<code>//</code>。</p><p>例如，要获取ul节点下的所有子孙a节点，可以这样实现：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree  <span class="hljs-comment"># 导入lxml库的etree模块</span><br><br><span class="hljs-comment"># 调用HTML类进行初始化,这样就可以成功构造一个XPath解析对象</span><br>html = etree.parse(<span class="hljs-string">'./test.html'</span>, etree.HTMLParser())<br><span class="hljs-comment"># 这里通过追加"/a"即选择了所有li节点的所有直接a子节点</span><br>result = html.xpath(<span class="hljs-string">'//ul//a'</span>)<br>print(result)<br><br>***************************************************************<br><br>运行结果：<br>[&lt;Element a at <span class="hljs-number">0x1088e2c48</span>&gt;, &lt;Element a at <span class="hljs-number">0x1088e2c88</span>&gt;, &lt;Element a at <span class="hljs-number">0x1088e2cc8</span>&gt;, &lt;Element a at <span class="hljs-number">0x1088e2d08</span>&gt;, &lt;Element a at <span class="hljs-number">0x1088e2d48</span>&gt;]<br></code></pre></td></tr></table></figure><p>但是如果这里使用<code>result = html.xpath(&#39;//ul/a&#39;)</code>，则无法获取任何结果。因为<code>/</code>用户获取直接子节点，而在ul节点下没有直接a子节点，只有li节点，所以无法获取任何匹配结果。</p><h3 id="父节点"><a href="#父节点" class="headerlink" title="父节点"></a>父节点</h3><p>可以用<code>..</code>来实现查找父节点。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree  <span class="hljs-comment"># 导入lxml库的etree模块</span><br><br><span class="hljs-comment"># 调用HTML类进行初始化,这样就可以成功构造一个XPath解析对象</span><br>html = etree.parse(<span class="hljs-string">'./test.html'</span>, etree.HTMLParser())<br><span class="hljs-comment"># 现在首先选中href属性为link4.html的a节点,</span><br><span class="hljs-comment"># 然后再获取其父节点,然后再获取其class属性</span><br>result = html.xpath(<span class="hljs-string">'//a[@href="link4.html"]/../@class'</span>)<br>print(result)<br><br>***************************************************************<br><br>运行结果：<br>[<span class="hljs-string">'item-1'</span>]<br></code></pre></td></tr></table></figure><p>检查一下结果发现，这正是我们获取目标li节点的class。</p><p>同时我们也可以通过<code>parent::</code>来获取父节点，代码如下：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree  <span class="hljs-comment"># 导入lxml库的etree模块</span><br><br><span class="hljs-comment"># 调用HTML类进行初始化,这样就可以成功构造一个XPath解析对象</span><br>html = etree.parse(<span class="hljs-string">'./test.html'</span>, etree.HTMLParser())<br><span class="hljs-comment"># 现在首先选中href属性为link4.html的a节点,</span><br><span class="hljs-comment"># 然后再获取其父节点,然后再获取其class属性</span><br>result = html.xpath(<span class="hljs-string">'//a[@href="link4.html"]/parent::*/@class'</span>)<br>print(result)<br><br>***************************************************************<br><br>运行结果：<br>[<span class="hljs-string">'item-1'</span>]<br></code></pre></td></tr></table></figure><h3 id="属性匹配"><a href="#属性匹配" class="headerlink" title="属性匹配"></a>属性匹配</h3><p>在选取的时候，我们还可以通过<code>@</code>符号进行属性过滤。</p><p>比如，我们要选取class为<code>item-0</code>的li节点，可以这样实现：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree  <span class="hljs-comment"># 导入lxml库的etree模块</span><br><br><span class="hljs-comment"># 调用HTML类进行初始化,这样就可以成功构造一个XPath解析对象</span><br>html = etree.parse(<span class="hljs-string">'./test.html'</span>, etree.HTMLParser())<br><span class="hljs-comment"># 通过加入[@class="item-0"]限制了节点的class属性为"item-0"</span><br>result = html.xpath(<span class="hljs-string">'//li[@class="item-0"]'</span>)<br>print(result)<br><br>***************************************************************<br><br>运行结果：<br>[&lt;Element li at <span class="hljs-number">0x1078e2c48</span>&gt;, &lt;Element li at <span class="hljs-number">0x1078e2c88</span>&gt;]<br></code></pre></td></tr></table></figure><h3 id="文本获取"><a href="#文本获取" class="headerlink" title="文本获取"></a>文本获取</h3><p>我们用XPath中的<code>text()</code>方法获取节点中的文本，接下来尝试获取前面li节点中的文本，相关代码如下：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree  <span class="hljs-comment"># 导入lxml库的etree模块</span><br><br><span class="hljs-comment"># 调用HTML类进行初始化,这样就可以成功构造一个XPath解析对象</span><br>html = etree.parse(<span class="hljs-string">'./test.html'</span>, etree.HTMLParser())<br><span class="hljs-comment"># 两种方式:</span><br><span class="hljs-comment"># 一种是先选取a节点再获取文本</span><br>result1 = html.xpath(<span class="hljs-string">'//li[@class="item-0"]/a/text()'</span>)<br><span class="hljs-comment"># 一种是直接使用//获取文本</span><br>result2 = html.xpath(<span class="hljs-string">'//li[@class="item-0"]//text()'</span>)<br><span class="hljs-comment"># 两者结果一样,但使用“//”有时会获取更多的内容</span><br>print(result1, result2)<br><br>***************************************************************<br><br>运行结果：<br>[<span class="hljs-string">'first item'</span>, <span class="hljs-string">'fifth item'</span>] [<span class="hljs-string">'first item'</span>, <span class="hljs-string">'fifth item'</span>]<br></code></pre></td></tr></table></figure><ul><li>如果想要获取子孙节点内部的所有文本，可以直接用<code>//text()</code>的方式，这样可以保证获取到最全面的文本信息，但是可能会夹杂一些换行符等特殊字符；</li><li>如果想要获取某些特定子孙节点下的所有文本，可以先选取到特定的子孙节点，然后再调用<code>text()</code>方法获取其内部文本，这样可以保证获取的结果是整洁的。</li></ul><h3 id="属性获取"><a href="#属性获取" class="headerlink" title="属性获取"></a>属性获取</h3><p>用<code>@</code>符号来获取属性。</p><p>例如，我们想要获取<strong>所有li节点下所有a节点的href属性</strong>，代码如下：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree  <span class="hljs-comment"># 导入lxml库的etree模块</span><br><br><span class="hljs-comment"># 调用HTML类进行初始化,这样就可以成功构造一个XPath解析对象</span><br>html = etree.parse(<span class="hljs-string">'./test.html'</span>, etree.HTMLParser())<br><span class="hljs-comment"># 通过@href即可获取节点的href属性</span><br>result = html.xpath(<span class="hljs-string">'//li/a/@href'</span>)<br>print(result)<br><br>***************************************************************<br><br>运行结果：<br>[<span class="hljs-string">'link1.html'</span>, <span class="hljs-string">'link2.html'</span>, <span class="hljs-string">'link3.html'</span>, <span class="hljs-string">'link4.html'</span>, <span class="hljs-string">'link5.html'</span>]<br></code></pre></td></tr></table></figure><p>可以看到，我们成功获取了<strong>所有li节点下a节点的href属性</strong>，它们以列表形式返回。</p><p>注意，<strong>属性获取</strong>和<strong>属性匹配</strong>不同：</p><ul><li><strong>属性匹配</strong>：是中括号加属性名和值来限定某个属性，如：<code>[@href=&quot;link1.html&quot;]</code></li><li><strong>属性获取</strong>：是值获取节点的某个属性，如：<code>@href</code></li></ul><h3 id="属性多值匹配"><a href="#属性多值匹配" class="headerlink" title="属性多值匹配"></a>属性多值匹配</h3><p>有时候，某些节点的某个属性可能有多个值，例如：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree  <span class="hljs-comment"># 导入lxml库的etree模块</span><br><br>text = <span class="hljs-string">'''<br>&lt;li class="li li-first"&gt;&lt;a href="link1.html"&gt;first item&lt;/a&gt;&lt;/li&gt;<br>'''</span><br>html = etree.HTML(text)<br>result = html.xpath(<span class="hljs-string">'//li[@class="li"]/a/text()'</span>)<br>print(result)<br><br>***************************************************************<br><br>运行结果：<br>[]<br></code></pre></td></tr></table></figure><p>这里HTML文本中li节点的<strong>class属性</strong>有两个值<strong>li</strong>和<strong>li-first</strong>，此时如果还想用之前的属性匹配获取，就无法匹配了。</p><p>因此，就需要使用<code>contains()</code>函数了，代码可以改写如下：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree  <span class="hljs-comment"># 导入lxml库的etree模块</span><br><br>text = <span class="hljs-string">'''<br>&lt;li class="li li-first"&gt;&lt;a href="link1.html"&gt;first item&lt;/a&gt;&lt;/li&gt;<br>'''</span><br>html = etree.HTML(text)<br>result = html.xpath(<span class="hljs-string">'//li[contains(@class,"li")]/a/text()'</span>)<br>print(result)<br><br>***************************************************************<br><br>运行结果：<br>[<span class="hljs-string">'first item'</span>]<br></code></pre></td></tr></table></figure><p>这样通过<code>contains()</code>方法：</p><ul><li>第一个参数传入属性名称</li><li>第二个参数传入属性值</li></ul><p>只要此属性包含所传入的属性值，就可以完成匹配了。</p><p>这种方式在某个节点的某个属性有多个值的时候经常用到，如：某个节点的class属性通常由多个。</p><h3 id="多属性匹配"><a href="#多属性匹配" class="headerlink" title="多属性匹配"></a>多属性匹配</h3><p>根据多个属性确定一个节点，这时就需要同时匹配多个属性。</p><p>此时可以使用运算符<code>and</code>来连接，实例如下：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree  <span class="hljs-comment"># 导入lxml库的etree模块</span><br><br>text = <span class="hljs-string">'''<br>&lt;li class="li li-first" name="item"&gt;&lt;a href="link1.html"&gt;first item&lt;/a&gt;&lt;/li&gt;<br>'''</span><br>html = etree.HTML(text)<br>result = html.xpath(<span class="hljs-string">'//li[contains(@class,"li") and @name="item"]/a/text()'</span>)<br>print(result)<br><br>***************************************************************<br><br>运行结果：<br>[<span class="hljs-string">'first item'</span>]<br></code></pre></td></tr></table></figure><p>这里li节点又增加了一个属性name。要确定这个节点，需要同时根据class和name属性来选择，一个条件是class属性里面包含li字符串，另一个条件是name属性为item字符串，二者需要同时满足，用<code>and</code>操作符相连，相连之后置于中括号<code>[]</code>内进行条件筛选。</p><p>另外还有其他运算符：</p><div class="table-container"><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th><th>返回值</th></tr></thead><tbody><tr><td>or</td><td>或</td><td>age=19 or age=20</td><td>如果age是19或20，则返回true。否则，返回false。</td></tr><tr><td>and</td><td>与</td><td>age&gt;19 and age&lt;21</td><td>如果age是20，则返回true。否则，返回false。</td></tr><tr><td>mod</td><td>计算机除法的余数</td><td>5 mod 2</td><td>1</td></tr><tr><td>\</td><td></td><td>计算两个节点集</td><td>//book \</td><td>//cd</td><td>返回所有拥有book和cd元素的节点集</td></tr><tr><td>+</td><td>加法</td><td>6 + 4</td><td>10</td></tr><tr><td>-</td><td>减法</td><td>6 - 4</td><td>2</td></tr><tr><td>*</td><td>乘法</td><td>6 * 4</td><td>24</td></tr><tr><td>div</td><td>除法</td><td>8 div 4</td><td>2</td></tr><tr><td>=</td><td>等于</td><td>age=19</td><td>如果age是19，则返回true。否则，返回false。</td></tr><tr><td>!=</td><td>不等于</td><td>age!=19</td><td>如果age是19，则返回false。否则，返回true。</td></tr><tr><td>&lt;</td><td>小于</td><td>age&lt;19</td><td>如果age小于19，则返回true。否则，返回false。</td></tr><tr><td>&lt;=</td><td>小于等于</td><td>age\&lt;=19</td><td>如果age小于等于19，则返回true。否则，返回false。</td></tr><tr><td>&gt;</td><td>大于</td><td>age&gt;19</td><td>如果age大于19，则返回true。否则，返回false。</td></tr><tr><td>>=</td><td>大于等于</td><td>age>=19</td><td>如果age大于等于19，则返回true。否则，返回false。</td></tr></tbody></table></div><h3 id="按序选择"><a href="#按序选择" class="headerlink" title="按序选择"></a>按序选择</h3><p>有时候，在选择的时候某些属性可能同时匹配了多个节点，但是只想要其中的某个节点，如第二个节点或者最后一个节点，此时可以 利用中括号传入索引的方法获取特定次序的节点，示例如下：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree  <span class="hljs-comment"># 导入lxml库的etree模块</span><br><br><span class="hljs-comment"># 调用HTML类进行初始化,这样就可以成功构造一个XPath解析对象</span><br>html = etree.parse(<span class="hljs-string">'./test.html'</span>, etree.HTMLParser())<br><span class="hljs-comment"># 选取第一个节点,注意从1开始</span><br>result = html.xpath(<span class="hljs-string">'//li[1]/a/text()'</span>)<br>print(result)<br><span class="hljs-comment"># 选取最后一个节点</span><br>result = html.xpath(<span class="hljs-string">'//li[last()]/a/text()'</span>)<br>print(result)<br><span class="hljs-comment"># 选取位置小于3的节点,即位置序号为1和2的节点</span><br>result = html.xpath(<span class="hljs-string">'//li[position()&lt;3]/a/text()'</span>)<br>print(result)<br><span class="hljs-comment"># 选取倒数第三个li节点</span><br>result = html.xpath(<span class="hljs-string">'//li[last()-2]/a/text()'</span>)<br>print(result)<br><br>***************************************************************<br><br>运行结果：<br>[<span class="hljs-string">'first item'</span>]<br>[<span class="hljs-string">'fifth item'</span>]<br>[<span class="hljs-string">'first item'</span>, <span class="hljs-string">'second item'</span>]<br>[<span class="hljs-string">'third item'</span>]<br></code></pre></td></tr></table></figure><p>这里使用了<code>last()</code>、<code>position()</code>函数。</p><p>在XPath中，提供了100多个函数，包括存取、数值、字符串、逻辑、节点、序列等处理功能。</p><p>具体可以参考<a href="https://www.w3school.com.cn/xpath/xpath_functions.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/xpath/xpath_functions.asp</a></p><h3 id="节点轴选择"><a href="#节点轴选择" class="headerlink" title="节点轴选择"></a>节点轴选择</h3>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> 原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 解析库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫实例1-猫眼电影排行</title>
      <link href="/2019/08/11/%E7%88%AC%E8%99%AB%E5%AE%9E%E4%BE%8B1-%E7%8C%AB%E7%9C%BC%E7%94%B5%E5%BD%B1%E6%8E%92%E8%A1%8C/"/>
      <url>/2019/08/11/%E7%88%AC%E8%99%AB%E5%AE%9E%E4%BE%8B1-%E7%8C%AB%E7%9C%BC%E7%94%B5%E5%BD%B1%E6%8E%92%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>本文简单介绍爬取猫眼电影排行前100榜单。</p><p>主要爬取的电影信息有：排名，名称，图片，详情页，演员，上映时间，评分，简介。</p><a id="more"></a><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> json<br><br><span class="hljs-comment"># 存放所有电影内容</span><br>contents = []<br><br><br><span class="hljs-comment"># 获取一个榜单页面</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_one_page</span><span class="hljs-params">(url)</span>:</span><br>    headers = &#123;<br>        <span class="hljs-string">'User-Agent'</span>: <span class="hljs-string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) \<br>                      AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36'</span><br>    &#125;<br>    response = requests.get(url, headers=headers)<br>    <span class="hljs-keyword">if</span> response.status_code == <span class="hljs-number">200</span>:    <span class="hljs-comment"># 如果正常返回请求</span><br>        <span class="hljs-keyword">return</span> response.text<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br><br><span class="hljs-comment"># 获取该电影的简单描述</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_movie_desc</span><span class="hljs-params">(url)</span>:</span><br>    headers = &#123;<br>        <span class="hljs-string">'User-Agent'</span>: <span class="hljs-string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) \<br>                          AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36'</span><br>    &#125;<br>    response = requests.get(url, headers=headers)<br>    desc = re.search(<span class="hljs-string">'&lt;meta name="description" content=".*?故事梗概:(.*?)"&gt;'</span>, response.text).group(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> desc<br><br><br><span class="hljs-comment"># 处理每一部电影</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse_one_page</span><span class="hljs-params">(html)</span>:</span><br>    pattern = re.compile(<br>        <span class="hljs-string">'&lt;i class="board-index board-index-.*?"&gt;(.*?)&lt;/i&gt;.*?(/films/.*?)" title="(.*?)".*?&lt;img data-src="(.*?)".*?&lt;p class="star"&gt;.*?主演：(.*?)\\n.*?&lt;/p&gt;.*?上映时间：(.*?)&lt;/p&gt;.*?&lt;i class="integer"&gt;(.*?).&lt;/i&gt;&lt;i class="fraction"&gt;(.*?)&lt;/i&gt;&lt;/p&gt;'</span>,<br>        re.S)<br>    items = re.findall(pattern, html)<br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> items:<br>        content = &#123;<br>            <span class="hljs-string">'index'</span>: item[<span class="hljs-number">0</span>],   <span class="hljs-comment"># 电影排名</span><br>            <span class="hljs-string">'details'</span>: <span class="hljs-string">'https://maoyan.com'</span> + item[<span class="hljs-number">1</span>],  <span class="hljs-comment"># 电影详情页</span><br>            <span class="hljs-string">'title'</span>: item[<span class="hljs-number">2</span>],   <span class="hljs-comment"># 电影名称</span><br>            <span class="hljs-string">'image'</span>: item[<span class="hljs-number">3</span>],   <span class="hljs-comment"># 电影图片</span><br>            <span class="hljs-string">'actor'</span>: item[<span class="hljs-number">4</span>],   <span class="hljs-comment"># 电影演员</span><br>            <span class="hljs-string">'time'</span>: item[<span class="hljs-number">5</span>],    <span class="hljs-comment"># 电影上映时间</span><br>            <span class="hljs-string">'score'</span>: item[<span class="hljs-number">6</span>] + <span class="hljs-string">'.'</span> + item[<span class="hljs-number">7</span>]    <span class="hljs-comment"># 电影评分</span><br>        &#125;<br>        content[<span class="hljs-string">'desc'</span>] = get_movie_desc(content[<span class="hljs-string">'details'</span>])    <span class="hljs-comment"># 电影简介</span><br>        print(content)<br>        time.sleep(<span class="hljs-number">2</span>)   <span class="hljs-comment"># 休息2s再爬,防止封ip</span><br>        contents.append(content)<br><br><br><span class="hljs-comment"># 将电影存放到maoyan.json文件中,方便以后调用</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write_to_file</span><span class="hljs-params">(contents)</span>:</span><br>    <span class="hljs-keyword">with</span> open(<span class="hljs-string">'maoyan.json'</span>, <span class="hljs-string">'w'</span>, encoding=<span class="hljs-string">'utf-8'</span>) <span class="hljs-keyword">as</span> f:<br>        f.write(json.dumps(contents, ensure_ascii=<span class="hljs-literal">False</span>) + <span class="hljs-string">'\n'</span>)<br><span class="hljs-comment"># 指定ensure_ascii为False可以确保输出结果是中文形式而不是Unicode编码</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    url = <span class="hljs-string">'https://maoyan.com/board/4?offset='</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):<br>        <span class="hljs-comment"># print(url+str(i*10))</span><br>        html = get_one_page(url + str(i * <span class="hljs-number">10</span>))<br>        parse_one_page(html)<br>    write_to_file(contents)<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> 爬虫实例 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> 正则表达式 </tag>
            
            <tag> 实例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2019/08/11/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2019/08/11/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>正则表达式是描述一组字符串特征的模式，有助于找到文本字符串中的各种模式。</p><p>更确切的说，正则表达式是经过专门编写的文本字符串，用来匹配字符串（尤其是文件内字符串）集合中符合该模式的所有字符串。</p><a id="more"></a><h2 id="常用匹配规则"><a href="#常用匹配规则" class="headerlink" title="常用匹配规则"></a>常用匹配规则</h2><div class="table-container"><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>\w</td><td>匹配字母、数字及下划线</td></tr><tr><td>\W</td><td>匹配除字母、数字及下划线以外</td></tr><tr><td>\s</td><td>匹配任意空白字符，等价于 <code>[\t\n\r\f]</code></td></tr><tr><td>\S</td><td>匹配任意非空字符</td></tr><tr><td>\d</td><td>匹配任意数字，等价于 <code>[0-9]</code></td></tr><tr><td>\D</td><td>匹配除数字外的字符</td></tr><tr><td>\A</td><td>匹配字符串开头</td></tr><tr><td>\z</td><td>匹配字符串结尾，如果存在换行，同时还会匹配换行符</td></tr><tr><td>\Z</td><td>匹配字符串结尾，如果存在换行，只匹配到换行前的结束字符串</td></tr><tr><td>\G</td><td>匹配最后匹配完成的位置</td></tr><tr><td>\n</td><td>匹配一个换行符</td></tr><tr><td>\t</td><td>匹配一个制表符</td></tr><tr><td>^</td><td>匹配一行字符串的开头</td></tr><tr><td>$</td><td>匹配一行字符串的结尾</td></tr><tr><td>.</td><td>匹配除了换行符外的任意字符。当<code>re.DOTALL</code>标记被指定时，则可以匹配包括换行符的任意字符。</td></tr><tr><td>[…]</td><td>用来表示一组字符，单独列出，比如 <code>[amk]</code>匹配a、m或k</td></tr><tr><td><sup><a href="#fn_..." id="reffn_...">...</a></sup></td><td>不在<code>[...]</code>中的字符，比如<code>[^abc]</code>匹配除了a、b、c之外的字符</td></tr><tr><td>*</td><td>匹配0个或多个表达式</td></tr><tr><td>+</td><td>匹配1个或多个表达式</td></tr><tr><td>?</td><td>匹配0个或1个前面的正则表达式定义的片段，非贪婪方式</td></tr><tr><td>{n}</td><td>精确匹配n个前面的表达式</td></tr><tr><td>{n,m}</td><td>匹配n到m个由前面正则表达式定义的片段，贪婪方式</td></tr><tr><td>a\</td><td>b</td><td>匹配a或b</td></tr><tr><td>( )</td><td>匹配括号内的表达式，也表示一个组</td></tr></tbody></table></div><h2 id="re库-Python"><a href="#re库-Python" class="headerlink" title="re库(Python)"></a>re库(Python)</h2><h3 id="match方法"><a href="#match方法" class="headerlink" title="match方法"></a>match方法</h3><p>向<code>match</code>传入要匹配的字符串以及正则表达式，就可以检测这个正则表达式是否匹配字符串。</p><p><strong><em>第一个参数传入正则表达式，第二个参数传入要匹配的字符串。</em></strong></p><p><code>match</code>从字符串的起始位置匹配正则表达式：</p><ul><li>如果匹配，就返回匹配成功的结果</li><li>如果不匹配，就返回None</li></ul><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>content = <span class="hljs-string">'Hello 123 4567 World_This is a Regex Demo'</span><br>print(len(content))<br>result = re.match(<span class="hljs-string">'^Hello\s\d\d\d\s\d&#123;4&#125;\s\w&#123;10&#125;'</span>, content)<br>print(result)<br>print(result.group())<br>print(result.span())<br><br>*************************************************************<br><br>运行结果如下:<br><span class="hljs-number">41</span><br>&lt;_sre.SRE_Match object; span=(<span class="hljs-number">0</span>, <span class="hljs-number">25</span>), match=<span class="hljs-string">'Hello 123 4567 World_This'</span>&gt;<br>Hello <span class="hljs-number">123</span> <span class="hljs-number">4567</span> World_This<br>(<span class="hljs-number">0</span>, <span class="hljs-number">25</span>)<br></code></pre></td></tr></table></figure><ol><li>开头的<code>^</code>是匹配字符串的开头，也就是以<code>Hello</code>开头；</li><li><code>\s</code>匹配空白字符，用来匹配目标串的空格；</li><li><code>\d</code>匹配数字，3个<code>\d</code>匹配123；</li><li><code>\s</code>匹配1个空格；</li><li><code>\d{4}</code>代表匹配前面的规则4次，也就是匹配4个数字；</li><li><code>\s</code>匹配1个空格；</li><li><code>\w{10}</code>匹配10个字母、数字及下划线；</li></ol><p>若输出结果是<strong>SRE_Match</strong>对象，则证明匹配成功。</p><p>该对象有两个方法：</p><ul><li><strong>group()：</strong>可以输出正则表达式规则匹配到的内容；</li><li><strong>span()：</strong>可以输出正则表达式规则所匹配到的结果字符串在原字符串中的位置范围；</li></ul><h4 id="匹配目标"><a href="#匹配目标" class="headerlink" title="匹配目标"></a>匹配目标</h4><p>可以使用<code>()</code>括号将想提取的子字符串括起来。<code>()</code>实际上标记了一个子表达式的开始和结束位置，被标记的每个子表达式会依次对应每一个分组，调用<code>group()</code>传入分组的索引即可获取提取的结果。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>content = <span class="hljs-string">'Hello 1234567 World_This is a Regex Demo'</span><br>print(len(content))<br>result = re.match(<span class="hljs-string">'^Hello\s(\d+)\s(World)'</span>, content)<br>print(result)<br>print(result.group())<br>print(result.group(<span class="hljs-number">0</span>))<br>print(result.group(<span class="hljs-number">1</span>))<br>print(result.group(<span class="hljs-number">2</span>))<br>print(result.span())<br><br>******************************************************************<br><br>运行结果：<br><span class="hljs-number">40</span><br>&lt;_sre.SRE_Match object; span=(<span class="hljs-number">0</span>, <span class="hljs-number">19</span>), match=<span class="hljs-string">'Hello 1234567 World'</span>&gt;<br>Hello <span class="hljs-number">1234567</span> World<br>Hello <span class="hljs-number">1234567</span> World<br><span class="hljs-number">1234567</span><br>World<br>(<span class="hljs-number">0</span>, <span class="hljs-number">19</span>)<br></code></pre></td></tr></table></figure><p>从结果中看出：</p><ul><li><code>group()</code>和<code>group(0)</code>结果相同，都是输出完整的匹配内容；</li><li><code>group(1)</code>输出第一个被<code>()</code>包围的内容；</li><li>如果正则表达式后面还有被<code>()</code>包围的内容，可以依次用<code>group(2)</code>、<code>group(3)</code>等来获取；</li></ul><h4 id="通用匹配"><a href="#通用匹配" class="headerlink" title="通用匹配"></a>通用匹配</h4><p>在正则表达式中，可以使用通用匹配(即万能匹配)，其中：</p><ul><li><code>.(点)</code>可以匹配<strong>除换行符外</strong>任意字符</li><li><code>*(星)</code>代表前面的字符可以匹配无线次</li></ul><p>因此，可以用<code>.*</code>组合匹配任意字符串。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>content = <span class="hljs-string">'Hello 123 4567 World_This is a Regex Demo'</span><br>print(len(content))<br>result = re.match(<span class="hljs-string">'^Hello.*Demo$'</span>, content)<br>print(result)<br>print(result.group())<br>print(result.span())<br><br>******************************************************************<br><br>运行结果：<br><span class="hljs-number">41</span><br>&lt;_sre.SRE_Match object; span=(<span class="hljs-number">0</span>, <span class="hljs-number">41</span>), match=<span class="hljs-string">'Hello 123 4567 World_This is a Regex Demo'</span>&gt;<br>Hello <span class="hljs-number">123</span> <span class="hljs-number">4567</span> World_This <span class="hljs-keyword">is</span> a Regex Demo<br>(<span class="hljs-number">0</span>, <span class="hljs-number">41</span>)<br></code></pre></td></tr></table></figure><p>可以看到，<code>group()</code>方法输出了匹配的全部字符串，也就是说我们写的正则表达式匹配到了目标字符串的全部内容，<code>span()</code>方法输出(0, 41)，这是整个字符串的长度。</p><h4 id="贪婪和非贪婪"><a href="#贪婪和非贪婪" class="headerlink" title="贪婪和非贪婪"></a>贪婪和非贪婪</h4><ul><li>在贪婪匹配下，<code>.*</code> 会匹配尽可能多的字符。</li><li>在非贪婪匹配下，<code>.*?</code> 会匹配尽可能少的字符。</li></ul><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>content = <span class="hljs-string">'Hello 1234567 World_This is a Regex Demo'</span><br>print(len(content))<br><br><span class="hljs-comment"># 贪婪匹配</span><br>result = re.match(<span class="hljs-string">'^He.*(\d+).*Demo$'</span>, content)<br>print(<span class="hljs-string">'贪婪匹配: '</span>+ result.group(<span class="hljs-number">1</span>))<br><br><span class="hljs-comment"># 非贪婪匹配</span><br>result = re.match(<span class="hljs-string">'^He.*?(\d+).*Demo$'</span>, content)<br>print(<span class="hljs-string">'非贪婪匹配: '</span>+ result.group(<span class="hljs-number">1</span>))<br><br>******************************************************************<br><br>运行结果：<br><span class="hljs-number">40</span><br>贪婪匹配: <span class="hljs-number">7</span><br>非贪婪匹配: <span class="hljs-number">1234567</span><br></code></pre></td></tr></table></figure><p><strong>在做匹配的时候，字符串中间尽量使用非贪婪匹配，也就是用 <code>.*?</code> 代替 <code>.*</code> ，以免出现匹配结果缺失的情况。</strong></p><p>但是要注意，如果匹配的结果在字符串的结尾，<code>.*?</code>就有可能匹配不到任何内容了，因为他会匹配尽可能少的字符。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>content = <span class="hljs-string">'Hello 1234567 World_This is a Regex Demo'</span><br>print(len(content))<br><br><span class="hljs-comment"># 贪婪匹配</span><br>result = re.match(<span class="hljs-string">'^He.*Regex (.*)'</span>, content)<br>print(<span class="hljs-string">'贪婪匹配: '</span>+ result.group(<span class="hljs-number">1</span>))<br><br><span class="hljs-comment"># 非贪婪匹配</span><br>result = re.match(<span class="hljs-string">'^He.*Regex (.*?)'</span>, content)<br>print(<span class="hljs-string">'非贪婪匹配: '</span>+ result.group(<span class="hljs-number">1</span>))<br><br>******************************************************************<br><br>运行结果：<br><span class="hljs-number">40</span><br>贪婪匹配: Demo<br>非贪婪匹配:<br></code></pre></td></tr></table></figure><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><p>正则表达式可以包含一些可选标志修饰符来控制匹配的模式。</p><p>修饰符被指定为一个可选的标志。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>content = <span class="hljs-string">'''Hello 1234567 World_This<br> is a Regex Demo'''</span><br>print(len(content))<br>result = re.match(<span class="hljs-string">'^He.*Regex (.*)'</span>, content)<br>print(result.group(<span class="hljs-number">1</span>))<br><br>******************************************************************<br><br>运行结果：<br><span class="hljs-number">41</span><br>Traceback (most recent call last):<br>  File <span class="hljs-string">"/Users/huben/Desktop/spider/cs.py"</span>, line <span class="hljs-number">7</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    print(result.group(<span class="hljs-number">1</span>))<br>AttributeError: <span class="hljs-string">'NoneType'</span> object has no attribute <span class="hljs-string">'group'</span><br></code></pre></td></tr></table></figure><p>运行直接报错，也就是说正则表达式没有匹配到这个字符串，返回的结果为None，而又调用了<code>group()</code>方法导致<code>AttributeError</code>。</p><p><strong>原因：</strong> <code>.</code> 匹配的是除了换行符之外的任意字符，当遇到换行符时，<code>.*?</code> 就不能匹配了，所以导致失败。</p><p>这里可以加上修饰符 <code>re.S</code> ，即可修正这个错误。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>content = <span class="hljs-string">'''Hello 1234567 World_This<br> is a Regex Demo'''</span><br>print(len(content))<br>result = re.match(<span class="hljs-string">'^He.*Regex (.*)'</span>, content, re.S)<br>print(result.group(<span class="hljs-number">1</span>))<br><br>******************************************************************<br><br>运行结果：<br><span class="hljs-number">41</span><br>Demo<br></code></pre></td></tr></table></figure><p>这个<code>re.S</code>在网页匹配中经常用到。因为HTML节点经常会有换行，加上它，就可以匹配节点与节点之间的换行了。</p><p>另外还有一些修饰符如下：</p><div class="table-container"><table><thead><tr><th>修饰符</th><th>描述</th></tr></thead><tbody><tr><td>re.I</td><td>使匹配与大小写不敏感</td></tr><tr><td>re.L</td><td>做本地化识别(locale-aware)匹配</td></tr><tr><td>re.M</td><td>多行匹配，影响 ^ 和 $</td></tr><tr><td>re.S</td><td>使 . (点) 匹配包括换行在内的所有字符</td></tr><tr><td>re.U</td><td>根据Unicode字符集解析字符。这个标志影响\w, \W, \b, \B</td></tr><tr><td>re.X</td><td>该标志通过给予更灵活的格式以便将正则表达式写的更易于理解</td></tr></tbody></table></div><p>较为常用的是 <code>re.I</code> ，和 <code>re.S</code> 。</p><h4 id="转义匹配"><a href="#转义匹配" class="headerlink" title="转义匹配"></a>转义匹配</h4><p>在正则表达式中定义了很多匹配，但是如果要匹配包含 <code>.</code> 等特殊字符时，就需要使用转义匹配了。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>content = <span class="hljs-string">'(百度)www.baidu.com'</span><br>result = re.match(<span class="hljs-string">'\(百度\)www\.baidu\.com'</span>, content)<br>print(result.group())<br><br>******************************************************************<br><br>运行结果：<br>(百度)www.baidu.com<br></code></pre></td></tr></table></figure><p>当遇到用于正则匹配模式的特殊字符时，<strong>在前面加反斜杠转义一下即可</strong>。</p><h3 id="search方法"><a href="#search方法" class="headerlink" title="search方法"></a>search方法</h3><p><code>match()</code>方法在匹配时是从字符串的开头开始匹配的，一旦开头不匹配，那么整个匹配就会失败。这在做匹配时会非常不方便，它更适合用来检测某个字符串是否符合某个正则表达式的规则。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>content = <span class="hljs-string">'Extra strings Hello 1234567 World_This is a Regex Demo'</span><br>print(len(content))<br>result = re.match(<span class="hljs-string">'He.*Regex (.*)'</span>, content)<br>print(result.group(<span class="hljs-number">1</span>))<br><br>******************************************************************<br><br>运行结果：<br>Traceback (most recent call last):<br>  File <span class="hljs-string">"/Users/huben/Desktop/spider/cs.py"</span>, line <span class="hljs-number">6</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br><span class="hljs-number">54</span><br>    print(result.group(<span class="hljs-number">1</span>))<br>AttributeError: <span class="hljs-string">'NoneType'</span> object has no attribute <span class="hljs-string">'group'</span><br></code></pre></td></tr></table></figure><p>而<code>search()</code>方法在匹配的时候会扫描整个字符串，然后<strong>返回第一个成功匹配的结果</strong>。</p><p>即，<strong>正则表达式可以是字符串的一部分</strong>，在匹配时，<code>search()</code>方法会依次扫描字符串，直到找到第一个符合规则的字符串，然后返回匹配内容，如果搜索完了还没有找到，则返回<strong>None</strong>。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>content = <span class="hljs-string">'Extra strings Hello 1234567 World_This is a Regex Demo'</span><br>print(len(content))<br>result = re.search(<span class="hljs-string">'He.*Regex (.*)'</span>, content)<br>print(result.group())<br><br>******************************************************************<br><br>运行结果：<br><span class="hljs-number">54</span><br>Hello <span class="hljs-number">1234567</span> World_This <span class="hljs-keyword">is</span> a Regex Demo<br></code></pre></td></tr></table></figure><p>因此，为了匹配方便，我们尽量使用<code>search()</code>方法。</p><h3 id="findall方法"><a href="#findall方法" class="headerlink" title="findall方法"></a>findall方法</h3><p>如果想要获取正则表达式的所有内容，则需要借助 <code>findall()</code> 方法。</p><p>该方法会搜索整个字符串，然后返回匹配正则表达式的所有内容。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">results = re.findall(RegEx, content, re.S) <span class="hljs-comment"># 匹配所有结果</span><br><span class="hljs-keyword">for</span> result <span class="hljs-keyword">in</span> results:<br>    print(result)<br>    print(result[<span class="hljs-number">0</span>],result[<span class="hljs-number">1</span>],result[<span class="hljs-number">2</span>])<span class="hljs-comment"># 这里相当于group(1),group(2)...</span><br></code></pre></td></tr></table></figure><p>可以看出，返回的列表中的每个元素都是元组类型，可以用对应的索引依次取出即可。</p><h3 id="sub方法"><a href="#sub方法" class="headerlink" title="sub方法"></a>sub方法</h3><p>除了使用正则表达式提取信息外，有时候还需要借助它来修改文本。</p><p>比如要把一串文本中的所有数字都去掉，如果只用字符串的<code>replace()</code>方法，那就太繁琐了。</p><p>可以使用<code>sub()</code>方法。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>content = <span class="hljs-string">"Hello 1234567 World_This is a Regex Demo"</span><br>content = re.sub(<span class="hljs-string">' \d+'</span>, <span class="hljs-string">''</span>, content)<br>print(content)<br><br>******************************************************************<br><br>运行结果：<br>Hello World_This <span class="hljs-keyword">is</span> a Regex Demo<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><strong>第一个参数：</strong>传入<code>\d+</code>来匹配所有的数字；</li><li><strong>第二个参数：</strong>替换成的字符串(如果去掉该参数的话，可以赋值为空)；</li><li><strong>第三个参数：</strong>原字符串；</li></ul><h3 id="compile方法"><a href="#compile方法" class="headerlink" title="compile方法"></a>compile方法</h3><p><code>compile()</code>方法可以将正则字符串编译成正则表达式对象，以便在后面的匹配中复用。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>content1 = <span class="hljs-string">'2016-12-15 12:00'</span><br>content2 = <span class="hljs-string">'2016-12-17 12:55'</span><br>content3 = <span class="hljs-string">'2016-12-22 13:21'</span><br><br>pattern = re.compile(<span class="hljs-string">'\d&#123;2&#125;:\d&#123;2&#125;'</span>)<br><br>result1 = re.sub(pattern, <span class="hljs-string">''</span>, content1)<br>result2 = re.sub(pattern, <span class="hljs-string">''</span>, content2)<br>result3 = re.sub(pattern, <span class="hljs-string">''</span>, content3)<br><br>print(result1, result2, result3)<br><br>******************************************************************<br><br>运行结果：<br><span class="hljs-number">2016</span><span class="hljs-number">-12</span><span class="hljs-number">-15</span>  <span class="hljs-number">2016</span><span class="hljs-number">-12</span><span class="hljs-number">-17</span>  <span class="hljs-number">2016</span><span class="hljs-number">-12</span><span class="hljs-number">-22</span><br></code></pre></td></tr></table></figure><p>例如，如果我们想要将三个日期中的时间去掉，此时可以借助<code>sub()</code>方法。</p><p>该方法的第一个参数是正则表达式，但是这里没有必要重复写3个同样的正则表达式，此时可以借助<code>compile()</code>方法将正则表达式编译成一个正则表达式对象，以便复用。</p><p>另外，<code>compile()</code>还可以传入修饰符，例如<code>re.S</code>等修饰符，这样在<code>search()</code>、<code>findall()</code>等方法中就不需要额外传了。例如：<code>pattern = re.compile(&#39;\d{2}:\d{2}&#39;, re.S)</code></p>]]></content>
      
      
      <categories>
          
          <category> 计算机工具 </category>
          
          <category> 正则表达式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> 正则表达式 </tag>
            
            <tag> 字符串处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代理的基本原理</title>
      <link href="/2019/08/11/%E4%BB%A3%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
      <url>/2019/08/11/%E4%BB%A3%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>当我们在做爬虫的时候，刚开始可以正常抓取数据，然而一段时间过后可能会出现错误，比如<strong>403 Forbidden</strong>，这时候打开网页一看，可能会看到<strong>IP访问频率过高</strong>这样的提示。出现这种现象的原因是网站采取了反爬虫措施。</p><p>当服务器检测到某个IP在单位时间内的请求次数，如果超过了这个阈值，就会直接拒绝服务，返回一些错误信息，这种情况可以称为封IP。</p><p>既然服务器检测的是某个IP单位时间的请求次数，那么借助某种方式来伪装我们的IP，让服务器识别不出是由我们本机发起的请求，就可以防止封IP了。</p><p>一种有效的方式就是使用代理，本文主要介绍了代理的一些基本原理。</p><a id="more"></a><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>代理实际上指的是代理服务器(proxy server)，功能是代理网络用户去取得网络信息，即网络信息的中转站。</p><p>如果设置了代理服务器，就可以在本机和服务器之间搭建一个桥，此时本机不是直接向Web服务器发起请求，而是向代理服务器发起请求，请求会发送给代理服务器，然后由代理服务器再发送给Web服务器，接着由代理服务器再把Web服务器返回的响应转发给本机。</p><p>这样我们同样可以正常访问页面，但这个过程中Web服务器识别出的真实IP就不再是我们本机的IP，就成功实现了IP伪装，即代理。</p><h2 id="代理的作用"><a href="#代理的作用" class="headerlink" title="代理的作用"></a>代理的作用</h2><ul><li>突破自身IP访问限制，访问一些平时不能访问的站点。</li><li>访问一些单位或团体内部资源：比如使用教育网内地址段免费代理服务器，就可以用于对教育网开放的各类FTP下载上传，以及各类资料查询共享等服务。</li><li>提高访问速度：通常代理服务器都设置一个较大的硬盘缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时，则直接由缓冲区中取信息，传给用户，以提高访问速度。</li><li>隐藏真实IP：上网者也可以通过这种方法隐藏自己的IP，免受攻击。对于爬虫来说，我们用代理就是为了隐藏自身的IP，防止自身的IP被封锁。</li></ul><h2 id="代理分类"><a href="#代理分类" class="headerlink" title="代理分类"></a>代理分类</h2><p>代理分类时，既可以根据协议区分，也可以根据其匿名程度区分。</p><h3 id="根据协议区分"><a href="#根据协议区分" class="headerlink" title="根据协议区分"></a>根据协议区分</h3><p>根据代理的协议，代理可以分为如下类别：</p><ul><li><strong>FTP代理服务器：</strong>主要用于访问FTP服务器，一般有上传、下载以及缓存功能，短裤一般为21、2121等。</li><li><strong>HTTP代理服务器：</strong>主要用于访问网页，一般有内容过滤和缓存功能，端口一般为80、8080、3128等。</li><li><strong>SSL/TLS代理：</strong>主要用于访问加密网站，一般有SSL或TLS加密功能(最高支持128位加密强度)，端口一般为443。</li><li><strong>RTSP代理：</strong>主要用于访问Real流媒体服务器，一般有缓存功能，端口一般为554。</li><li><strong>Telnet代理：</strong>主要用于telnet远程控制(黑客入侵计算机时常用于隐藏身份)，端口一把为23。</li><li><strong>POP3/SMTP代理：</strong>主要用于POP3/SMTP方式收发邮件，一般有缓存功能，端口一般为110/25。</li><li><strong>SOCKS代理：</strong>只是单纯传递数据包，不关心具体协议和用法，所以速度快很多，一般有缓存功能，端口一般为1080。SOCKS代理又分为SOCKS4和SOCKS5，前者只支持TCP，后者支持TCP和UDP，还支持各种身份验证机制、服务器域名解析等。SOCKS4能做的，SOCKS5都能做。</li></ul><h3 id="根据匿名程度区分"><a href="#根据匿名程度区分" class="headerlink" title="根据匿名程度区分"></a>根据匿名程度区分</h3><p>根据代理的匿名程度，代理可以分为如下类别：</p><ul><li><strong>高度匿名代理：</strong>会将数据包原封不动地转发，在服务端看来就好像真的是一个普通客户端在访问，而记录的IP是代理服务器的IP。</li><li><strong>普通匿名代理：</strong>会在数据包上做一些改动，服务端上有可能发现这是个代理服务器，也有一定几率追查到客户端的真实IP。代理服务器通常会加入的HTTP头有<code>HTTP_VIA</code>和<code>HTTP_X_FORWARDED_FOR</code>。</li><li><strong>透明代理：</strong>不但改动了数据包，还会告诉服务器客户端的真实IP。这种代理除了能用缓存的技术提高浏览速度，能用内容过滤提高安全性外，并无其他显著作用，最常见的例子是内网中的硬件防火墙。</li><li><strong>间谍代理：</strong>指组织或个人创建的用于记录用户传输的数据，然后进行研究、监控等目的的代理服务器。</li></ul><h2 id="常见的代理设置"><a href="#常见的代理设置" class="headerlink" title="常见的代理设置"></a>常见的代理设置</h2><ul><li><strong>使用网上的免费代理：</strong>最好使用高匿代理，另外可用的代理不多，需要在使用前筛选一下可用代理，也可以进一步维护一个代理池。</li><li><strong>使用付费代理：</strong>互联网上存在许多代理商，可以付费使用，质量比免费代理好很多。</li><li><strong>ASDL拨号：</strong>拨一次换一次IP，稳定性高，也是一种比较有效的解决方案。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> 原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>会话和Cookies</title>
      <link href="/2019/08/07/%E4%BC%9A%E8%AF%9D%E5%92%8CCookies/"/>
      <url>/2019/08/07/%E4%BC%9A%E8%AF%9D%E5%92%8CCookies/</url>
      
        <content type="html"><![CDATA[<p>在浏览网站的时候，我们经常会遇到需要登录的情况，有些页面只有登录之后才可以访问，而且登录之后可以连续访问很多次网站，但是有时候过一段时间就需要重新登录。</p><p>还有一些网站，再打开浏览器时就自动登录了，而且很长时间都不会失效，这里面涉及会话(<strong>Session</strong>)和<strong>Cookies</strong>的相关知识。</p><a id="more"></a><h2 id="静态网页和动态网页"><a href="#静态网页和动态网页" class="headerlink" title="静态网页和动态网页"></a>静态网页和动态网页</h2><p>在开始之前，需要先了解一下动态网页和静态网页的概念，代码如下：</p><figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>This is a Demo<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"container"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"wrapper"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title"</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"text"</span>&gt;</span>Hello, this is a paragraph.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这种网页的内容是HTML代码编写的，文字、图片等内容均通过写好的HTML代码来指定，这种网页叫作静态网页。它<strong>加载速度快</strong>，<strong>编写简单</strong>，但是存在很大的缺陷，如<strong>可维护性差</strong>，<strong>不能根据URL灵活多变地显示内容</strong>等。例如，我们想要给这个网页的URL传入一个name参数，让其在网页中显示出来，是无法做到的。</p><p>动态网站可以动态解析URL中参数的变化，关联数据库并动态呈现不同页面内容，非常灵活多变。我们现在遇到的大多数网站都是动态网站，它们不再是一个简单的HTML，而是可能由<strong>JSP</strong>、<strong>PHP</strong>、<strong>Python</strong>等语言编写的，其功能比静态网页强大和丰富。</p><p>此外，动态网站还可以实现用户登录和注册的功能。很多页面时需要登录之后才可以查看的。按照一般的逻辑来说，输入用户名和密码登录之后，肯定是拿到了一种类似于<strong>凭证</strong>（会话和Cookies共同产生的结果）的东西，有了它，我们才能保持登录状态，才能访问登录之后才能看到的页面。</p><h2 id="无状态HTTP"><a href="#无状态HTTP" class="headerlink" title="无状态HTTP"></a>无状态HTTP</h2><p>HTTP的无状态是指HTTP协议对事务处理是没有记忆能力的，也就说<strong>服务器不知道客户端是什么状态</strong>。</p><blockquote><p>当我们向服务器发送请求后，服务器解析此请求，然后返回对应的响应，服务器负责完成这个过程，而且这个过程是完全独立的，服务器不会记录前后状态的变化，也就是缺少状态记录。</p></blockquote><p>这意味着如果后续需要处理前面的信息，则必须重传，这导致需要额外传递一些前面的重复请求，才能获取后续响应，然而这种效果显然不是我们想要的。为了保持前后状态，我们肯定不能将前面的请求全部重传一次，这太浪费资源了，对于这种需要用户登录的页面来说，更为棘手。</p><p>这时，两个用于保持HTTP连接状态的技术就出现了，它们分别是<strong>会话</strong>和<strong>Cookies</strong>。</p><ul><li><strong>会话</strong>在服务端，也就是网站的服务器，用来保存用户的会话信息。</li><li><strong>Cookies</strong>在客户端，也可以理解为浏览器端，有了Cookies，浏览器在下次访问网页时会自动附带上它发送给服务器，服务器通过识别Cookies并鉴定出是哪个用户，然后再判断用户是否是登录状态，然后返回对应的响应。</li></ul><p>可以理解为Cookies里面保存了登陆的凭证，有了它，只需要在下次<strong>携带Cookies发送请求</strong>，而不必重新输入用户名、密码等信息重新登录了。</p><p>因此在爬虫中，有时候处理需要登录才能访问的页面时，我们一般会直接将登录成功后获取的Cookies放在请求头里面直接请求，而不必重新模拟登录。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p>会话，本来的含义是指有始有终的一系列动作/消息。比如，打电话时，从拿起电话拨号到挂断电话这中间的一系列过程可以称为一个会话。</p><p>在Web中，会话对象用来存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的Web页之间跳转时，存储在会话对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当用户请求来自应用程序的Web页时，如果该用户还没有会话，则Web服务器将自动创建一个会话对象。当会话过期或被放弃后，服务器将终止该会话。</p><h3 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h3><p>Cookies指某些网站为了辨别用户身份、进行会话跟踪而存储在用户本地终端上的数据。</p><h4 id="会话维持"><a href="#会话维持" class="headerlink" title="会话维持"></a>会话维持</h4><p>当客户端第一次请求服务器时，服务器会返回一个请求头中带有<strong>Set-Cookie</strong>字段的响应给客户端，用来标记是哪一个用户，客户端浏览器会把Cookies保存起来。当浏览器下一次再请求该网站时，浏览器会把此Cookies放到请求头一起提交给服务器，Cookies携带了会话ID消息，服务器检查该Cookies即可找到对应的会话是什么，然后再判断会话来辨认用户状态。</p><p>在成功登录某个网站时，服务器会告诉客户端设置哪些Cookies信息，在后续访问页面时客户端会把Cookies发送给服务器，服务器再找到对应的会话加以判断。如果会话中的某些设置登录状态的变量是有效的，那就证明用户处于登录状态，此时返回登录之后才可以查看的网页内容，浏览器再进行解析便可以看到了。</p><p>反之，如果传给服务器的Cookies是无效的，或者会话已经过期了，我们将不能继续访问页面，此时可能会收到错误的响应或者跳转到登录界面重新登录。</p><p>Cookies和会话需要配合，一个处于客户端，一个处于服务端，二者协作，就实现了登录会话控制。</p><h4 id="属性结构"><a href="#属性结构" class="headerlink" title="属性结构"></a>属性结构</h4><ul><li>Name：该Cookie的名称。一旦创建，该名称便不可更改。</li><li>Value：该Cookie的值。如果值为Unicode字符，需要为字符编码。如果值为二进制数据，则需要使用BASE64编码。</li><li>Domain：可以访问该Cookie的域名。例如，如果设置为<code>.zhihu.com</code>，则所有以<code>zhihu.com</code>结尾的域名都可以访问该Cookie。</li><li>Max Age：该Cookie失效的时间，单位为秒，也常和<strong>Expires</strong>一起使用，通过它可以计算出其有效时间。Max Age如果为正数，则该Cookie在Max Age秒之后失效。如果为负数，则关闭浏览器时Cookie即失效，浏览器不会以任何形式保存该Cookie。</li><li>Path：该Cookie的使用路径。如果设置为<code>/path/</code>，则只有路径为<code>/path/</code>的页面可以访问该Cookie。如果设置为<code>/</code>，则本域名下的所有页面都可以访问该Cookie。</li><li>Size字段：此Cookie的大小。</li><li>HTTP字段：Cookie的<strong>httponly</strong>属性。若此属性为<strong>true</strong>，则只有在HTTP头中会带有此Cookie的信息，而不能通过<code>document.cookie</code>来访问此Cookie。</li><li>Secure：该Cookie是否仅被使用安全协议传输。安全协议有HTTPS和SSL等，在网络上传输数据之前先将数据加密。默认为<strong>false</strong>。</li></ul><h4 id="会话Cookie和持久Cookie"><a href="#会话Cookie和持久Cookie" class="headerlink" title="会话Cookie和持久Cookie"></a>会话Cookie和持久Cookie</h4><ul><li>会话Cookie：把Cookie放在浏览器的内存里，浏览器在关闭之后该Cookie即失效。</li><li>持久Cookie：会将Cookie保存到客户端的硬盘中，下次还可以继续使用，用于长久保存用户登录状态。</li></ul><p>一些持久化登录的网站其实就是把Cookie的有效时间和会话有效期设置得比较长，下次我们再访问页面时仍然携带之前的Cookie，就可以直接保持登录状态。</p><h2 id="常见误区"><a href="#常见误区" class="headerlink" title="常见误区"></a>常见误区</h2><p><strong>关闭浏览器，会话结束</strong></p><p>当我们关闭浏览器时，浏览器不会主动在关闭之前通知服务器它将要关闭，所以服务器不会有机会知道浏览器已经关闭。</p><p>之所以会有这种误区，是因为大部分会话机制都使用<strong>会话Cookie</strong>来保存会话ID信息，而关闭浏览器后Cookies就消失了，再次连接服务器时，也就无法找到原来的会话了。</p><p>如果服务器设置的Cookies保存在硬盘上，或者使用某种手段改写浏览器发出的HTTP请求头，把原来的Cookies发送给服务器，则再次打开浏览器，仍然能够找到原来的会话ID，依旧还是可以保持登录状态的。</p><p>由于关闭浏览器不会导致会话删除，这就需要服务器为会话设置一个失效时间，当距离客户端上一次使用会话的时间超过这个失效时间时，服务器就可以认为客户端已经停止了活动，才会把会话删除以节省存储空间。</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> 原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> cookies </tag>
            
            <tag> 会话 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫的基本原理</title>
      <link href="/2019/08/07/%E7%88%AC%E8%99%AB%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
      <url>/2019/08/07/%E7%88%AC%E8%99%AB%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>我们可以把互联网比作一张大网，而爬虫便是在网上爬行的蜘蛛。</p><p>把网的节点比作一个个网页，爬虫爬到这就相当于访问了该页面，获取了其信息。</p><p>可以把节点间的连线比作网页与网页之间的链接关系，这样蜘蛛通过一个节点后，可以顺着节点连线继续爬行到达下一个节点，即通过一个网页继续获取后续的网页，这样整个网的节点便可以被蜘蛛全部爬行到，网站的数据就可以被抓取下来了。</p><a id="more"></a><h2 id="爬虫概述"><a href="#爬虫概述" class="headerlink" title="爬虫概述"></a>爬虫概述</h2><p>简单来说，爬虫就是获取网页并提取和保存信息的自动化程序。</p><h3 id="获取网页"><a href="#获取网页" class="headerlink" title="获取网页"></a>获取网页</h3><p>爬虫首先要做的工作就是获取网页，这里就是获取网页的源代码。源代码里包含了网页的部分有用信息，所以只要把源代码获取下来，，就可以从中提取想要的信息了。</p><p><strong>最关键的部分就是构造一个请求并发送给服务器，然后接收到响应并将其解析出来。</strong></p><p>Python提供了很多库来帮我们实现这个操作，如<code>urllib</code>、<code>requests</code>等。我们可以用这些库来帮助我们实现HTTP请求操作，请求和响应都可以用类库提供的数据结构来表示，得到相应之后只需要解析数据结构中的<strong>Body</strong>部分即可得到网页的源代码，这样我们可以用程序来实现获取网页的过程了。</p><h3 id="提取信息"><a href="#提取信息" class="headerlink" title="提取信息"></a>提取信息</h3><p>获取网页源代码后，接下来就是分析网页源代码，从中提取我们想要的数据。</p><p>最通用的方法是采用正则表达式提取，这是一个万能的方法，但是在构造正则表达式时比较复杂且容易出错。</p><p>另外，由于网页的结构有一定的规则，所以还有一些根据网页节点属性、CSS选择器或XPath来提取网页信息的库，如<strong>Beautiful Soup</strong>、<strong>Pyquery</strong>、<strong>lxml</strong>等，使用这些库，我们可以高效快速地从中提取网页信息，如节点属性、文本值等。</p><p>提取信息是爬虫非常重要的部分，他可以使杂乱的数据变得条理清晰，以便我们后续处理和分析数据。</p><h3 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h3><p>提取信息后，我们一般会将提取到的数据保存在某处以便后续使用。这里保存形式有多种多样，如可简单保存为<strong>TXT文本</strong>或<strong>JSON文本</strong>，也可以保存到数据库，如<strong>MySQL</strong>和<strong>MongoDB</strong>等，也可保存至远程服务器，如借助<strong>SFTP</strong>进行操作等。</p><h3 id="自动化程序"><a href="#自动化程序" class="headerlink" title="自动化程序"></a>自动化程序</h3><p>即爬虫可以代替人来完成这些操作。当量特别大或者想快速获取大量数据的话，肯定要借助程序。爬虫就是替我们来完成这份爬取工作的自动化程序，它可以在抓取过程中进行各种异常处理、错误重试等操作，确保爬取持续高效地运行。</p><h2 id="能抓怎样的数据"><a href="#能抓怎样的数据" class="headerlink" title="能抓怎样的数据"></a>能抓怎样的数据</h2><ul><li>最常抓取的是<strong>HTML源代码</strong>。</li><li>有些网页返回的是一个<strong>JSON字符串</strong>(其中API接口大多采用这样的形式)，这种格式的数据方便传输和解析，它们同样可以抓取，而且数据提取方便。</li><li><strong>各种二进制数据</strong>，如图片、视频和音频等。利用爬虫，我们可以将这些二进制数据抓取下来，然后保存成对应的文件名。</li><li><strong>各种扩展名的文件</strong>，如CSS、JavaScript和配置文件等，这些其实也是最普通的文件，只要在浏览器里面可以访问到，就可以将其抓取下来。</li></ul><p>上述内容其实都对应各自的URL，是基于HTTP或HTTPS协议的，只要是这种数据，爬虫都可以抓取。</p><h2 id="JavaScript渲染页面"><a href="#JavaScript渲染页面" class="headerlink" title="JavaScript渲染页面"></a>JavaScript渲染页面</h2><p>有时候，我们使用<code>urllib</code>和<code>requests</code>抓取网页时，得到的源代码实际和浏览器中看到的不一样。</p><p>这是由于现在越来越多的网页采用<strong>Ajax</strong>、<strong>前端模块化工具</strong>来构建，整个网页可能都是由JavaScript渲染出来的，也就是说原始的HTML代码就是一个空壳，例如：</p><figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>This is a Demo<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"container"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"app.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>body</code>节点里面只有一个<strong>id为container</strong>的节点，但是需要注意在<code>body</code>节点后引入了<code>app.js</code>，它便负责整个网站的渲染。</p><p>在浏览器中打开这个页面时，首先会加载这个HTML内容，接着浏览器会发现其中引入了一个<code>app.js</code>文件，然后便会接着去请求这个文件，获取到该文件后，便会执行其中的JavaScript代码，而JavaScript则会改变HTML中的节点，向其添加内容，最后得到完整的页面。</p><p>但是用<code>urllib</code>或<code>requests</code>等库请求当前页面时，我们得到的只是这个HTML代码，它不会帮助我们继续去加载这个JavaScript文件，这样也就看不到浏览器中的内容了。</p><p>这也就解释了为什么有时我们得到的源代码和浏览器中看到的不一样。</p><p>因此，使用基本HTTP请求库得到的源代码可能跟浏览器中的页面源代码不太一样。对于这样的情况，我们可以分析其后台<strong>Ajax接口</strong>，也可使用<strong>Selenium</strong>、<strong>Splash</strong>这样的库来实现模拟JavaScript渲染。</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> 原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网页基础</title>
      <link href="/2019/08/06/%E7%BD%91%E9%A1%B5%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/08/06/%E7%BD%91%E9%A1%B5%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>用浏览器访问网站时，网页各不相同，本文简单介绍了网页的基本组成、结构和结点等内容。</p><p>了解了这些内容，我们才有更加清晰的思路去解析和提取网页内容。</p><a id="more"></a><h2 id="网页的组成"><a href="#网页的组成" class="headerlink" title="网页的组成"></a>网页的组成</h2><p>网页可以分为三个部分(<strong>HTML</strong>、<strong>CSS</strong>和<strong>JavaScript</strong>)。</p><p>如果把一个网页比作一个人的话，HTML相当于骨架，CSS相当于皮肤，JavaScript相当于肌肉。</p><p>即，HTML定义了网页的内容和结构，CSS描述了网页的布局，JavaScript定义了网页的行为。</p><p>三者结合起来才能形成一个完善的网页。</p><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p>HTML(Hyper Text Markup Language，超文本标记语言)是用来描述网页的一种语言。</p><p>网页包括文字、按钮、图片和视频等各种复杂元素，其基础架构就是HTML。</p><p>不同类型的元素通过不同类型的标签来表示，如图片用<code>img</code>标签表示，视频用<code>video</code>标签表示，段落用<code>p</code>标签表示。</p><p>它们之间的布局又常通过布局标签<code>div</code>嵌套组合而成，各种标签通过不同的排列和嵌套才形成了网页的框架。</p><p>在浏览器中可以查看网页源代码，以下为www.baidu.com的网页源代码：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E7%BD%91%E9%A1%B5%E5%9F%BA%E7%A1%80/%E7%99%BE%E5%BA%A6%E6%BA%90%E4%BB%A3%E7%A0%81.png" width="70%"></p><p>这就是HTML，整个网页就是由各种标签嵌套组合而成的。这些标签定义的节点元素相互嵌套和组合形成了复杂的层次关系，就形成了网页的架构。</p><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p>HTML定义了网页的结构，但是只有HTML页面的布局并不美观，可能只是简单的节点元素的排列，为了让网页看起来更好看一些，可以借助CSS。</p><p>CSS(Cascading Style Sheets，层叠样式表)。”层叠”是指当在HTML中引用了数个样式文件，并且样式发生冲突时，浏览器能依据层叠顺序处理。”样式”指网页中文字大小、颜色、元素间距、排列等格式。</p><p>CSS是目前唯一的网页页面排版样式标准，有了它的帮助，页面才会变得更为美观。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E7%BD%91%E9%A1%B5%E5%9F%BA%E7%A1%80/CSS.png" width="70%"></p><p>上图中右边<strong>Styles</strong>中存放的即是CSS，例如：</p><figure class="hljs highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">min-width</span>: <span class="hljs-number">1000px</span>;<br>    <span class="hljs-attribute">cursor</span>: default<br>&#125;<br></code></pre></td></tr></table></figure><p>就是一个CSS样式。</p><p>在网页中，一般会统一定义整个网页的样式规则，并写入CSS文件中(其后缀为css)。在HTML中，只需要用link标签即可引入写好的CSS文件，这样整个页面就会变得美观、优雅。</p><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>JavaScript是一种脚本语言。</p><p>若仅仅HTML和CSS配合使用，提供给用户的只是一种静态信息，缺乏交互性。</p><p>我们在网页里可能会看到一些交互和动画效果，如下载进度条、提示框、轮播图等，这通常就是JavaScript的功劳。它的出现使得用户与信息之间不只是一种浏览与现实的关系，而是实现了一种实时、动态、交互的页面功能。</p><p>JavaScript通常也是以单独的文件形式加载的，后缀为<code>js</code>，在HTML中通过<code>script</code>即可引入，例如：</p><p><code>&lt;script src=&quot;jquery-2.1.0.js&quot;&gt;&lt;/script&gt;</code></p><h2 id="网页的结构"><a href="#网页的结构" class="headerlink" title="网页的结构"></a>网页的结构</h2><p>首先以一个例子来讲解一些HTML的基本结构。</p><p>新建一个文本文件，名字可以自取，后缀为<code>html</code>。</p><p>内容如下：</p><figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>This is a Demo<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"container"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"wrapper"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title"</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"text"</span>&gt;</span>Hello, this is a paragraph.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这就是一个最简单的HTML实例。</p><p>开头用<strong>DOCTYPE</strong>定义了文档类型，其次最外层是<code>html</code>标签，最后还有对应的结束标签来表示闭合，其内部是<code>head</code>标签和<code>body</code>标签，分别代表网页头和网页体，它们也需要结束标签。</p><p><code>head</code>标签内定义了一些页面的配置和引用，如：<code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code>指定了网页的编码为UTF-8。</p><p><code>title</code>标签则定义了网页的标题，会显示在网页的选项卡中，不会显示在正文中。</p><p><code>body</code>标签内则是在网页正文中显示的内容。</p><p><code>div</code>标签定义了网页中的区块，它的id是container，这是一个非常常用的属性，且id的内容在网页中是唯一的，我们可以通过它来获取这个区块。然后在此区块内又有一个div标签，它的class为wrapper，这也是一个非常常用的属性，经常与CSS配合使用来设定样式。</p><p><code>h2</code>标签代表一个二级标题。</p><p><code>p</code>标签代表一个段落。</p><p>将代码保存后，在浏览器中打开该文件，可以看到下图所示的内容。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E7%BD%91%E9%A1%B5%E5%9F%BA%E7%A1%80/Demo%E7%BD%91%E9%A1%B5.png" width="70%"></p><p>这个实例便是网页的一般结构。一个网页的标准形式是<code>html</code>标签内嵌套<code>head</code>和<code>body</code>标签。</p><h2 id="节点树及节点间的关系"><a href="#节点树及节点间的关系" class="headerlink" title="节点树及节点间的关系"></a>节点树及节点间的关系</h2><p>在HTML中，所有标签定义的内容都是节点，他们构成了一个<strong>HTML DOM树</strong>。</p><p><strong>DOM(Document Object Model，文档对象模型)</strong>是W3C(万维网联盟)的标准，定义了访问HTML和XML文档的标准：</p><blockquote><p>W3C文档对象模型(DOM)是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。</p></blockquote><p>W3C DOM标准被分为3个不同的部分：</p><ul><li><strong>核心DOM：</strong>针对任何结构化文档的标准模型</li><li><strong>XML DOM：</strong>针对XML文档的标准模型</li><li><strong>HTML DOM：</strong>针对HTML文档的标准模型</li></ul><p>根据W3C的HTML DOM标准，HTML文档中的所有内容都是节点。</p><ul><li>整个文档是一个文档节点</li><li>每个HTML元素是元素节点</li><li>HTML元素内的文本是文本节点</li><li>每个HTML属性是属性节点</li><li>注释是注释节点</li></ul><p><strong>HTML DOM</strong>将HTML文档视作树结构，这种结构被称为节点树，如下图所示：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E7%BD%91%E9%A1%B5%E5%9F%BA%E7%A1%80/HTML%20DOM" width="70%"></p><p><em>通过HTML DOM树中所有的节点均可通过JavaScript访问</em>，所有HTML节点元素均可被修改，也可以被创建或删除。</p><p>节点树中的节点彼此拥有层级关系。常用<strong>父(parent)、子(child)和兄弟(sibling)</strong>等术语描述这些关系。父节点拥有子节点，同级的子节点被称为兄弟。</p><p>在节点树中，顶端节点称为根(root)。除了根结点之外，每个节点都有父节点，同时可拥有任意数量的子节点或兄弟结点。</p><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>网页由一个个节点组成，<strong>CSS选择器</strong>会根据不同的节点设置不同的样式规则。</p><p>在CSS中，我们使用CSS选择器来定位节点。一共有三种方式：</p><ul><li><code>&lt;div id=&quot;container&quot;&gt;</code>，则可以表示为<code>#container</code>，其中#开头代表选择id，其后紧跟id的名称。</li><li>若想选择<strong>class为wrapper</strong>的节点，可以使用<code>.wrapper</code>，这里的<code>.</code>代表选择class，其后紧跟class的名称。</li><li>根据<strong>标签名</strong>筛选，例如想选择二级标题，直接用<code>h2</code>即可。</li></ul><p>另外，CSS选择器还支持<em>嵌套选择</em>，各个选择器之间加上空格分隔开便可以代表嵌套关系，如：<code>#container .wrapper p</code>则代表先选择id为container的节点，然后选其内部的class为wrapper的节点，然后再进一步选其内部的p节点。另外，若不加空格，则代表并列关系，如<code>div#container .wrapper p.text</code>代表先选择id为container的div节点，然后选其中内部的class为wrapper的节点，再进一步选其内部的class为text的p节点。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 网页 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP基本原理</title>
      <link href="/2019/08/06/HTTP%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
      <url>/2019/08/06/HTTP%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>在本文中，我们会详细了解HTTP的基本原理，了解在浏览器中敲入URL到获取网页内容之间发生了什么。</p><a id="more"></a><h2 id="URI和URL"><a href="#URI和URL" class="headerlink" title="URI和URL"></a>URI和URL</h2><ul><li>URI：Uniform Resource Identifier，统一资源标志符。</li><li>URL：Uniform Resource Locator，统一资源定位符。</li></ul><p><a href="https://github.com/favicon.ico" target="_blank" rel="noopener">https://github.com/favicon.ico</a> 是Github的网站图标链接，它是一个URL，也是一个URI。</p><p>即有这样一个图标资源，我们用URL/URI来唯一指定了它的访问方式，这其中包括了<strong>访问协议https</strong>、<strong>访问路径(/即根目录)</strong>、<strong>资源名称</strong>(favicon.ico)。通过这样一个链接，我们便可以从互联网上找到这个资源，这就是URL/URI。</p><p><strong>URL是URI的子集</strong>。URI还包括一个子类<strong>URN</strong>(Uniform Resource Name，即统一资源名称)。URN只命名资源而不指定如何定位资源，比如<code>urn:isbn:0451450523</code>指定了一本书的ISBN，可以唯一标识这本书，但是没有指定到哪里定位这本书。</p><p>URL、URN和URI的关系如下图所示。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/HTTP%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/URN%3AURL%3AURI%E5%85%B3%E7%B3%BB.png" width="30%"></p><p>在目前的互联网中，URN用的非常少，所以几乎所有的URI都是URL。</p><h2 id="超文本-Hypertext"><a href="#超文本-Hypertext" class="headerlink" title="超文本(Hypertext)"></a>超文本(Hypertext)</h2><p>我们在浏览器里看到的网页就是超文本解析而成的，其网页源代码是一系列HTML代码，里面包含了一系列标签，比如img显示图片，p指定显示段落等。浏览器解析这些标签后，便形成了平常看到的网页，而网页的源代码HTML就可以称作超文本。下图是百度网页的源代码。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/HTTP%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/%E7%99%BE%E5%BA%A6%E7%BD%91%E9%A1%B5%E6%BA%90%E4%BB%A3%E7%A0%81.png" width="70%"></p><h3 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h3><p><strong>HTTP</strong>和<strong>HTTPS</strong>是访问资源所需要的协议类型，另外还有<strong>ftp</strong>、<strong>sftp</strong>、<strong>smb</strong>等。</p><p><strong>HTTP</strong>(Hyper Text Transfer Protocol，超文本传输协议)。HTTP协议是用于从网络传输超文本数据到本地浏览器的传送协议，它能保证高效而准确地传送超文本文档。HTTP由<strong>万维网协会</strong>(World Wide Web Consortium)和<strong>Internet工作小组IETF</strong>(Internet Engineering Task Force)共同合作制定的规范，目前广泛使用的是<strong>HTTP1.1版本</strong>。</p><p><strong>HTTPS</strong>(Hyper Text Transfer Protocol over Secure Socket Layer)，以安全为目标的HTTP通道，即HTTP下加入<strong>SSL层</strong>。HTTPS的安全基础是SSL，因此<em>通过它传输的内容都是经过SSL加密的</em>，主要作用可以分为两种：</p><ul><li>建立一个信息安全通道来保证数据传输的安全。</li><li>确认网站的真实性，凡是使用了HTTPS的网站，都可以通过点击浏览器地址栏的锁头标志来查看网站认证之后的真实信息，也可以通过CA机构颁发的安全签章来查询。</li></ul><h2 id="HTTP请求过程"><a href="#HTTP请求过程" class="headerlink" title="HTTP请求过程"></a>HTTP请求过程</h2><ol><li>在浏览器中输入一个URL。</li><li>浏览器向网站所在的服务器发送了一个请求。</li><li>网络服务器接收到这个请求后进行处理和解析，然后返回对应的响应，接着传回给浏览器。</li><li>响应里包含了页面的源代码等内容，浏览器再对其进行解析，便将网页呈现了出来。</li></ol><h2 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h2><p>请求，由客户端向服务端发出，可以分为4部分内容：</p><ul><li>请求方法(Request Method)</li><li>请求的网址(Request URL)</li><li>请求头(Request Header)</li><li>请求体(Request Body)</li></ul><h3 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h3><p>常见的请求方法有两种：<strong>GET</strong>和<strong>POST</strong>。</p><p>在浏览器中直接输入URL并回车，这便发起了一个<strong>GET请求</strong>，请求的参数会直接包含到URL里。例如：在百度中搜索Python，这就是一个GET请求，链接为：<a href="https://www.baidu.com/s?wd=Python，其中URL中包含了请求的参数信息，这里参数wd表示要搜寻的关键字。" target="_blank" rel="noopener">https://www.baidu.com/s?wd=Python，其中URL中包含了请求的参数信息，这里参数wd表示要搜寻的关键字。</a></p><p><strong>POST请求</strong>大多在表单提交时发起。比如，对于一个登录表单，输入用户名和密码后，点击”登录”按钮，这通常会发起一个POST请求，其数据通常以表单的形式传输，而不会体现在URL中。</p><p><strong>GET</strong>和<strong>POST</strong>请求方法的区别：</p><ul><li>GET请求中的参数包含在URL里面，数据可以在URL中看到，而POST请求的URL不会包含这些数据，数据都是通过表单形式传输的，会包含在请求体中。</li><li>GET请求提交的数据最多只有1024个字节，而POST方式没有限制。</li></ul><p>一般来说，登录时，需要提供账号和密码，其中包含了敏感信息，使用GET方法请求的话，密码就会暴露在URL里面，造成密码的泄露，所以最好选择POST方式传输。上传文件时，由于文件的内容比较大，也会选择使用POST方式。</p><p>另外还有其他的一些请求方法，如下表所示：</p><div class="table-container"><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>GET</td><td>请求网页，并返回页面内容</td></tr><tr><td>POST</td><td>大多用于提交表单或上传文件，数据包含在请求体中</td></tr><tr><td>HEAD</td><td>类似于GET请求， 只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td>PUT</td><td>从客户端向服务器传送的数据取代指定文档中的内容</td></tr><tr><td>DELETE</td><td>请求服务器删除指定页面</td></tr><tr><td>CONNECT</td><td>把服务器当做跳板，让服务器代替客户端访问其他网页</td></tr><tr><td>OPTIONS</td><td>允许客户端查看服务器的性能</td></tr><tr><td>TRACE</td><td>回显服务器收到的请求，主要用于测试或诊断</td></tr></tbody></table></div><h3 id="请求网址"><a href="#请求网址" class="headerlink" title="请求网址"></a>请求网址</h3><p>请求的网址，即统一资源定位符URL，它可以唯一确定我们想请求的资源。</p><h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h3><p>用来说明服务器要使用的附加信息，比较重要的信息有Cookie、Referer、User-Agent等。</p><p>常用的请求头信息：</p><ul><li>Accept：请求报头域，用于指定客户端可接受哪些类型的信息。</li><li>Accept-Language：指定客户端可接受的语言类型。</li><li>Accept-Encoding：指定客户端可接受的内容编码。</li><li>Host：用于指定请求资源的主机IP和端口号，其内容为请求URL的原始服务器或网关的位置。从HTTP1.1版本开始，请求必须包含此内容。</li><li>Cookie：常用复数形式Cookies，这是网站为了辨别用户进行会话跟踪而存储在用户本地的数据。它的主要功能是维持当前访问会话。例如：我们输入用户名和密码成功登录某而过网站后，服务器会用会话保存登录状态信息，后面我们每次刷新或请求该站点的其他网页时，会发现都是登录状态，这就是Cookies的功劳。Cookies里有信息标识了我们所对应的服务器的会话，每次浏览器在请求该站点的页面时，都会在请求头中加入Cookies并将其发送给服务器，服务器通过Cookies识别出是我们自己，并且查出当前状态是登录状态，所以返回结果就是登录之后才能看到的网页内容。</li><li>Referer：此内容用来标识这个请求时从哪个页面发过来的，服务器可以拿到这一信息并做出相应的处理，如做来源统计，防盗链处理等。</li><li>User-Agent：简称UA，它是一个特殊的字符串头，可以是服务器识别客户使用的操作系统及版本、浏览器及版本信息。在做爬虫时加上此信息，可以伪装为浏览器；如果不加，很可能会被识别出为爬虫。</li><li>Content-Type：也叫互联网媒体类型(Internet Media Type)或者MIME类型，在HTTP协议消息头中，它用来表示具体请求中的媒体类型信息。例如：text/html代表HTML格式，image/gif代表GIF图片，application/json代表JSON类型等(具体可以查看<a href="[http://tool.oschina.net/commons](http://tool.oschina.net/commons">这里</a>))。</li></ul><p>请求头是请求的重要组成部分，在写爬虫时，大部分情况下都需要设定请求头。</p><h3 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h3><p>请求体一般承载的内容是<strong>POST请求中的表单数据</strong>，而对于GET请求，请求体则为空。</p><p><strong>Content-Type</strong>和<strong>POST提交数据方式</strong>的联系。</p><div class="table-container"><table><thead><tr><th>Content-Type</th><th>提交数据的方式</th></tr></thead><tbody><tr><td>application/x-www-form-urlencoded</td><td>表单数据</td></tr><tr><td>multipart/form-data</td><td>表单文件上传</td></tr><tr><td>application/json</td><td>序列化JSON数据</td></tr><tr><td>text/xml</td><td>XML数据</td></tr></tbody></table></div><p>在爬虫时，如果要构造POST请求，需要使用正确的Content-Type，并了解各种请求库的各个参数设置时使用的是哪种Content-Type，不然可能会导致POST提交后无法正常相应。</p><h2 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h2><p>由服务端返回给客户端，可以分为三部分：</p><ul><li>响应状态码(Response Status Code)</li><li>响应头(Response Headers)</li><li>响应体(Response Body)</li></ul><h3 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h3><p>响应状态码表示服务器的响应状态，如<em>200代表服务器正常响应</em>，<em>404代表页面未找到</em>，<em>500代表服务器内部发生错误</em>。</p><p>在爬虫过程中，我们可以根据状态码来判断服务器响应状态，如状态码为200，则证明成功返回数据，再进行处理，否则直接忽略。</p><p>响应状态码一共分五大类：</p><ul><li>消息响应</li></ul><div class="table-container"><table><thead><tr><th>状态码</th><th>说明</th><th>详情</th></tr></thead><tbody><tr><td>100</td><td>继续</td><td>请求者应当继续提出请求。服务器已收到请求的一部分，正在等待其他部分</td></tr><tr><td>101</td><td>切换协议</td><td>请求者已要求服务器切换协议，服务器已确认并准备切换</td></tr></tbody></table></div><ul><li>成功响应</li></ul><div class="table-container"><table><thead><tr><th>状态码</th><th>说明</th><th>详情</th></tr></thead><tbody><tr><td>200</td><td>成功</td><td>服务器已成功处理了请求</td></tr><tr><td>201</td><td>已创建</td><td>请求成功并且服务器创建了新的资源</td></tr><tr><td>202</td><td>已接受</td><td>服务器已接受请求，但尚未处理</td></tr><tr><td>203</td><td>非授权信息</td><td>服务器已成功处理了请求，但返回的信息可能来自另一个源</td></tr><tr><td>204</td><td>无内容</td><td>服务器成功处理了请求，但没有返回任何内容</td></tr><tr><td>205</td><td>重置内容</td><td>服务器成功处理了请求，内容被重置</td></tr><tr><td>206</td><td>部分内容</td><td>服务器成功处理了部分请求</td></tr></tbody></table></div><ul><li>重定向</li></ul><div class="table-container"><table><thead><tr><th>状态码</th><th>说明</th><th>详情</th></tr></thead><tbody><tr><td>300</td><td>多种选择</td><td>针对请求，服务器可执行多种操作</td></tr><tr><td>301</td><td>已创建</td><td>请求的网页已永久移动到新位置，即永久重定向</td></tr><tr><td>302</td><td>临时移动</td><td>请求的网页暂时跳转到其他页面，即暂时重定向</td></tr><tr><td>303</td><td>非授权信息</td><td>如果原来的请求是POST，重定向目标文档应该通过GET提取</td></tr><tr><td>304</td><td>无内容</td><td>此次请求返回的页面未修改，继续使用上次的资源</td></tr><tr><td>305</td><td>重置内容</td><td>请求者应该使用代理访问该页面</td></tr><tr><td>307</td><td>部分内容</td><td>请求的资源临时从其他位置响应</td></tr></tbody></table></div><ul><li>客户端错误</li></ul><div class="table-container"><table><thead><tr><th>状态码</th><th>说明</th><th>详情</th></tr></thead><tbody><tr><td>400</td><td>错误请求</td><td>服务器无法解析该请求</td></tr><tr><td>401</td><td>未授权</td><td>请求没有进行身份验证或验证未通过</td></tr><tr><td>403</td><td>禁止访问</td><td>服务器拒绝此请求</td></tr><tr><td>404</td><td>未找到</td><td>服务器找不到请求的页面</td></tr><tr><td>405</td><td>方法禁用</td><td>服务器禁用了请求中指定的方法</td></tr><tr><td>406</td><td>不接受</td><td>无法使用请求的内容响应请求的页面</td></tr><tr><td>407</td><td>需要代理授权</td><td>请求者需要使用代理授权</td></tr><tr><td>408</td><td>请求超时</td><td>服务器请求超时</td></tr><tr><td>409</td><td>冲突</td><td>服务器在完成请求时发生冲突</td></tr><tr><td>410</td><td>已删除</td><td>请求的资源已永久删除</td></tr><tr><td>411</td><td>需要有效长度</td><td>服务器不接受不含有效内容长度标头字段的请求</td></tr><tr><td>412</td><td>未满足前提条件</td><td>服务器未满足请求者在请求中设置的其中一个前提条件</td></tr><tr><td>413</td><td>请求实体过大</td><td>请求实体过大，超出服务器的处理能力</td></tr><tr><td>414</td><td>请求URL过长</td><td>请求网址过长，服务器无法处理</td></tr><tr><td>415</td><td>不支持类型</td><td>请求格式不被请求页面支持</td></tr><tr><td>416</td><td>请求范围不符</td><td>页面无法提供请求的范围</td></tr><tr><td>417</td><td>未满足期望值</td><td>服务器未满足期望请求标头字段的要求</td></tr></tbody></table></div><ul><li>服务器端错误</li></ul><div class="table-container"><table><thead><tr><th>状态码</th><th>说明</th><th>详情</th></tr></thead><tbody><tr><td>500</td><td>成功</td><td>服务器遇到错误，无法完成请求</td></tr><tr><td>501</td><td>未实现</td><td>服务器不具备完成请求的功能</td></tr><tr><td>502</td><td>错误网关</td><td>服务器作为网关或代理，从上游服务器收到无效响应</td></tr><tr><td>503</td><td>服务不可用</td><td>服务器目前无法使用</td></tr><tr><td>504</td><td>网关超时</td><td>服务器作为网关或代理。但是没有及时从上游服务器收到请求</td></tr></tbody></table></div><h3 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h3><p>响应头包含了服务器对请求的应答信息，如Content-Type、Server、Set-Cookie等。</p><p>下面简要说明一些常用的头信息：</p><ul><li>Date：标识响应产生的时间。</li><li>Last-Modified：指定资源的最后修改时间。</li><li>Content-Encoding：指定响应内容的编码。</li><li>Server：包含服务器的信息，比如名称、版本号。</li><li>Content-Type：文档类型，指定返回的数据类型是什么，如text/html代表返回HTML文档，application/x-javascript则代表返回JavaScript文件，image/jpeg则代表返回图片。</li><li>Set-Cookie：设置Cookies。响应头中的Set-Cookie告诉浏览器需要将此内容放在Cookies中，下次请求携带Cookies请求。</li><li>Expires：指定响应的过期时间，可以使代理服务器或浏览器将加载的内容更新到缓存中。如果再次访问时，就可以直接从缓存中加载，降低服务器负载，缩短加载时间。</li></ul><h3 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h3><p>响应的正文数据都在响应体中，比如请求网页时，它的响应体就是网页的HTML代码，请求一张图片时，它的响应体就是图片的二进制数据。做爬虫请求网页后，要解析的内容就是响应体。</p><p>在浏览器开发者工具中点击<strong>Preview</strong>，就可以看到网页的源代码，也就是响应体的内容，它是解析的目标。</p><p>在做爬虫时，我们主要通过响应体得到网页的源代码、JSON数据等，然后从中做相应内容的提取。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> HTTP </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell后台执行</title>
      <link href="/2019/08/05/shell%E5%90%8E%E5%8F%B0%E6%89%A7%E8%A1%8C/"/>
      <url>/2019/08/05/shell%E5%90%8E%E5%8F%B0%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>后台执行：<code>nohup sh run.sh &gt;log.txt 2&gt;&amp;1 &amp;</code></p><p>后台查看：<code>ps -ef | grep 13549</code></p><p>终止进程：<code>kill -9 pid</code></p><a id="more"></a><h2 id="后台执行"><a href="#后台执行" class="headerlink" title="后台执行"></a>后台执行</h2><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nohup sh run.sh &gt;log.txt 2&gt;&amp;1 &amp;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[1] 13549  <span class="hljs-comment"># 进程号，后面查看相关信息用到。</span><br></code></pre></td></tr></table></figure><p>这个命令分为五个部分，分别是<code>nohup</code>、<code>sh run.sh</code>、<code>&gt;log.txt</code>、<code>2&gt;&amp;1</code>、<code>&amp;</code>。</p><ul><li><code>nohup</code>和最后的<code>&amp;</code>：表示命令在后台执行</li><li><code>sh run.sh</code>执行<strong>run.sh</strong>脚本</li><li><code>&gt;log.txt</code>是将信息输出到<strong>log.txt</strong>日志中</li><li><code>2&gt;&amp;1</code>是将标准错误信息转变成标准输出，这样就可以将错误信息输出到<strong>log.txt</strong>日志里。</li></ul><p>其中0、1、2分别代表如下含义：</p><ul><li>0：stdin(标准输入)</li><li>1：stdout(标准输出)</li><li>2：stderr(标准错误)</li></ul><h2 id="后台查看"><a href="#后台查看" class="headerlink" title="后台查看"></a>后台查看</h2><h3 id="查看本地进程"><a href="#查看本地进程" class="headerlink" title="查看本地进程"></a>查看本地进程</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps -ef | grep 13549<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">work  12929 44118  0 11:36 pts/2    00:00:00 grep 13549<br></code></pre></td></tr></table></figure><p>这个命令也是分五个部分<code>ps</code> 、<code>-ef</code>、 <code>|</code>、 <code>grep</code>、 <code>13549</code>。</p><ul><li><code>ps</code>表示将某个进程显示出来</li><li><code>-e</code>表示显示所有程序、<code>-f</code>表示显示UID,PPIP,C与STIME栏位</li><li><code>grep</code>表示查找和其后面内容相关的信息，即和<code>13549</code>相关的信息</li><li><code>|</code>是管道命令 是指ps命令与grep同时执行</li></ul><p>输出的信息分别是：UID 、 PID 、PPID 、 C STIME 、 TTY、 TIME 、 CMD。</p><ul><li>UID 程序被该 UID 所拥有</li><li>PID 就是这个程序的 ID</li><li>PPID 则是其上级父程序的ID</li><li>C CPU 使用的资源百分比</li><li>STIME 系统启动时间</li><li>TTY 登入者的终端机位置</li><li>TIME 使用掉的 CPU 时间</li></ul><h3 id="查看hadoop进程"><a href="#查看hadoop进程" class="headerlink" title="查看hadoop进程"></a>查看hadoop进程</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim log.txt<br></code></pre></td></tr></table></figure><h2 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h2><h3 id="终止本地进程"><a href="#终止本地进程" class="headerlink" title="终止本地进程"></a>终止本地进程</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">kill</span> -9 pid<br><span class="hljs-comment"># kill -9 13549</span><br></code></pre></td></tr></table></figure><h3 id="终止hadoop进程"><a href="#终止hadoop进程" class="headerlink" title="终止hadoop进程"></a>终止hadoop进程</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop job -<span class="hljs-built_in">kill</span> jobid<br><span class="hljs-comment"># hadoop job -kill job_20180809144936_572433</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>App爬取相关库的安装</title>
      <link href="/2019/08/05/App%E7%88%AC%E5%8F%96%E7%9B%B8%E5%85%B3%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2019/08/05/App%E7%88%AC%E5%8F%96%E7%9B%B8%E5%85%B3%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>爬虫也可以抓取App的数据。App中的页面要加载出来，首先需要获取数据，而这些数据一般是通过请求服务器的接口来获取的。由于App没有浏览器这种可以比较直观地看到后台请求的工具，所以主要用一些抓包技术来抓取数据。</p><p>本文介绍的抓包工具有 <strong>Charles</strong> 、 <strong>mitmproxy</strong> 和 <strong>mitmdump</strong> 。一些简单的接口可以通过<strong>Charles</strong>或<strong>mitmproxy</strong>分析，找出规律，然后直接用程序模拟来抓取。但是如果遇到更复杂的接口，就需要利用<strong>mitmdump</strong>对接Python来对抓取的请求和响应进行实时处理和保存。</p><p>另外，既然要做规模采集，就需要自动化App的操作而不是人工去采集，所以之力还需要一个工具叫做<strong>Appium</strong>，它可以对App进行自动化控制，如自动化模拟App的点击、下拉等操作。</p><a id="more"></a><h2 id="Charles"><a href="#Charles" class="headerlink" title="Charles"></a>Charles</h2><p>Charles是一个网络抓包工具，相比Fiddler，其功能更为强大，而且跨平台支持得更好，所以可以选用它来作为主要的移动端抓包工具。</p><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>官方网站：<a href="https://www.charlesproxy.com" target="_blank" rel="noopener">https://www.charlesproxy.com</a></li><li>下载链接：<a href="https://www.charlesproxy.com/download" target="_blank" rel="noopener">https://www.charlesproxy.com/download</a></li></ul><h3 id="下载Charles"><a href="#下载Charles" class="headerlink" title="下载Charles"></a>下载Charles</h3><p>可以选择官方正版或者破解版下载。</p><h3 id="证书配置"><a href="#证书配置" class="headerlink" title="证书配置"></a>证书配置</h3><p>现在很多页面都在向HTTPS方向发展，HTTPS通信协议应用得越来越广泛。如果一个App通信应用了HTTPS协议，那么它通信的数据都会是被加密的，常规的截包方法是无法识别请求内部的数据的。</p><p>安装完成后，如果我们想要做HTTPS抓包的话，那么还需要配置一下相关的<strong>SSL证书</strong>。</p><p><strong>Charles</strong>是运行在PC端的，我们要抓取的是App端的数据，所以要在<strong>PC和手机</strong>端都安装证书。</p><p>具体内容配置可以参考这篇<a href="https://www.jianshu.com/p/0bc767840e42" target="_blank" rel="noopener">博客</a>。</p><h2 id="mitmproxy"><a href="#mitmproxy" class="headerlink" title="mitmproxy"></a>mitmproxy</h2><p><strong>mitmproxy</strong>是一个支持HTTP和HTTPS的抓包程序，类似Fiddler、Charles的功能，只不过它是通过控制台的形式操作。</p><p>此外，<strong>mitmproxy</strong>还有两个关联组件：</p><ul><li><strong>mitmdump</strong>：它是<strong>mitmproxy</strong>的命令行接口，利用它可以对接Python脚本，实现监听后的处理。</li><li><strong>mitmweb</strong>：它是一个web程序，通过它可以清楚地观察到mitmproxy捕获的请求。</li></ul><h3 id="相关链接-1"><a href="#相关链接-1" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>Github：<a href="https://github.com/mitmproxy/mitmproxy" target="_blank" rel="noopener">https://github.com/mitmproxy/mitmproxy</a></li><li>官方网站：<a href="https://mitmproxy.org" target="_blank" rel="noopener">https://mitmproxy.org</a></li><li>官方文档：<a href="http://docs.mitmproxy.org" target="_blank" rel="noopener">http://docs.mitmproxy.org</a></li><li>mitmdump脚本：<a href="http://docs.mitmproxy.org/en/stable/scripting/overview.html" target="_blank" rel="noopener">http://docs.mitmproxy.org/en/stable/scripting/overview.html</a></li></ul><h3 id="pip安装"><a href="#pip安装" class="headerlink" title="pip安装"></a>pip安装</h3><p>输入命令：<code>pip3 install mitmproxy</code></p><p>执行完毕后即可完成<strong>mitmproxy</strong>的安装，另外还附带安装了<strong>mitmdump</strong>和<strong>mitmweb</strong>两个组件。</p><h3 id="证书配置-1"><a href="#证书配置-1" class="headerlink" title="证书配置"></a>证书配置</h3><p>对于mitmproxy来说，如果想要截获HTTPS请求，就需要设置证书（该证书在安装后会提供，只需信任即可）。</p><p>首先运行以下命令产生CA证书，并启动mitmproxy：<code>mitmdump</code></p><p>接下来我们可以在用户目录下的<code>.mitmproxy</code>目录里找到CA证书。</p><p>在Mac中，点击<code>mitmproxy-ca-cert.pem</code>这个证书，然后授权信任即可。</p><h2 id="Appium"><a href="#Appium" class="headerlink" title="Appium"></a>Appium</h2><p>Appium是移动端的自动化测试工具，类似于Selenium，利用它可以驱动Android、iOS等设备完成自动化测试，比如模拟点击、滑动、输入等操作。</p><h3 id="相关链接-2"><a href="#相关链接-2" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>Github：<a href="https://github.com/appium/appium" target="_blank" rel="noopener">https://github.com/appium/appium</a></li><li>官方网站：<a href="http://appium.io" target="_blank" rel="noopener">http://appium.io</a></li><li>官方文档：<a href="http://appium.io/introduction.html" target="_blank" rel="noopener">http://appium.io/introduction.html</a></li><li>Python Client：<a href="https://github.com/appium/python-client" target="_blank" rel="noopener">https://github.com/appium/python-client</a></li><li>下载链接：<a href="https://github.com/appium/appium-desktop/releases" target="_blank" rel="noopener">https://github.com/appium/appium-desktop/releases</a></li></ul><h3 id="安装Appium"><a href="#安装Appium" class="headerlink" title="安装Appium"></a>安装Appium</h3><p>首先需要安装Appium。Appium负责驱动移动端来完成一系列操作，对于<strong>iOS</strong>设备来说，它使用苹果的<strong>UIAutomation</strong>来实现驱动；对于<strong>Android</strong>来说，它使用<strong>UIAutomation</strong>和<strong>Selendroid</strong>来实现驱动。</p><p>同时Appium也相当于一个服务器，我们可以向他发送一些操作指令，它会根据不同的指令对移动设备进行驱动，以完成不同的动作。</p><p>两种方法安装：</p><ul><li>Appium Desktop：<a href="https://github.com/appium/appium-desktop/releases" target="_blank" rel="noopener">https://github.com/appium/appium-desktop/releases</a> 选择对应的版本下载安装。</li><li>Node.js：使用命令：<code>npm install -g appium</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> 开发环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发环境配置 </tag>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web库的安装</title>
      <link href="/2019/08/05/Web%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2019/08/05/Web%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>现在日常访问的网站都是Web服务程序搭建而成的。</p><p>Python也有一些这样的Web服务程序，比如Flask、Django等，我们可以拿它来开发网站和接口等。</p><p>在爬虫中主要使用这些Web服务程序来搭建一些API接口。例如：维护一个代理池，代理保存在Redis数据库中，我们要将代理池作为一个公共的组件使用，那么如何构建一个方便的平台来供我们获取这些代理呢？最合适不过的就是通过Web服务提供一个API接口，我们只需要请求接口即可获取新的代理，这样做，简单、高效、实用！</p><p>本文主要介绍Web服务程序<strong>Flask</strong>和<strong>Tornado</strong>。</p><a id="more"></a><h2 id="Flask"><a href="#Flask" class="headerlink" title="Flask"></a>Flask</h2><p>Flask是一个轻量级的Web服务程序，它简单、易用、灵活，这里主要用来做一些API服务。</p><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>Github：<a href="https://github.com/pallets/flask" target="_blank" rel="noopener">https://github.com/pallets/flask</a></li><li>官方文档：<a href="http://flask.pocoo.org" target="_blank" rel="noopener">http://flask.pocoo.org</a></li><li>中文文档：<a href="http://docs.jinkan.org/docs/flask" target="_blank" rel="noopener">http://docs.jinkan.org/docs/flask</a></li><li>PyPI：<a href="https://pypi.python.org/pypi/Flask" target="_blank" rel="noopener">https://pypi.python.org/pypi/Flask</a></li></ul><h3 id="pip安装"><a href="#pip安装" class="headerlink" title="pip安装"></a>pip安装</h3><p>执行命令：<code>pip3 install flask</code></p><h3 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h3><p>安装成功后，可以运行如下实例代码测试：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><br>app = Flask(__name__)<br><br><br><span class="hljs-meta">@app.route("/")</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello World!"</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    app.run()<br></code></pre></td></tr></table></figure><p>可以发现，系统会在<strong>5000端口</strong>开启Web服务，控制台输出如下：</p><p> <strong>* Running on <a href="http://127.0.0.1:5000/" target="_blank" rel="noopener">http://127.0.0.1:5000/</a> (Press CTRL+C to quit)</strong></p><p>直接访问<a href="http://127.0.0.1:5000/" target="_blank" rel="noopener">http://127.0.0.1:5000/</a>，可以观察到网页中呈现了 <strong>Hello World!</strong> ，如下图所示，一个简单的Flask程序就运行成功了。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Web%E5%BA%93%E5%AE%89%E8%A3%85/Flask%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" width="70%"></p><h2 id="Tornado安装"><a href="#Tornado安装" class="headerlink" title="Tornado安装"></a>Tornado安装</h2><p>Tornado是一个支持异步的Web框架，通过使用非阻塞I/O流，它可以支撑成千上万的开放连接，效率非常高。</p><h3 id="相关链接-1"><a href="#相关链接-1" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>Github：<a href="https://github.com/tornadoweb/tornado" target="_blank" rel="noopener">https://github.com/tornadoweb/tornado</a></li><li>PyPI：<a href="https://pypi.python.org/pypi/tornado" target="_blank" rel="noopener">https://pypi.python.org/pypi/tornado</a></li><li>官方文档：<a href="http://www.tornadoweb.org" target="_blank" rel="noopener">http://www.tornadoweb.org</a></li></ul><h3 id="pip安装-1"><a href="#pip安装-1" class="headerlink" title="pip安装"></a>pip安装</h3><p>执行命令：<code>pip3 install tornado</code></p><h3 id="验证安装-1"><a href="#验证安装-1" class="headerlink" title="验证安装"></a>验证安装</h3><p>安装成功后，可以运行如下实例代码测试：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tornado.ioloop<br><span class="hljs-keyword">import</span> tornado.web<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainHandler</span><span class="hljs-params">(tornado.web.RequestHandler)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span><span class="hljs-params">(self)</span>:</span><br>        self.write(<span class="hljs-string">"Hello World!"</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_app</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-keyword">return</span> tornado.web.Application([(<span class="hljs-string">r"/"</span>, MainHandler), ])<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>  app = make_app()<br>  app.listen(<span class="hljs-number">8888</span>)<br>  tornado.ioloop.IOLoop.current().start()<br></code></pre></td></tr></table></figure><p>可以发现，系统会在<strong>8888端口</strong>开启Web服务，控制台没有输出内容。</p><p>直接访问<a href="http://127.0.0.1:8888/" target="_blank" rel="noopener">http://127.0.0.1:8888/</a>，可以观察到网页中呈现了 <strong>Hello World!</strong> ，如下图所示，一个简单的<strong>Tornado</strong>程序就运行成功了。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Web%E5%BA%93%E5%AE%89%E8%A3%85/tornado.png" width="70%"></p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> 开发环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发环境配置 </tag>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>存储库的安装</title>
      <link href="/2019/08/05/%E5%AD%98%E5%82%A8%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2019/08/05/%E5%AD%98%E5%82%A8%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>数据库想要和Python进行交互的话，还需要安装一些Python存储库，如：<strong>MySQL</strong>需要安装<strong>PyMySQL</strong>、<strong>MongoDB</strong>需要安装<strong>PyMongo</strong>等。</p><p>本文主要说明这些存储库的安装方式。</p><a id="more"></a><h2 id="PyMySQL"><a href="#PyMySQL" class="headerlink" title="PyMySQL"></a>PyMySQL</h2><p>在<strong>Python3</strong>中，如果想要将数据存储到<strong>MySQL</strong>中，就需要借助<strong>PyMySQL</strong>来操作。</p><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>Github：<a href="https://github.com/PyMySQL/PyMySQL" target="_blank" rel="noopener">https://github.com/PyMySQL/PyMySQL</a></li><li>官方文档：<a href="http://pymysql.readthedocs.io" target="_blank" rel="noopener">http://pymysql.readthedocs.io</a></li><li>PyPI：<a href="https://pypi.python.org/pypi/PyMySQL" target="_blank" rel="noopener">https://pypi.python.org/pypi/PyMySQL</a></li></ul><h3 id="pip安装"><a href="#pip安装" class="headerlink" title="pip安装"></a>pip安装</h3><p>安装命令：<code>pip3 install pymysql</code></p><h3 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h3><p>使用以下命令进行验证：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python3<br>&gt;&gt;&gt; import pymysql<br>&gt;&gt;&gt; pymysql.VERSION<br>(0, 9, 3, None)<br></code></pre></td></tr></table></figure><p>如果成功输出了其版本内容，则证明PyMySQL成功安装。</p><h2 id="PyMongoDB"><a href="#PyMongoDB" class="headerlink" title="PyMongoDB"></a>PyMongoDB</h2><p>在Python中，如果想要和<strong>MongoDB</strong>进行交互，就需要借助于<strong>PyMongo</strong>库。</p><h3 id="相关链接-1"><a href="#相关链接-1" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>Github：<a href="https://github.com/mongodb/mongo-python-driver" target="_blank" rel="noopener">https://github.com/mongodb/mongo-python-driver</a></li><li>官方文档：<a href="http://api.mongodb.com/python/current" target="_blank" rel="noopener">http://api.mongodb.com/python/current</a></li><li>PyPI：<a href="https://pypi.python.org/pypi/pymongo" target="_blank" rel="noopener">https://pypi.python.org/pypi/pymongo</a></li></ul><h3 id="pip安装-1"><a href="#pip安装-1" class="headerlink" title="pip安装"></a>pip安装</h3><p>安装命令：<code>pip3 install pymongo</code></p><h3 id="验证安装-1"><a href="#验证安装-1" class="headerlink" title="验证安装"></a>验证安装</h3><p>使用以下命令进行验证：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python3<br>&gt;&gt;&gt; import pymongo<br>&gt;&gt;&gt; pymongo.VERSION<br><span class="hljs-string">'3.8.0'</span><br></code></pre></td></tr></table></figure><p>如果成功输出了其版本内容，则证明<strong>PyMongo</strong>成功安装。</p><h2 id="redis-py"><a href="#redis-py" class="headerlink" title="redis-py"></a>redis-py</h2><p>在Python中，如果想要和<strong>Redis</strong>进行交互，就需要借助于<strong>redis-py</strong>库。</p><h3 id="相关链接-2"><a href="#相关链接-2" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>Github：<a href="https://github.com/andymccurdy/redis-py" target="_blank" rel="noopener">https://github.com/andymccurdy/redis-py</a></li><li>官方文档：<a href="https://redis-py.readthedocs.io/" target="_blank" rel="noopener">https://redis-py.readthedocs.io/</a></li></ul><h3 id="pip安装-2"><a href="#pip安装-2" class="headerlink" title="pip安装"></a>pip安装</h3><p>安装命令：<code>pip3 install redis</code></p><h3 id="验证安装-2"><a href="#验证安装-2" class="headerlink" title="验证安装"></a>验证安装</h3><p>使用以下命令进行验证：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python3<br>&gt;&gt;&gt; import redis<br>&gt;&gt;&gt; redis.VERSION<br>(3, 3, 5)<br></code></pre></td></tr></table></figure><p>如果成功输出了其版本内容，则证明<strong>redis-py</strong>成功安装。</p><h2 id="RedisDump"><a href="#RedisDump" class="headerlink" title="RedisDump"></a>RedisDump</h2><p>RedisDump是一个用于Redis数据导入/导出的工具，是基于Ruby实现的，所以要安装RedisDump，需要先安装Ruby。</p><h3 id="相关链接-3"><a href="#相关链接-3" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>Github：<a href="https://github.com/delano/redis-dump" target="_blank" rel="noopener">https://github.com/delano/redis-dump</a></li><li>官方文档：<a href="http://delanotes.com/redis-dump" target="_blank" rel="noopener">http://delanotes.com/redis-dump</a></li></ul><h3 id="gem安装"><a href="#gem安装" class="headerlink" title="gem安装"></a>gem安装</h3><p>安装Ruby(参考<a href="http://www.ruby-lang.org/zh_cn/documentation/installation" target="_blank" rel="noopener">这里</a>)后，利用<strong>gem命令</strong>安装RedisDump：<code>gem install redis-dump</code></p><h3 id="验证安装-3"><a href="#验证安装-3" class="headerlink" title="验证安装"></a>验证安装</h3><p>安装成功后，可以执行如下两个命令：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">redis-dump<br>redis-load<br></code></pre></td></tr></table></figure><p>如果可以成功调用，则说明安装成功。</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> 开发环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发环境配置 </tag>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库的安装</title>
      <link href="/2019/08/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2019/08/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>作为数据存储的重要部分，数据库同样是必不可少的，数据库可以分为关系型数据库和非关系型数据库。</p><p>关系型数据库如SQLite、MySQL、Oracle、SQL Server、DB2等，其数据库是以表的形式存储。</p><p>非关系型数据库如MongoDB、Redis它们的存储形式是键值对，存储形式更加灵活。</p><p>本文主要介绍关系型数据库MySQL以及非关系型数据库MongoDB、Redis的安装。</p><a id="more"></a><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>MySQL是一个轻量级的关系型数据库。</p><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>官方网站：<a href="https://www.mysql.com/cn" target="_blank" rel="noopener">https://www.mysql.com/cn</a></li><li>下载地址：<a href="https://www.mysql.com/cn/downloads" target="_blank" rel="noopener">https://www.mysql.com/cn/downloads</a></li><li>中文教程：<a href="http://www.runoob.com/mysql/mysql-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/mysql/mysql-tutorial.html</a></li></ul><h3 id="Mac下安装"><a href="#Mac下安装" class="headerlink" title="Mac下安装"></a>Mac下安装</h3><p>使用<strong>HomeBrew</strong>安装，直接执行brew命令即可：<code>brew install mysql</code></p><p>启动、停止和重启MySQL服务的命令如下：</p><ul><li><code>sudo mysql.server start</code></li><li><code>sudo mysql.server stop</code></li><li><code>sudo mysql.server restart</code></li></ul><p>Mac一般不会作为服务器使用，如果想取消本地host绑定，那么需要修改<strong>my.cnf</strong>文件，然后重启服务。</p><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><p>MongoDB是由<strong>C++</strong>语言编写的非关系型数据库，是一个基于分布式文件存储的开源数据库系统，其内容存储形式类似JSON对象，它的字段值可以包含其他文档，数组及文档数据，非常灵活。</p><h3 id="相关链接-1"><a href="#相关链接-1" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>官方网站：<a href="https://www.mongodb.com" target="_blank" rel="noopener">https://www.mongodb.com</a></li><li>官方文档：<a href="https://docs.mongodb.com" target="_blank" rel="noopener">https://docs.mongodb.com</a></li><li>Github：<a href="https://github.com/mongodb" target="_blank" rel="noopener">https://github.com/mongodb</a></li><li>中文教程：<a href="https://www.runoob.com/mongodb/mongodb-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/mongodb/mongodb-tutorial.html</a></li></ul><h3 id="Mac下安装-1"><a href="#Mac下安装-1" class="headerlink" title="Mac下安装"></a>Mac下安装</h3><p>使用<strong>HomeBrew</strong>安装，直接执行brew命令即可：<code>brew install mongodb</code></p><p>然后创建一个新文件夹/data/db，用于存放MongoDB数据。</p><p>启动MongoDB命令：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew services start mongodb<br>sudo mongod<br></code></pre></td></tr></table></figure><p>停止和重启MongoDB服务的命令：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew services stop mongodb<br>brew services restart mongodb<br></code></pre></td></tr></table></figure><h3 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h3><p>二选一即可。</p><p><strong>RoboMongo/Robo 3T</strong>：</p><ul><li>官方网址：<a href="https://robomongo.org" target="_blank" rel="noopener">https://robomongo.org</a></li><li>下载链接：<a href="https://robomongo.org/download" target="_blank" rel="noopener">https://robomongo.org/download</a></li></ul><p><strong>Studio 3T</strong>：</p><ul><li>官方网站：<a href="https://studio3t.com" target="_blank" rel="noopener">https://studio3t.com</a></li><li>下载链接：<a href="https://studio3t.com/download" target="_blank" rel="noopener">https://studio3t.com/download</a></li></ul><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>Redis是一个基于内存的高效的非关系型数据库。</p><h3 id="相关链接-2"><a href="#相关链接-2" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>官方网站：<a href="https://redis.io" target="_blank" rel="noopener">https://redis.io</a></li><li>官方文档：<a href="https://redis.io/documentation" target="_blank" rel="noopener">https://redis.io/documentation</a></li><li>中文官网：<a href="http://www.redis.cn" target="_blank" rel="noopener">http://www.redis.cn</a></li><li>Github：<a href="https://github.com/antirez/redis" target="_blank" rel="noopener">https://github.com/antirez/redis</a></li><li>中文教程：<a href="https://www.runoob.com/redis/redis-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/redis/redis-tutorial.html</a></li></ul><h3 id="Mac下安装-2"><a href="#Mac下安装-2" class="headerlink" title="Mac下安装"></a>Mac下安装</h3><p>使用<strong>HomeBrew</strong>安装，直接执行brew命令即可：<code>brew install redis</code></p><p>启动<strong>redis</strong>命令：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew services start redis<br>redis-server /usr/<span class="hljs-built_in">local</span>/etc/redis.conf<br></code></pre></td></tr></table></figure><p>这里可以使用命令：<code>redis-cli</code>进入Redis命令行模式。</p><p>Mac下的Redis配置文件路径是：<code>/usr/local/etc/redis.conf</code>，可以通过修改它来配置访问密码。</p><p>修改配置文件后，需要重启Redis服务。停止和重启Redis服务的命令如下：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew services stop redis<br>brew services restart redis<br></code></pre></td></tr></table></figure><p>另外Mac下可以安装<strong>Redis Desktop Manager</strong>可视化管理工具来管理Redis。</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> 开发环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发环境配置 </tag>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解析库的安装</title>
      <link href="/2019/08/05/%E8%A7%A3%E6%9E%90%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2019/08/05/%E8%A7%A3%E6%9E%90%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>爬取网页代码后，下一步就是从网页中提取信息。</p><p>提取信息的方式有多种多样，可以使用正则表达式来提取，但是写起来相对比较繁琐。</p><p>这里还有许多强大的解析库，如lxml、Beautiful Soup、pyquery等。</p><p>此外还有非常强大的解析方法，如XPath解析和CSS选择器解析等，利用它们，我们可以高效便捷地从网页中提取有效信息。</p><a id="more"></a><h2 id="lxml库"><a href="#lxml库" class="headerlink" title="lxml库"></a>lxml库</h2><p>lxml是Python的一个解析库，支持HTML和XML的解析，支持XPath解析方式而且解析效率非常高。</p><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>官方网站：<a href="http://lxml.de" target="_blank" rel="noopener">http://lxml.de</a></li><li>Github：<a href="https://github.com/lxml/lxml" target="_blank" rel="noopener">https://github.com/lxml/lxml</a></li><li>PyPI：<a href="https://pypi.python.org/pypi/lxml" target="_blank" rel="noopener">https://pypi.python.org/pypi/lxml</a></li></ul><h3 id="pip安装"><a href="#pip安装" class="headerlink" title="pip安装"></a>pip安装</h3><p>命令行输入：<code>pip3 install lxml</code></p><p>如果产生错误，可以执行如下命令将必要的类库安装(Mac操作系统)：<code>xcode-select --install</code></p><p>lxml是一个非常重要的库，后面的Beautiful Soup、Scrapy框架都需要用到此库。</p><h3 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h3><p>安装完成之后，可以在Python命令下测试：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python3<br>&gt;&gt;&gt;import lxml<br></code></pre></td></tr></table></figure><p>如果没有报错，则证明库已经安装好了。</p><h2 id="Beautiful-Soup库"><a href="#Beautiful-Soup库" class="headerlink" title="Beautiful Soup库"></a>Beautiful Soup库</h2><p>Beautiful Soup是Python的一个HTML或XML的解析库，我们可以用它来方便地从网页中提取数据。</p><p>它拥有强大的API和多样的解析方式。</p><h3 id="相关链接-1"><a href="#相关链接-1" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>官方文档：<a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/" target="_blank" rel="noopener">https://www.crummy.com/software/BeautifulSoup/bs4/doc</a></li><li>中文文档：<a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/" target="_blank" rel="noopener">https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/</a></li><li>PyPI：<a href="https://pypi.python.org/pypi/beautifulsoup4" target="_blank" rel="noopener">https://pypi.python.org/pypi/beautifulsoup4</a></li></ul><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>Beautiful Soup的HTML和XML解析器是依赖于lxml库的，所以在此之前请确保已经安装了<strong>lxml库</strong>。</p><h3 id="pip安装-1"><a href="#pip安装-1" class="headerlink" title="pip安装"></a>pip安装</h3><p>目前，Beautiful Soup的最新版本是4.x版本，之前的版本以及停止开发。</p><p>这里推荐使用pip安装，命令为：<code>pip3 install beautifulsoup4</code></p><h3 id="验证安装-1"><a href="#验证安装-1" class="headerlink" title="验证安装"></a>验证安装</h3><p>安装完成之后，可以运行如下代码验证一下：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br>soup = BeautifulSoup(<span class="hljs-string">'&lt;p&gt;hello&lt;/p&gt;'</span>, <span class="hljs-string">'lxml'</span>)<br>print(soup.p.string)<br></code></pre></td></tr></table></figure><p>若输出结果为：<code>hello</code>，则证明安装成功。</p><p><strong>注意</strong>：</p><p>这里我们虽然安装的是beautifulsoup4这个包，但在引入的时候却是bs4。这是因为这个包源代码本身的库文件夹名称就是bs4，所以安装完成之后，这个库文件夹就被移入到本机Python3的lib库里，所以识别到的库文件名就叫做bs4。</p><p>因此，<em>包本身的名称和我们使用时导入的包的名称并不一定是一致的</em>。</p><h2 id="pyquery库"><a href="#pyquery库" class="headerlink" title="pyquery库"></a>pyquery库</h2><p>pyquery是一个强大的网页解析工具，它提供了和jQuery类似的语法来解析HTML文档，支持CSS选择器。</p><h3 id="相关链接-2"><a href="#相关链接-2" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>Github：<a href="https://github.com/gawel/pyquery" target="_blank" rel="noopener">https://github.com/gawel/pyquery</a></li><li>PyPI：<a href="https://pypi.python.org/pypi/pyquery" target="_blank" rel="noopener">https://pypi.python.org/pypi/pyquery</a></li><li>官方文档：<a href="http://pyquery.readthedocs.io" target="_blank" rel="noopener">http://pyquery.readthedocs.io</a></li></ul><h3 id="pip安装-2"><a href="#pip安装-2" class="headerlink" title="pip安装"></a>pip安装</h3><p>命令行：<code>pip3 install pyquery</code></p><h3 id="验证安装-2"><a href="#验证安装-2" class="headerlink" title="验证安装"></a>验证安装</h3><p>安装完成之后，可以在Python命令下测试：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python3<br>&gt;&gt;&gt;import pyquery<br></code></pre></td></tr></table></figure><p>如果没有报错，则证明库已经安装好了。</p><h2 id="tesserocr库"><a href="#tesserocr库" class="headerlink" title="tesserocr库"></a>tesserocr库</h2><p>在爬虫过程中，难免会遇到各种各样的验证码，而大多数验证码还是图形验证码，这时候我们可以直接使用OCR来识别。</p><p>OCR( Optical Character Recognition )，光学字符识别，是指通过扫描字符，然后通过其形状将其翻译成电子文本的过程。对于图形验证码来说，它们都是一些不规则的字符，这些符确实是由字符稍加扭曲变换得到的内容。</p><p>tesserocr是Python的一个OCR识别库，但其实是对tesseract做的一层Python API封装，所以它的核心是tesseract。因此，在安装tesserocr之前，我们需要安装tesseract。</p><h3 id="相关链接-3"><a href="#相关链接-3" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>tesserocr Github：<a href="https://github.com/sirfz/tesserocr" target="_blank" rel="noopener">https://github.com/sirfz/tesserocr</a></li><li>tesserocr PyPI：<a href="https://pypi.python.org/pypi/tesserocr" target="_blank" rel="noopener">https://pypi.python.org/pypi/tesserocr</a></li><li>tesseract 下载地址：<a href="http://digi.bib.uni-mannheim.de/tesseract" target="_blank" rel="noopener">http://digi.bib.uni-mannheim.de/tesseract</a></li><li>tesseract Github：<a href="https://github.com/tesseract-ocr/tesseract" target="_blank" rel="noopener">https://github.com/tesseract-ocr/tesseract</a></li><li>tesseract 语言包：<a href="https://github.com/tesseract-ocr/tessdata" target="_blank" rel="noopener">https://github.com/tesseract-ocr/tessdata</a></li><li>tesseract文档：<a href="https://github.com/tesseract-ocr/tesseract/wiki/Documentation" target="_blank" rel="noopener">https://github.com/tesseract-ocr/tesseract/wiki/Documentation</a></li></ul><h3 id="Mac下安装"><a href="#Mac下安装" class="headerlink" title="Mac下安装"></a>Mac下安装</h3><ol><li>使用<strong>HomeBrew</strong>安装<strong>ImageMagick</strong>和<strong>tesseract</strong>库。</li></ol><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install imagemagick<br>//先安装依赖库libpng, jpeg, libtiff, leptonica<br>brew install leptonica<br>brew install tesseract<br></code></pre></td></tr></table></figure><ol><li><p>下载语言库</p><p> 下载地址:<a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Ftesseract-ocr%2Ftessdata" target="_blank" rel="noopener">https://github.com/tesseract-ocr/tessdata</a></p><p> 根据自己的需求选择所要的语言库，在这里我们选择的是简体中文和英文，所以选择的库是<code>chi_sim.traineddata</code>、<code>eng.traineddata</code><br>  将文件拷贝到到：/usr/local/Cellar/tesseract/4.1.0/share/tessdata目录下。</p></li><li><p>接下来再安装tesserocr即可</p></li></ol><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip3 install tesserocr pillow<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：</p><p>这里可能会出现无法安装<strong>tesserocr</strong>的错误，需要执行以下两个步骤：</p><ol><li>命令行中输入：<code>xcode-select --install</code></li></ol><p>输出：</p><p><strong>xcode-select: error: command line tools are already installed, use “Software Update” to install updates</strong></p><p>不用管它。</p><ol><li>命令行中输入：<code>export MACOSX_DEPLOYMENT_TARGET=10.13</code></li></ol><p>这里 <strong>10.13</strong> 是我自己的macOS的系统版本号。换成自己电脑相对应的就行。</p><ol><li>执行以上两个步骤，再次执行<code>pip3 install tesserocr pillow</code>就能成功安装啦。</li></ol><h3 id="验证安装-3"><a href="#验证安装-3" class="headerlink" title="验证安装"></a>验证安装</h3><p>可以使用tesseract和tesserocr来分别进行测试。</p><p>从<a href="https://raw.githubusercontent.com/Python3WebSpider/TestTess/master/image.png" target="_blank" rel="noopener">链接</a>中获取样例图片，如下所示。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E8%A7%A3%E6%9E%90%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/%E9%AA%8C%E8%AF%81%E7%A0%81.png" width="50%"></p><p>首先使用命令进行测试，将图片下载来并保存为<strong>image.png</strong>，然后用<code>tesseract</code>命令测试：</p><p><code>tesseract image.png result -l eng &amp;&amp; cat result.txt</code></p><p>运行结果如下：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Tesseract Open Source OCR Engine v4.1.0 with Leptonica<br>Python3WebSpider<br></code></pre></td></tr></table></figure><p>这里我们调用了<code>tesseract</code>命令，其中</p><ul><li>第一个参数为图片名称。</li><li>第二个参数result为结果保存的目标文件名称。</li><li><code>-l</code>指定使用的语言包，此处使用英文(eng)。</li><li>然后再用cat命令将结果输出。</li></ul><p>运行结果便是图片的识别结果：<code>Python3WebSpider</code>，可以看到，这时已经成功将图片转化为文本了。</p><p>然后还可以利用Python代码来进行测试，这里就需要借助于tesserocr库了，测试代码如下：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tesserocr<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br>image = Image.open(<span class="hljs-string">'image.png'</span>)<br>print(tesserocr.image_to_text(image))<br></code></pre></td></tr></table></figure><p>我们首先使用<code>Image</code>读取了图片文件，然后调用了<strong>tesserocr</strong>的<code>image_to_text()</code>方法，再将其识别结果输出。</p><p>运行结果如下：</p><p><code>Python3WebSpider</code></p><p>另外，我们还可以直接调用<code>file_to_text()</code>方法，达到同样的效果：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tesserocr<br>print(tesserocr.file_to_text(<span class="hljs-string">'image.png'</span>))<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><code>Python3WebSpider</code></p><p>如果成功输出结果，则证明<strong>tesseract</strong>和<strong>tesserocr</strong>都已经成功安装。</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> 开发环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发环境配置 </tag>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>请求库的安装</title>
      <link href="/2019/08/03/%E8%AF%B7%E6%B1%82%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2019/08/03/%E8%AF%B7%E6%B1%82%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>爬虫可以简单分为几步：抓取页面、分析页面和存储数据。</p><p>在抓取页面的过程中，我们需要模拟浏览器向服务器发出请求，所以需要用到一些Python库来实现HTTP请求操作。</p><p>我们要用到的第三方库有requests、Selenium和aiohttp等。</p><a id="more"></a><h2 id="requests库"><a href="#requests库" class="headerlink" title="requests库"></a>requests库</h2><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>Github：<a href="https://github.com/requests/requests" target="_blank" rel="noopener">https://github.com/requests/requests</a></li><li>PyPI：<a href="https://pypi.python.org/pypi/requests" target="_blank" rel="noopener">https://pypi.python.org/pypi/requests</a></li><li>官方文档：<a href="https://www.python-requests.org" target="_blank" rel="noopener">https://www.python-requests.org</a>  (需要科学上网)</li><li>中文文档：<a href="http://docs.python-requests.org/zh_CN/latest" target="_blank" rel="noopener">http://docs.python-requests.org/zh_CN/latest</a></li></ul><h3 id="pip安装-推荐"><a href="#pip安装-推荐" class="headerlink" title="pip安装(推荐)"></a>pip安装(推荐)</h3><p>在命令行界面中运行如下命令，即可完成requests库的安装。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip3 install requests<br></code></pre></td></tr></table></figure><h3 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h3><p>如果想要获取某一特定版本，可以选择下载源码安装。</p><p>requests项目的地址是：<a href="https://github.com/psf/requests" target="_blank" rel="noopener">https://github.com/psf/requests</a></p><p>可以通过Git来下载源代码：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/psf/requests.git<br></code></pre></td></tr></table></figure><p>下载完成后，进入目录，进行安装</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> requests<br>python3 setup.py install<br></code></pre></td></tr></table></figure><h3 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h3><p>进入Python命令行交互模式，导入requests包，如果没有报错，则证明安装成功：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python3<br>&gt;&gt;&gt; import requests<br></code></pre></td></tr></table></figure><h2 id="Selenium库"><a href="#Selenium库" class="headerlink" title="Selenium库"></a>Selenium库</h2><p>Selenium是一个自动化测试工具，利用它我们可以驱动浏览器执行特定的动作，如点击、下拉等操作。</p><p>对于一些JavaScript渲染的页面来说，这种抓取方式非常有效。</p><h3 id="相关链接-1"><a href="#相关链接-1" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>Github：<a href="https://github.com/SeleniumHQ/selenium/tree/master/py" target="_blank" rel="noopener">https://github.com/SeleniumHQ/selenium/tree/master/py</a></li><li>PyPI：<a href="https://pypi.org/project/selenium/" target="_blank" rel="noopener">https://pypi.org/project/selenium/</a></li><li>官方文档：<a href="https://selenium-python.readthedocs.io/" target="_blank" rel="noopener">https://selenium-python.readthedocs.io/</a></li><li>中文文档：<a href="https://selenium-python-zh.readthedocs.io/en/latest/" target="_blank" rel="noopener">https://selenium-python-zh.readthedocs.io/en/latest/</a></li></ul><h3 id="pip安装-推荐-1"><a href="#pip安装-推荐-1" class="headerlink" title="pip安装(推荐)"></a>pip安装(推荐)</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip3 install selenium<br></code></pre></td></tr></table></figure><h3 id="验证安装-1"><a href="#验证安装-1" class="headerlink" title="验证安装"></a>验证安装</h3><p>进入Python命令行交互模式，导入selenium包，如果没有报错，则证明安装成功：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python3<br>&gt;&gt;&gt; import selenium<br></code></pre></td></tr></table></figure><p>但是这样做还不够，还需要用浏览器(如Chrome、Firefox等)来配合Selenium工作。</p><h2 id="ChromeDriver的安装"><a href="#ChromeDriver的安装" class="headerlink" title="ChromeDriver的安装"></a>ChromeDriver的安装</h2><p>上一部已经安装好Selenium，但是它是一个自动化测试工具，需要浏览器来配合使用。</p><p>该节中我们就介绍一下Chrome浏览器及ChromeDriver驱动的配置。</p><h3 id="相关链接-2"><a href="#相关链接-2" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>官方网址：<a href="https://sites.google.com/a/chromium.org/chromedriver" target="_blank" rel="noopener">https://sites.google.com/a/chromium.org/chromedriver</a> (需要科学上网)</li><li>下载地址：<a href="https://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">https://chromedriver.storage.googleapis.com/index.html</a></li></ul><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>确保安装好Chrome浏览器并可以正常运行。</p><h3 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h3><p>点击Chrome菜单 “帮助” -&gt; “关于Google Chrome(G)”，即可查看Chrome的版本号，如下图所示。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E7%89%88%E6%9C%AC.png" width="70%"></p><p>这里我的版本号是 <em>75.0</em> ，这个版本号在选择ChromeDriver版本的时候会用到。</p><h3 id="下载ChromeDriver"><a href="#下载ChromeDriver" class="headerlink" title="下载ChromeDriver"></a>下载ChromeDriver</h3><p>打开<a href="https://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">下载链接</a>，选择对应的版本进行下载。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/ChromeDriver%E7%89%88%E6%9C%AC.png" width="70%"></p><h3 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h3><p>下载完成后，将ChromeDriver的可执行文件配置到环境变量下。</p><ul><li>在Windows下，建议直接将ChromeDriver.exe文件拖到Python的Scripts目录下。</li><li>在Linux和Mac下，需要将可执行文件配置到环境变量或将文件移动到属于环境变量的目录里。</li></ul><p>Mac配置：</p><p>方法一：</p><p>例如要移动文件到<code>/usr/bin</code>目录。首先需要在命令行模式下进入其所在路径，然后将其移动到<code>/usr/bin</code>：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo mv chromedriver /usr/bin<br></code></pre></td></tr></table></figure><p>另外，若系统为Mac OS X EI Capitan 10.11 及以上版本时，需要先关闭Rootless内核保护机制。具体操作如下：</p><ol><li>重启电脑后按住<code>command+R</code>进入恢复分区。</li><li>在<code>实用工具栏</code>找到<code>终端</code>启动运行。</li><li>输入：<code>csrutil disable; reboot</code>。</li><li>执行上述移动语句：<code>sudo mv chromedriver /usr/bin</code>。</li><li>重复执行1-2，在3中输入：<code>csrutil enable; reboot</code>，开启保护。</li></ol><p>方法二：</p><p>将ChromeDriver配置到<code>$PATH</code>：</p><ol><li><p>将可执行文件放到某一目录，目录可以任意选择。例如将当前可执行文件放在<code>/usr/local/chromedriver</code>目录下。</p></li><li><p>Linux修改<code>~/.profile</code>文件，mac修改<code>~/.bash_profile</code>文件，添加如下内容：</p><p> <code>export PATH=&quot;$PATH:/usr/local/chromedriver&quot;</code></p></li><li><p>保存后，</p><ul><li>在linux执行：<code>source ~/.profile</code></li><li>在mac执行：<code>source ~/.bash_profile</code></li></ul></li></ol><h3 id="验证安装-2"><a href="#验证安装-2" class="headerlink" title="验证安装"></a>验证安装</h3><p>配置完成后，可以在命令行中直接执行<code>chromedriver</code>命令了</p><p>如果输入控制台有如下所示的输出，则证明ChromeDriver的环境变量配置好了。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/chromedriver%E6%8E%A7%E5%88%B6%E5%8F%B0.png" width="70%"></p><p>随后再在程序中测试，执行如下Python代码：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br>browser = webdriver.Chrome()<br></code></pre></td></tr></table></figure><p>运行后，如果弹出一个空白的Chrome浏览器，则证明所有的配置都没有问题。如果没有弹出，则检查之前的每一步配置。</p><p>如果弹出后闪退，则可能是ChromeDriver版本和Chrome版本不兼容，请更换ChromeDriver版本。</p><h2 id="PhantomJS的安装"><a href="#PhantomJS的安装" class="headerlink" title="PhantomJS的安装"></a>PhantomJS的安装</h2><p>PhantomJS是一个无界面的、可脚本编程的WebKit浏览器引擎，它原生支持多种Web标准：DOM操作，CSS选择器，JSON，Canvas以及SVG。</p><p>Selenium支持PhantomJS，这样在运行的时候就不会再弹出一个浏览器了。而且PhantomJS的运行效率也很高，还支持各种参数配置，使用非常方便。</p><h3 id="相关链接-3"><a href="#相关链接-3" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>官方网站：<a href="http://phantomjs.org" target="_blank" rel="noopener">http://phantomjs.org</a></li><li>官方文档：<a href="https://phantomjs.org/quick-start.html" target="_blank" rel="noopener">https://phantomjs.org/quick-start.html</a></li><li>下载地址：<a href="https://phantomjs.org/download.html" target="_blank" rel="noopener">https://phantomjs.org/download.html</a></li><li>API接口说明：<a href="https://phantomjs.org/api/command-line.html" target="_blank" rel="noopener">https://phantomjs.org/api/command-line.html</a></li></ul><h3 id="下载PhantomJS"><a href="#下载PhantomJS" class="headerlink" title="下载PhantomJS"></a>下载PhantomJS</h3><p>在<a href="https://phantomjs.org/download.html" target="_blank" rel="noopener">下载页面</a>选择对应的操作系统版本进行下载，并将PhantomJS可执行文件所在的路径配置到环境变量里（与ChromeDriver安装一致）。</p><p>配置成功后，可以在命令行下测试，输入：<code>phantomjs</code></p><p>如果可以进入到PhantomJS的命令行，则证明配置完成。</p><h3 id="验证安装-3"><a href="#验证安装-3" class="headerlink" title="验证安装"></a>验证安装</h3><p>在Selenium中使用的话，只需要将Chrome切换成PhantomJS即可：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br>driver = webdriver.PhantomJS()<br>driver.get(<span class="hljs-string">"http://www.baidu.com/"</span>)<br>print(driver.current_url)<br></code></pre></td></tr></table></figure><p>运行之后就会发现没有浏览器弹出了，但实际上PhantomJS已经运行起来了。</p><p>这里我们访问了百度，然后将当前URL打印出来了。</p><p>控制台的输出为：<code>https://www.baidu.com</code></p><p>如此一来，我们便完成了PhantomJS的配置，后面可以利用它来完成一些页面的抓取。</p><h2 id="aiohttp库"><a href="#aiohttp库" class="headerlink" title="aiohttp库"></a>aiohttp库</h2><p>上述提到的requests库是一个阻塞式HTTP请求库。(当我们发出一个请求后，程序会一直等待服务器响应，直到得到响应后，程序才会进行下一步处理)。其实，这个过程比较耗费时间。</p><p>如果程序可以在这个等待过程中做一些其他事情，如进行请求的调度、响应的处理等，那么爬取的效率会大大提高。</p><p>aiohttp就是这样一个提供异步Web服务的库，从Python3.5版本开始，Python中加入了<code>async/await</code>关键字，使得回调的写法更加直观和人性化。aiohttp的异步操作借助于<code>async/await</code>关键字的写法变得更加简洁，架构更加清晰。使用异步请求库进行数据抓取时，会大大提高效率。</p><h3 id="相关链接-4"><a href="#相关链接-4" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>官方文档：<a href="http://aiohttp.readthedocs.io/en/stable" target="_blank" rel="noopener">http://aiohttp.readthedocs.io/en/stable</a></li><li>Github：<a href="https://github.com/aio-libs/aiohttp/" target="_blank" rel="noopener">https://github.com/aio-libs/aiohttp/</a></li><li>PyPI：<a href="https://pypi.org/project/aiohttp/3.5.4/" target="_blank" rel="noopener">https://pypi.org/project/aiohttp/3.5.4/</a></li></ul><h3 id="pip安装"><a href="#pip安装" class="headerlink" title="pip安装"></a>pip安装</h3><p>安装命令：<code>pip3 install aiohttp</code></p><p>另外，官方还推荐安装如下两个库：</p><ul><li>字符编码检测库<strong>cchardet</strong></li><li>加速DNS的解析库<strong>aiodns</strong></li></ul><p>安装命令：<code>pip3 install cchardet aiodns</code></p><h3 id="测试安装"><a href="#测试安装" class="headerlink" title="测试安装"></a>测试安装</h3><p>安装完成后，可以在Python命令行下测试：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python3<br>&gt;&gt;&gt; import aiohttp<br></code></pre></td></tr></table></figure><p>如果没有错误报出，则证明库已经安装好了。</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> 开发环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发环境配置 </tag>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天一个linux命令(1): ls</title>
      <link href="/2019/08/03/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4-1-ls/"/>
      <url>/2019/08/03/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4-1-ls/</url>
      
        <content type="html"><![CDATA[<p>ls命令是linux下最常用的命令。ls命令就是list的缩写，缺省下ls用来打印出当前目录的清单，如果ls指定其他目录，那么就会显示指定目录里的文件及文件夹清单。</p><p>通过ls命令不仅可以查看linux文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限)、查看目录信息等等。ls命令在日常的linux操作中用的很多。</p><a id="more"></a><h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ls [选项] [目录名]<br></code></pre></td></tr></table></figure><h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p>列出目标目录中所有的子目录和文件。</p><h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">-a,—all</td><td style="text-align:left">列出目录下的所有文件，包括以 . 开头的隐含文件</td></tr><tr><td style="text-align:left">-A</td><td style="text-align:left">同-a，但不列出“.”(表示当前目录)和“..”(表示当前目录的父目录)。</td></tr><tr><td style="text-align:left">-c  配合 -lt</td><td style="text-align:left">根据 ctime 排序及显示 ctime (文件状态最后更改的时间)配合 -lt：显示 ctime 但根据名称排序否则：根据 ctime 排序</td></tr><tr><td style="text-align:left">-C</td><td style="text-align:left">每栏由上至下列出项目</td></tr><tr><td style="text-align:left">-color[=WHEN]</td><td style="text-align:left">控制是否使用色彩分辨文件。WHEN 可以是’never’、’always’或’auto’其中之一</td></tr><tr><td style="text-align:left">-d,—directory</td><td style="text-align:left">将目录象文件一样显示，而不是显示其下的文件。</td></tr><tr><td style="text-align:left">-D,—dired</td><td style="text-align:left">产生适合 Emacs 的 dired 模式使用的结果</td></tr><tr><td style="text-align:left">-f</td><td style="text-align:left">对输出的文件不进行排序，-aU 选项生效，-lst 选项失效</td></tr><tr><td style="text-align:left">-g</td><td style="text-align:left">类似 -l,但不列出所有者</td></tr><tr><td style="text-align:left">-G, —no-group</td><td style="text-align:left">不列出任何有关组的信息</td></tr><tr><td style="text-align:left">-h,—human-readable</td><td style="text-align:left">以容易理解的格式列出文件大小 (例如 1K 234M 2G)</td></tr><tr><td style="text-align:left">—si</td><td style="text-align:left">类似 -h,但文件大小取 1000 的次方而不是 1024</td></tr><tr><td style="text-align:left">-H, —dereference-command-line</td><td style="text-align:left">使用命令列中的符号链接指示的真正目的地</td></tr><tr><td style="text-align:left">—indicator-style=&lt;方式&gt;</td><td style="text-align:left">指定在每个项目名称后加上指示符号&lt;方式&gt;：none (默认)，classify (-F)，file-type (-p)</td></tr><tr><td style="text-align:left">-i, —inode</td><td style="text-align:left">印出每个文件的 inode 号</td></tr><tr><td style="text-align:left">-I,—ignore=样式</td><td style="text-align:left">不印出任何符合 shell 万用字符&lt;样式&gt;的项目</td></tr><tr><td style="text-align:left">-k</td><td style="text-align:left">即 –block-size=1K,以 k 字节的形式表示文件的大小</td></tr><tr><td style="text-align:left">-l</td><td style="text-align:left">除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来。</td></tr><tr><td style="text-align:left">-L, —dereference</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">-m</td><td style="text-align:left">所有项目以逗号分隔，并填满整行行宽</td></tr><tr><td style="text-align:left">-o</td><td style="text-align:left">类似 -l,显示文件的除组信息外的详细信息。</td></tr><tr><td style="text-align:left">-r, —reverse</td><td style="text-align:left">依相反次序排列</td></tr><tr><td style="text-align:left">-R, —recursive</td><td style="text-align:left">同时列出所有子目录层</td></tr><tr><td style="text-align:left">-s,—size</td><td style="text-align:left">以块大小为单位列出所有文件的大小</td></tr><tr><td style="text-align:left">-S</td><td style="text-align:left">根据文件大小排序</td></tr><tr><td style="text-align:left">—sort=WORD</td><td style="text-align:left">可选用的 WORD 和它们代表的相应选项： <br>extension -X status -c<br>none -U time -t<br>size -S atime -u<br>time -t access -u<br>version -v use -u</td></tr><tr><td style="text-align:left">-t</td><td style="text-align:left">以文件修改时间排序</td></tr><tr><td style="text-align:left">-u</td><td style="text-align:left">配合 -lt:显示访问时间而且依访问时间排序<br>配合 -l:显示访问时间但根据名称排序<br>否则：根据访问时间排序</td></tr><tr><td style="text-align:left">-U</td><td style="text-align:left">不进行排序;依文件系统原有的次序列出项目</td></tr><tr><td style="text-align:left">-v</td><td style="text-align:left">根据版本进行排序</td></tr><tr><td style="text-align:left">-w, —width=COLS</td><td style="text-align:left">自行指定屏幕宽度而不使用目前的数值</td></tr><tr><td style="text-align:left">-x</td><td style="text-align:left">逐行列出项目而不是逐栏列出</td></tr><tr><td style="text-align:left">-X</td><td style="text-align:left">根据扩展名排序</td></tr><tr><td style="text-align:left">-1</td><td style="text-align:left">每行只列出一个文件</td></tr><tr><td style="text-align:left">—help</td><td style="text-align:left">显示此帮助信息并离开</td></tr><tr><td style="text-align:left">—version</td><td style="text-align:left">显示版本信息并离开</td></tr></tbody></table></div><h2 id="常用范例"><a href="#常用范例" class="headerlink" title="常用范例"></a>常用范例</h2><p><code>例一</code>：<strong>列出/home/huben/ 文件夹下的所有文件和目录的详细信息</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ls -l -R /home/huben<br>$ ls -lR /home/huben<br></code></pre></td></tr></table></figure><p><code>例二</code>：<strong>列出当前目录中所有以“t”开头的目录的详细内容，可以使用如下命令</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ls -l t*<br></code></pre></td></tr></table></figure><p><code>例三</code>：<strong>只列出文件下的子目录</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ls -F /opt/soft |grep /$<br></code></pre></td></tr></table></figure><p><code>例四</code>：<strong>列出文件下的子目录详细情况</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ls -l /opt/soft | grep <span class="hljs-string">"^d"</span><br></code></pre></td></tr></table></figure><p><code>例五</code>：<strong>列出目前工作目录下所有名称是s 开头的文件，愈新的排愈后面，可以使用如下命令</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ls -ltr s*<br></code></pre></td></tr></table></figure><p><code>例六</code>：<strong>列出目前工作目录下所有档案及目录;目录于名称后加”/“, 可执行档于名称后加*</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ls -AF<br></code></pre></td></tr></table></figure><p><code>例七</code>：<strong>计算当前目录下的文件数和目录数</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ls -l * |grep <span class="hljs-string">"^-"</span>|wc -l    ---文件个数<br>$ ls -l * |grep <span class="hljs-string">"^d"</span>|wc -l    ---目录个数<br></code></pre></td></tr></table></figure><p><code>例八</code>：<strong>在ls中列出文件的绝对路径</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ls | sed <span class="hljs-string">"s:^:`pwd`/:"</span><br></code></pre></td></tr></table></figure><p><code>例九</code>：<strong>列出当前目录下的所有文件（包括隐藏文件）的绝对路径， 对目录不做递归</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ find <span class="hljs-variable">$PWD</span> -maxdepth 1 | xargs ls -ld<br></code></pre></td></tr></table></figure><p><code>例十</code>：<strong>列出当前目录下的所有文件（包括隐藏文件）的绝对路径， 对目录不做递归</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ find <span class="hljs-variable">$PWD</span> -maxdepth 1 | xargs ls -ld<br></code></pre></td></tr></table></figure><p><code>例十一</code>：<strong>递归列出当前目录下的所有文件（包括隐藏文件）的绝对路径</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ find <span class="hljs-variable">$PWD</span> | xargs ls -ld<br></code></pre></td></tr></table></figure><p><code>例十二</code>：<strong>指定文件时间输出格式</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ls -tl --time-style=full-iso<br>$ ls -ctl --time-style=long-iso<br><br>2016-08-05 22:17:06.020535551 +0800<br>2016-10-29 12:03<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> linux基础命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python多线程</title>
      <link href="/2019/08/03/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2019/08/03/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>本文主要介绍了以下内容:</strong></p><p>Python多线程相关基础</p><a id="more"></a><h2 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h2><p>Python中多线程用在IO密集型代码中。</p><ul><li>计算密集型：需要大量计算，绝大部分时间都消耗在CPU计算上，此时，无论开多少线程，所需要的时间就是那么多，甚至比原来时间还长，因为全局解释器锁(GIL)一个时刻只让跑一个线程，大部分计算密集型任务分了很多线程但是依然会按照代码顺序线性执行，甚至代码变得冗长了，反而使执行时间增加了。</li><li>IO密集型：90%以上的时间都花费在网络、硬盘、输入输出上，CPU执行完命令之后剩下的就不需要在CPU中跑了，就可以释放内存在跑下一条命令了。</li></ul><p>每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。</p><p>但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p><p>每个线程都有自己的一组CPU寄存器，称为线程的上下文，该上下文反映了线程上次运行该线程的CPU寄存器的状态。</p><p>指令指针和堆栈指针寄存器是线程上下文中两个最重要的寄存器，线程总是在进程得到上下文中运行的，这些地址都用于标志拥有线程的进程的进程地址空间中的内存。</p><ul><li>线程可以被抢断(中断)</li><li>在其他线程正在运行时，线程可以暂时搁置(也称为睡眠）— — 即线程的退让。</li></ul><p>线程可分为：</p><ul><li>内核线程：由操作系统内核创建和撤销。</li><li>用户线程：不需要内核支持而在用户程序中实现的线程。</li></ul><h2 id="Threading模块"><a href="#Threading模块" class="headerlink" title="Threading模块"></a>Threading模块</h2><h4 id="Threading模块对象"><a href="#Threading模块对象" class="headerlink" title="Threading模块对象"></a>Threading模块对象</h4><div class="table-container"><table><thead><tr><th style="text-align:center">对象</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">Thread</td><td style="text-align:center">线程对象</td></tr><tr><td style="text-align:center">Lock</td><td style="text-align:center">互斥锁</td></tr><tr><td style="text-align:center">Condition</td><td style="text-align:center">条件变量</td></tr><tr><td style="text-align:center">Event</td><td style="text-align:center">事件，该事件发生后所有等待该事件的线程将被激活</td></tr><tr><td style="text-align:center">Semaphore</td><td style="text-align:center">信号量</td></tr><tr><td style="text-align:center">Timer</td><td style="text-align:center">定时器，运行前会等待一段时间</td></tr><tr><td style="text-align:center">Barrier</td><td style="text-align:center">创建一个障碍，必须达到指定数量的线程才开始运行</td></tr></tbody></table></div><h4 id="Threading模块的Thread类"><a href="#Threading模块的Thread类" class="headerlink" title="Threading模块的Thread类"></a>Threading模块的Thread类</h4><div class="table-container"><table><thead><tr><th style="text-align:center">对象</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">name</td><td style="text-align:center">线程名(属性)</td></tr><tr><td style="text-align:center">ident</td><td style="text-align:center">线程标识符(属性)</td></tr><tr><td style="text-align:center">daemon</td><td style="text-align:center">线程是否是守护线程(属性)</td></tr><tr><td style="text-align:center">__init__(group=None,tatget=None,name=None,args=(),kwargs={},verbose=None,daemon=None)</td><td style="text-align:center">实例化一个线程对象，需要有一个可调用的target，以及其参数args或kwargs。还可以传递name或group参数，不过后者还未实现。此外，verbose标志也是可接受的。而daemon的值将会设定thread.daemon属性/标志</td></tr><tr><td style="text-align:center">start()</td><td style="text-align:center">开启线程活动</td></tr><tr><td style="text-align:center">run()</td><td style="text-align:center">定义线程活动的方法(通常在子类中被应用开发者重写)</td></tr><tr><td style="text-align:center">join([time])</td><td style="text-align:center">等待至线程中止。阻塞调用线程直至线程的join()方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生</td></tr><tr><td style="text-align:center">Barrier</td><td style="text-align:center">创建一个障碍，必须达到指定数量线程才开始运行</td></tr><tr><td style="text-align:center">isAlive()</td><td style="text-align:center">返回线程是否活动的</td></tr><tr><td style="text-align:center">getName()</td><td style="text-align:center">返回线程名</td></tr><tr><td style="text-align:center">setName()</td><td style="text-align:center">设置线程名</td></tr></tbody></table></div><h5 id="Threading模块常用方法"><a href="#Threading模块常用方法" class="headerlink" title="Threading模块常用方法"></a>Threading模块常用方法</h5><ol><li>threading.Lock()</li></ol><p>如果多个线程共同对某个数据修改，则可能出现不可预料的结果，为了保证数据的正确性，需要对多个线程进行同步。</p><p>使用Thread对象的<code>Lock</code>和<code>RLock</code>可以实现简单的线程同步，这两个对象都有<code>acquire</code>方法和<code>release</code>方法，对于那些需要每次只允许一个线程操作的数据，可以将其放到<code>acquire</code>和<code>release</code>方法之间。</p><p>多个线程同时操作一个变量可能会把内容给改乱了</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><br><span class="hljs-keyword">import</span> time, threading<br><br><span class="hljs-comment"># 假定这是你的银行存款:</span><br>balance = <span class="hljs-number">0</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">change_it</span><span class="hljs-params">(n)</span>:</span><br>    <span class="hljs-comment"># 先存后取，结果应该为0:</span><br>    <span class="hljs-keyword">global</span> balance<br>    balance = balance + n<br>    balance = balance - n<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_thread</span><span class="hljs-params">(n)</span>:</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1000000</span>):<br>        change_it(n)<br><br><br>t1 = threading.Thread(target=run_thread, args=(<span class="hljs-number">5</span>,))<br>t2 = threading.Thread(target=run_thread, args=(<span class="hljs-number">8</span>,))<br>t1.start()<br>t2.start()<br>t1.join()<br>t2.join()<br>print(balance)<br></code></pre></td></tr></table></figure><p>上述代码中首先定义了一个共享变量<strong>balance</strong>，初始值为0，并且启动两个线程，先存后取，理论上结果应该为0。但是，由于线程的调度是由操作系统决定的，当<strong>t1</strong>,<strong>t2</strong>交替执行时，只要循环次数足够多，<strong>balance</strong>的结果就不一定是0了。</p><p>如果要确保balance计算争取，就要给<code>change_it()</code>上一把锁，当某个线程开始执行<code>change_it()</code>时，由于该进程获得了锁，因此其他线程不能同时执行<code>change_it()</code>，只能等待，直到锁被释放后，获得该锁以后才能改。</p><p>由于锁只有一个，无论多少线程，同一时刻最多只有一个线程持有该锁，所以，不会造成修改的冲突。</p><p>创建一个锁就是<code>threading.Lock()</code>来实现</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><br><span class="hljs-keyword">import</span> time, threading<br><br>balance = <span class="hljs-number">0</span><br>lock = threading.Lock()<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">change_it</span><span class="hljs-params">(n)</span>:</span><br>    <span class="hljs-comment"># 先存后取，结果应该为0:</span><br>    <span class="hljs-keyword">global</span> balance<br>    balance = balance + n<br>    balance = balance - n<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_thread</span><span class="hljs-params">(n)</span>:</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1000000</span>):<br>        <span class="hljs-comment"># 先要获取锁:</span><br>        lock.acquire()<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 放心地改吧:</span><br>            change_it(n)<br>        <span class="hljs-keyword">finally</span>:<br>            <span class="hljs-comment"># 改完了一定要释放锁:</span><br>            lock.release()<br><br><br>t1 = threading.Thread(target=run_thread, args=(<span class="hljs-number">5</span>,))<br>t2 = threading.Thread(target=run_thread, args=(<span class="hljs-number">8</span>,))<br>t1.start()<br>t2.start()<br>t1.join()<br>t2.join()<br>print(balance)<br></code></pre></td></tr></table></figure><p>当多个线程同时执行<code>lock.acquire()</code>时，只有一个线程能成功地获取锁，然后继续执行代码，其他线程就继续等待直到获得锁为止。</p><p>获得锁的线程用完后一定要释放锁，否则那些苦苦等待锁的线程将永远等待下去，成为死线程。此处可以用try…finally来确保锁一定会被释放。</p><p>锁的好处就是确保了某段关键代码只能由一个线程从头到尾完整地执行，坏处当然也有很多：</p><ul><li>首先是阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了。</li><li>其次，由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁，导致多个线程全部挂起，既不能执行，也无法结束，只能靠操作系统强制终止。</li></ul><ol><li>threading.RLock()</li></ol><p>RLock允许在同一线程中被多次<code>acquire</code>。而Lock却不允许这种情况。注意：如果使用RLock，那么<code>acquire</code>和<code>release</code>必须成对出现，即调用了n次<code>acquire</code>，必须调用n次的<code>release</code>才能真正释放所占用的锁。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br>lock = threading.Lock() <br><span class="hljs-comment">#Lock对象</span><br>lock.acquire()<br>lock.acquire() <br><span class="hljs-comment">#产生了死琐。</span><br>lock.release()<br>lock.release()<br>  <br><span class="hljs-keyword">import</span> threading<br>rLock = threading.RLock() <br><span class="hljs-comment">#RLock对象</span><br>rLock.acquire()<br>rLock.acquire() <br><span class="hljs-comment">#在同一线程内，程序不会堵塞。</span><br>rLock.release()<br>rLock.release()<br></code></pre></td></tr></table></figure><ol><li>threading.Condition()</li></ol><p>可以把Condition理解为一把高级的锁，它提供了比Lock，RLock更高级的功能，允许我们能够控制复杂的线程同步问题。threading.Condition在内部维护一个锁对象(默认是RLock)，可以在创建Condition对象的时候把锁对象作为参数传入。Condition也提供了<code>acquire</code>，<code>release</code>方法，其含义与锁的<code>acquire</code>，<code>release</code>方法一致，其实它只是简单的调用内部锁对象的对应的方法而已。Condition还提供<code>wait</code>方法、<code>notify</code>方法、<code>notifyAll</code>方法(特别要注意：这些方法只有在占用锁(<code>acquire</code>)之后才能调用，否则将会报<code>RuntimeError</code>异常。)</p><blockquote><p><code>acquire()</code>/<code>release()</code>：获得/释放 Lock</p><p><code>wait([timeout])</code>：线程挂起，直到收到一个<code>notify</code>通知或者超时(可选的，浮点数，单位是秒s)才会被唤醒继续执行。<strong><code>wait()</code>必须在已获得Lock前提下才能调用，否则会触发RuntimeError。调用<code>wait()</code>释放Lock，直至该线程被<code>Notify()</code>、<code>NotifyAll()</code>或者超时线程又重新获得Lock</strong>。</p><p><code>notify(n=1)</code>通知其他线程，那些挂起的线程接到这个通知之后会开始运行，默认是通知一个正等待该condition的线程，最多唤醒n个等待的线程。</p><p><strong><code>notify()</code>必须在已获得Lock前提下才能调用，否则会触发RuntimeError。<code>notify()</code>不会主动释放Lock</strong></p><p><code>notifyAll()</code>如果wait状态线程比较多，notifyAll的作用就是通知所有线程(这个一般用的比较少)</p></blockquote><p>捉迷藏游戏：</p><p>假设该游戏有两个人玩，一个藏(Hider)，一个找(Seeker)。</p><p>游戏规则如下：</p><ul><li>游戏开始后，Seeker先把自己眼睛蒙上，蒙上眼睛后，就通知Hider；</li><li>Hider接收到通知后开始找地方将自己藏起来，藏好之后，再通知Seeker可以找了；</li><li>Seeker就收到通知后，就开始找Hider</li></ul><p>Hider和Seeker都是独立的个体，在程序中用两个独立的线程表示，在游戏过程中，两者之间的行为有一定的时序关系，我们可以通过Condition来控制这种关系。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Seeker</span><span class="hljs-params">(cond, name)</span>:</span><br>    time.sleep(<span class="hljs-number">2</span>)<br>    cond.acquire()<br>    print(<span class="hljs-string">'%s :我已经把眼睛蒙上了！'</span> % name)<br>    cond.notify()<br>    cond.wait()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):<br>        print(<span class="hljs-string">'%s is finding!!!'</span> % name)<br>        time.sleep(<span class="hljs-number">2</span>)<br>    cond.notify()<br>    cond.release()<br>    print(<span class="hljs-string">'%s :我赢了！'</span> % name)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Hider</span><span class="hljs-params">(cond, name)</span>:</span><br>    cond.acquire()<br>    cond.wait()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>):<br>        print(<span class="hljs-string">'%s is hiding!!!'</span> % name)<br>        time.sleep(<span class="hljs-number">3</span>)<br>    print(<span class="hljs-string">'%s :我已经藏好了，你快来找我吧！'</span> % name)<br>    cond.notify()<br>    cond.wait()<br>    cond.release()<br>    print(<span class="hljs-string">'%s :被你找到了，唉~^~!'</span> % name)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    cond = threading.Condition()<br>    seeker = threading.Thread(target=Seeker, args=(cond, <span class="hljs-string">'seeker'</span>))<br>    hider = threading.Thread(target=Hider, args=(cond, <span class="hljs-string">'hider'</span>))<br>    seeker.start()<br>    hider.start()<br></code></pre></td></tr></table></figure><ol><li>threading.Semaphore和BoundedSemaphore</li></ol><p>Semaphore：Semaphore在内部管理者一个计数器。调用<code>acquire()</code>会使这个计数器-1，<code>release()</code>则是+1(可以多次<code>release()</code>，所以计数器的值理论上可以无限)，计数器的值永远不会小于0，当计数器到0时，再调用<code>acquire()</code>就会阻塞，直到其他线程来调用<code>release()</code></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(n)</span>:</span><br>    <span class="hljs-comment"># 获得信号量，信号量减一</span><br>    semaphore.acquire()<br>    time.sleep(<span class="hljs-number">1</span>)<br>    print(<span class="hljs-string">"run the thread: %s"</span> % n)<br><br>    <span class="hljs-comment"># 释放信号量，信号量加一</span><br>    semaphore.release()<br>    <span class="hljs-comment"># semaphore.release()    # 可以多次释放信号量，每次释放计数器+1</span><br>    <span class="hljs-comment"># semaphore.release()    # 可以多次释放信号量，每次释放计数器+1</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br><br>    num = <span class="hljs-number">0</span><br>    semaphore = threading.Semaphore(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 最多允许2个线程同时运行(即计数器值)；在多次释放信号量后，计数器值增加后每次可以运行的线程数也会增加</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">20</span>):<br>        t = threading.Thread(target=run, args=(i,))<br>        t.start()<br><br><span class="hljs-keyword">while</span> threading.active_count() != <span class="hljs-number">1</span>:<br>    <span class="hljs-keyword">pass</span>  <span class="hljs-comment"># print threading.active_count()</span><br><span class="hljs-keyword">else</span>:<br>    print(<span class="hljs-string">'----all threads done---'</span>)<br>    print(num)<br></code></pre></td></tr></table></figure><p>BoundedSemaphore：类似于Semaphore，不同在于BoundedSemaphore会检查内部计数器的值，并保证它不会大于初始值，如果超了，就引发一个ValueError。</p><p>多数情况下，semaphore用于守护限制(但不限于1)的资源，如果semaphore被<code>release()</code>过多次，这意味着存在bug</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(n)</span>:</span><br>    semaphore.acquire()<br>    time.sleep(<span class="hljs-number">1</span>)<br>    print(<span class="hljs-string">"run the thread: %s"</span> % n)<br>    semaphore.release()<br>    <span class="hljs-comment"># 如果再次释放信号量，信号量加一，这是超过限定的信号量数目，这时会报错ValueError: Semaphore released too many times</span><br>    <span class="hljs-comment"># semaphore.release()</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br><br>    num = <span class="hljs-number">0</span><br>    semaphore = threading.BoundedSemaphore(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 最多允许2个线程同时运行</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">20</span>):<br>        t = threading.Thread(target=run, args=(i,))<br>        t.start()<br><br><span class="hljs-keyword">while</span> threading.active_count() != <span class="hljs-number">1</span>:<br>    <span class="hljs-keyword">pass</span>  <span class="hljs-comment"># print threading.active_count()</span><br><span class="hljs-keyword">else</span>:<br>    print(<span class="hljs-string">'----all threads done---'</span>)<br>    print(num)<br></code></pre></td></tr></table></figure><ol><li>threading.Event</li></ol><p>时间处理的机制：全局定义了一个”Flag”，如果“Flag“值为False，那么当程序执行<code>event.wait</code>方法时就会阻塞；如果”Flag”值为True，那么执行<code>event.wait</code>方法时便不再阻塞。</p><ul><li>clear：将”Flag”设置为False</li><li>set：将”Flag”设置为True</li></ul><p>用threading.Event实现线程间通信，使用threading.Event可以使一个线程等待其他线程的通知，我们把这个Event传递到线程对象中。</p><p>Event默认内置了一个标志，初始值为False。一旦该线程通过<code>wait()</code>方法进入等待状态，知道另一个线程调用该Event的<code>set()</code>方法将内置标志设置为True时，该Event会通知所有等待状态的线程恢复运行。</p><p>通过Event来实现两个或多个线程间的交互，下面是一个红绿灯的例子，即启动一个线程做交通指挥灯，生成几个线程做车辆，车辆行驶按红灯停，绿灯行的规则。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time<br><span class="hljs-keyword">import</span> random<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">light</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> event.isSet():  <span class="hljs-comment"># 初始化evet的flag为真</span><br>        event.set()  <span class="hljs-comment"># wait就不阻塞 #绿灯状态</span><br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">if</span> count &lt; <span class="hljs-number">10</span>:<br>            print(<span class="hljs-string">'\033[42;1m---green light on---\033[0m'</span>)<br>        <span class="hljs-keyword">elif</span> count &lt; <span class="hljs-number">13</span>:<br>            print(<span class="hljs-string">'\033[43;1m---yellow light on---\033[0m'</span>)<br>        <span class="hljs-keyword">elif</span> count &lt; <span class="hljs-number">20</span>:<br>            <span class="hljs-keyword">if</span> event.isSet():<br>                event.clear()<br>            print(<span class="hljs-string">'\033[41;1m---red light on---\033[0m'</span>)<br>        <span class="hljs-keyword">else</span>:<br>            count = <span class="hljs-number">0</span><br>            event.set()  <span class="hljs-comment"># 打开绿灯</span><br>        time.sleep(<span class="hljs-number">1</span>)<br>        count += <span class="hljs-number">1</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">car</span><span class="hljs-params">(n)</span>:</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>        time.sleep(random.randrange(<span class="hljs-number">3</span>, <span class="hljs-number">10</span>))<br>        <span class="hljs-comment"># print(event.isSet())</span><br>        <span class="hljs-keyword">if</span> event.isSet():<br>            print(<span class="hljs-string">"car [%s] is running..."</span> % n)<br>        <span class="hljs-keyword">else</span>:<br>            print(<span class="hljs-string">'car [%s] is waiting for the red light...'</span> % n)<br>            event.wait()  <span class="hljs-comment"># 红灯状态下调用wait方法阻塞，汽车等待状态</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    car_list = [<span class="hljs-string">'BMW'</span>, <span class="hljs-string">'AUDI'</span>, <span class="hljs-string">'SANTANA'</span>]<br>    event = threading.Event()<br>    Light = threading.Thread(target=light)<br>    Light.start()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> car_list:<br>        t = threading.Thread(target=car, args=(i,))<br>        t.start()<br></code></pre></td></tr></table></figure><ol><li>threading.active_count()</li></ol><p>返回当前存活的线程对象数量；通过计算len(threading.enumerate())长度而来</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">()</span>:</span><br>    thread = threading.current_thread()<br>    print(<span class="hljs-string">'%s is running...'</span>% thread.getName())    <span class="hljs-comment">#返回线程名称</span><br>    time.sleep(<span class="hljs-number">10</span>)    <span class="hljs-comment">#休眠10S方便统计存活线程数量</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    <span class="hljs-comment">#print('The current number of threads is: %s' % threading.active_count())</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):<br>        print(<span class="hljs-string">'The current number of threads is: %s'</span> % threading.active_count())    <span class="hljs-comment">#返回当前存活线程数量</span><br>        thread_alive = threading.Thread(target=run, name=<span class="hljs-string">'Thread-***%s***'</span> % i)<br>        thread_alive.start()<br>    thread_alive.join()<br>    print(<span class="hljs-string">'\n%s thread is done...'</span>% threading.current_thread().getName())<br></code></pre></td></tr></table></figure><ol><li>threading.current_thread()</li></ol><p>返回当前线程对象</p><p>继承线程threading方法；通过help(threading.current_thread())查看</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(n)</span>:</span><br>    thread = threading.current_thread()<br>    thread.setName(<span class="hljs-string">'Thread-***%s***'</span> % n)  <span class="hljs-comment"># 自定义线程名称</span><br>    print(<span class="hljs-string">'-'</span> * <span class="hljs-number">30</span>)<br>    print(<span class="hljs-string">"Pid is :%s"</span> % thread.ident)  <span class="hljs-comment"># 返回线程pid</span><br>    <span class="hljs-comment"># print('ThreadName is :%s' % thread.name)  # 返回线程名称</span><br>    print(<span class="hljs-string">'ThreadName is :%s'</span> % thread.getName())  <span class="hljs-comment"># 返回线程名称</span><br>    time.sleep(<span class="hljs-number">2</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    <span class="hljs-comment"># print('The current number of threads is: %s' % threading.active_count())</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):<br>        <span class="hljs-comment"># print('The current number of threads is: %s' % threading.active_count())    #返回当前存活线程数量</span><br>        thread_alive = threading.Thread(target=run, args=(i,))<br>        thread_alive.start()<br>    thread_alive.join()<br>    print(<span class="hljs-string">'\n%s thread is done...'</span> % threading.current_thread().getName())<br></code></pre></td></tr></table></figure><ol><li>threading.enumerate()</li></ol><p>返回当前存在的所有线程对象的列表</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(n)</span>:</span><br>    thread = threading.current_thread()<br>    thread.setName(<span class="hljs-string">'Thread-***%s***'</span> % n)<br>    print(<span class="hljs-string">'-'</span> * <span class="hljs-number">30</span>)<br>    print(<span class="hljs-string">"Pid is :%s"</span> % thread.ident)  <span class="hljs-comment"># 返回线程pid</span><br>    <span class="hljs-comment"># print('ThreadName is :%s' % thread.name)  # 返回线程名称</span><br>    print(<span class="hljs-string">'ThreadName is :%s'</span> % threading.enumerate())  <span class="hljs-comment"># 返回所有线程对象列表</span><br>    time.sleep(<span class="hljs-number">2</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    <span class="hljs-comment"># print('The current number of threads is: %s' % threading.active_count())</span><br>    threading.main_thread().setName(<span class="hljs-string">'Chengd---python'</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):<br>        <span class="hljs-comment"># print('The current number of threads is: %s' % threading.active_count())    #返回当前存活线程数量</span><br>        thread_alive = threading.Thread(target=run, args=(i,))<br>        thread_alive.start()<br>    thread_alive.join()<br>    print(<span class="hljs-string">'\n%s thread is done...'</span> % threading.current_thread().getName())<br></code></pre></td></tr></table></figure><ol><li>threading.get_ident()</li></ol><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(n)</span>:</span><br>    print(<span class="hljs-string">'-'</span> * <span class="hljs-number">30</span>)<br>    print(<span class="hljs-string">"Pid is :%s"</span> % threading.get_ident())  <span class="hljs-comment"># 返回线程pid</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    threading.main_thread().setName(<span class="hljs-string">'Chengd---python'</span>)  <span class="hljs-comment"># 自定义线程名</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):<br>        thread_alive = threading.Thread(target=run, args=(i,))<br>        thread_alive.start()<br>    thread_alive.join()<br>    print(<span class="hljs-string">'\n%s thread is done...'</span> % threading.current_thread().getName())  <span class="hljs-comment"># 获取线程名</span><br></code></pre></td></tr></table></figure><ol><li>threading.main_thread()</li></ol><p>返回主线程对象，类似threading.current_thread()；只不过一个是返回当前线程对象，一个是返回主线程对象。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(n)</span>:</span><br>    print(<span class="hljs-string">'-'</span> * <span class="hljs-number">30</span>)<br>    print(<span class="hljs-string">"Now Pid is :%s"</span> % threading.current_thread().ident)  <span class="hljs-comment"># 返回当前线程pid</span><br>    print(<span class="hljs-string">"Main Pid is :%s"</span> % threading.main_thread().ident)  <span class="hljs-comment"># 返回主线程pid</span><br>    print(<span class="hljs-string">'Now thread is %s...'</span> % threading.current_thread().getName())  <span class="hljs-comment"># 获取当前线程名</span><br>    print(<span class="hljs-string">'Main thread is %s...'</span> % threading.main_thread().getName())  <span class="hljs-comment"># 获取主线程线程名</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    threading.main_thread().setName(<span class="hljs-string">'Chengd---python'</span>)  <span class="hljs-comment"># 自定义线程名</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):<br>        thread_alive = threading.Thread(target=run, args=(i,))<br>        thread_alive.start()<br>        time.sleep(<span class="hljs-number">2</span>)<br>    thread_alive.join()<br></code></pre></td></tr></table></figure><h4 id="Threading模块的Thread类方法"><a href="#Threading模块的Thread类方法" class="headerlink" title="Threading模块的Thread类方法"></a>Threading模块的Thread类方法</h4><div class="table-container"><table><thead><tr><th style="text-align:center">类方法</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">threading.currentThread()</td><td>返回当前的线程变量</td></tr><tr><td style="text-align:center">threading.enumerate()</td><td>返回一个包含正在运行的线程的list，正在运行指线程启动后、结束前，不包括启动前和终止后的线程</td></tr><tr><td style="text-align:center">threading.activeCount()</td><td>返回正在运行的线程数量，与len(threading.enumerate())有相同的结果</td></tr></tbody></table></div><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-comment"># 继承类threading.Thread</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(threading.Thread)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, n)</span>:</span><br>        <span class="hljs-comment"># 这里要继承构造函数</span><br>        super(MyThread, self).__init__()<br>        <span class="hljs-comment"># 可以定义自己的实例变量</span><br>        self.n = n<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span><br>        print(<span class="hljs-string">'running task'</span>, self.n)<br>        time.sleep(<span class="hljs-number">2</span>)<br><br><br>t1 = MyThread(<span class="hljs-string">'t1'</span>)<br>t2 = MyThread(<span class="hljs-string">'t2'</span>)<br><br>t1.start()<br>t2.start()<br></code></pre></td></tr></table></figure><p>这样就实现了通过继承父类的方式使用多线程，这里注意的几个点：</p><ul><li>继承类之后还要继承构造函数</li><li>这里的<code>run</code>函数时重写的，所以说<code>t1.start()</code>之后才会自动调用<code>run</code>函数</li><li>线程是通过start()函数激活，而不是对象建立时激活的！</li></ul><p>循环创建多个进程</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-comment"># 继承类threading.Thread</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(threading.Thread)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, n)</span>:</span><br>        <span class="hljs-comment"># 这里要继承构造函数</span><br>        super(MyThread, self).__init__()<br>        <span class="hljs-comment"># 可以定义自己的实例变量</span><br>        self.n = n<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span><br>        print(<span class="hljs-string">'running task'</span>, self.n)<br>        time.sleep(<span class="hljs-number">2</span>)<br><br><br><span class="hljs-comment"># t1 = MyThread('t1')</span><br><span class="hljs-comment"># t2 = MyThread('t2')</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">50</span>):<br>    t = MyThread(i)<br>    t.start()<br><br><span class="hljs-comment"># t1.start()</span><br><span class="hljs-comment"># t2.start()</span><br></code></pre></td></tr></table></figure><h4 id="计算这些线程执行所花费的时间join"><a href="#计算这些线程执行所花费的时间join" class="headerlink" title="计算这些线程执行所花费的时间join()"></a>计算这些线程执行所花费的时间<code>join()</code></h4><p>能够使主线程等待子线程的执行完毕才会继续主线程</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-comment"># 继承类threading.Thread</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(threading.Thread)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, n)</span>:</span><br>        <span class="hljs-comment"># 这里要继承构造函数</span><br>        super(MyThread, self).__init__()<br>        <span class="hljs-comment"># 可以定义自己的实例变量</span><br>        self.n = n<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span><br>        print(<span class="hljs-string">'running task'</span>, self.n)<br>        time.sleep(<span class="hljs-number">2</span>)<br><br><br><span class="hljs-comment"># 得到开始时间</span><br>start_time = time.time()<br><span class="hljs-comment"># 声明空列表</span><br>threads = []<br><br><span class="hljs-comment"># 循环开启50线程</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">50</span>):<br>    t = MyThread(i)<br>    t.start()<br>    <span class="hljs-comment"># 线程实例放入列表中</span><br>    threads.append(t)<br><br><span class="hljs-comment"># 对线程实例所在列表再循环</span><br><span class="hljs-keyword">for</span> res <span class="hljs-keyword">in</span> threads:<br>    <span class="hljs-comment"># 对每一个实例使用jion()方法</span><br>    res.join()<br><span class="hljs-comment"># 获得结束时间</span><br>end_time = time.time()<br><span class="hljs-comment"># 计算花费时间</span><br>spend_time = end_time - start_time<br><span class="hljs-comment"># 打印花费时间</span><br>print(spend_time)<br></code></pre></td></tr></table></figure><p>这里需要注意的点就是<code>join()</code>方法不能在线程启动之后就使用，这样的话50个线程就会变成串行，必须要等50个线程全部启动之后才能使用<code>join()</code>方法，这里就用到了一个小技巧新建了一个空列表，再将50个线程实例放进去，这样后面就可以实现对这50个线程使用<code>join()</code>方法了。</p><h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><p>多线程的优势在于可以同时运行多个任务(至少感觉起来是这样)。但是当线程需要共享数据时，可能存在数据不同步的问题。</p><p>使用Threading对象的Lock和Rlock可以实现简单的线程同步，这两个对象都有<code>acquire</code>方法和<code>release</code>方法，对于那些需要每次只允许一个线程操作的数据，可以将其操作放到acquire和release方法之间。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time<br><br><span class="hljs-comment"># 创建锁</span><br>threadLock = threading.Lock()<br><span class="hljs-comment"># 创建线程列表</span><br>threads = []<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myThread</span><span class="hljs-params">(threading.Thread)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, threadID, name, counter)</span>:</span><br>        threading.Thread.__init__(self)<br>        self.threadID = threadID<br>        self.name = name<br>        self.counter = counter<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span><br>        print(<span class="hljs-string">"Thread Start: "</span> + self.name)<br>        <span class="hljs-comment"># 获取锁，同步线程</span><br>        threadLock.acquire()<br>        print_time(self.name, self.counter, <span class="hljs-number">3</span>)<br>        <span class="hljs-comment"># 释放锁，开启下一个线程</span><br>        threadLock.release()<br>        print(<span class="hljs-string">"Thread Exit: "</span> + self.name)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_time</span><span class="hljs-params">(threadName, delay, counter)</span>:</span><br>    <span class="hljs-keyword">while</span> counter:<br>        time.sleep(delay)<br>        print(<span class="hljs-string">"&#123;&#125;: &#123;&#125;"</span>.format(threadName, time.ctime()))<br>        counter -= <span class="hljs-number">1</span><br><br><br><span class="hljs-comment"># 创建线程</span><br>thread1 = myThread(<span class="hljs-number">1001</span>, <span class="hljs-string">"Thread-1"</span>, <span class="hljs-number">1</span>)<br>thread2 = myThread(<span class="hljs-number">1002</span>, <span class="hljs-string">"Thread-2"</span>, <span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 开启线程</span><br>thread1.start()<br>thread2.start()<br><br><span class="hljs-comment"># 添加线程列表</span><br>threads.append(thread1)<br>threads.append(thread2)<br><br><span class="hljs-comment"># 等待所有线程完成</span><br><span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads:<br>    t.join()<br>print(<span class="hljs-string">"exit"</span>)<br></code></pre></td></tr></table></figure><h5 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h5><p>同一个进程下的线程数据之间可以共享，多线程中GIL锁，一个时刻只有一线程在运行，所以说就是有很多线程在修改这些共享数据。</p><p>当开启了很多个线程，当这些线程一起修改全局变量的时候，最后得出的结果可能跟期望的不太一样。</p><p>Python提供了另一把锁，给用户的锁，叫做<strong>线程锁</strong>，可以在多个线程操作共享数据时更加有规律，来防止操作数据失误的情况出现。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-comment"># 获取锁</span><br>    lock.acquire()<br>    <span class="hljs-comment"># 声明全局变量num</span><br>    <span class="hljs-keyword">global</span> num<br>    <span class="hljs-comment"># num+=1</span><br>    num += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 释放锁</span><br>    lock.release()<br><br><br><span class="hljs-comment"># 生成线程锁实例</span><br>lock = threading.Lock()<br>num = <span class="hljs-number">0</span><br><br><span class="hljs-comment"># 开启1000个线程</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1000</span>):<br>    t = threading.Thread(target=run)<br>    t.start()<br><br>print(<span class="hljs-string">"-----all thread has finshed"</span>)<br>print(<span class="hljs-string">"num:"</span>, num)<br></code></pre></td></tr></table></figure><p>注意获取锁与释放锁之间的这一段锁操作的数据量不是很大，如果数据量很大，需要的时间很多，那么程序就会变成串行。</p><h5 id="递归锁"><a href="#递归锁" class="headerlink" title="递归锁"></a>递归锁</h5><p>在我们分出一个线程，使用线程锁之后里面再调用别的函数，然后调用的这个函数中再使用线程锁的话就不能在使用Lock()实例了， 不然就会出现死循环错误，这是因为一把锁对应一个钥匙，锁里面再加一把锁就会导致程序分不清哪把钥匙开哪把锁，导致程序一直在锁中出不来，如下：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run1</span><span class="hljs-params">()</span>:</span><br>    print(<span class="hljs-string">"grab the first part data"</span>)<br>    <span class="hljs-comment"># 获取锁</span><br>    lock.acquire()<br>    <span class="hljs-keyword">global</span> num<br>    num += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 释放锁</span><br>    lock.release()<br>    <span class="hljs-keyword">return</span> num<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run2</span><span class="hljs-params">()</span>:</span><br>    print(<span class="hljs-string">"grab the second part data"</span>)<br>    <span class="hljs-comment"># 获取锁</span><br>    lock.acquire()<br>    <span class="hljs-keyword">global</span> num2<br>    num2 += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 释放锁</span><br>    lock.release()<br>    <span class="hljs-keyword">return</span> num2<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run3</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-comment"># 获取锁</span><br>    lock.acquire()<br>    <span class="hljs-comment"># 去跑run1</span><br>    res = run1()<br>    print(<span class="hljs-string">'--------between run1 and run2-----'</span>)<br>    <span class="hljs-comment"># 去跑run2</span><br>    res2 = run2()<br>    <span class="hljs-comment"># 释放锁</span><br>    lock.release()<br>    print(res, res2)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    <span class="hljs-comment"># 初始化两个为0的变量</span><br>    num, num2 = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 生成lock实例</span><br>    lock = threading.Lock()<br>    <span class="hljs-comment"># 开始10个线程</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):<br>        <span class="hljs-comment"># 线程跑的是run3</span><br>        t = threading.Thread(target=run3)<br>        t.start()<br><br><span class="hljs-comment"># 判读是否有多个线程，有多个就继续打印，只剩一个说明子线程都执行完了，只剩主线程了，然后跳出循环程序结束</span><br><span class="hljs-comment"># 可以用之前学到的join()方法来实现一样的效果</span><br><span class="hljs-keyword">while</span> threading.active_count() != <span class="hljs-number">1</span>:<br>    print(threading.active_count())<br><span class="hljs-keyword">else</span>:<br>    print(<span class="hljs-string">'----all threads done---'</span>)<br>    print(num, num2)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Iimage3.png" width="50%"></p><p>可以看到一直在打印线程数11，说明一直有11个线程在活跃，说明分出的10个线程一直在运行不结束，这个时候就不能使用<code>Lock()</code>了，而是使用<code>RLock()</code></p><p>修改后结果：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run1</span><span class="hljs-params">()</span>:</span><br>    print(<span class="hljs-string">"grab the first part data"</span>)<br>    <span class="hljs-comment"># 获取锁</span><br>    lock.acquire()<br>    <span class="hljs-keyword">global</span> num<br>    num += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 释放锁</span><br>    lock.release()<br>    <span class="hljs-keyword">return</span> num<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run2</span><span class="hljs-params">()</span>:</span><br>    print(<span class="hljs-string">"grab the second part data"</span>)<br>    <span class="hljs-comment"># 获取锁</span><br>    lock.acquire()<br>    <span class="hljs-keyword">global</span> num2<br>    num2 += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 释放锁</span><br>    lock.release()<br>    <span class="hljs-keyword">return</span> num2<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run3</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-comment"># 获取锁</span><br>    lock.acquire()<br>    <span class="hljs-comment"># 去跑run1</span><br>    res = run1()<br>    print(<span class="hljs-string">'--------between run1 and run2-----'</span>)<br>    <span class="hljs-comment"># 去跑run2</span><br>    res2 = run2()<br>    <span class="hljs-comment"># 释放锁</span><br>    lock.release()<br>    print(res, res2)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    <span class="hljs-comment"># 初始化两个为0的变量</span><br>    num, num2 = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 生成lock实例</span><br>    lock = threading.RLock()<br>    <span class="hljs-comment"># 开始10个线程</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):<br>        <span class="hljs-comment"># 线程跑的是run3</span><br>        t = threading.Thread(target=run3)<br>        t.start()<br><br><span class="hljs-comment"># 判读是否有多个线程，有多个就继续打印，只剩一个说明子线程都执行完了，只剩主线程了，然后跳出循环程序结束</span><br><span class="hljs-comment"># 可以用之前学到的join()方法来实现一样的效果</span><br><span class="hljs-keyword">while</span> threading.active_count() != <span class="hljs-number">1</span>:<br>    print(threading.active_count())<br><span class="hljs-keyword">else</span>:<br>    print(<span class="hljs-string">'----all threads done---'</span>)<br>    print(num, num2)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Iimage4.png" width="50%"></p><h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><p>信号量的用法和线程锁非常相似。</p><p>线程锁锁住一个线程在运行和修改数据，而信号量可以自己控制同一时刻运行几个线程和几个线程修改数据，也就是设置最大同时运行的线程数。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(n)</span>:</span><br>    <span class="hljs-comment"># 获取信号量</span><br>    semaphore.acquire()<br>    print(<span class="hljs-string">'task %s is running'</span> % n)<br>    <span class="hljs-comment"># 暂停1s方便看出一次运行几个线程</span><br>    time.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 释放信号量</span><br>    semaphore.release()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    <span class="hljs-comment"># 生成信号量实例并设置信号量为5</span><br>    semaphore = threading.BoundedSemaphore(<span class="hljs-number">5</span>)<br>    <span class="hljs-comment"># 开启50个线程</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">50</span>):<br>        t = threading.Thread(target=run, args=(i,))<br>        t.start()<br><br><span class="hljs-comment"># 线程没有运行完就不退出</span><br><span class="hljs-keyword">while</span> threading.active_count() != <span class="hljs-number">1</span>:<br>    <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">else</span>:<br>    print(<span class="hljs-string">'----all threads done---'</span>)<br></code></pre></td></tr></table></figure><p>虽然我们看到的是一次执行五个线程，但并不是五个一组五个一组分组执行的，因为这五个线程同时完成，所以我们看不出来，但是其中的过程是执行完一个线程放进去一个线程，加入这五个中有两个先完成，那么就会立刻再放进去两个，也就是说这五个线程之间不会互相等待，这个设置的信号量5不是按5来分组，而是同时运行的线程最大数，可以写多个执行时间不同的函数然后一次执行几个来证明这一点。</p><h4 id="区分主-子线程"><a href="#区分主-子线程" class="headerlink" title="区分主/子线程"></a>区分主/子线程</h4><p>子线程可能比较明白的看出来，而主线程有的时候是看不到的，主线程就是程序本身，但是跟子线程还是有区分的，而threading module提供给我们方法让我们可以知道当前线程是主线程还是子线程。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">threading.current_thread() <span class="hljs-comment"># 返回当前线程类型</span><br>threading.active_count()<span class="hljs-comment"># 返回当前活跃线程数</span><br></code></pre></td></tr></table></figure><p>实例</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-comment"># 继承类threading.Thread</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(threading.Thread)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, n)</span>:</span><br>        <span class="hljs-comment"># 这里要继承构造函数</span><br>        super(MyThread, self).__init__()<br>        <span class="hljs-comment"># 可以定义自己的实例变量</span><br>        self.n = n<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-comment"># 打印当前线程类型</span><br>        print(<span class="hljs-string">'running task'</span>, self.n, threading.current_thread())<br>        time.sleep(<span class="hljs-number">2</span>)<br><br><br><span class="hljs-comment"># 得到开始时间</span><br>start_time = time.time()<br><span class="hljs-comment"># 声明空列表</span><br>threads = []<br><br><span class="hljs-comment"># 循环开启50线程</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">50</span>):<br>    t = MyThread(i)<br>    t.start()<br>    <span class="hljs-comment"># 线程实例放入列表中</span><br>    threads.append(t)<br><span class="hljs-comment"># 打印当前活跃的线程数</span><br>print(threading.active_count())<br><span class="hljs-comment"># 对线程实例所在列表再循环</span><br><span class="hljs-keyword">for</span> res <span class="hljs-keyword">in</span> threads:<br>    <span class="hljs-comment"># 对每一个实例使用jion()方法</span><br>    res.join()<br><span class="hljs-comment"># 获得结束时间</span><br>end_time = time.time()<br><span class="hljs-comment"># 计算花费时间</span><br>spend_time = end_time - start_time<br><span class="hljs-comment"># 打印当前线程类型</span><br>print(<span class="hljs-string">'all thread has finished'</span>, threading.current_thread())<br><span class="hljs-comment"># 打印花费时间</span><br>print(spend_time)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Iimage1.png" width="50%"></p><p>可以看到在开启50个子线程后活跃线程数为51，这些线程的类型都为Thread(子线程)，而最后的则为Main Thread(主线程)</p><p>这样，我们就可以知道当前线程是主线程还是子线程了，甚至还可以知道当前活跃的线程数。</p><h4 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h4><p>顾名思义，守护进程就是用来守护主线程的，一旦主线程没了，那这些守护线程也就没有存在的意义了。</p><p>threading module提供<code>setDaemon(True)</code>来使子线程变为守护线程，守护线程就是一旦主线程结束了，即使子线程还在运行，也会跟着一起结束。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-comment"># 继承类threading.Thread</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(threading.Thread)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, n)</span>:</span><br>        <span class="hljs-comment"># 这里要继承构造函数</span><br>        super(MyThread, self).__init__()<br>        <span class="hljs-comment"># 可以定义自己的实例变量</span><br>        self.n = n<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-comment"># 打印当前线程类型</span><br>        print(<span class="hljs-string">'running task'</span>, self.n, threading.current_thread())<br>        time.sleep(<span class="hljs-number">2</span>)<br>        <span class="hljs-comment"># 线程结束打印一句话</span><br>        print(<span class="hljs-string">'done'</span>)<br><br><br><span class="hljs-comment"># 得到开始时间</span><br>start_time = time.time()<br><br><span class="hljs-comment"># 循环开启50线程</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">50</span>):<br>    t = MyThread(i)<br>    <span class="hljs-comment"># 设置这个线程为守护线程</span><br>    t.setDaemon(<span class="hljs-literal">True</span>)<br>    t.start()<br><span class="hljs-comment"># 打印当前活跃的线程数</span><br>print(threading.active_count())<br><br><span class="hljs-comment"># 获得结束时间</span><br>end_time = time.time()<br><span class="hljs-comment"># 计算花费时间</span><br>spend_time = end_time - start_time<br><span class="hljs-comment"># 打印当前线程类型</span><br>print(<span class="hljs-string">'all thread has finished'</span>, threading.current_thread())<br><span class="hljs-comment"># 打印花费时间</span><br>print(spend_time)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Iimage2.png" width="50%"></p><p>可以看到，直到程序结束都没有执行每一个线程中的打印<code>done</code>的这段代码，这是因为子线程变成了守护线程，一旦主线程结束，这些守护线程也会跟着结束。</p><p>这里也有注意的地方，就是设置子线程为守护线程时必须要在子线程开始之前也就是<code>start()</code>之前。</p><p>程序会等待主线程的完成，而不会等待守护线程</p><h2 id="queue模块-线程间通信"><a href="#queue模块-线程间通信" class="headerlink" title="queue模块(线程间通信)"></a>queue模块(线程间通信)</h2><p>Python的Queue模块中提供了同步的、线程安全的队列类，包括：</p><ul><li>FIFO队列Queue</li><li>LIFO队列LifoQueue</li><li>优先级队列PriorityQueue</li></ul><h4 id="Queue模块中常用方法"><a href="#Queue模块中常用方法" class="headerlink" title="Queue模块中常用方法"></a>Queue模块中常用方法</h4><div class="table-container"><table><thead><tr><th style="text-align:center">对象</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">Queue(maxsize=0)</td><td style="text-align:left">创建一个先入先出队列。如果给定最大值，则在队列没有空间时阻塞；否则(没有指定最大值)，为无限队列</td></tr><tr><td style="text-align:center">LifoQueue(maxsize=0)</td><td style="text-align:left">创建一个后入先出队列。如果给定最大值，则在队列没有空间时阻塞；否则(没有指定最大值)，为无限队列</td></tr><tr><td style="text-align:center">PriorityQueue(maxsize=0)</td><td style="text-align:left">创建一个优先级队列。如果给定最大值，则在队列没有空间时阻塞，否则(没有指定最大值)，为无限队列</td></tr><tr><td style="text-align:center">Empty</td><td style="text-align:left">当对空队列调用get*()方法时抛出异常</td></tr><tr><td style="text-align:center">Full</td><td style="text-align:left">当对已满的队列调用put*()方法时抛出异常</td></tr><tr><td style="text-align:center">qsize()</td><td style="text-align:left">返回队列大小</td></tr><tr><td style="text-align:center">empty()</td><td style="text-align:left">如果队列为空，则返回True；否则，返回False</td></tr><tr><td style="text-align:center">full()</td><td style="text-align:left">如果队列为满，则返回True；否则，返回False</td></tr><tr><td style="text-align:center">put(item,block=True,timeout=None)</td><td style="text-align:left">将item放入队列。如果block为True(默认)且timeout为None，则在有可用空间之前阻塞；如果timeout为正值，则最多阻塞timeout秒；如果block为False，则抛出Empty异常</td></tr><tr><td style="text-align:center">put_nowait(item)</td><td style="text-align:left">相当于put(item,False)</td></tr><tr><td style="text-align:center">get(blcok=True,timeout=None)</td><td style="text-align:left">获取队列。如果给定了block(非0)，则一直阻塞到有可用的元素为止</td></tr><tr><td style="text-align:center">get_nowait()</td><td style="text-align:left">相当于get(False)</td></tr><tr><td style="text-align:center">join()</td><td style="text-align:left">在队列中所有元素执行完毕并调用上面的task_done()信号之前，保持阻塞</td></tr></tbody></table></div><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> randint<br><span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> ctime, sleep<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mythread</span><span class="hljs-params">(threading.Thread)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, func, name=<span class="hljs-string">''</span>)</span>:</span><br>        threading.Thread.__init__(self)<br>        self.name = name<br>        self.func = func<br><br>    <span class="hljs-string">''' rewrite run() '''</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span><br>        self.func()<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, q, loops)</span>:</span><br>        self.q = q<br>        self.loops = loops<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">WriteQueue</span><span class="hljs-params">(self)</span>:</span><br>        self.q.put(<span class="hljs-string">'xxx'</span>, <span class="hljs-number">1</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ReadQueue</span><span class="hljs-params">(self)</span>:</span><br>        value = self.q.get(<span class="hljs-number">1</span>)<br>        print(<span class="hljs-string">'value: '</span> + str(value))<br>        <span class="hljs-keyword">return</span> value<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Writer</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(self.loops):<br>                self.WriteQueue()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Reader</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(self.loops):<br>                aaa = self.ReadQueue()<br>                print(<span class="hljs-string">"aaa = "</span> + str(aaa))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span><br>    que = Queue(<span class="hljs-number">32</span>)<br>    nloops = randint(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>)<br>    q = MyQueue(que, nloops)<br><br>    t1 = Mythread(q.Writer, q.Writer.__name__)<br><br>    t2 = Mythread(q.Reader, q.Reader.__name__)<br><br>    t1.start()<br>    t2.start()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    main()<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matplotlib基础</title>
      <link href="/2019/08/03/Matplotlib%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/08/03/Matplotlib%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p><strong>本文主要介绍了以下内容:</strong></p><p>Matplotlib的一些基础画图命令</p><a id="more"></a><h3 id="标准头文件"><a href="#标准头文件" class="headerlink" title="标准头文件"></a>标准头文件</h3><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>plt.rcParams[<span class="hljs-string">'font.sans-serif'</span>] = [<span class="hljs-string">'STHeiti'</span>]  <span class="hljs-comment"># 用来正常显示中文标签</span><br>plt.rcParams[<span class="hljs-string">'axes.unicode_minus'</span>] = <span class="hljs-literal">False</span>  <span class="hljs-comment"># 用来正常显示负号</span><br><br>plt.show()<br></code></pre></td></tr></table></figure><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h5 id="figure-函数，创建图表"><a href="#figure-函数，创建图表" class="headerlink" title="figure()函数，创建图表"></a><code>figure()</code>函数，创建图表</h5><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> matplotlib.patches <span class="hljs-keyword">import</span> Polygon<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>plt.figure(<span class="hljs-number">1</span>)   <span class="hljs-comment"># 创建图表1</span><br>plt.figure(<span class="hljs-number">2</span>)   <span class="hljs-comment"># 创建图表2</span><br><br>plt.show()<br></code></pre></td></tr></table></figure><h5 id="subplot-创建子图"><a href="#subplot-创建子图" class="headerlink" title="subplot()创建子图"></a><code>subplot()</code>创建子图</h5><p>子图序号排序顺序：从左到右，从上到下，逐次增加1</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> matplotlib.patches <span class="hljs-keyword">import</span> Polygon<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>plt.figure(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 创建图表1</span><br>plt.subplot(<span class="hljs-number">221</span>)  <span class="hljs-comment"># 创建2*2的图表矩阵，绘制的子图为矩阵中的1序号</span><br>plt.subplot(<span class="hljs-number">222</span>)  <span class="hljs-comment"># 创建2*2的图表矩阵，绘制的子图为矩阵中的2序号</span><br>plt.subplot(<span class="hljs-number">223</span>)  <span class="hljs-comment"># 创建2*2的图表矩阵，绘制的子图为矩阵中的3序号</span><br>plt.subplot(<span class="hljs-number">224</span>)  <span class="hljs-comment"># 创建2*2的图表矩阵，绘制的子图为矩阵中的4序号</span><br><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Image1.png" width="50%"></p><h5 id="在多个表中创建子图"><a href="#在多个表中创建子图" class="headerlink" title="在多个表中创建子图"></a>在多个表中创建子图</h5><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> matplotlib.patches <span class="hljs-keyword">import</span> Polygon<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>plt.figure(<span class="hljs-number">1</span>, dpi=<span class="hljs-number">50</span>)  <span class="hljs-comment"># 创建图表1</span><br>plt.subplot(<span class="hljs-number">111</span>)  <span class="hljs-comment"># 在图表1中创建子图</span><br>plt.figure(<span class="hljs-number">2</span>, dpi=<span class="hljs-number">50</span>)  <span class="hljs-comment"># 创建图表2</span><br>plt.subplot(<span class="hljs-number">221</span>)  <span class="hljs-comment"># 在图表2中创建子图</span><br>plt.show()  <span class="hljs-comment"># 显示所有图表</span><br></code></pre></td></tr></table></figure><h5 id="plot-函数，画函数图像"><a href="#plot-函数，画函数图像" class="headerlink" title="plot()函数，画函数图像"></a><code>plot()</code>函数，画函数图像</h5><p><code>splot(x,y)</code>中<code>x</code>表示横坐标，<code>y</code>表示纵坐标</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>plt.figure(<span class="hljs-number">1</span>, dpi=<span class="hljs-number">100</span>)<br><span class="hljs-comment"># x轴的定义域为 -3.14~3.14，中间间隔100个元素</span><br>x = np.linspace(-np.pi, np.pi, <span class="hljs-number">100</span>) <br>plt.plot(x, np.sin(x))<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Image2.png" width="50%"></p><h5 id="sca-函数，选择子图"><a href="#sca-函数，选择子图" class="headerlink" title="sca()函数，选择子图"></a><code>sca()</code>函数，选择子图</h5><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>plt.figure(<span class="hljs-number">1</span>, dpi=<span class="hljs-number">100</span>)<br>ax1 = plt.subplot(<span class="hljs-number">211</span>)  <span class="hljs-comment"># 创建子图 ax1</span><br>ax2 = plt.subplot(<span class="hljs-number">212</span>)  <span class="hljs-comment"># 创建子图 ax2</span><br><br>x = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>)  <span class="hljs-comment"># x轴定义域</span><br><br>plt.sca(ax1)  <span class="hljs-comment"># 选择子图ax1</span><br>plt.plot(x, np.exp(x))  <span class="hljs-comment"># 在子图ax1 中绘制函数 exp(x)</span><br><br>plt.sca(ax2)  <span class="hljs-comment"># 选择子图ax2</span><br>plt.plot(x, np.sin(x))  <span class="hljs-comment"># 在子图ax2 中绘制函数 sin(x)</span><br><br>plt.show()  <span class="hljs-comment"># 展示所有图表</span><br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Image3.png" width="50%"></p><h5 id="在一张图中画多条曲线"><a href="#在一张图中画多条曲线" class="headerlink" title="在一张图中画多条曲线"></a>在一张图中画多条曲线</h5><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pylab <span class="hljs-keyword">as</span> plt<br><br>x = np.linspace(-np.pi * <span class="hljs-number">2</span>, np.pi * <span class="hljs-number">2</span>, <span class="hljs-number">100</span>)  <span class="hljs-comment"># 定义域为： -2pi 到 2pi</span><br>plt.figure(<span class="hljs-number">1</span>, dpi=<span class="hljs-number">100</span>)  <span class="hljs-comment"># 创建图表1</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>):  <span class="hljs-comment"># 画四条线</span><br>    plt.plot(x, np.sin(x / i))<br><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Image4.png" width="50%"></p><h3 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h3><p>使用<code>plot()</code>函数</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>x = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>y = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]<br><br>x1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>y1 = [<span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">12</span>, <span class="hljs-number">14</span>]<br><br>plt.plot(x, y, label=<span class="hljs-string">'line one'</span>)<br>plt.plot(x1, y1, label=<span class="hljs-string">'line two'</span>)<br><br>plt.xlabel(<span class="hljs-string">'x_data'</span>)<br>plt.ylabel(<span class="hljs-string">'y_data'</span>)<br>plt.title(<span class="hljs-string">'title is here!'</span>)<br><br>plt.legend(loc=<span class="hljs-number">0</span>)<br><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Image9.png" width="50%"></p><h3 id="条形图"><a href="#条形图" class="headerlink" title="条形图"></a>条形图</h3><p>使用<code>bar()</code>函数</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>x = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>]<br>y = [<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]<br><br>plt.bar(x, y)<br><br>plt.axis([<span class="hljs-number">0</span>, <span class="hljs-number">12</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>])<br><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Image10.png" width="50%"></p><h3 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h3><p>使用<code>hist()</code>函数</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>plt.figure(<span class="hljs-number">1</span>, dpi=<span class="hljs-number">100</span>)  <span class="hljs-comment"># 创建图表1</span><br>data = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>]<br>plt.hist(data)  <span class="hljs-comment"># 只要传入数据，直方图就会统计数据出现的次数</span><br><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Image5.png" width="50%"></p><h3 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h3><p>散点图用<code>scatter(x,y)</code>绘制，x参数传入x轴的坐标，y参数传入y轴坐标</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># 产生测试数据</span><br>x = np.arange(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)<br>y = x<br>fig = plt.figure()<br>plt.scatter(x, y, c=<span class="hljs-string">'r'</span>, marker=<span class="hljs-string">'o'</span>)  <span class="hljs-comment"># c = 'r'表示散点的颜色为红色，marker 表示指定三点多形状为圆形</span><br><span class="hljs-comment"># 显示所画的图</span><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Image6.png" width="50%"></p><h3 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h3><p>使用<code>pie()</code>函数</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>data = [<span class="hljs-number">100</span>, <span class="hljs-number">500</span>, <span class="hljs-number">300</span>]  <span class="hljs-comment"># 饼图中的数据</span><br>fig = plt.figure(dpi=<span class="hljs-number">100</span>)<br>plt.pie(data,  <span class="hljs-comment"># 每个饼块的实际数据，如果大于1，会进行归一化，计算percentage</span><br>        explode=[<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.1</span>],  <span class="hljs-comment"># 每个饼块离中心的距离</span><br>        colors=[<span class="hljs-string">'y'</span>, <span class="hljs-string">'r'</span>, <span class="hljs-string">'g'</span>],  <span class="hljs-comment"># 每个饼块的颜色,黄红绿</span><br>        labels=[<span class="hljs-string">'A part'</span>, <span class="hljs-string">'B part'</span>, <span class="hljs-string">'C part'</span>],  <span class="hljs-comment"># 每个饼块的标签</span><br>        labeldistance=<span class="hljs-number">1.2</span>,  <span class="hljs-comment"># 每个饼块标签到中心的距离</span><br>        autopct=<span class="hljs-string">'%1.1f%%'</span>,  <span class="hljs-comment"># 百分比的显示格式</span><br>        pctdistance=<span class="hljs-number">0.5</span>,  <span class="hljs-comment"># 百分比到中心的距离</span><br>        shadow=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 每个饼块是否显示阴影</span><br>        startangle=<span class="hljs-number">0</span>,  <span class="hljs-comment"># 默认从x轴正半轴逆时针起</span><br>        radius=<span class="hljs-number">1</span>  <span class="hljs-comment"># 饼块的半径</span><br>        )<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Image7.png" width="50%"></p><h3 id="图标的注释与标识"><a href="#图标的注释与标识" class="headerlink" title="图标的注释与标识"></a>图标的注释与标识</h3><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>fig = plt.figure(dpi=<span class="hljs-number">100</span>)<br>x = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>)<br>plt.plot(x, np.sin(x), label=<span class="hljs-string">"sin(x)"</span>)  <span class="hljs-comment"># 先设置一个label用于显示图例</span><br>plt.xlabel(<span class="hljs-string">"X axe"</span>)  <span class="hljs-comment"># 设置X轴的文字</span><br>plt.ylabel(<span class="hljs-string">"Y axe"</span>)  <span class="hljs-comment"># 设置Y轴的文字</span><br><span class="hljs-comment"># 设置x轴y轴的起点和终点</span><br>plt.axis([np.min(x), np.max(x), np.min(np.sin(x)), np.max(np.sin(x))])<br>plt.title(<span class="hljs-string">"sin(x) function"</span>)  <span class="hljs-comment"># 设置图的标题</span><br>plt.legend()  <span class="hljs-comment"># 显示图例。</span><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Image8.png" width="50%"></p><h3 id="插入Latex公式"><a href="#插入Latex公式" class="headerlink" title="插入Latex公式"></a>插入Latex公式</h3><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> matplotlib.patches <span class="hljs-keyword">import</span> Polygon<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>plt.rcParams[<span class="hljs-string">'font.sans-serif'</span>] = [<span class="hljs-string">'STHeiti'</span>]  <span class="hljs-comment"># 用来正常显示中文标签</span><br>plt.rcParams[<span class="hljs-string">'axes.unicode_minus'</span>] = <span class="hljs-literal">False</span>  <span class="hljs-comment"># 用来正常显示负号</span><br><br><br><span class="hljs-comment"># 定义一个求积分的函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(x)</span>:</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0.3</span> * (x ** <span class="hljs-number">2</span>) + (<span class="hljs-number">0.1</span> * x) + <span class="hljs-number">1</span><br><br><br><span class="hljs-comment"># 定义积分区间</span><br>a, b = <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br>x = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)<br>y = func(x)<br><br><span class="hljs-comment"># 绘制曲线</span><br>fig, ax = plt.subplots(figsize=(<span class="hljs-number">14</span>, <span class="hljs-number">8</span>))<br>plt.plot(x, y, <span class="hljs-string">'g'</span>)<br><br><span class="hljs-comment"># 使用Polygon生成阴影部分</span><br>Ix = np.linspace(a, b)<br>Iy = func(Ix)<br>verts = [(a, <span class="hljs-number">0</span>)] + list(zip(Ix, Iy)) + [(b, <span class="hljs-number">0</span>)]<br>ploy = Polygon(verts, facecolor=<span class="hljs-string">'0.7'</span>, edgecolor=<span class="hljs-string">'0.5'</span>)<br>ax.add_patch(ploy)<br><br><span class="hljs-comment"># 添加数学公式和坐标轴标签</span><br><span class="hljs-comment"># r" "中间为LaTex语法表示的公式</span><br>plt.text(<span class="hljs-number">0.5</span> * (a + b), <span class="hljs-number">1</span>, <span class="hljs-string">r"$\int_a^b f(x)\mathrm&#123;d&#125;x$"</span>,<br>         horizontalalignment=<span class="hljs-string">'center'</span>, fontsize=<span class="hljs-number">20</span>)<br><span class="hljs-comment"># 前两个参数是放置文本的坐标</span><br>plt.figtext(<span class="hljs-number">0.9</span>, <span class="hljs-number">0.075</span>, <span class="hljs-string">'$x$'</span>)<br>plt.figtext(<span class="hljs-number">0.075</span>, <span class="hljs-number">0.9</span>, <span class="hljs-string">'$f(x)$'</span>)<br><br>ax.set_xticks((a, b))<br>ax.set_xticklabels((<span class="hljs-string">'$a$'</span>, <span class="hljs-string">'$b$'</span>))<br>ax.set_yticks((func(a), func(b)))<br>ax.set_yticklabels((<span class="hljs-string">'$f(a)$'</span>, <span class="hljs-string">'$f(b)$'</span>))<br>plt.grid(<span class="hljs-literal">True</span>)<span class="hljs-comment"># 网格</span><br>plt.show()<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 画图 </tag>
            
            <tag> Matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTex学习</title>
      <link href="/2019/08/02/Latex%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/08/02/Latex%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><strong>本文主要介绍了以下内容:</strong></p><p>LaTex一些基础知识</p><a id="more"></a><h3 id="开始第一个LaTex文档"><a href="#开始第一个LaTex文档" class="headerlink" title="开始第一个LaTex文档"></a>开始第一个LaTex文档</h3><p>打开TeXstudio,新建一个TeX文件,写入以下内容</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass&#123;article&#125;<br>\begin&#123;document&#125;<br>Here comes \LaTeX!<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><p>​    此处的第一行<code>\documentclass{article}</code>中包含了一个控制序列(或称命令/标记).所谓控制序列,是以反斜杠<code>\</code>开头,以第一个空格或非字母的字符结束的一串文字.它们不能被输出,但是它们会影响输出文档的效果.这里的控制序列是<code>documentclass</code>,它后面紧跟着的<code>{article}</code>代表这个控制序列有一个必要的参数,该参数的值为<code>article</code>这个控制序列的作用,是调用名为<code>article</code>的文档类.</p><p>​    <strong>Tex对控制序列的大小写是敏感的</strong></p><ul><li><p>部分控制序列还有被方括号<code>[]</code>包括的可选参数</p></li><li><p>所谓文档类,即是Tex系统预设的(或是用户自定的)一些格式的集合.不同文档类在输出效果上会有差别.</p><p>  此处的第二行以<code>%</code>开头.Tex以<code>%</code>作为注释标记符.具体来说,Tex会忽略从<code>%</code>开始当当前行末尾的所有内容.这些内容不会被输出,也不影响最终的排版效果,只供人类阅读.若要输出<code>%</code>字符本身,则需要在<code>%</code>之前加上反斜杠<code>\</code>进行转义(escape).例如</p>  <figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">今年的净利润为20\%, 比去年高<br></code></pre></td></tr></table></figure><p>  此处<code>%</code>被当做正常的百分号来处理, 其后的文字也将被正常输出.</p><p>  在注释行之后出现了控制序列<code>begin</code>.这个控制序列总是与<code>end</code>成对出现.这两个控制序列以及它们中间的内容被称为[环境],它们之后的第一个必要参数总是一致,被称为环境名.</p><p>  只有在<code>document</code>环境中的内容,才会被正常输出到文档中去或是作为控制序列对文档产生影响.也就是说,在<code>\end{document}</code>之后插入任何内容都是无效的.</p><p>  从<code>\documentclass{article}</code>开始到<code>\begin{document}</code>之前的部分被称为导言区.你可以将导言区理解为时对整篇文档进行设置的区域——在导言区出现的控制序列,往往会影响整篇文档的格式.</p><p>  <strong>通常在导言区设置页面的大小,页眉页脚样式,章节标题等等</strong></p></li></ul><h3 id="实现中英文混排"><a href="#实现中英文混排" class="headerlink" title="实现中英文混排"></a>实现中英文混排</h3><p>​    <strong>关于LaTeX的中文支持,首先要说明的是:在现在,一切教你使用<code>CJK</code>宏包的模板,人,网页,书,都是糟糕的,有害的,恼人的,邪恶的和应该摒弃的</strong></p><p>​    成功编译出一个文档后,中国Tex用户面临的第二个普遍问题大概就是<strong>实现中英文混排</strong>了.</p><p>​    宏包,就是一系列控制序列的合集.这里控制序列太常用,以至于人们会觉得每次将他们写在导言区太过繁琐,于是将他们打包在同一个文件架中,称为所谓的宏包.<code>\usepackage{}</code>可以用来调用宏包</p><p>​    除去中文支持,中文的板式处理和标点禁则也是不小的挑战.好在由刘海洋,李清等人维护的<code>CTeX</code>宏集一次性解决了这些问题.<code>CTeX</code>宏集的优势在于,他能适配于多种编译方式,在内部处理好了中文和中文版式的支持,影藏了这些细节,并且提供了不少中文用户需要的功能接口.</p><figure class="hljs highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&gt;请注意,`CTeX`宏集和`CTeX`套装是两个不同的东西.`CTeX`宏集的本质是LaTeX宏的集合,包含若干文档类(`.cls`文件)和宏包(`.sty`文件).`CTeX`套装是一个过时的TeX系统.<br>&gt;<br>&gt;新版`CTeX`宏集默认能够自动检测用户的操作系统,并为之配置合适的字库.<br></code></pre></td></tr></table></figure><p>​    使用以下代码来完成对<code>CTeX</code>宏集的调用:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[UTF8]&#123;ctexart&#125;<br>\begin&#123;document&#125;<br>你好, world!<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><h3 id="组织你的文章"><a href="#组织你的文章" class="headerlink" title="组织你的文章"></a>组织你的文章</h3><h4 id="作者-标题-日期"><a href="#作者-标题-日期" class="headerlink" title="作者,标题,日期"></a>作者,标题,日期</h4><p>保存并用XeLaTeX编译如下文档:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[UTF8]&#123;ctexart&#125;<br>\title&#123;你好, world!&#125;<br>\author&#123;胡奔&#125;<br>\date&#123;\today&#125;<br>\begin&#123;document&#125;<br>\maketitle<br>你好, 胡奔<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><p>导言区复杂了很多,但和之前的文档区别只有一处: 定义了<strong>标题,作者,日期</strong></p><p>在<code>document</code>环境中,除了原本的<code>你好,world!</code>,还多了一个控制序列<code>\maketitle</code>,这个控制序列能将在导言区中定义的标题,作者,日期按照预定义的格式展现出来.</p><blockquote><p>使用<code>titling</code>红包可以修改上述默认格式,参考<a href="http://texdoc.net/texmf-dist/doc/latex/titling/titling.pdf" target="_blank" rel="noopener">TeXdoc</a>    </p></blockquote><h4 id="章节和段落"><a href="#章节和段落" class="headerlink" title="章节和段落"></a>章节和段落</h4><p>保存并用XeLaTeX编译如下文档,查看效果:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[UTF8]&#123;ctexart&#125;<br>\title&#123;你好,\LaTeX&#125;<br>\author&#123;Huris&#125;<br>\date&#123;\today&#125;<br>\begin&#123;document&#125;<br>\maketitle<br>\section&#123;你好中国&#125;<br>中国在East Asia.<br>\subsection&#123;Hello Beijing&#125;<br>北京是 captical of China<br>\subsubsection&#123;Hello Dongcheng District&#125;<br>\paragraph&#123;Tian&apos;anmen Square&#125;<br>is in the center of Beijing<br>\subparagraph&#123;Chairman Mao&#125;<br>is in the center of 天安门广场<br>\subsection&#123;Hello 山东&#125;<br>\paragraph&#123;山东大学&#125;<br>is one of the best university in 山东.<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><p>在文档类<code>article</code>/<code>ctexart</code>中,定义了五个控制序列(只有五个)来调整行文组织结构,他们分别是:</p><ul><li><code>\section{.}</code></li><li><code>\subsection{.}</code></li><li><code>\subsubsection{.}</code></li><li><code>\paragraph{.}</code></li><li><code>\subparagraph</code></li></ul><h4 id="插入目录"><a href="#插入目录" class="headerlink" title="插入目录"></a>插入目录</h4><p>在上一节文档中,找到<code>\maketitle</code>,在他的下面插入控制序列<code>\tableofcontents</code>,保存并用XeLaTeX编译两次,观察结果:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[UTF8]&#123;ctexart&#125;<br>\title&#123;你好,\LaTeX&#125;<br>\author&#123;Huris&#125;<br>\date&#123;\today&#125;<br>\begin&#123;document&#125;<br>\maketitle<br>\tableofcontents<br>\section&#123;你好中国&#125;<br>中国在East Asia.<br>\subsection&#123;Hello Beijing&#125;<br>北京是 captical of China<br>\subsubsection&#123;Hello Dongcheng District&#125;<br>\paragraph&#123;Tian&apos;anmen Square&#125;<br>is in the center of Beijing<br>\subparagraph&#123;Chairman Mao&#125;<br>is in the center of 天安门广场<br>\subsection&#123;Hello 山东&#125;<br>\paragraph&#123;山东大学&#125;<br>is one of the best university in 山东.<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意<code>\maketitle</code>与<code>\tableofcontents</code>位置不能交换</p></blockquote><p>另外,LaTeX中间一个换行当做是一个简单的空格来处理,如果需要换行另起一段,则需要使用两个换行(一个空行)来实现.</p><h4 id="插入数学公式"><a href="#插入数学公式" class="headerlink" title="插入数学公式"></a>插入数学公式</h4><p>为了使用AMS-LaTeX提供的数学功能,我们需要在导言区加载<code>amsmath</code>宏包</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\usepackage&#123;amsmath&#125;<br></code></pre></td></tr></table></figure><h5 id="数学模式"><a href="#数学模式" class="headerlink" title="数学模式"></a>数学模式</h5><p>LaTex的数学模式有两种: 行内模式(inline)和行间模式(display).前者在正文的行文中,插入数学公式;后者独立排列单独成行</p><p>在行文中,使用<script type="math/tex">...</script>可以插入行内公式,使用<code>\[...\]</code>可以插入行间公式,如果需要对行间公式进行编号,可以使用equation环境.</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex">\begin&#123;equation&#125;<br>...<br>\end&#123;equation&#125;<br></code></pre></td></tr></table></figure><h5 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h5><p>示例代码:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[UTF8]&#123;ctexart&#125;<br>\usepackage&#123;amsmath&#125;<br>\begin&#123;document&#125;<br>Einsten&apos;s $E=mc^2$.<br>\[E=mc^2.\]<br>\begin&#123;equation&#125;<br>E=mc^2.<br>\end&#123;equation&#125;<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><blockquote><p>标点公式使用的规范</p><p>行内公式: 应该放在数学模式限定符之外</p><p>行间公式: 应该放在数学模式限定符之内</p></blockquote><p><code>_{...}</code>表示下标,<code>^{...}</code>表示上标.它默认只作用于之后的一个字符,如果想对连续的几个字符起作用,请将这些字符用花括号<code>{}</code>括起来.</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\[ z = r\cdot e^&#123;2\pi i&#125;. \]<br></code></pre></td></tr></table></figure><h5 id="根式与分式"><a href="#根式与分式" class="headerlink" title="根式与分式"></a>根式与分式</h5><p>根式用<code>\sqrt{.}</code>表示,分式用<code>\frac{.}{.}</code>表示(第一个参数为分子,第二个参数为分母).</p><p>示例代码:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[UTF8]&#123;ctexart&#125;<br>\usepackage&#123;amsmath&#125;<br>\begin&#123;document&#125;<br>$\sqrt&#123;x&#125;$, $\frac&#123;1&#125;&#123;2&#125;$.<br><br>\[ \sqrt&#123;x&#125;, \]<br><br>\[ \frac&#123;1&#125;&#123;2&#125;. \]<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><p>可以发现,在行间公式和行内公式中,分式的输出效果是由差异的. 如果要强制行内模式的分式显示为行间模式的大小,可以使用<code>\dfrac</code>,反之可以使用<code>\tfrac</code></p><blockquote><p>在行内写分式,可能会喜欢<code>xfrac</code>宏包提供的<code>\sfrac</code>命令的效果</p><p>排版繁公式时,应该使用<code>\cfrac</code>命令</p></blockquote><h5 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h5><p>一些小的运算符,可以在数学模式下直接输入;另一些要用控制序列生成</p><blockquote><p>控制序列</p><p>凡是键盘不能够直接表示的符号或者起着特定作用的皆有命令,类似转义,叫做<strong>控制序列(control sequence)</strong>,比如求和符合$\sum$对应的命令为<code>\sum</code></p></blockquote><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex">\[ \pm\; \times \; \div\; \cdot\; \cap\; \cup\;<br>   \geq\; \leq\; \neq\; \approx\; \equiv \]<br></code></pre></td></tr></table></figure><p>连加,连乘,极限,积分符号等大型运算符分别用<code>\sum</code>,<code>\prod</code>,<code>\lim</code>,<code>\int</code>生成</p><p>他们的上下标在行内公式中被压缩,以适应行高.我们可以使用<code>\limits</code>和<code>\nolimits</code>来强制显示地指定是否压缩这些上下标.</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">$ \sum_&#123;i=1&#125;^n i\quad \prod_&#123;i=1&#125;^n $<br>$ \sum\limits _&#123;i=1&#125;^n i\quad \prod\limits _&#123;i=1&#125;^n $<br>\[ \lim_&#123;x\to0&#125;x^2 \quad \int_a^b x^2 dx \]<br>\[ \lim\nolimits _&#123;x\to0&#125;x^2\quad \int\nolimits_a^b x^2 dx \]<br></code></pre></td></tr></table></figure><p>多重积分可以使用<code>\iint</code>,<code>\iiint</code>,<code>\iiint</code>,<code>\idotsint</code>等命令输入</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\[ \iint\quad \iiint\quad \iiint\quad \idotsint \]<br></code></pre></td></tr></table></figure><h5 id="定界符"><a href="#定界符" class="headerlink" title="定界符"></a>定界符</h5><p>各种括号用<code>()</code>,<code>[]</code>,<code>\{\}</code>,<code>\langle\rangle</code>等命令表示</p><p>注意花括号通常用来输入命令和环境的参数,所以在数学公式中它们前面要加<code>\</code></p><p>因为LaTeX中<code>|</code>和<code>\|</code>的应用过于随意,amsmath宏包推荐用<code>\lvert\rvert</code>和<code>\lVert\rVert</code>取而代之.</p><p>为了调整这些定界符的大小,amsmath宏包推荐使用<code>\big</code>,<code>\Big</code>,<code>\bigg</code>,<code>\Bigg</code>等一系列命令放在上述括号前面调整大小</p><blockquote><p>有时候可能会觉得amsmath宏包提供的定界符放大命令不太够用.</p><p>通常这就意味着你的公式过于复杂</p><p>此时应当首先考虑将公式中的部分提出去,以字母符号代替以简化公式</p><p>如果真的想排版出如此复杂的公式,可以参考<a href="https://liam.page/2018/11/09/the-bigger-than-bigger-delimiter-in-LaTeX/" target="_blank" rel="noopener">这篇博文</a></p></blockquote><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs latex">\[ \Biggl(\biggl(\Bigl(\bigl((x)\bigr)\Bigr)\biggr)\Biggr) \]<br>\[ \Biggl[\biggl[\Bigl[\bigl[[x]\bigr]\Bigr]\biggr]\Biggr] \]<br>\[ \Biggl \&#123;\biggl \&#123;\Bigl \&#123;\bigl \&#123;\&#123;x\&#125;\bigr \&#125;\Bigr \&#125;\biggr \&#125;\Biggr\&#125; \]<br>\[ \Biggl\langle\biggl\langle\Bigl\langle\bigl\langle\langle x<br>\rangle\bigr\rangle\Bigr\rangle\biggr\rangle\Biggr\rangle \]<br>\[ \Biggl\lvert\biggl\lvert\Bigl\lvert\bigl\lvert\lvert x<br>\rvert\bigr\rvert\Bigr\rvert\biggr\rvert\Biggr\rvert \]<br>\[ \Biggl\lVert\biggl\lVert\Bigl\lVert\bigl\lVert\lVert x<br>\rVert\bigr\rVert\Bigr\rVert\biggr\rVert\Biggr\rVert \]<br></code></pre></td></tr></table></figure><h5 id="省略号"><a href="#省略号" class="headerlink" title="省略号"></a>省略号</h5><p>省略号用<code>\dots</code>,<code>\cdots</code>,<code>\vdots</code>,<code>\ddots</code>等命令表示.</p><p><code>\dots</code>和<code>\cdots</code>的纵向位置不同,前者一般用于有下标的序列.</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex">\[ x_1,x_2,\dots ,x_n\quad 1,2,\cdots ,n\quad<br>\vdots\quad \ddots \]<br></code></pre></td></tr></table></figure><h5 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h5><p><code>amsmath</code>的<code>pmatrix</code>,<code>bmatrix</code>,<code>Bmatrix</code>,<code>vmatrix</code>,<code>Vmatrix</code>等环境可以在矩阵两边加上各种分隔符.</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs latex">\[ \begin&#123;pmatrix&#125; a&amp;b\\c&amp;d \end&#123;pmatrix&#125; \quad<br>\begin&#123;bmatrix&#125; a&amp;b\\c&amp;d \end&#123;bmatrix&#125; \quad<br>\begin&#123;Bmatrix&#125; a&amp;b\\c&amp;d \end&#123;Bmatrix&#125; \quad<br>\begin&#123;vmatrix&#125; a&amp;b\\c&amp;d \end&#123;vmatrix&#125; \quad<br>\begin&#123;Vmatrix&#125; a&amp;b\\c&amp;d \end&#123;Vmatrix&#125; \]<br></code></pre></td></tr></table></figure><p>使用<code>smallmatrix</code>环境,可以生成行内公式的小矩阵</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">Marry has a little matrix $(\begin&#123;smallmatrix&#125; a&amp;b\\c&amp;d \end&#123;smallmatrix&#125; )$.<br></code></pre></td></tr></table></figure><h5 id="多行公式"><a href="#多行公式" class="headerlink" title="多行公式"></a>多行公式</h5><ul><li>有的公式特别长,需要手动为他们换行</li><li>有几个公式是一组,我们需要将他们放在一起</li><li>还有些类似分段函数,我们需要给他加上一个左边的花括号</li></ul><h6 id="长公式"><a href="#长公式" class="headerlink" title="长公式"></a>长公式</h6><h6 id="不对齐"><a href="#不对齐" class="headerlink" title="不对齐"></a>不对齐</h6><p>无须对齐的长公式可以使用<code>multline</code>环境.</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">\begin&#123;multline&#125;<br>x = a+b+c+&#123;&#125; \\<br>d+e+f+g<br>\end&#123;multline&#125;<br></code></pre></td></tr></table></figure><p>如果不需要编号,则可以使用<code>multline*</code>环境代替.</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[UTF8]&#123;ctexart&#125;<br>\usepackage&#123;amsmath&#125;<br>\begin&#123;document&#125;<br>\begin&#123;multline*&#125;<br>x = a+b+c+&#123;&#125; \\<br>d+e+f+g<br>\end&#123;multline*&#125;<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><h6 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h6><p>需要对齐公式,可以使用<code>aligned</code>次环境来实现,它必须包含在数学环境之内</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">\[\begin&#123;aligned&#125;<br>x =&#123;&#125;&amp; a+b+c+&#123;&#125; \\<br>&amp;d+e+f+g<br>\end&#123;aligned&#125;\]<br></code></pre></td></tr></table></figure><h6 id="公式组"><a href="#公式组" class="headerlink" title="公式组"></a>公式组</h6><p>无需对齐公式的公式组可以使用<code>gather</code>环境,需要对齐的公式组可以使用<code>align</code>环境</p><p>他们都带有编号,如果不需要编号可以使用待星花的版本.</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs latex">\begin&#123;gather&#125;<br>a=b+c+d \\<br>x=y+z<br>\end&#123;gather&#125;<br>\begin&#123;align&#125;<br>a &amp;= b+c+d \\<br>x &amp;= y+z<br>\end&#123;align&#125;<br></code></pre></td></tr></table></figure><h6 id="分段函数"><a href="#分段函数" class="headerlink" title="分段函数"></a>分段函数</h6><p>分段函数可以用<code>cases</code>次环境来实现,它必须包含在数学环境之内.</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">\[ y\begin&#123;cases&#125;<br>-x,\quad x\leq 0 \\<br>x,\quad x&gt;0<br>\end&#123;cases&#125; \]<br></code></pre></td></tr></table></figure><h4 id="插入图片和表格"><a href="#插入图片和表格" class="headerlink" title="插入图片和表格"></a>插入图片和表格</h4><h5 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h5><p>LaTeX中插入图片,有很多种方式.</p><p>最好用的应当属利用<code>graphicx</code>宏包提供的<code>\includegraphics</code>命令</p><p>比如,在TeX源文件同目录下,有名为<code>a.jpg</code>的图片,可以用这样的方式将他插入到输出文档中:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[UTF8]&#123;ctexart&#125;<br>\usepackage&#123;graphicx&#125;<br>\begin&#123;document&#125;<br>\includegraphics&#123;a.jpg&#125;<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><p>图片可能很大,超过了输出文件的纸张大小,或者输出效果不是很好</p><p>此时可以用<code>\includegraphics</code>控制序列的可选参数来控制.</p><p>比如:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\includegraphics[width = .8\textwidth]&#123;a.jpg&#125;<br></code></pre></td></tr></table></figure><p>这样图片的高度会缩小为原来的80%,图片的总高度会按比例缩放</p><p><code>\includegraphics</code>控制序列还有若干其他的可选参数,一般用不到,具体可以查看该宏包的<a href="http://texdoc.net/texmf-dist/doc/latex/graphics/graphicx.pdf" target="_blank" rel="noopener">参考文档</a></p><h5 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h5><p><code>tabular</code>环境提供了最简单的表格功能.它用<code>\hline</code>命令表示横线,在列格式中用<code>|</code>表示竖线,用<code>&amp;</code>来进行分列,用<code>\\</code>来换行,每列可以采用居左,居中,居右等横向对齐方式,分别用<code>l</code>,<code>c</code>,<code>r</code>来表示</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs latex">\begin&#123;tabular&#125;&#123;l|c|r&#125;<br>\hline<br>操作系统&amp;发行版&amp;编辑器\\<br>\hline<br>Windows &amp; MikTeX &amp;TexMakerX \\<br>\hline<br>Unix/Linux &amp; teTeX &amp; Kile \\<br>\hline<br>Mac OS &amp; MacTeX &amp; TeXShop \\<br>\hline<br>通用&amp; TeX Live &amp; TeXworks \\<br>\hline<br>\end&#123;tabular&#125;<br></code></pre></td></tr></table></figure><p>浮动体</p><p>插图和表格通常需要占据大块空间,所以在文字处理软件中我们经常需要调整他们的位置</p><p><code>figure</code>和<code>table</code>环境可以自动完成这样的任务</p><p>这种自动调整位置的环境称作浮动体(float)</p><p>以<code>figure</code>为例</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs latex">\begin&#123;figure&#125;[htbp]<br>\centering% 使插图居中<br>\includegraphics&#123;a.jpg&#125;<br>\caption&#123;有图有真相&#125;% 设置插图标题<br>\label&#123;fig:myphoto&#125;  <br>\end&#123;figure&#125;<br></code></pre></td></tr></table></figure><p><code>htbp</code>选项用来指定插图的理想位置,如下表所示:</p><div class="table-container"><table><thead><tr><th style="text-align:center">here</th><th style="text-align:center">top</th><th style="text-align:center">bottom</th><th style="text-align:center">float page(专门放浮动体的单独页面或芬兰)</th></tr></thead><tbody><tr><td style="text-align:center">这里</td><td style="text-align:center">页眉</td><td style="text-align:center">页尾</td><td style="text-align:center">浮动页</td></tr></tbody></table></div><h3 id="版面设置"><a href="#版面设置" class="headerlink" title="版面设置"></a>版面设置</h3><h4 id="页边距"><a href="#页边距" class="headerlink" title="页边距"></a>页边距</h4><p>设置页边距,推荐使用<code>geometry</code>宏包,可以看到<a href="http://texdoc.net/texmf-dist/doc/latex/geometry/geometry.pdf" target="_blank" rel="noopener">文档</a></p><p>将纸张的长度设置为20cm,宽度设置为15cm,左边距1cm,右边距2cm,上边距3cm,下边距4cm,可以在导言区加上这样的几行:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex">\usepackage&#123;geometry&#125;<br>\geometry&#123;papersize=&#123;20cm,15cm&#125;&#125;<br>\geometry&#123;left=1cm,right=2cm,top=3cm,bottom=4cm&#125;<br></code></pre></td></tr></table></figure><p>页眉页脚,推荐使用<code>fancyhdr</code>宏包,可以在这里查看它的<a href="http://texdoc.net/texmf-dist/doc/latex/fancyhdr/fancyhdr.pdf" target="_blank" rel="noopener">说明文档</a></p><p>页眉左边写上我的名字,中间写上今天的日期,右边写上我的电话</p><p>页脚的正中写上页码,页眉和正文之间有一道宽为0.4pt的横线分割,可以在导言区加上如下几行:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs latex">\usepackage&#123;fancyhdr&#125;<br>\pagestyle&#123;fancy&#125;<br>\lhead&#123;\author&#125;<br>\chead&#123;\date&#125;<br>\rhead&#123;18757479599&#125;<br>\lfoot&#123;&#125;<br>\cfoot&#123;\thepage&#125;<br>\rfoot&#123;&#125;<br>\renewcommand&#123;\headrulewidth&#125;&#123;0.4pt&#125;<br>\renewcommand&#123;\headwidth&#125;&#123;\textwidth&#125;<br>\renewcommand&#123;\footrulewidth&#125;&#123;0pt&#125;<br></code></pre></td></tr></table></figure><h4 id="首行缩进"><a href="#首行缩进" class="headerlink" title="首行缩进"></a>首行缩进</h4><p>CTeX宏集已经处理好了首行缩进的问题(自然段前空两格汉字宽度)</p><p>因此,使用CTeX宏集进行中西文混合排版时,不需要关注首行缩进的问题.</p><h4 id="行间距"><a href="#行间距" class="headerlink" title="行间距"></a>行间距</h4><p>可以通过<code>setspace</code>宏包提供的命令来调整行间距</p><p>在导言区添加如下内容,可以将行距设置为字号的1.5倍</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex">\usepackage&#123;setspace&#125;<br>\onehalfspacing<br></code></pre></td></tr></table></figure><p>注意用词的差别</p><ul><li>行距是字号的1.5倍</li><li>1.5倍行距</li></ul><p>事实上,这不是设置1.5倍行距的正确方法,具体可看<a href>此处</a></p><h4 id="段间距"><a href="#段间距" class="headerlink" title="段间距"></a>段间距</h4><p>可以通过修改长度<code>\parskip</code>的值来调整段间距.</p><p>在导言区添加如下内容:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\addtolength&#123;\parskip&#125;&#123;.4em&#125;<br></code></pre></td></tr></table></figure><h3 id="命令与环境"><a href="#命令与环境" class="headerlink" title="命令与环境"></a>命令与环境</h3><p>LaTeX中的命令通常是由一个反斜杠加上命令名称，再加上花括号内的参数构成的(有的命令不带参数，例如<code>\TeX</code>)</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass&#123;ctexart&#125;<br></code></pre></td></tr></table></figure><p>如果有一些选项是备选的，那么通常会在花括号前用方括号标出，比如：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[a4paper]&#123;ctexart&#125;<br></code></pre></td></tr></table></figure><p>还有一种重要指令叫做环境。它被定义于控制命令<code>\begin{environment}</code>和<code>\end{environment}</code>间的内容。比如：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex">\begin&#123;document&#125;<br>...内容...<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><p>环境如果有备选参数，只需要写在<code>\begin[...]{name}</code>这里就行。</p><p>注意：不带花括号的命令后面如果想打印空格，需加上<strong>一对内部为空的花括号</strong>再键入空格。否则空格会被忽略。例如<code>\LaTeX{}Studio</code></p><p><strong>有时候LaTeX编译出现异常，需要删除文件夹下除了tex以外的文件再编译。</strong></p><p><strong>另外，在某些独占程序打开了以上文件时(比如用Acrobat打开了pdf)，编译可能出现错误。在编译时确保关闭这些独占程序。</strong></p><h3 id="保留字符-共8个"><a href="#保留字符-共8个" class="headerlink" title="保留字符(共8个)"></a>保留字符(共8个)</h3><p>#：自定义命令时，用于标明参数序号</p><p>$： 数学环境命令符</p><p>%：注释符，在其后的该行命令都会视为注释。如果在回车前输入这个命令，可以防止行末LaTeX插入一些奇怪的空白符。</p><p>^：数学环境中的上标命令符。</p><p>&amp;：表格环境中的跳列符</p><p>_：数学环境中的下标命令符</p><p>{与}：花括号用于标记命令的必选参数，或者标记某一部分命令称为一个整体。</p><p>\：反斜杠用于开始各种LaTeX命令。</p><blockquote><p>以上命令除了反斜杠，均能在前加反斜杠的形式输出。</p></blockquote><p>反斜杠输出：<code>\texttt{\char92}</code></p><p>其中命令<code>\char[num]</code>是一个特殊的命令，使用环境需要是tt字体环境，用于输出USCII码对应的字符，92对应的即反斜杠。</p><p>也可以使用   <strong>\char`</strong>  后加字符的方式输出想要的命令，但需要包裹在<code>\texttt</code>或者<code>\ttfamily</code>内、如果想要输出的字符是保留字，则需要在前面加一个反斜杠。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex">\texttt&#123;\char`~&#125;% 输出一个波浪线<br>\texttt&#123;\char`\\&#125;% 输出保留字反斜杠<br>\texttt&#123;\char`@&#125;% 实际上可直接输入@<br></code></pre></td></tr></table></figure><p>另外上面说的波浪线<code>~</code>用来输出一个禁止在该处断行的空格，也不能能够直接输出。</p><p>尝试：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">a $\sim$ b<br>a\~b<br>a\~&#123;&#125; b<br>a\textasciitilde b<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/image1.png" width="30%"></p><h3 id="导言区"><a href="#导言区" class="headerlink" title="导言区"></a>导言区</h3><p>任何一份LaTeX文档都应当包含如下结构：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[options]&#123;doc-class&#125;<br>% 导言区<br>\begin&#123;document&#125;<br>...<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><p>其中，在语句<code>\begin{document}</code>之前的内容称为<strong>导言区</strong>。导言区可以留空，以可以进行一些文档的准备操作。即，<strong>导言区即为模板定义</strong>。</p><p>文档类参数<strong>doc-class</strong>和可选选项<strong>options</strong>由表3.1取值。</p><div class="table-container"><table><thead><tr><th>doc-class</th><th>文档类</th></tr></thead><tbody><tr><td>article</td><td>科学期刊，演示文稿，段报告，邀请函</td></tr><tr><td>proc</td><td>基于article的会议论文集</td></tr><tr><td>report</td><td>多章节的长报告、博士论文、短篇书</td></tr><tr><td>book</td><td>书籍</td></tr><tr><td>slides</td><td>幻灯片，使用了大号Scans Serif字体</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>options</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td>字体</td><td style="text-align:left">默认10pt，可选11pt和12pt</td></tr><tr><td>页面方向</td><td style="text-align:left">默认竖向protrait，可选横向landscape</td></tr><tr><td>纸张尺寸</td><td style="text-align:left">默认letterpaper，可选用a4paper，b5paper等</td></tr><tr><td>分栏</td><td style="text-align:left">默认onecolumn，还有twocolumn</td></tr><tr><td>双面打印</td><td style="text-align:left">有oneside/twoside两个选项，用于排版奇偶页。article/report默认单页</td></tr><tr><td>章节分页</td><td style="text-align:left">有openright/openany两个选项，决定是在奇数页开启新页或是任意页开启新页。注意article是没有chapter(“章”)命令的，默认任意页。</td></tr><tr><td>公式对齐</td><td style="text-align:left">默认居中，可改为左对齐fleqn，默认编号居中，可改为左对齐leqno</td></tr><tr><td>草稿选项</td><td style="text-align:left">默认final，可改为draft，使行溢出的部分显示为黑块。</td></tr></tbody></table></div><p>在导言区最常见的是<strong>宏包</strong>的加载工作，命令形如：<code>\usepackage{package}</code>。</p><p>宏包是一系列已经制作好的功能”模块”，在需要使用一些原生LaTeX不带有的功能时，只需要调用这些宏包就可以了。</p><h3 id="标点与强调"><a href="#标点与强调" class="headerlink" title="标点与强调"></a>标点与强调</h3><p>英文符号$|&lt;&gt;+=$一般用于数学环境中，如果在文本中使用，在两侧加上”$”</p><p>如果在LaTeX中直接输入大于，小于号而不把他们放在数学环境中，它们并不会被正确地打印。</p><p>应该使用<code>\textgreater</code>、<code>\textless</code>命令。</p><h4 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h4><p>英文单引号：左单引号是重音符`(键盘上1左侧)，右单引号是常用的引号符</p><p>英文双引号：左双引号是连续两个重音符``(键盘上1左侧)，右双引号是常用的引号符</p><p>英文下的引号嵌套需要借助<code>\thinspace</code>命令分隔，比如：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">``\thinspace`Max&apos; is here.&apos;&apos;<br></code></pre></td></tr></table></figure><p>中文下册单引号和双引号可用中文输入法直接输入。</p><h4 id="破折、省略号与短横"><a href="#破折、省略号与短横" class="headerlink" title="破折、省略号与短横"></a>破折、省略号与短横</h4><p>英文短横分为三种：</p><ul><li>连字符：输入一个短横：-，效果如daughter-in-law</li><li>数字起止符：输入链各个短横：- -，效果如：page 1-2</li><li>破折号：输入三个短横 - - -，效果如：Listen—I’m serious.</li></ul><p>中文的破折号可以直接使用日常的输入方式。中文的省略号同样。但是注意，英文的省略号使用<code>\ldots</code>这个命令而不是三个句点。</p><h4 id="强调：粗与斜"><a href="#强调：粗与斜" class="headerlink" title="强调：粗与斜"></a>强调：粗与斜</h4><p>LaTeX中专门有个叫做<code>\emph{text}</code>的命令，可以强调文本。对于通常的西文文本，上述命令的作用就是斜体。如果对一段已经这样转为斜体的文本再使用这个命令，他就会取消斜体，而成为正体。</p><p><strong>因为一般采用斜体强调的方式而不是粗体</strong></p><h4 id="下划线与删除线"><a href="#下划线与删除线" class="headerlink" title="下划线与删除线"></a>下划线与删除线</h4><p>建议使用<strong>ulem</strong>宏包中的uline命令代替原生的，<strong>ulem</strong>宏包还提供了一些实用命令：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[a4paper]&#123;ctexart&#125;<br>\usepackage[normalem]&#123;ulem&#125;<br><br>\begin&#123;document&#125;<br>\uline&#123;下划线&#125;<br>\uuline&#123;双下划线&#125;<br>\dashuline&#123;虚下划线&#125;<br>\dotuline&#123;点下划线&#125;<br>\uwave&#123;波浪线&#125;<br>\sout&#123;删除线&#125;<br>\xout&#123;斜删除线&#125;<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/image2.png" width="30%"></p><p>需要注意，<strong>ulem</strong>宏包冲定义了<code>\emph</code>命令，<strong>使得原来的加斜强调变成了下划线，原来的两次强调就取消强调变成了两次强调就双下划线。</strong></p><p>通过宏包的<strong>normalem</strong>选项可以取消这个更改：<code>\usepackage[normalem]{ulem}</code></p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>角度符号或者温度符号需要借助数学模式$…$输入：</li></ul><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex">$30\,^&#123;\circ&#125;$ 三角形<br>$37\,^&#123;\circ&#125;\mathrm&#123;C&#125;$<br></code></pre></td></tr></table></figure><ul><li>欧元符号可能需要用到<strong>textcomp</strong>宏包支持的<code>\texteuro</code>命令</li><li>千分位分隔符，如果不想它在中间断行，就在外侧再加上一个<code>\mbox</code>命令：<code>\mbox{1\,000\,000}</code></li><li>注音符号</li></ul><p><strong>hologo</strong>宏包，它允许输出许多TeX家族标志。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">\LaTeX<br>\TeX<br>\hologo&#123;XeLaTeX&#125;<br>\hologo&#123;BibTex&#125;<br></code></pre></td></tr></table></figure><h3 id="格式控制"><a href="#格式控制" class="headerlink" title="格式控制"></a>格式控制</h3><p>LaTeX的长度单位：</p><ul><li><strong>pt</strong>：point，磅</li><li><strong>pc</strong>：pica，1pc=12pt，四号字大小</li><li><strong>in</strong>：inch，英寸，1in=72.72pt</li><li><strong>bp</strong>：bigpoint，大点。1bp=$\tfrac1{12}$in</li><li><strong>cm</strong>：centimeter，厘米，1cm=$\tfrac1{2.54}$in</li><li><strong>mm</strong>：millimeter，毫米，1mm=$\tfrac1{10}$cm</li><li><strong>sp</strong>：scaled point，TeX的基本长度单位，1sp=$\tfrac1{65536}$pt</li><li><strong>em</strong>：当前字号下，大写字母的宽度</li><li><strong>ex</strong>：当前字号下，小写字母x的高度</li></ul><p>几个常用的长度宏：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex">\textwidth % 页面上文字的总宽度，即页宽减去两侧边距<br>\linewidth % 当前行允许的行宽<br></code></pre></td></tr></table></figure><p>有时候可以使用可变长度，比如”5pt plus 3pt minus 2pt”，表示一个能收缩到3pt也能伸长到8pt的长度，直接使用倍数也是允许的，例如：1.5<code>\parindent</code>等。</p><p>通常使用<code>\hspace{len}</code>和<code>\vspace{len}</code>这两个命令控制特殊的空格。</p><h4 id="空格、换行与分段"><a href="#空格、换行与分段" class="headerlink" title="空格、换行与分段"></a>空格、换行与分段</h4><p>在LaTeX中，多个空格会被视为一个，多个换行也会被视为一个，如果想要禁止LaTeX在某个空格处的换行，将空格用~命令替代即可，比如”Fig .~8”</p><p>通常的换行方法非常简单：LaTeX会自动转行，然后在每一段的末尾，只需要输入两个回车即可完成分段。如果需要一个空白段落(实质是一个空白行)，先输入两个回车，再输入<code>\mbox{}</code>，最后再输入两个回车即可。也可以用<code>\par</code>来产生一个带缩进的新段。</p><p><strong>正文中想要换行，直接使用两个回车。</strong></p><p>段落之间的距离由<code>\parskip</code>控制，默认”0pt plus 1pt”</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\setlength&#123;\parskip&#125;&#123;0pt&#125;<br></code></pre></td></tr></table></figure><p>宏包<strong>lettrine</strong>能够产生首字下沉的效果：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex">\lettrine&#123;T&#125;&#123;his&#125; is an example.<br>Hope you like this package,<br>and enjoy your \LaTeX\ trip!<br></code></pre></td></tr></table></figure><h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><p>用<code>\newpage</code>命令开始新的一页</p><p>用<code>\clearpage</code>命令清空浮动体队列，并开始新的一页</p><p>用<code>\cleardoublepage</code>命令清空浮动体队列，并在偶数页上开始新的一页</p><p>注意：以上命令都是基于<code>\vfill</code>的，如果要连续新开两页，在中间加上一个空的箱子(<code>\mbox{}</code>)，如<code>\newpage\mbox{}\newpage</code></p><h4 id="缩进、对齐与行距"><a href="#缩进、对齐与行距" class="headerlink" title="缩进、对齐与行距"></a>缩进、对齐与行距</h4><p>英文的段首不需要缩进，但是对中文而言，段首缩进需要借助<strong>indentfirst</strong>宏包来完成</p><p>可能还需要使用<code>\setlength\parindent{2em}</code>这样的命令来设置缩进距离</p><p>如果在行首强制取消缩进，可以在段首使用<code>\noindent</code>命令</p><p>LaTeX默认使用两端对齐的排版方式。也可以使用<code>flushleft</code>，<code>flushright</code>，<code>center</code>这三种环境来构造居左，居中，居右三种效果。</p><h4 id="字体与颜色"><a href="#字体与颜色" class="headerlink" title="字体与颜色"></a>字体与颜色</h4><p>字族：宋体，黑体，楷体，罗马体，等宽体</p><p>字系和字形：加粗，加斜</p><p>字号：五号，小四</p><p><strong>字族+字系和字形+字号=字体</strong></p><h5 id="原生字体命令"><a href="#原生字体命令" class="headerlink" title="原生字体命令"></a>原生字体命令</h5><p>LaTeX提供了基本的字体命令</p><p>字族</p><ul><li><code>\rmfamily</code>：把字体设置为Roman罗马字族</li><li><code>\saffamily</code>：把字体设置为Sans Serif无衬线字族</li><li><code>\ttfamily</code>：把字体设置为Typewriter等宽字族</li></ul><p>字系</p><ul><li><code>\bfseries</code>：粗体BoldSeries字系属性</li><li><code>\mdseries</code>：中粗体MiddleSeries字系属性</li></ul><p>字形</p><ul><li><code>\upshape</code>：竖直Upright字形</li><li><code>\slshape</code>：斜体Slant字形</li><li><code>\itshape</code>：强调体Italic字形</li><li><code>\scshape</code>：小号大写体SCAP字形</li></ul><p>如果临时改变字体，使用<code>\textrm</code>，<code>\textbf</code>这类命令</p><p>字族，字系，字形三种命令是相互独立的，可以任意组合使用。</p><p>但这种复合字体的效果有时候无法达到(因为没有对应的设计)，比如<code>\scshape</code>字形和<code>\bfseries</code>字系。</p><p>如果在文中多次使用某种字体变换，可以将其自定义成一个命令。</p><p>使用text系列的命令而不要使用family，series或shape系列的命令。</p><p>否则需要多加一组花括号防止”泄露”。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">􏲨􏲫􏱌􏲲􏲩􏰾􏲪􏲪􏲬􏲫􏰼􏲮􏲨􏲩􏰾􏲫􏲩􏱌􏱖􏰺􏲯􏳭􏰉􏳮􏲮􏲨􏰺􏱌􏱛􏰺􏲰􏲿􏲮􏸙􏰉􏲯􏲯􏲨􏲫􏱌􏲲􏲩􏰾􏲪􏲪􏲬􏲫􏰼􏲮􏲨􏲩􏰾􏲫􏲩􏱌􏱖􏰺􏲯􏳭􏰉􏳮􏲮􏲨􏰺􏱌􏱛􏰺􏲰􏲿􏲮􏸙􏰉􏲯􏲯􏲨􏲫􏱌􏲲􏲩􏰾􏲪􏲪􏲬􏲫􏰼􏲮􏲨􏲩􏰾􏲫􏲩􏱌􏱖􏰺􏲯􏳭􏰉􏳮􏲮􏲨􏰺􏱌􏱛􏰺􏲰􏲿􏲮􏸙􏰉\newcommand&#123;\concept&#125;[1]&#123;\textbf&#123;#1&#125;&#125;<br></code></pre></td></tr></table></figure><h6 id="字号命令"><a href="#字号命令" class="headerlink" title="字号命令"></a>字号命令</h6><p>在行文中会有一个默认的”标准”字号，比如在documentclass的选项中设置的12pt</p><p>在LaTeX中给出了一系列”相对字号命令”，此外，<strong>ctex</strong>宏包的<code>\zihao</code>命令，参数0-8以及-0–8表示初号到八号，小初到小八</p><p>日常使用的小四为12pt，五号为10.5pt</p><div class="table-container"><table><thead><tr><th>命令</th><th>10pt</th><th>11pt</th><th>12pt</th></tr></thead><tbody><tr><td>\tiny</td><td>5pt</td><td>6pt</td><td>6pt</td></tr><tr><td>\scriptsize</td><td>7pt</td><td>8pt</td><td>8pt</td></tr><tr><td>\footnotesize</td><td>8pt</td><td>9pt</td><td>10pt</td></tr><tr><td>\small</td><td>9pt</td><td>10pt</td><td>11pt</td></tr><tr><td>\normalsize</td><td>10pt</td><td>11pt</td><td>12pt</td></tr><tr><td>\large</td><td>12pt</td><td>12pt</td><td>14pt</td></tr><tr><td>\Large</td><td>14pt</td><td>14pt</td><td>17pt</td></tr><tr><td>\LARGE</td><td>17pt</td><td>17pt</td><td>20pt</td></tr><tr><td>\huge</td><td>20pt</td><td>20pt</td><td>25pt</td></tr><tr><td>\Huge</td><td>25pt</td><td>25pt</td><td>25pt</td></tr></tbody></table></div><p>如果想要设置特殊的字号，使用：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\fontsize&#123;font-size&#125;&#123;line-height&#125;&#123;\selectfont &lt;text&gt;&#125;<br></code></pre></td></tr></table></figure><p>其中<strong>font-size</strong>填数字，单位pt，一般而言，<strong>line-height</strong>填<code>\baselineskip</code></p><p>默认全文的字体使用<code>\rmfamily</code>族的字体。可以通过重定义的方式改变他，使<code>\rmfamily</code>，<code>\textrm</code>命令都指向新的字体。甚至把默认字体改为sf/tt字族。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs latex">\renewcommand&#123;\rmdefault&#125;&#123;font-name&#125;<br>% 默认字体改为sf字族，也可以用\ttdefault<br>\renewcommand&#123;\familydefault&#125;&#123;\sfdefault&#125;<br>\renewcommand&#123;\sfdefault&#125;&#123;font-name&#125;<br>% 如果你的排版CJK文档，还需要更改CJK默认字体<br>\renewcommand&#123;\CJKfamilydefault&#125;&#123;\CJKsfdefault&#125;<br></code></pre></td></tr></table></figure><h6 id="西文字体"><a href="#西文字体" class="headerlink" title="西文字体"></a>西文字体</h6><p>LaTeX预报含如下字体：</p><div class="table-container"><table><thead><tr><th>命令</th><th>字体名</th></tr></thead><tbody><tr><td>cmr</td><td>Computer Modern Roman(默认)</td></tr><tr><td>lmr</td><td>Latin Modern Roman</td></tr><tr><td>pbk</td><td>Bookman</td></tr><tr><td>ppl</td><td>Palatino</td></tr><tr><td>lmss</td><td>Latin Modern Roman Serif</td></tr><tr><td>phv</td><td>Helvetica</td></tr><tr><td>lmtt</td><td>Latin Modern</td></tr></tbody></table></div><p>以上可以这样使用</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">\newcommand&#123;\myfont&#125;[2]&#123;&#123;\fontfamily&#123;#1&#125;\selectfont #2&#125;&#125;<br>\renewcommand&#123;\rmdefault&#125;&#123;ptm&#125;% 可更改默认字体，同理可改sfdefault等<br>% 以上在导言区定义，在正文中：<br>Let&apos;s change font to \myfont&#123;pp1&#125;&#123;Palatino&#125;!<br></code></pre></td></tr></table></figure><h6 id="中文支持与CJK字体"><a href="#中文支持与CJK字体" class="headerlink" title="中文支持与CJK字体"></a>中文支持与CJK字体</h6><p>中文方面，<strong>ctex</strong>宏包直接定义了新的中文文档类ctexart，ctexrep，ctexbook，ctexbeamer</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[a4paper,zihao=-4,linespread=1]&#123;ctexrep&#125;<br>\renewcommand&#123;\CTEXthechapter&#125;&#123;\thechapter&#125;<br></code></pre></td></tr></table></figure><p> 以上设置字号为小四，行距因子为1(故行距为1x1.2=1.2倍，其中1.2是LaTeX默认的基线间距)</p><p>a4paper选项继承与原生文档类report，可见ctex文档类还是很好地保留了原生文档类的特征</p><p>值得注意的是，<strong>ctex文档类会用<code>\CTEX</code>开头的计数器命令代替原有的</strong></p><p><strong>除非使用scheme=plain来让ctex文档类仅支持中文而不做任何文档细节更改</strong></p><p><strong>ctex</strong>宏包支持一下字体命令：</p><ul><li>宋体：<code>\songti</code></li><li>黑体：<code>\heiti</code></li><li>仿宋：<code>\fangsong</code></li><li>楷书：<code>\kaishu</code></li><li>雅黑：<code>\yahei</code></li><li>隶书：<code>\lishu</code></li><li>幼圆：<code>\youyuan</code></li></ul><h5 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h5><p>使用<strong>xcolor</strong>宏包来方便地调用颜色</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs latex">\usepackage&#123;xcolor&#125;<br>\definecolor&#123;keywordcolor&#125;&#123;RGB&#125;&#123;34,34,250&#125;<br><br>% 指定颜色的text<br>&#123;\color&#123;color-name&#125;&#123;text&#125;&#125;<br></code></pre></td></tr></table></figure><p><strong>xcolor</strong>宏包预定义的颜色：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/image3.png" width="70%"></p><p>还可以通过”调色”做出新的效果</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex">&#123;\color&#123;red!70&#125;百分之70红色&#125;<br>&#123;\color&#123;blue!50!black!20!white!30&#125;50蓝20黑30白&#125;<br>&#123;\color&#123;-yellow&#125;黄色的互补色&#125;<br></code></pre></td></tr></table></figure><h3 id="引用与注释"><a href="#引用与注释" class="headerlink" title="引用与注释"></a>引用与注释</h3><p>电子文档最大优越性在于能够使用超链接，跳转标签、目录，甚至访问外部网站。这些功能都需要引用。</p><h4 id="标签和引用"><a href="#标签和引用" class="headerlink" title="标签和引用"></a>标签和引用</h4><p>使用<code>\label</code>命令插入标签(在MS Word中称为”题注”)，然后在其他地方用<code>\ref</code>或者<code>\pageref</code>命令进行引用，分别引用标签的序号、标签所在的页的页码。</p><figure class="hljs highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">\<span class="hljs-selector-tag">label</span>&#123;<span class="hljs-attribute">section</span>:this&#125;<br>\<span class="hljs-selector-tag">ref</span>&#123;<span class="hljs-attribute">section</span>:this&#125;<br>\<span class="hljs-selector-tag">pageref</span><br></code></pre></td></tr></table></figure><h3 id="中英文之间空格问题解决"><a href="#中英文之间空格问题解决" class="headerlink" title="中英文之间空格问题解决"></a>中英文之间空格问题解决</h3><p><code>&lt;\hspace{0em}变量\hspace{0em}&gt;</code></p><h3 id="空格设置"><a href="#空格设置" class="headerlink" title="空格设置"></a>空格设置</h3><p><code>\hspace{0em}</code></p><h3 id="空行距离"><a href="#空行距离" class="headerlink" title="空行距离"></a>空行距离</h3><p><code>\vspace{3mm}</code></p><h3 id="两端对齐"><a href="#两端对齐" class="headerlink" title="两端对齐"></a>两端对齐</h3><p><code>\usepackage{ragged2e}</code></p><p><code>\justifying</code></p><h3 id="分数"><a href="#分数" class="headerlink" title="分数"></a>分数</h3><p>分数小：$\tfrac{1}{2}$</p><p>分数大：$\dfrac{1}{2}$</p><h3 id="摄氏度"><a href="#摄氏度" class="headerlink" title="摄氏度"></a>摄氏度</h3><p>$^{\circ}$C</p><h3 id="max下面加限制范围"><a href="#max下面加限制范围" class="headerlink" title="max下面加限制范围"></a>max下面加限制范围</h3><p>$y_{N+1}=\arg \max \limits_{y_{N+1}} \hat{P}(y_{N+1}|x_{N+1})$</p><p><a herf="https://huris.oss-cn-hangzhou.aliyuncs.com/avatar.jpg"></a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机工具 </category>
          
          <category> LaTex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matlab画图总结</title>
      <link href="/2019/08/02/Matlab%E7%94%BB%E5%9B%BE%E6%80%BB%E7%BB%93/"/>
      <url>/2019/08/02/Matlab%E7%94%BB%E5%9B%BE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-built_in">plot</span><br>数据点: . o x + * S(正方形) H(六角星) D(菱形) p(五角星) V(倒三角) ^(三角形) &gt;(右三角) &lt;(左三角)<br>线型:  -  -.  --  : <br>颜色:r-red，g-green，b-blue，w-white，k-black，<span class="hljs-built_in">i</span>-invisible(无色)，y-yellow<br><br><span class="hljs-built_in">legend</span>(<span class="hljs-string">'a'</span>)<br>title(<span class="hljs-string">'a'</span>)<br>xlabel(<span class="hljs-string">'T'</span>)<br>ylabel(<span class="hljs-string">'a'</span>)<br><br>set(gca, <span class="hljs-string">'Box'</span>, <span class="hljs-string">'off'</span>, <span class="hljs-string">'TickDir'</span>, <span class="hljs-string">'out'</span>, <span class="hljs-string">'TickLength'</span>, [<span class="hljs-number">.02</span> <span class="hljs-number">.02</span>], ...<br>    <span class="hljs-string">'XMinorTick'</span>, <span class="hljs-string">'on'</span>, <span class="hljs-string">'YMinorTick'</span>, <span class="hljs-string">'on'</span>, <span class="hljs-string">'XGrid'</span>, <span class="hljs-string">'on'</span>, <span class="hljs-string">'YGrid'</span>, <span class="hljs-string">'on'</span>,...<br>    <span class="hljs-string">'box'</span>,<span class="hljs-string">'on'</span>, <span class="hljs-string">'XColor'</span>, [<span class="hljs-number">.3</span> <span class="hljs-number">.3</span> <span class="hljs-number">.3</span>], <span class="hljs-string">'YColor'</span>, [<span class="hljs-number">.3</span> <span class="hljs-number">.3</span> <span class="hljs-number">.3</span>],<span class="hljs-string">'LineWidth'</span>, <span class="hljs-number">1</span>)<br><br>LineWidth    线宽,数值,如<span class="hljs-number">0.5</span>,<span class="hljs-number">1</span>等,单位为points<br>MarkerEdgeColor   标记点边框线条颜色,颜色字符,如’g’,’b’等<br>MarkerFaceColor   标记点内部区域填充颜色,颜色字符<br>MarkerSize   标记点大小,数值,单位为points<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
            <tag> 画图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim速查表</title>
      <link href="/2019/08/02/vim%E9%80%9F%E6%9F%A5%E8%A1%A8/"/>
      <url>/2019/08/02/vim%E9%80%9F%E6%9F%A5%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>本文主要介绍了以下内容:</strong></p><p>本文主要介绍了vim的一些快捷键，方便自己要用的时候查找。</p><a id="more"></a><h2 id="VIM使用说明与快捷键"><a href="#VIM使用说明与快捷键" class="headerlink" title="VIM使用说明与快捷键"></a>VIM使用说明与快捷键</h2><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/vim%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E4%B8%8E%E5%BF%AB%E6%8D%B7%E9%94%AE.jpg"></p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><div class="table-container"><table><thead><tr><th style="text-align:center">移动方向</th><th style="text-align:center">快捷键</th></tr></thead><tbody><tr><td style="text-align:center">左</td><td style="text-align:center">h</td></tr><tr><td style="text-align:center">上</td><td style="text-align:center">j</td></tr><tr><td style="text-align:center">下</td><td style="text-align:center">k</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">l</td></tr></tbody></table></div><h3 id="进入插入模式"><a href="#进入插入模式" class="headerlink" title="进入插入模式"></a>进入插入模式</h3><div class="table-container"><table><thead><tr><th style="text-align:center">插入模式</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">i</td><td style="text-align:center">在光标前面插入</td></tr><tr><td style="text-align:center">I</td><td style="text-align:center">在光标所在行最前面插入</td></tr><tr><td style="text-align:center">a</td><td style="text-align:center">在光标后面插入</td></tr><tr><td style="text-align:center">A</td><td style="text-align:center">在光标所在行最后面插入</td></tr><tr><td style="text-align:center">o</td><td style="text-align:center">光标所在行的下一行插入</td></tr><tr><td style="text-align:center">O</td><td style="text-align:center">光标所在行的上一行插入</td></tr><tr><td style="text-align:center">s</td><td style="text-align:center">删除光标指向的字符并进入插入模式</td></tr><tr><td style="text-align:center">S</td><td style="text-align:center">删除光标所在的行并插入</td></tr></tbody></table></div><h3 id="操作范围"><a href="#操作范围" class="headerlink" title="操作范围"></a>操作范围</h3><div class="table-container"><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">将光标移到行首</td></tr><tr><td style="text-align:center">$</td><td style="text-align:center">将光标移到行尾</td></tr><tr><td style="text-align:center">b  (begin)</td><td style="text-align:center">将光标移到单词起始处</td></tr><tr><td style="text-align:center">e  (end)</td><td style="text-align:center">将光标移到单词末尾</td></tr><tr><td style="text-align:center">w</td><td style="text-align:center">将光标移到下一个单词的开头</td></tr><tr><td style="text-align:center">gg</td><td style="text-align:center">将光标移到文件的开头</td></tr><tr><td style="text-align:center">G</td><td style="text-align:center">将光标移到文件的末尾</td></tr></tbody></table></div><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><div class="table-container"><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">d0</td><td style="text-align:center">删除光标到行首的所有字符</td></tr><tr><td style="text-align:center">d$</td><td style="text-align:center">删除光标到行尾的所有字符</td></tr><tr><td style="text-align:center">db</td><td style="text-align:center">删除光标到该单词行首的所有字符</td></tr><tr><td style="text-align:center">de</td><td style="text-align:center">删除光标到该单词行尾的所有字符</td></tr><tr><td style="text-align:center">dw</td><td style="text-align:center">删除光标到下一个单词开头的所有字符</td></tr><tr><td style="text-align:center">dh</td><td style="text-align:center">删除光标所在字符的上一个字符</td></tr><tr><td style="text-align:center">dl</td><td style="text-align:center">删除光标所在字符</td></tr><tr><td style="text-align:center">dj</td><td style="text-align:center">删除光标所在行和下一行</td></tr><tr><td style="text-align:center">dk</td><td style="text-align:center">删除光标所在行和上一行</td></tr><tr><td style="text-align:center">dd</td><td style="text-align:center">删除光标所在行</td></tr><tr><td style="text-align:center">dgg</td><td style="text-align:center">删除光标所在行到文件开头所有字符</td></tr><tr><td style="text-align:center">dG</td><td style="text-align:center">删除光标所在行到文件末尾所有字符</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 计算机工具 </category>
          
          <category> vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
            <tag> 速查表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数阶乘</title>
      <link href="/2019/08/02/%E5%A4%A7%E6%95%B0%E9%98%B6%E4%B9%98/"/>
      <url>/2019/08/02/%E5%A4%A7%E6%95%B0%E9%98%B6%E4%B9%98/</url>
      
        <content type="html"><![CDATA[<p><strong>本文主要介绍了以下内容:</strong></p><p>求n!具体值c++实现</p><a id="more"></a><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;//大数N!  </span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;  </span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;  <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  <br></span>&#123;  <br>    <span class="hljs-keyword">int</span> n,a[<span class="hljs-number">100000</span>],i,j,wei,up;  <br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n)!=EOF)  <br>    &#123;  <br>        <span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(a));<span class="hljs-comment">//一定要清零  </span><br>        up=<span class="hljs-number">0</span>;  <br>        wei=<span class="hljs-number">1</span>;  <br>        a[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-comment">//当前结果的位数，便于相乘和最后输出   </span><br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>||n==<span class="hljs-number">0</span>)  <br>        &#123;  <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"1\n"</span>);  <br>            <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//如果为1!或0!则输出后直接进行下一个阶乘计算  </span><br>        &#125;  <br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>; i&lt;=n; i++)<span class="hljs-comment">//N!中的每个数  </span><br>        &#123;  <br>            <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>,up=<span class="hljs-number">0</span>; j&lt;=wei; j++)  <br>            &#123;  <br>                a[j]=a[j]*i+up; <span class="hljs-comment">//当前j数加 进位  </span><br>                up=a[j]/<span class="hljs-number">10</span>;<span class="hljs-comment">//进位整除10  </span><br>                a[j]=a[j]%<span class="hljs-number">10</span>;<span class="hljs-comment">//当前数取余存储  </span><br>            &#125;  <br>            <span class="hljs-keyword">while</span>(up&gt;<span class="hljs-number">0</span>)<span class="hljs-comment">//最后首位大于0则要取余进位  </span><br>            &#123;  <br>                a[j++]+=up%<span class="hljs-number">10</span>;<span class="hljs-comment">//j++的值为进位取余 注意 j++导致后面的j加了一  </span><br>                up=up/<span class="hljs-number">10</span>;  <br>            &#125;  <br>            wei=j<span class="hljs-number">-1</span>;<span class="hljs-comment">//减去上面的j++  </span><br>        &#125;  <br>        <span class="hljs-keyword">for</span>(i=wei; i&gt;=<span class="hljs-number">1</span>; i--)  <br>            (i!=<span class="hljs-number">1</span>)? <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,a[i]) : <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,a[i]);<span class="hljs-comment">//三目 判断是否为最后一位 则输出换行  </span><br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
          <category> 算法模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数 </tag>
            
            <tag> 算法模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++文件操作</title>
      <link href="/2018/05/11/c++%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/05/11/c++%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p><strong>本文主要介绍了以下内容:</strong></p><p>c++的读取文件/输入方式总结</p><a id="more"></a><p><strong>getline(istream &amp;in,string &amp;s)</strong></p><p>​    从输入流读入一行到string s</p><p>功能</p><ul><li>从输入流中读取字符，存到string 变量中</li><li>一直到出现以下情况为止<ul><li>读入了文件结束标志</li><li>读到了一个新行</li><li>达到字符串的最大长度</li></ul></li><li>如果getline没有读入字符，将返回false,可用于判断文件是否结束</li></ul><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;<br>    <span class="hljs-built_in">string</span> buff;<br>    ifstream infile;<br>    ofstream outfile;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Input file name: "</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;buff;<br>    infile.open(buff.c_str());<br><br>    <span class="hljs-keyword">if</span>(!infile)<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"error"</span>&lt;&lt;buff&lt;&lt;<span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Input outfile name: "</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;buff;<br>    outfile.open(buff.c_str());<br><br>    <span class="hljs-keyword">while</span>(getline(infile, buff))<br>        outfile&lt;&lt;buff&lt;&lt;<span class="hljs-built_in">endl</span>;<br><br>    infile.close();<br>    outfile.close();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab学习笔记(8)</title>
      <link href="/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-8/"/>
      <url>/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-8/</url>
      
        <content type="html"><![CDATA[<p><strong>本文主要介绍了以下内容:</strong></p><p>matlab程序流程控制:</p><ol><li>M文件的概念与基本操作</li><li>matlab程序控制结构</li><li>matlab函数文件</li><li>matlab程序调试与优化</li></ol><a id="more"></a><h1 id="M文件"><a href="#M文件" class="headerlink" title="M文件"></a>M文件</h1><p>用matlab语言编写的程序,称为M文件</p><p>M文件是由若干matlab命令组合在一起构成的,它可以完成某些操作,也可以实现某种算法</p><p>matlab提供的内部函数以及各种工具箱,都是利用matlab命令开发的M文件</p><p>用户可以根据自己的需要,开发具体的程序或工具箱</p><h2 id="M文件的分类"><a href="#M文件的分类" class="headerlink" title="M文件的分类"></a>M文件的分类</h2><p>通常,M文件可以根据调用方式的不同分为两类:<strong>命令文件(脚本文件)</strong>和<strong>函数文件</strong>,它们的扩展名均为<strong>.m</strong></p><p>主要区别:</p><ol><li><p>命令文件没有参数,也不会返回输出参数,而函数文件可以带参数,也可以返回输出参数</p></li><li><p>命令文件对matlab工作空间中的变量进行操作,文件中所有命令的执行结果也完全返回到工作空间中,而函数文件中定义的变量为<strong>局部变量</strong>,当函数文件执行完毕时,这些变量被清除</p></li><li><p>命令文件可以直接运行,在matlab命令行窗口输入命令文件的名字,就会顺序执行命令文件中的命令,而函数文件不能直接运行,要以函数调用的方式来调用</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab学习笔记(7)</title>
      <link href="/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-7/"/>
      <url>/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-7/</url>
      
        <content type="html"><![CDATA[<p><strong>本文主要介绍了以下内容:</strong></p><p>字符串</p><a id="more"></a><h3 id="字符串的表示"><a href="#字符串的表示" class="headerlink" title="字符串的表示"></a>字符串的表示</h3><p>在matlab中,字符串是用单撇号括起来的字符序列,例如:</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; s=<span class="hljs-string">'hello world'</span><br><br>s =<br><br>    <span class="hljs-string">'hello world'</span><br></code></pre></td></tr></table></figure><p>matlab将字符串当做一个行向量,每个元素对应一个字符,其标识方法和数值向量相同,也可以建立多行字符串矩阵,例如:</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; s=[<span class="hljs-string">'hello '</span>,<span class="hljs-string">'hu ben'</span>]<br><br>s =<br><br>    <span class="hljs-string">'hello hu ben'</span><br></code></pre></td></tr></table></figure><p>这里要求各行字符数要相等,为此,有时候必须添加几个空格来保证各行的长度相等</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; ch=<span class="hljs-string">'abcdefg1234567ABCDEFG'</span><br><br>ch =<br><br>    <span class="hljs-string">'abcdefg1234567ABCDEFG'</span><br><br>&gt;&gt; subch=ch(<span class="hljs-number">1</span>:<span class="hljs-number">5</span>)<span class="hljs-comment">%取子串</span><br><br>subch =<br><br>    <span class="hljs-string">'abcde'</span><br><br>&gt;&gt; revch=ch(<span class="hljs-keyword">end</span>:<span class="hljs-number">-1</span>:<span class="hljs-number">1</span>)<span class="hljs-comment">%反转字符串</span><br><br>revch =<br><br>    <span class="hljs-string">'GFEDCBA7654321gfedcba'</span><br> <br>&gt;&gt; k=<span class="hljs-built_in">find</span>(ch&gt;=<span class="hljs-string">'a'</span>&amp;ch&lt;=<span class="hljs-string">'z'</span>)<span class="hljs-comment">%找到特定字符</span><br><br>k =<br><br>     <span class="hljs-number">1</span>     <span class="hljs-number">2</span>     <span class="hljs-number">3</span>     <span class="hljs-number">4</span>     <span class="hljs-number">5</span>     <span class="hljs-number">6</span>     <span class="hljs-number">7</span><br><br>&gt;&gt; ch(k)=ch(k)-<span class="hljs-string">'a'</span>+<span class="hljs-string">'A'</span><span class="hljs-comment">%修改特定字符</span><br><br>ch =<br><br>    <span class="hljs-string">'ABCDEFG1234567ABCDEFG'</span><br><br>&gt;&gt; <span class="hljs-built_in">length</span>(ch)<span class="hljs-comment">%计算字符串ch的长度</span><br><br><span class="hljs-built_in">ans</span> =<br><br>    <span class="hljs-number">21</span><br></code></pre></td></tr></table></figure><h3 id="字符串的操作"><a href="#字符串的操作" class="headerlink" title="字符串的操作"></a>字符串的操作</h3><h4 id="字符串的执行"><a href="#字符串的执行" class="headerlink" title="字符串的执行"></a>字符串的执行</h4><p>与字符串有关的一个重要函数是<strong>eval</strong>,它的作用是把字符串的内容作为对应的matlab命令来执行,其调用格式为:<strong>eval(s)</strong></p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; t=<span class="hljs-built_in">pi</span><br><br>t =<br><br>   <span class="hljs-number">3.141592653589793</span><br><br>&gt;&gt; m=<span class="hljs-string">'[t,sin(t),cos(t)]'</span>;<br>&gt;&gt; y=eval(m)<br><br>y =<br><br>   <span class="hljs-number">3.141592653589793</span>   <span class="hljs-number">0.000000000000000</span>  <span class="hljs-number">-1.000000000000000</span><br></code></pre></td></tr></table></figure><h4 id="字符串与数值之间的转换"><a href="#字符串与数值之间的转换" class="headerlink" title="字符串与数值之间的转换"></a>字符串与数值之间的转换</h4><p>字符串是以ASCII码来保存的,<strong>abs</strong>和<strong>double</strong>函数都可以用来获取字符串矩阵对应的ASCII码数值矩阵</p><p>相反,<strong>char</strong>函数可以把ASCII码矩阵转换为字符串矩阵,例如:</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; s1=<span class="hljs-string">'matlab'</span><br><br>s1 =<br><br>    <span class="hljs-string">'matlab'</span><br><br>&gt;&gt; a=<span class="hljs-built_in">abs</span>(s1)<br><br>a =<br><br>   <span class="hljs-number">109</span>    <span class="hljs-number">97</span>   <span class="hljs-number">116</span>   <span class="hljs-number">108</span>    <span class="hljs-number">97</span>    <span class="hljs-number">98</span><br><br>&gt;&gt; char(a)<br><br><span class="hljs-built_in">ans</span> =<br><br>    <span class="hljs-string">'matlab'</span><br></code></pre></td></tr></table></figure><p>matlab还有很多用于字符串和数值数据之间转换的函数,例如,<strong>setstr</strong>函数将ASCII码值转换为对应的字符,<strong>str2num</strong>函数或<strong>str2double</strong>函数将数字字符串转换成数值,<strong>num2str</strong>函数将数值转换成字符串,<strong>int2str</strong>函数将整数转换成字符串</p><h4 id="字符串的连接"><a href="#字符串的连接" class="headerlink" title="字符串的连接"></a>字符串的连接</h4><p>用中括号将若干个字符串括起来,从而得到一个更大的字符串</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; a=<span class="hljs-string">'12345'</span>;<br>&gt;&gt; b=<span class="hljs-string">'4321'</span>;<br>&gt;&gt; [a,b]<br><br><span class="hljs-built_in">ans</span> =<br><br>    <span class="hljs-string">'123454321'</span><br></code></pre></td></tr></table></figure><h4 id="字符串的比较"><a href="#字符串的比较" class="headerlink" title="字符串的比较"></a>字符串的比较</h4><h5 id="利用关系运算符进行比较"><a href="#利用关系运算符进行比较" class="headerlink" title="利用关系运算符进行比较"></a>利用关系运算符进行比较</h5><p>当两个字符串长度相等时,可以<strong>直接</strong>利用关系运算符进行比较,比较的规则是按ASCII值大小进行比较的</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; a=<span class="hljs-string">'134567'</span>;<br>&gt;&gt; b=<span class="hljs-string">'213145'</span>;<br>&gt;&gt; a&gt;b<br><br><span class="hljs-built_in">ans</span> =<br><br>  <span class="hljs-number">1</span>×<span class="hljs-number">6</span> logical 数组<br><br>   <span class="hljs-number">0</span>   <span class="hljs-number">1</span>   <span class="hljs-number">1</span>   <span class="hljs-number">1</span>   <span class="hljs-number">1</span>   <span class="hljs-number">1</span><br><br>&gt;&gt; a&lt;b<br><br><span class="hljs-built_in">ans</span> =<br><br>  <span class="hljs-number">1</span>×<span class="hljs-number">6</span> logical 数组<br><br>   <span class="hljs-number">1</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span><br><br>&gt;&gt; a==b<br><br><span class="hljs-built_in">ans</span> =<br><br>  <span class="hljs-number">1</span>×<span class="hljs-number">6</span> logical 数组<br><br>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h5 id="利用字符串比较函数进行比较"><a href="#利用字符串比较函数进行比较" class="headerlink" title="利用字符串比较函数进行比较"></a>利用字符串比较函数进行比较</h5><ol><li><strong>strcmp(s1,s2)</strong>:比较s1和s2<strong>所有字符是否完全相等</strong></li><li><strong>strncmp(s1,s2)</strong>:比较s1和s2<strong>前n个字符是否完全相等</strong></li><li><strong>strcmpi(s1,s2)</strong>:<strong>在忽略字母大小写的情况下</strong>,比较s1和s2<strong>所有字符是否相等</strong></li><li><strong>strncmpi(s1,s2)</strong>:<strong>在忽略字母大小写的情况下</strong>,比较s1和s2<strong>前n个字符是否相等</strong></li></ol><h4 id="字符串的查找与替换"><a href="#字符串的查找与替换" class="headerlink" title="字符串的查找与替换"></a>字符串的查找与替换</h4><h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><p><strong>findstr(s1,s2)</strong>:返回短字符串s2在长字符串s1中出现的位置</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; a=<span class="hljs-string">'12321232123'</span>;<br>&gt;&gt; b=<span class="hljs-string">'123'</span>;<br>&gt;&gt; findstr(a,b)<br><br><span class="hljs-built_in">ans</span> =<br><br>     <span class="hljs-number">1</span>     <span class="hljs-number">5</span>     <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h5 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h5><p><strong>strrep(s1,s2,s3)</strong>:将字符串s1中<strong>所有</strong>子字符串s2替换为字符串s3</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; a=<span class="hljs-string">'12321232123'</span>;<br>&gt;&gt; b=<span class="hljs-string">'123'</span>;<br>&gt;&gt; findstr(a,b)<br><br><span class="hljs-built_in">ans</span> =<br><br>     <span class="hljs-number">1</span>     <span class="hljs-number">5</span>     <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab学习笔记(6)</title>
      <link href="/2018/04/30/matalb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6/"/>
      <url>/2018/04/30/matalb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6/</url>
      
        <content type="html"><![CDATA[<p><strong>matlab学习笔记(6)主要介绍了以下内容:</strong></p><p>矩阵分析</p><ol><li>对角阵与三角阵</li><li>矩阵的转置与旋转</li><li>矩阵的逆与伪逆</li><li>方阵的行列式</li><li>矩阵的秩与迹</li><li>向量和矩阵的范数</li><li>矩阵的条件数</li><li>矩阵的特征值与特征向量</li><li>矩阵的超越函数</li></ol><a id="more"></a><h3 id="对角阵与三角阵"><a href="#对角阵与三角阵" class="headerlink" title="对角阵与三角阵"></a>对角阵与三角阵</h3><h4 id="对角阵"><a href="#对角阵" class="headerlink" title="对角阵"></a>对角阵</h4><p>只有对角线上有非0元素的矩阵称为<strong>对角矩阵</strong>,对角线上的元素相等的对角矩阵称为<strong>数量矩阵</strong>,对角线上都为1的矩阵称为<strong>单位矩阵</strong></p><h5 id="提取矩阵的对角线元素"><a href="#提取矩阵的对角线元素" class="headerlink" title="提取矩阵的对角线元素"></a>提取矩阵的对角线元素</h5><p>调用函数diag(a)</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br><span class="hljs-built_in">diag</span>(a)=<br><span class="hljs-number">1.00</span><br><span class="hljs-number">5.00</span><br><span class="hljs-number">9.00</span><br></code></pre></td></tr></table></figure><ul><li>diag(a)函数还有一种形式diag(a,k),其功能是提取<strong>第k条对角线元素</strong></li><li>与主对角线平行,往上为第1条,第2条,…,第n条对角线,往下为第-1条,第-2条,…,第-n条</li><li>主对角线为第0条对角线</li></ul><h5 id="构造对角矩阵"><a href="#构造对角矩阵" class="headerlink" title="构造对角矩阵"></a>构造对角矩阵</h5><p>设<strong>V</strong>为具有m个元素的向量,diag(<strong>V</strong>)将产生一个m×m对角矩阵,其主对角线元素即为向量<strong>V</strong>的元素</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-built_in">diag</span>(<span class="hljs-number">1</span>:<span class="hljs-number">3</span>)=<br><span class="hljs-number">1.00</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span><br>   <span class="hljs-number">0</span>    <span class="hljs-number">2.00</span>       <span class="hljs-number">0</span><br>   <span class="hljs-number">0</span>       <span class="hljs-number">0</span>    <span class="hljs-number">3.00</span><br></code></pre></td></tr></table></figure><p>diag(<strong>V</strong>,k)创建一个矩阵,对角线向上或者向下移动k个单位,<strong>还是形成方阵</strong></p><h5 id="三角阵"><a href="#三角阵" class="headerlink" title="三角阵"></a>三角阵</h5><p>三角阵分为<strong>上三角阵</strong>(矩阵对角线以下的元素全为0的矩阵)和<strong>下三角阵</strong>(矩阵对角线以上的元素全为0的矩阵)</p><h6 id="上三角矩阵"><a href="#上三角矩阵" class="headerlink" title="上三角矩阵"></a>上三角矩阵</h6><p>调用函数<strong>triu(a)</strong></p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br><span class="hljs-built_in">triu</span>(a)=<br>          <span class="hljs-number">1.00</span>          <span class="hljs-number">2.00</span>          <span class="hljs-number">3.00</span><br>             <span class="hljs-number">0</span>          <span class="hljs-number">5.00</span>          <span class="hljs-number">6.00</span><br>             <span class="hljs-number">0</span>             <span class="hljs-number">0</span>          <span class="hljs-number">9.00</span><br></code></pre></td></tr></table></figure><p><strong>triu(a,k)</strong>求矩阵a的第k条对角线以上的元素</p><h6 id="下三角矩阵"><a href="#下三角矩阵" class="headerlink" title="下三角矩阵"></a>下三角矩阵</h6><p>调用函数<strong>tril(a)</strong></p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br><span class="hljs-built_in">tril</span>(a)=<br>          <span class="hljs-number">1.00</span>             <span class="hljs-number">0</span>             <span class="hljs-number">0</span><br>          <span class="hljs-number">4.00</span>          <span class="hljs-number">5.00</span>             <span class="hljs-number">0</span><br>          <span class="hljs-number">7.00</span>          <span class="hljs-number">8.00</span>          <span class="hljs-number">9.00</span><br></code></pre></td></tr></table></figure><p><strong>tril(a,k)</strong>求矩阵a的第k条对角线以下的元素</p><h3 id="矩阵的转置与旋转"><a href="#矩阵的转置与旋转" class="headerlink" title="矩阵的转置与旋转"></a>矩阵的转置与旋转</h3><h4 id="矩阵的转置"><a href="#矩阵的转置" class="headerlink" title="矩阵的转置"></a>矩阵的转置</h4><p>把源矩阵的第1行变成目标矩阵的第1列,第2行变成第2列,…,以此类推</p><p>转置运算符是  <strong>.’</strong></p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">71</span>,<span class="hljs-number">3</span>,<span class="hljs-number">-8</span>;<span class="hljs-number">2</span>,<span class="hljs-number">-9</span>,<span class="hljs-number">8</span>;<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br>a.'=<br>         <span class="hljs-number">71.00</span>          <span class="hljs-number">2.00</span>             <span class="hljs-number">0</span><br>          <span class="hljs-number">3.00</span>         <span class="hljs-number">-9.00</span>          <span class="hljs-number">4.00</span><br>         <span class="hljs-number">-8.00</span>          <span class="hljs-number">8.00</span>          <span class="hljs-number">5.00</span><br></code></pre></td></tr></table></figure><p>还有一种转置叫做共轭转置,其运算符是单个引号  <strong>‘</strong>  ,它在转置的基础上还要取每个数的复共轭</p><p>例如: <strong>b=a’</strong>得到的b就是a的共轭转置矩阵,等价于<strong>b=conj(a).’</strong>或者<strong>b=conj(a.’)</strong></p><p>如果矩阵元素都是实数,那么转置和共轭转置得到的结果是一样的</p><h4 id="矩阵的旋转"><a href="#矩阵的旋转" class="headerlink" title="矩阵的旋转"></a>矩阵的旋转</h4><p>调用函数<strong>rot90(a,k)</strong></p><p>将矩阵a逆时针旋转90的k倍,当k=1时可省略不写</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br><span class="hljs-built_in">rot90</span>(a,<span class="hljs-number">2</span>)=<br>          <span class="hljs-number">9.00</span>          <span class="hljs-number">8.00</span>          <span class="hljs-number">7.00</span><br>          <span class="hljs-number">6.00</span>          <span class="hljs-number">5.00</span>          <span class="hljs-number">4.00</span><br>          <span class="hljs-number">3.00</span>          <span class="hljs-number">2.00</span>          <span class="hljs-number">1.00</span><br></code></pre></td></tr></table></figure><h4 id="矩阵的左右翻"><a href="#矩阵的左右翻" class="headerlink" title="矩阵的左右翻"></a>矩阵的左右翻</h4><p>对矩阵实施左右翻转是将矩阵的第1列和最后1列调换,第2列和倒数第2列调换,…,依次类推</p><p>matlab对矩阵a实施左右翻转的函数是fliplr(a)</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br><span class="hljs-built_in">fliplr</span>(a)=<br>          <span class="hljs-number">3.00</span>          <span class="hljs-number">2.00</span>          <span class="hljs-number">1.00</span><br>          <span class="hljs-number">6.00</span>          <span class="hljs-number">5.00</span>          <span class="hljs-number">4.00</span><br>          <span class="hljs-number">9.00</span>          <span class="hljs-number">8.00</span>          <span class="hljs-number">7.00</span><br></code></pre></td></tr></table></figure><h4 id="矩阵的上下翻转"><a href="#矩阵的上下翻转" class="headerlink" title="矩阵的上下翻转"></a>矩阵的上下翻转</h4><p>对矩阵实施上下翻转是将矩阵的第1行和最后1行调换,第2行和倒数第2行调换,…,依次类推</p><p>matlab对矩阵a实施上下翻转的函数是flipud(a)</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br><span class="hljs-built_in">flipud</span>(a)=<br>          <span class="hljs-number">7.00</span>          <span class="hljs-number">8.00</span>          <span class="hljs-number">9.00</span><br>          <span class="hljs-number">4.00</span>          <span class="hljs-number">5.00</span>          <span class="hljs-number">6.00</span><br>          <span class="hljs-number">1.00</span>          <span class="hljs-number">2.00</span>          <span class="hljs-number">3.00</span><br></code></pre></td></tr></table></figure><h3 id="矩阵的逆与伪逆"><a href="#矩阵的逆与伪逆" class="headerlink" title="矩阵的逆与伪逆"></a>矩阵的逆与伪逆</h3><h4 id="矩阵的逆"><a href="#矩阵的逆" class="headerlink" title="矩阵的逆"></a>矩阵的逆</h4><p>对于一个方阵a,如果存在一个与其同阶的方阵b,使得</p><script type="math/tex; mode=display">a·b=b·a=I(I为单位矩阵)</script><p>则称b为a的逆矩阵,当然,a也是b的逆矩阵</p><p>在matlab中求逆矩阵直接使用<strong>inv(a)</strong>即可</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>;<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>;<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br>inv(a)=<br>          <span class="hljs-number">5.22</span>          <span class="hljs-number">1.44</span>         <span class="hljs-number">-3.22</span><br>         <span class="hljs-number">-5.11</span>         <span class="hljs-number">-1.22</span>          <span class="hljs-number">3.11</span><br>          <span class="hljs-number">2.22</span>          <span class="hljs-number">0.44</span>         <span class="hljs-number">-1.22</span><br></code></pre></td></tr></table></figure><h4 id="矩阵的伪逆"><a href="#矩阵的伪逆" class="headerlink" title="矩阵的伪逆"></a>矩阵的伪逆</h4><p>如果矩阵a不是一个方阵,或者a是一个非满秩的方阵时,矩阵a没有逆矩阵,但可以找到一个与a的转置矩阵a’同型的矩阵b使得</p><script type="math/tex; mode=display">a·b·a=a\\\b·a·b=b</script><p>此时称矩阵b为矩阵a的伪逆,也称为广义逆矩阵,可以使用函数<strong>pinv(a)</strong>求解</p><figure class="hljs highlight Matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Matlab">a=[<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>];<br>pinv(a)=<br>          <span class="hljs-number">0.39</span>         <span class="hljs-number">-0.11</span>         <span class="hljs-number">-0.11</span><br>         <span class="hljs-number">-0.11</span>          <span class="hljs-number">0.39</span>         <span class="hljs-number">-0.11</span><br>         <span class="hljs-number">-0.11</span>         <span class="hljs-number">-0.11</span>          <span class="hljs-number">0.39</span><br>          <span class="hljs-number">0.04</span>          <span class="hljs-number">0.04</span>          <span class="hljs-number">0.04</span><br></code></pre></td></tr></table></figure><p>若a是一个奇异矩阵(行列式为0),无一般意义上的逆矩阵,但可以求a得伪逆矩阵,例如:</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>];<br>pinv(a)=<br>             <span class="hljs-number">0</span>             <span class="hljs-number">0</span>             <span class="hljs-number">0</span><br>             <span class="hljs-number">0</span>          <span class="hljs-number">1.00</span>             <span class="hljs-number">0</span><br>             <span class="hljs-number">0</span>             <span class="hljs-number">0</span>          <span class="hljs-number">1.00</span><br></code></pre></td></tr></table></figure><h3 id="方阵的行列式"><a href="#方阵的行列式" class="headerlink" title="方阵的行列式"></a>方阵的行列式</h3><p>调用函数det(a)求解</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>;<span class="hljs-number">-3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>];<br>det(a)=<br><span class="hljs-number">-10.00</span><br></code></pre></td></tr></table></figure><h3 id="矩阵的秩与迹"><a href="#矩阵的秩与迹" class="headerlink" title="矩阵的秩与迹"></a>矩阵的秩与迹</h3><h4 id="矩阵的秩"><a href="#矩阵的秩" class="headerlink" title="矩阵的秩"></a>矩阵的秩</h4><p>矩阵线性无关的行数与列数称为矩阵的秩</p><p>调用函数rank(a)</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>];<br>rank(a)=<br><span class="hljs-number">3.00</span><br></code></pre></td></tr></table></figure><h4 id="矩阵的迹"><a href="#矩阵的迹" class="headerlink" title="矩阵的迹"></a>矩阵的迹</h4><p>矩阵的迹等于矩阵的对角线元素之和,也等于矩阵的特征值之和</p><p>调用函数trace(a)</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>];<br>trace(a)=<br><span class="hljs-number">3.00</span><br></code></pre></td></tr></table></figure><h3 id="向量和矩阵范数"><a href="#向量和矩阵范数" class="headerlink" title="向量和矩阵范数"></a>向量和矩阵范数</h3><p>矩阵或向量的范数用来度量矩阵或向量在某种意义下的长度</p><p>范数有多种方法定义,其定义不同,范数值也就不同,因此,讨论范数时,一定要弄清是哪一种范数</p><h4 id="向量的三种常用范数及其计算函数"><a href="#向量的三种常用范数及其计算函数" class="headerlink" title="向量的三种常用范数及其计算函数"></a>向量的三种常用范数及其计算函数</h4><p>向量的1-范数:向量元素的绝对值之和     <strong>norm(V,1)</strong></p><script type="math/tex; mode=display">\\left\\| v\\right\\| \_{1}=\\sum ^{n}\_{i=1}\\left| v\_{i}\\right|</script><p>向量的2-范数:向量元素平方和的平方根    <strong>norm(V,2)</strong></p><script type="math/tex; mode=display">\\left\\| v\\right\\|\_{2} =\\sqrt {\\sum ^{n}\_{i=1}v^{2}\_{i}}</script><p>向量的∞-范数:所有向量元素绝对值中的最大值     <strong>norm(V,inf)</strong></p><script type="math/tex; mode=display">\\left\\|v\\right\\|\_{∞} =\\max \_{1\\leq i\\leq n}\\left\\{ \\left| V\_{i}\\right| \\right\\}</script><h4 id="矩阵的范数及其计算函数"><a href="#矩阵的范数及其计算函数" class="headerlink" title="矩阵的范数及其计算函数"></a>矩阵的范数及其计算函数</h4><p>设a是一个m×n的矩阵,V是一个含有n个元素的列向量,定义</p><script type="math/tex; mode=display">\\left\\| a\\right\\|=max\\left\\| a·V\\right\\| ,\\left\\| V\\right\\| =1</script><p>矩阵a的1-范数:所有矩阵列元素绝对值之和的最大值  <strong>norm(a,1)</strong></p><script type="math/tex; mode=display">\\left\\| a\\right\\| \_{1}=\\max \_{1\\leq j\\leq n}\\left\\{ \\sum ^{m}\_{i=1}\\left| a\_{ij}\\right|  \\right\\}</script><p>矩阵a的2-范数:a’a矩阵的最大特征值的平方根    <strong>norm(V,2)</strong></p><script type="math/tex; mode=display">\\left\\| a\\right\\|\_{2} =\\sqrt {\\lambda \_{1}}     (其中\\lambda \_{1}为a'a的最大特征值)</script><p>向量的∞-范数:所有向量元素绝对值中的最大值     <strong>norm(V,inf)</strong></p><script type="math/tex; mode=display">\\left\\| a\\right\\|\_{∞} =\\max\_{1\\leq i\\leq m}\\left\\{\\sum ^{n}\_{j=1}\\left| a\_{ij}\\right|  \\right\\}</script><h3 id="矩阵的条件数"><a href="#矩阵的条件数" class="headerlink" title="矩阵的条件数"></a>矩阵的条件数</h3><p>在求解线性方程组AX=B时,一般认为,系数矩阵A中个别元素的微小扰动不会引起解向量的很大变化</p><p>这样的假设在工程应用中非常重要,因为一般系数矩阵的数据是由实验数据获得的,并非精确值,但与精确值误差不大</p><p>由上面的假设可以得出如下结论:</p><p><strong>当参与运算的系数与实数精确值误差很小时,所获得的解与问题的准确解误差也很小</strong></p><p>遗憾的是,上述假设并非总是正确的</p><p>对于有的系数矩阵,个别元素的微小扰动会引起解的很大变化,在计算数学中,称这种矩阵为<strong>病态矩阵</strong>,而称解不因其系数矩阵的微小扰动而发生大的变化的矩阵为<strong>良性矩阵</strong></p><p>当然,<strong>良性</strong>与<strong>病态</strong>是相对的,需要一个参数来描述,条件数就是用来描述矩阵的这种性能的一个参数</p><p>矩阵a的条件数等于a的范数与a的逆矩阵的范数的乘积,这样定义的条件数总是大于1的</p><p>计算a的1-范数下的条件数    <strong>cond(a,1)</strong></p><script type="math/tex; mode=display">cond(a,1)=\\left\\| a\\right\\|\_{1}·\\left\\| a^{-1}\\right\\|\_{1}</script><p>计算a的2-范数下的条件数    <strong>cond(a,2)</strong></p><script type="math/tex; mode=display">cond(a,2)=\\left\\| a\\right\\|\_{2}·\\left\\| a^{-1}\\right\\|\_{2}</script><p>计算a的∞-范数下的条件数    <strong>cond(a,inf)</strong></p><script type="math/tex; mode=display">cond(a,∞)=\\left\\| a\\right\\|\_{∞}·\\left\\| a^{-1}\\right\\|\_{∞}</script><p><strong>条件数越接近于1,矩阵的性能越好,反之,矩阵的性能越差</strong></p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">-6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br>b=[<span class="hljs-number">2</span>,<span class="hljs-number">-5</span>,<span class="hljs-number">4</span>;<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">-2</span>;<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>];<br>cond(a)=<br>         <span class="hljs-number">87.98</span><br>cond(b)=<br>          <span class="hljs-number">3.75</span><br></code></pre></td></tr></table></figure><h3 id="矩阵的特征值与特征向量"><a href="#矩阵的特征值与特征向量" class="headerlink" title="矩阵的特征值与特征向量"></a>矩阵的特征值与特征向量</h3><p>对于n阶方阵a,求数λ和向量ξ,使得等式aξ=λξ成立</p><p>满足等式的数λ称为a的特征值,向量ξ称为a的特征向量</p><p>实际上,方程aξ=λξ和(a-λE)ξ=0是两个等价方程</p><p>要使方程(a-λE)ξ=0有非零解ξ,必须使其系数行列式为0,即|a-λE|=0</p><p>线性代数中已经证明,行列式|a-λE|是一个关于λ的n阶多项式,因而|a-λE|=0是一个n次方程,有n个根(含重根),就是矩阵a的n个特征值每一个特征值对应无穷多个特征向量</p><p><strong>矩阵的特征值问题有确定解,但特征向量问题没有确定解</strong></p><p>在matlab中,计算矩阵a的特征值和特征向量的函数是<strong>eig(a)</strong>,常用的调用格式有三种:</p><ol><li><strong>e=eig(a)</strong>:求矩阵a的全部特征值,构成<strong>向量e</strong></li><li><strong>[V,D]=eig(a)</strong>:求矩阵a的全部特征值,构成<strong>对角阵D</strong>,并求a得特征向量构成<strong>V</strong>的列向量</li><li><strong>[V,D]=eig(a,’nobalance’)</strong>:与2功能类似,第2种方法是先对a做相似变换后求矩阵a的特征值和特征向量,而第3种方法是直接求矩阵a的特征值和特征向量</li></ol><p>一个矩阵的特征向量有无穷多个,eig函数只找其中的n个,a的其他特征向量,均可由这n个特征向量的线性组合表示,例如:</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0.5</span>;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0.25</span>;<span class="hljs-number">0.5</span>,<span class="hljs-number">0.25</span>,<span class="hljs-number">2</span>];<br>[V,D]=eig(a)<br>V =<br>   <span class="hljs-number">0.721207129830347</span>   <span class="hljs-number">0.444281058188505</span>   <span class="hljs-number">0.531483411986466</span><br>  <span class="hljs-number">-0.686349287710169</span>   <span class="hljs-number">0.562109420455869</span>   <span class="hljs-number">0.461473352095774</span><br>  <span class="hljs-number">-0.093727963498713</span>  <span class="hljs-number">-0.697601133004864</span>   <span class="hljs-number">0.710329309608377</span><br>D =<br>  <span class="hljs-number">-0.016647283606310</span>                   <span class="hljs-number">0</span>                   <span class="hljs-number">0</span><br>                   <span class="hljs-number">0</span>   <span class="hljs-number">1.480121423189129</span>                   <span class="hljs-number">0</span><br>                   <span class="hljs-number">0</span>                   <span class="hljs-number">0</span>   <span class="hljs-number">2.536525860417180</span><br></code></pre></td></tr></table></figure><p>求得的三个特征值是-0.0166,1.4801和2.5365,各特征值对应的特征向量为V的各列构成的向量</p><h3 id="矩阵的超越函数"><a href="#矩阵的超越函数" class="headerlink" title="矩阵的超越函数"></a>矩阵的超越函数</h3><p>matlab的数学函数,如sqrt,exp,log等都是作用在矩阵的各元素上的</p><p>matlab还提供了一些直接作用于矩阵的超越函数,其函数名都是上述数学函数名之后缀以m,并规定输入参数a必须是方阵</p><h4 id="矩阵平方根sqrtm"><a href="#矩阵平方根sqrtm" class="headerlink" title="矩阵平方根sqrtm"></a>矩阵平方根sqrtm</h4><p><strong>sqrtm(a)</strong>计算矩阵a的平方根,这是在矩阵意义下的平方根,它与sqrt(a)的结果是不同的</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; a=[<span class="hljs-number">4</span>,<span class="hljs-number">2</span>;<span class="hljs-number">3</span>,<span class="hljs-number">6</span>];<br>&gt;&gt; b1=sqrtm(a)<br><br>b1 =<br><br>   <span class="hljs-number">1.917137824293506</span>   <span class="hljs-number">0.465175638988947</span><br>   <span class="hljs-number">0.697763458483421</span>   <span class="hljs-number">2.382313463282453</span><br><br>&gt;&gt; b1*b1<br><br><span class="hljs-built_in">ans</span> =<br><br>   <span class="hljs-number">4.000000000000000</span>   <span class="hljs-number">2.000000000000000</span><br>   <span class="hljs-number">3.000000000000000</span>   <span class="hljs-number">6.000000000000000</span><br><br>&gt;&gt; b2=<span class="hljs-built_in">sqrt</span>(a)<br><br>b2 =<br><br>   <span class="hljs-number">2.000000000000000</span>   <span class="hljs-number">1.414213562373095</span><br>   <span class="hljs-number">1.732050807568877</span>   <span class="hljs-number">2.449489742783178</span><br><br>&gt;&gt; b2*b2<br><br><span class="hljs-built_in">ans</span> =<br><br>   <span class="hljs-number">6.449489742783179</span>   <span class="hljs-number">6.292528739883945</span><br>   <span class="hljs-number">7.706742302257039</span>   <span class="hljs-number">8.449489742783177</span><br><br>&gt;&gt; b2.*b2<br><br><span class="hljs-built_in">ans</span> =<br><br>   <span class="hljs-number">4.000000000000000</span>   <span class="hljs-number">2.000000000000000</span><br>   <span class="hljs-number">3.000000000000000</span>   <span class="hljs-number">5.999999999999999</span><br></code></pre></td></tr></table></figure><p>若a为实对称<a href="https://en.wikipedia.org/wiki/Positive-definite_matrix" target="_blank" rel="noopener">正定矩阵</a>或复<a href="https://en.wikipedia.org/wiki/Hermitian_matrix" target="_blank" rel="noopener">埃尔米特(Hermitian)</a>正定阵,则一定能算出它的平方根</p><p><strong>但某些矩阵,如a=[0,1;0,0]就得不到平方根</strong></p><p>如果矩阵a含有负的特征值,则sqrtm(a)将会得到一个复矩阵,例如:</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; a=[<span class="hljs-number">4</span>,<span class="hljs-number">9</span>;<span class="hljs-number">16</span>,<span class="hljs-number">25</span>];<br>&gt;&gt; eig(a)<br><br><span class="hljs-built_in">ans</span> =<br><br>  <span class="hljs-number">-1.445218719101973</span><br>  <span class="hljs-number">30.445218719101973</span><br><br>&gt;&gt; b=sqrtm(a)<br><br>b =<br><br>  <span class="hljs-number">0.942137741124329</span> + <span class="hljs-number">0.996904315125749</span><span class="hljs-built_in">i</span>  <span class="hljs-number">1.557189914222098</span> - <span class="hljs-number">0.339272627367266</span><span class="hljs-built_in">i</span><br>  <span class="hljs-number">2.768337625283729</span> - <span class="hljs-number">0.603151337541807</span><span class="hljs-built_in">i</span>  <span class="hljs-number">4.575580874309223</span> + <span class="hljs-number">0.205268184602128</span><span class="hljs-built_in">i</span><br></code></pre></td></tr></table></figure><h4 id="矩阵对数logm"><a href="#矩阵对数logm" class="headerlink" title="矩阵对数logm"></a>矩阵对数logm</h4><p><strong>logm(a)</strong>计算矩阵a的自然对数</p><p>此函数输入参数的条件与输出结果间的关系和函数<strong>sqrtm(a)</strong>完全一样,例如:</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; a=[<span class="hljs-number">4</span>,<span class="hljs-number">9</span>;<span class="hljs-number">1</span>,<span class="hljs-number">5</span>];<br>&gt;&gt; l=logm(a)<br><br>l =<br><br>   <span class="hljs-number">1.063900819033590</span>   <span class="hljs-number">2.430842712580726</span><br>   <span class="hljs-number">0.270093634731192</span>   <span class="hljs-number">1.333994453764781</span><br></code></pre></td></tr></table></figure><h4 id="矩阵指数expm"><a href="#矩阵指数expm" class="headerlink" title="矩阵指数expm"></a>矩阵指数expm</h4><p><strong>expm(a)</strong>的功能就是求矩阵指数e^a^,例如,对上面计算所得到的a的自然对数l,求其矩阵指数b=e^l^</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; a=[<span class="hljs-number">4</span>,<span class="hljs-number">9</span>;<span class="hljs-number">1</span>,<span class="hljs-number">5</span>];<br>l=logm(a)<br><br>l =<br><br>   <span class="hljs-number">1.063900819033590</span>   <span class="hljs-number">2.430842712580726</span><br>   <span class="hljs-number">0.270093634731192</span>   <span class="hljs-number">1.333994453764781</span><br><br>&gt;&gt; expm(l)<br><br><span class="hljs-built_in">ans</span> =<br><br>   <span class="hljs-number">4.000000000000001</span>   <span class="hljs-number">9.000000000000002</span><br>   <span class="hljs-number">1.000000000000000</span>   <span class="hljs-number">5.000000000000000</span><br></code></pre></td></tr></table></figure><p>从这个结果可以看出,这里所得到的结果恰好和a相同,即<strong>expm函数</strong>和<strong>logm函数</strong>是互逆的</p><h4 id="普通矩阵函数funm"><a href="#普通矩阵函数funm" class="headerlink" title="普通矩阵函数funm"></a>普通矩阵函数funm</h4><p><strong>funm(a,@fun)</strong>对方阵a计算由fun定义的函数的矩阵函数值</p><p>例如,当fun取exp时,<strong>funm(a,@exp)</strong>可以计算矩阵a的指数,与<strong>expm(a)</strong>的计算结果是一样的</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; a=[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>;<span class="hljs-number">2</span>,<span class="hljs-number">-1</span>];<br>&gt;&gt; funm(a,@<span class="hljs-built_in">exp</span>)<br><br><span class="hljs-built_in">ans</span> =<br><br>   <span class="hljs-number">2.718281828459046</span>                   <span class="hljs-number">0</span><br>   <span class="hljs-number">2.350402387287603</span>   <span class="hljs-number">0.367879441171442</span><br><br>&gt;&gt; expm(a)<br><br><span class="hljs-built_in">ans</span> =<br><br>   <span class="hljs-number">2.718281828459046</span>                   <span class="hljs-number">0</span><br>   <span class="hljs-number">2.350402387287603</span>   <span class="hljs-number">0.367879441171442</span><br></code></pre></td></tr></table></figure><p><strong>funm函数</strong>可以用于<strong>exp</strong>,<strong>log</strong>,<strong>sin</strong>,<strong>cos</strong>,<strong>sinh</strong>和<strong>cosh</strong>等函数,但求矩阵的平方根只能使用<strong>sqrtm函数</strong></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab学习笔记(5)</title>
      <link href="/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/"/>
      <url>/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/</url>
      
        <content type="html"><![CDATA[<p><strong>matlab学习笔记(5)主要介绍了以下内容:</strong></p><ol><li>基本算术运算</li><li>点运算</li></ol><a id="more"></a><h4 id="基本算术运算"><a href="#基本算术运算" class="headerlink" title="基本算术运算"></a>基本算术运算</h4><p>matlab的基本算数运算有:+(加),-(减),*(乘),/(右除),\(左除),^(乘方)</p><h5 id="矩阵加减运算"><a href="#矩阵加减运算" class="headerlink" title="矩阵加减运算"></a>矩阵加减运算</h5><p>a和b必须同型(即大小相同)</p><h5 id="矩阵乘法运算"><a href="#矩阵乘法运算" class="headerlink" title="矩阵乘法运算"></a>矩阵乘法运算</h5><p>a为n×m矩阵,b为m×p矩阵才能进行乘法运算</p><h5 id="矩阵除法运算"><a href="#矩阵除法运算" class="headerlink" title="矩阵除法运算"></a>矩阵除法运算</h5><ul><li>在matlab中,有两种矩阵除法运算:/和\\,分别表示左除和右除</li><li>只有矩阵a的行列式不为零(即矩阵a为非奇异矩阵)才能进行实现</li><li>a\\b等效于a的逆左乘b矩阵,即inv(a)*b</li><li>b/a等效于a的逆右乘b矩阵,即b*inv(a)</li><li>对于标量的运算,两种除法运算的结果都相等</li><li>对于矩阵来说,左除和右除代表两种不同的除数矩阵和被除数矩阵的关系</li><li>对于矩阵来说,一般a\b不等于b/a</li></ul><h5 id="矩阵的乘方"><a href="#矩阵的乘方" class="headerlink" title="矩阵的乘方"></a>矩阵的乘方</h5><ul><li><p>a^x</p></li><li><p>要求a为方阵,x为标量</p></li><li><p>可以计算一个矩阵的方根,例如:</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br>a^<span class="hljs-number">0.1</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="点运算"><a href="#点运算" class="headerlink" title="点运算"></a>点运算</h4><p>在matlab中,有一种特殊的运算,因为其运算符是在有关算术运算符前面加点,所以叫点运算</p><p>点运算符有  .*  ,  ./  ,  .\  ,  .^</p><p>两矩阵进行点运算是指他们对应的对应元素进行相关运算,要求两矩阵的维数相同</p><h5 id="a-b"><a href="#a-b" class="headerlink" title="a.*b"></a>a.*b</h5><p>表示a和b单个元素之间对应相乘,例如</p><figure class="hljs highlight Matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br>b=[<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>;<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>;<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>];<br>a.*b=<br><span class="hljs-number">9</span> <span class="hljs-number">16</span> <span class="hljs-number">21</span><br><span class="hljs-number">24</span> <span class="hljs-number">25</span> <span class="hljs-number">24</span><br><span class="hljs-number">21</span> <span class="hljs-number">16</span> <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h5 id="a-b与b-a"><a href="#a-b与b-a" class="headerlink" title="a./b与b.\a"></a>a./b与b.\a</h5><p>a./b等价于b.\a,例如</p><figure class="hljs highlight Matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];<br>b=[<span class="hljs-number">-2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>;<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>];<br>a./b=<br><span class="hljs-number">-0.5</span> <span class="hljs-number">2.0</span> <span class="hljs-number">1.0</span><br><span class="hljs-number">-4.0</span> <span class="hljs-number">5.0</span> <span class="hljs-number">1.5</span><br>b.\a=<br><span class="hljs-number">-0.5</span> <span class="hljs-number">2.0</span> <span class="hljs-number">1.0</span><br><span class="hljs-number">-4.0</span> <span class="hljs-number">5.0</span> <span class="hljs-number">1.5</span><br></code></pre></td></tr></table></figure><h5 id="a-b-1"><a href="#a-b-1" class="headerlink" title="a.^b"></a>a.^b</h5><p>若两个矩阵同型,则<strong>a.^b</strong>表示两矩阵对应元素进行乘方运算,例如:</p><figure class="hljs highlight Matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>b=[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];<br>a.^b=<br><span class="hljs-number">1</span> <span class="hljs-number">32</span> <span class="hljs-number">729</span><br></code></pre></td></tr></table></figure><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>a.^<span class="hljs-number">2</span>=<br><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><figure class="hljs highlight Matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>b=[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];<br><span class="hljs-number">2.</span>^[a b]=<br><span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">8</span> <span class="hljs-number">16</span> <span class="hljs-number">32</span> <span class="hljs-number">64</span><br></code></pre></td></tr></table></figure><figure class="hljs highlight Matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Matlab"><span class="hljs-comment">%当x分别为0.1,0.4,0.7,1时,分别求y=sin(x)cos(x)的值</span><br>x=[<span class="hljs-number">0.1</span>,<span class="hljs-number">0.4</span>,<span class="hljs-number">0.7</span>,<span class="hljs-number">1</span>];<br><span class="hljs-built_in">sin</span>(x).*<span class="hljs-built_in">cos</span>(x)=<br> <span class="hljs-number">0.10</span>          <span class="hljs-number">0.36</span>          <span class="hljs-number">0.49</span>          <span class="hljs-number">0.45</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab学习笔记(4)</title>
      <link href="/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4/"/>
      <url>/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4/</url>
      
        <content type="html"><![CDATA[<p><strong>matlab学习笔记(4)主要介绍了以下内容:</strong></p><p>矩阵</p><a id="more"></a><h3 id="矩阵的建立"><a href="#矩阵的建立" class="headerlink" title="矩阵的建立"></a>矩阵的建立</h3><h4 id="直接输入法建立矩阵"><a href="#直接输入法建立矩阵" class="headerlink" title="直接输入法建立矩阵"></a>直接输入法建立矩阵</h4><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]<br></code></pre></td></tr></table></figure><h4 id="冒号表达式建立一个向量"><a href="#冒号表达式建立一个向量" class="headerlink" title="冒号表达式建立一个向量"></a>冒号表达式建立一个向量</h4><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=<span class="hljs-number">0</span>:<span class="hljs-number">1</span>:<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>如果冒号表达式中省略第二个冒号,则默认步长为1</p><h4 id="用linspace函数产生行向量"><a href="#用linspace函数产生行向量" class="headerlink" title="用linspace函数产生行向量"></a>用linspace函数产生行向量</h4><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-built_in">linspace</span>(l,r,n)<br></code></pre></td></tr></table></figure><p>其中l,r是生成向量的第一个元素和最后一个元素,n是元素总数,当n省略时,自动产生100个元素</p><h4 id="利用已建好的小矩阵拼接成大矩阵"><a href="#利用已建好的小矩阵拼接成大矩阵" class="headerlink" title="利用已建好的小矩阵拼接成大矩阵"></a>利用已建好的小矩阵拼接成大矩阵</h4><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>:<span class="hljs-number">2</span>:<span class="hljs-number">6</span>;<span class="hljs-number">2</span>:<span class="hljs-number">2</span>:<span class="hljs-number">6</span>];<br>b=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];<br>c=[a;b]<br></code></pre></td></tr></table></figure><h3 id="矩阵的拆分"><a href="#矩阵的拆分" class="headerlink" title="矩阵的拆分"></a>矩阵的拆分</h3><h4 id="直接通过下标来引用"><a href="#直接通过下标来引用" class="headerlink" title="直接通过下标来引用"></a>直接通过下标来引用</h4><p>如<code>a(3,2)</code>表示a矩阵第3行第2列元素,通常情况下,是对矩阵的单个元素进行赋值或其他操作</p><p><strong>如果给出的行下标或者列下标大于原矩阵的行数和列数,则matlab将自动扩展原来的矩阵,并将扩展后未赋值的元素置为0</strong></p><h4 id="通过冒号表达式获得子矩阵"><a href="#通过冒号表达式获得子矩阵" class="headerlink" title="通过冒号表达式获得子矩阵"></a>通过冒号表达式获得子矩阵</h4><ol><li>可以直接用单个的冒号来作为行下标或列下标<ul><li><strong>a(i,:)</strong>表示a矩阵第i行的全部元素</li><li><strong>a(:,j)</strong>表示a矩阵第j列的全部元素</li><li><strong>a(i:i+m,j:j+k)</strong>表示a矩阵第i~i+m行,第j ~j+k列所有的元素</li></ul></li><li>速度比循环结构快</li><li>此外还可以用<strong>end</strong>关键字来表示某一维的末尾元素下标</li></ol><h4 id="利用空矩阵删除矩阵的元素"><a href="#利用空矩阵删除矩阵的元素" class="headerlink" title="利用空矩阵删除矩阵的元素"></a>利用空矩阵删除矩阵的元素</h4><p>在matlab中,定义[]为空矩阵,给变量x赋空矩阵的语句为</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">x=[]<br></code></pre></td></tr></table></figure><p><strong>x=[]与clear x不同,clear是将x从工作空间中删除,而空矩阵则存在于工作空间中,只是维数为0</strong></p><p>将矩阵中的某些元素删除,可以采用空矩阵的方法,例如:</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>;<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>;<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>];<br>a(:,<span class="hljs-number">2</span>:<span class="hljs-number">4</span>)=[]       <span class="hljs-comment">%删除a的第2~4列元素</span><br>a(:,[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>])=[]      <span class="hljs-comment">%删除a的第2列和第4列元素</span><br></code></pre></td></tr></table></figure><h4 id="改变矩阵的形状"><a href="#改变矩阵的形状" class="headerlink" title="改变矩阵的形状"></a>改变矩阵的形状</h4><p>reshape(a,m,n)函数在矩阵总元素保持不变的前提下,将矩阵a重新排成m*n的二维矩阵</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab">x=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br>y=<span class="hljs-built_in">reshape</span>(a,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>);<br>y =<br><br>          <span class="hljs-number">1.00</span>          <span class="hljs-number">4.00</span>          <span class="hljs-number">7.00</span><br>          <span class="hljs-number">2.00</span>          <span class="hljs-number">5.00</span>          <span class="hljs-number">8.00</span><br>          <span class="hljs-number">3.00</span>          <span class="hljs-number">6.00</span>          <span class="hljs-number">9.00</span><br></code></pre></td></tr></table></figure><ol><li>在matlab中,矩阵元素<strong>按列存储</strong>,即首先存储矩阵第1列元素,然后存储第2列元素,…一直到矩阵的最后一列元素</li><li>reshape函数只是改变原矩阵的行数和列数,即改变其逻辑结构,但并不改变原矩阵元素的个数及其存储结构</li></ol><h3 id="特殊矩阵"><a href="#特殊矩阵" class="headerlink" title="特殊矩阵"></a>特殊矩阵</h3><h4 id="通用的特殊矩阵"><a href="#通用的特殊矩阵" class="headerlink" title="通用的特殊矩阵"></a>通用的特殊矩阵</h4><div class="table-container"><table><thead><tr><th style="text-align:center">函数名</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">zeros</td><td style="text-align:center">产生全0矩阵(零矩阵)</td></tr><tr><td style="text-align:center">ones</td><td style="text-align:center">产生全1矩阵(幺矩阵)</td></tr><tr><td style="text-align:center">eye</td><td style="text-align:center">产生单位矩阵</td></tr><tr><td style="text-align:center">rand</td><td style="text-align:center">产生(0,1)区间均匀分布的随机矩阵</td></tr><tr><td style="text-align:center">randn</td><td style="text-align:center">产生均值为0,方差为1的标准正态分布随机矩阵</td></tr></tbody></table></div><p><strong>调用方式</strong></p><ol><li><strong>zeros(m)</strong>:产生m×m零矩阵</li><li><strong>zeros(n,m)</strong>:产生n×m零矩阵</li><li><strong>zeros(size(a))</strong>:产生与矩阵a同样大小的零矩阵</li><li><strong>20+(50-20)*rand(4,5)</strong>:产生4行5列在区间[20,50]内均匀分布的随机矩阵</li><li><strong>0.6+sqrt(0.1)*randn(4,5)</strong>:产生4行5列均值为0.6,方差为0.1的正态分布随机矩阵</li></ol><h4 id="用于专门学科的特殊矩阵"><a href="#用于专门学科的特殊矩阵" class="headerlink" title="用于专门学科的特殊矩阵"></a>用于专门学科的特殊矩阵</h4><ol><li><p>魔方矩阵</p><ul><li>调用函数magic(n)</li><li>每行每列及两条对角线上的元素之和都相等</li><li>其元素由1,2,3,…,n^2^共n^2^个元素组成</li></ul></li><li><p>范德蒙矩阵</p><ul><li>调用函数vander(<strong>V</strong>)</li><li>范德蒙矩阵最后一列全为1,倒数第2列为一个指定的向量,其它各列是其后一列与倒数第2列对应元素的乘积</li><li><strong>V</strong>为一个指定的向量</li></ul></li><li><p>希尔伯特矩阵</p><ul><li>调用函数hilb(n)</li><li>求希尔伯特逆矩阵的函数 invhilb(n)</li><li>希尔伯特矩阵是一种数学变换矩阵,它的每个元素h~ij~=1/(i+j-1)</li><li>希尔伯特矩阵是一个高度病态的矩阵,即任何一个元素发生微小变动,整个矩阵的值和逆矩阵都会发生很大的变化,病态程度和阶数有关</li></ul></li><li><p>托普利兹矩阵</p><ul><li>调用函数toeplitz(x,y)</li><li>托普利兹矩阵除第1行和第1列外,其他每个元素都与左上角的元素相同</li><li>toeplitz(1:6)用向量[1:6]生成一个对称的托普利兹矩阵</li></ul></li><li><p>伴随矩阵</p><p>设多项式p(x)为:</p><script type="math/tex; mode=display">p\left( x\right) =a_{n}x^{n}+a_{n-1}x^{n-1}+...a_{1}x+a_{0}</script><ul><li>调用函数compan(p)</li><li>其中p是系数向量,高次幂系数排在前,低次幂排在后</li></ul></li><li><p>帕斯卡矩阵</p><ul><li>调用函数pascal(n)</li><li>杨辉三角形组成的矩阵称为帕斯卡矩阵</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab学习笔记(3)</title>
      <link href="/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3/"/>
      <url>/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3/</url>
      
        <content type="html"><![CDATA[<p><strong>matlab学习笔记(3)注意介绍了以下内容:</strong></p><ol><li>常用函数</li><li>常用数学函数</li><li>数据的输出格式</li><li>常用快捷键(mac系统)</li><li>预定义变量</li><li>注意点</li></ol><a id="more"></a><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><ol><li><p>画图函数</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-built_in">plot</span>(自变量,函数,自变量,函数)<br></code></pre></td></tr></table></figure></li><li><p>求根函数</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">roots(p)<br></code></pre></td></tr></table></figure></li></ol><ol><li>求积分<script type="math/tex; mode=display">\int ^{1}_{0}x\ln \left( 1+x\right) dx</script></li></ol><ul><li><p>方法一</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">f=@(x)x.*<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>+x);<br>integral(f,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></li><li><p>方法二</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">syms x<br>int(x*<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>+x),<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure></li></ul><ol><li>求解线性方程组</li></ol><script type="math/tex; mode=display">\begin{cases}2x-3y+z=4\\\8x+3y+2z=2\\\45x+y-9z=17\end{cases}</script><ul><li><p>方法一</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">2</span>,<span class="hljs-number">-3</span>,<span class="hljs-number">1</span>;<span class="hljs-number">8</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>;<span class="hljs-number">45</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-9</span>];<br>b=[<span class="hljs-number">4</span>;<span class="hljs-number">2</span>;<span class="hljs-number">17</span>];<br>x=inv(a)*b<br></code></pre></td></tr></table></figure></li><li><p>方法二</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">syms x y z<br>[x,y,z]=solve(<span class="hljs-number">2</span>*x<span class="hljs-number">-3</span>*y+z<span class="hljs-number">-4</span>,<span class="hljs-number">8</span>*x+<span class="hljs-number">3</span>*y+<span class="hljs-number">2</span>*z<span class="hljs-number">-2</span>,<span class="hljs-number">45</span>*x+y<span class="hljs-number">-9</span>*z<span class="hljs-number">-17</span>)<br></code></pre></td></tr></table></figure></li></ul><h2 id="常用数学函数"><a href="#常用数学函数" class="headerlink" title="常用数学函数"></a>常用数学函数</h2><div class="table-container"><table><thead><tr><th style="text-align:center">函数名</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">sin/sind</td><td style="text-align:center">正弦函数,输入值为弧度/角度</td></tr><tr><td style="text-align:center">cos/cosd</td><td style="text-align:center">余弦函数,输入值为弧度/角度</td></tr><tr><td style="text-align:center">tan/tand</td><td style="text-align:center">正切函数,输入值为弧度/角度</td></tr><tr><td style="text-align:center">asin/asind</td><td style="text-align:center">反正弦函数,输入值为弧度/角度</td></tr><tr><td style="text-align:center">acos/acosd</td><td style="text-align:center">反余弦函数,输入值为弧度/角度</td></tr><tr><td style="text-align:center">atan/atand</td><td style="text-align:center">反正切函数,输入值为弧度/角度</td></tr><tr><td style="text-align:center">sinh/asinh</td><td style="text-align:center">双曲正弦函数/反双曲正弦函数</td></tr><tr><td style="text-align:center">cosh/acosh</td><td style="text-align:center">双曲余弦函数/反双曲余弦函数</td></tr><tr><td style="text-align:center">tanh/atanh</td><td style="text-align:center">双曲正切函数/反双曲正切函数</td></tr><tr><td style="text-align:center">sqrt</td><td style="text-align:center">平方根函数</td></tr><tr><td style="text-align:center">log</td><td style="text-align:center">自然对数函数</td></tr><tr><td style="text-align:center">log10</td><td style="text-align:center">以10为底的对数函数</td></tr><tr><td style="text-align:center">log2</td><td style="text-align:center">以2为底的对数函数</td></tr><tr><td style="text-align:center">exp</td><td style="text-align:center">自然指数函数</td></tr><tr><td style="text-align:center">pow2</td><td style="text-align:center">2的幂</td></tr><tr><td style="text-align:center">abs</td><td style="text-align:center">绝对值函数</td></tr><tr><td style="text-align:center">rem</td><td style="text-align:center">求余</td></tr><tr><td style="text-align:center">mod</td><td style="text-align:center">求模</td></tr><tr><td style="text-align:center">fix</td><td style="text-align:center">向零方向取整</td></tr><tr><td style="text-align:center">floor</td><td style="text-align:center">向下取整</td></tr><tr><td style="text-align:center">ceil</td><td style="text-align:center">向上取整</td></tr><tr><td style="text-align:center">round</td><td style="text-align:center">四舍五入到最邻近的整数</td></tr><tr><td style="text-align:center">sign</td><td style="text-align:center">符号函数</td></tr><tr><td style="text-align:center">gcd</td><td style="text-align:center">最大公约数</td></tr><tr><td style="text-align:center">lcm</td><td style="text-align:center">最小公倍数</td></tr><tr><td style="text-align:center">factorial</td><td style="text-align:center">阶乘</td></tr><tr><td style="text-align:center">isprime</td><td style="text-align:center">判断是否为素数</td></tr><tr><td style="text-align:center">primes</td><td style="text-align:center">生成素数序列</td></tr><tr><td style="text-align:center">perms</td><td style="text-align:center">生成所有排列</td></tr><tr><td style="text-align:center">randperm</td><td style="text-align:center">生成任意排列</td></tr></tbody></table></div><h2 id="数据的输出格式"><a href="#数据的输出格式" class="headerlink" title="数据的输出格式"></a>数据的输出格式</h2><p><strong>format命令只影响数据输出格式,而不影响数据的计算和存储</strong></p><p>format命令格式为:</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">format 格式符<br></code></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center">格式符</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">short</td><td style="text-align:center">输出小数点后4位,最多不超过7位有效数字<br>对于大于1000的实数,用5位有效数字的科学记数形式输出</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">15位有效数字形式输出</td></tr><tr><td style="text-align:center">short e</td><td style="text-align:center">5位有效数字的科学记数形式输出</td></tr><tr><td style="text-align:center">long e</td><td style="text-align:center">15位有效数字的科学记数形式输出</td></tr><tr><td style="text-align:center">short g</td><td style="text-align:center">从short到short e中自动选择最佳输出方式</td></tr><tr><td style="text-align:center">long g</td><td style="text-align:center">从long到long e中自动选择最佳输出方式</td></tr><tr><td style="text-align:center">rat</td><td style="text-align:center">近似有理数表示</td></tr><tr><td style="text-align:center">hex</td><td style="text-align:center">十六进制表示</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">正数,负数,零分别用+,-,空格表示</td></tr><tr><td style="text-align:center">bank</td><td style="text-align:center">银行格式,用元角分表示</td></tr><tr><td style="text-align:center">compact</td><td style="text-align:center">输出变量之间没有空行</td></tr><tr><td style="text-align:center">loose</td><td style="text-align:center">输出变量之间有空行</td></tr></tbody></table></div><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><div class="table-container"><table><thead><tr><th style="text-align:center">组合键</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">⌘ +k</td><td style="text-align:center">清除命令行窗口</td></tr><tr><td style="text-align:center">esc</td><td style="text-align:center">删除当前行命令</td></tr><tr><td style="text-align:center">control+c</td><td style="text-align:center">中断当前任务</td></tr><tr><td style="text-align:center">tab</td><td style="text-align:center">代码补全</td></tr></tbody></table></div><h2 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h2><div class="table-container"><table><thead><tr><th style="text-align:center">预定义变量</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">ans</td><td style="text-align:center">计算结果的默认赋值变量</td></tr><tr><td style="text-align:center">eps</td><td style="text-align:center">机器零阈值</td></tr><tr><td style="text-align:center">pi</td><td style="text-align:center">圆周率π的近似值</td></tr><tr><td style="text-align:center">i,j</td><td style="text-align:center">虚数单位</td></tr><tr><td style="text-align:center">inf,Inf</td><td style="text-align:center">无穷大</td></tr><tr><td style="text-align:center">NaN,nan</td><td style="text-align:center">非数</td></tr><tr><td style="text-align:center">nargin</td><td style="text-align:center">函数输入参数个数</td></tr><tr><td style="text-align:center">nargout</td><td style="text-align:center">函数输出参数个数</td></tr><tr><td style="text-align:center">realmax</td><td style="text-align:center">最大正实数</td></tr><tr><td style="text-align:center">realmin</td><td style="text-align:center">最小正实数</td></tr><tr><td style="text-align:center">lasterr</td><td style="text-align:center">存放最新的错误信息</td></tr><tr><td style="text-align:center">lastwarn</td><td style="text-align:center">存放最新的警告信息</td></tr></tbody></table></div><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ol><li><p>matlab变量名</p><p>变量名<strong>只能以字母开头</strong>,后接字母,数字或下划线,变量名区分大小写</p></li><li><p>注释</p><p>使用<strong>%</strong>进行注释</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab学习笔记(2)</title>
      <link href="/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/"/>
      <url>/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/</url>
      
        <content type="html"><![CDATA[<p><strong>matlab学习笔记(2)主要介绍了以下内容:</strong></p><ol><li>数值类型<ul><li>整数类型</li><li>浮点数类型</li><li>复数</li><li>无穷量和非数值量</li></ul></li><li>逻辑类型</li><li>字符和字符串</li><li>函数句柄</li><li>结构体</li><li>数组类型</li><li>单元数组类型</li></ol><a id="more"></a><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><div class="table-container"><table><thead><tr><th style="text-align:center">数据格式</th><th style="text-align:center">示例</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">int8,uint8<br>int16,uint16<br>int32,uint32<br>int64,uint64</td><td style="text-align:center">int8(20)</td><td style="text-align:left">有符号和无符号的整数类型<br>相同数值的整数类型比浮点数占更少内存<br>除了int64和uint64类型外的所有整数类型,都可以进行数学运算</td></tr><tr><td style="text-align:center">single</td><td style="text-align:center">single(128.1)</td><td style="text-align:left">单精度浮点数<br>相同数值的单精度浮点数比双精度浮点数占更少内存<br>单精度浮点数类型能够表示的范围和精度都比双精度浮点数少</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">333.77<br>1.000-1.000i</td><td style="text-align:left">双精度浮点数<br>matlab中默认的数值类型</td></tr></tbody></table></div><p><strong>说明</strong></p><ol><li>matlab中数值类型的数据包括<strong>有符号</strong>和<strong>无符号</strong>整数,<strong>单精度浮点数</strong>和<strong>双精度浮点数</strong></li><li>在未加说明与特殊定义时,<strong>matlab对所有数值按照双精度浮点数类型进行存储和操作</strong></li><li>相对于双精度浮点数,整数和单精度浮点数的优点在于节省变量占用的内存空间</li><li>matlab会自动进行记忆体的使用和回收,而不像c语言那样,必须由使用者一一指定</li></ol><h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><div class="table-container"><table><thead><tr><th style="text-align:center">转换函数</th><th style="text-align:center">数值范围</th></tr></thead><tbody><tr><td style="text-align:center">int8</td><td style="text-align:center">-2^7^~2^7^-1</td></tr><tr><td style="text-align:center">uint8</td><td style="text-align:center">0~2^8^-1</td></tr><tr><td style="text-align:center">int16</td><td style="text-align:center">-2^15^~2^15^-1</td></tr><tr><td style="text-align:center">uint16</td><td style="text-align:center">0~2^16^-1</td></tr><tr><td style="text-align:center">int32</td><td style="text-align:center">-2^31^~2^31^-1</td></tr><tr><td style="text-align:center">uint32</td><td style="text-align:center">0~2^32^-1</td></tr><tr><td style="text-align:center">int64</td><td style="text-align:center">-2^63^~2^63^-1</td></tr><tr><td style="text-align:center">uint64</td><td style="text-align:center">0~2^64^-1</td></tr></tbody></table></div><p><strong>注意</strong></p><ol><li>由于<strong>matlab默认是double类型</strong>,将数值转化为整数时,遵循四舍六入,当小数部分为0.5时,则会转化为绝对值较大的那个整数</li><li>这些转换函数也可以将其他数据类型转换为指定的整数类型</li><li>在不超过数值范围的情况下,任意两个整数类型之间也可以通过转换函数进行互相转换</li><li>由于不同的整数类型能够表示的数值范围不同,因此当结果超出相应的整数类型能够表示的范围时,就会出现一处错误,运算结果被置为该整数能够表示的最大值或最小值</li></ol><h5 id="取整函数"><a href="#取整函数" class="headerlink" title="取整函数"></a>取整函数</h5><div class="table-container"><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">运算法则</th><th style="text-align:center">示例</th></tr></thead><tbody><tr><td style="text-align:center">floor(x)</td><td style="text-align:center">向下取整</td><td style="text-align:center">floor(1.2)=1<br>floor(-1.2)=-2</td></tr><tr><td style="text-align:center">ceil(x)</td><td style="text-align:center">向上取整</td><td style="text-align:center">ceil(1.2)=2<br>ceil(-1.2)=-1</td></tr><tr><td style="text-align:center">round(x)</td><td style="text-align:center">取最接近的整数<br>如果小数部分是0.5,则向绝对值大的方向取整</td><td style="text-align:center">round(1.2)=1<br>round(1.6)=2<br>round(-1.2)=-1<br>round(-1.6)=-2<br>round(-1.5)=-2</td></tr><tr><td style="text-align:center">fix(x)</td><td style="text-align:center">向0取整</td><td style="text-align:center">fix(1.2)=1<br>fix(1.6)=1<br>fix(-1.2)=-1<br>fix(-1.6)=-1</td></tr></tbody></table></div><h4 id="浮点数类型"><a href="#浮点数类型" class="headerlink" title="浮点数类型"></a>浮点数类型</h4><div class="table-container"><table><thead><tr><th style="text-align:center">浮点类型</th><th style="text-align:center">存储位宽</th><th style="text-align:center">各数位的含义</th><th style="text-align:center">数值范围</th><th style="text-align:center">转换函数</th></tr></thead><tbody><tr><td style="text-align:center">单精度</td><td style="text-align:center">32</td><td style="text-align:center">0~22位表示小数部分 <br>23~30位表示指数部分<br>31位表示符号(0正1负)</td><td style="text-align:center">-3.40282e+038 ~ -1.17549e-038<br>1.17549e-038 ~ 3.40282e+038</td><td style="text-align:center">single</td></tr><tr><td style="text-align:center">双精度</td><td style="text-align:center">64</td><td style="text-align:center">0~51位表示小数部分 <br>52~62位表示指数部分<br>63位表示符号(0正1负)</td><td style="text-align:center">-1.79769e+308 ~ -2.22507e-308<br>2.22507e-308 ~ 1.79769+308</td><td style="text-align:center">Double</td></tr></tbody></table></div><p><strong>注意</strong></p><ol><li>matlab中默认数值类型为双精度浮点类型,因此与创建整数类型数值一样,也可以通过转换函数来实现创建单精度浮点类型</li><li>双精度浮点数参与运算时,返回值得类型依赖于参与运算的其他数据类型<ul><li>参与运算的其他数据为<strong>逻辑型</strong>,<strong>字符型</strong>时,返回<strong>双精度浮点型</strong></li><li>参与运算的其他数据为<strong>整数型</strong>时,返回相应的<strong>整数类型</strong></li><li>参与运算的其他数据为<strong>单精度浮点型</strong>时,返回相应的<strong>单精度浮点型</strong></li></ul></li><li><strong>matlab中,单精度浮点型不能与整数进行算数运算</strong></li><li>由于浮点数只占用一定的存储位宽,其中只有有限位分别用来存储指数部分和小数部分,因此,浮点类型能够表示的实际数值是有限且离散的,任何两个最近相邻的浮点数之间都有微小间隙,而处在间隙中的数值都只能用这两个相邻的浮点数之中的一个来表示(matlab中提供eps函数:可以获得一个数值和最接近该数值的浮点数之间的间隙)</li></ol><h4 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h4><p>复数包括<strong>实部和虚部</strong>两部分,matlab中<strong>默认使用字符i或j作为虚部标志</strong>,创建复数时,可以直接按照复数形式进行输入或者利用complex函数</p><div class="table-container"><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">real(z)</td><td style="text-align:center">返回复数z的实部</td></tr><tr><td style="text-align:center">imag(z)</td><td style="text-align:center">返回复数z的虚部</td></tr><tr><td style="text-align:center">abs(z)</td><td style="text-align:center">返回复数z的模</td></tr><tr><td style="text-align:center">angle(z)</td><td style="text-align:center">返回复数z的辐角</td></tr><tr><td style="text-align:center">conj(z)</td><td style="text-align:center">返回复数z的共轭复数</td></tr><tr><td style="text-align:center">complex(a,b)</td><td style="text-align:center">以a为实部,b为虚部创建复数</td></tr></tbody></table></div><h4 id="无穷量-Inf-和非数值量-NaN"><a href="#无穷量-Inf-和非数值量-NaN" class="headerlink" title="无穷量(Inf)和非数值量(NaN)"></a>无穷量(Inf)和非数值量(NaN)</h4><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">Inf</td><td style="text-align:center">正无穷量</td></tr><tr><td style="text-align:center">-Inf</td><td style="text-align:center">负无穷量</td></tr><tr><td style="text-align:center">NaN</td><td style="text-align:center">非数值量</td></tr></tbody></table></div><p><strong>注意</strong></p><ol><li>正负无穷量一般都是由于运算溢出,产生了超出双精度浮点数数值范围的结果</li><li>非数值量一般都是由于0/0,Inf/Inf或者Inf-Inf造成的,这三个NaN彼此不相等</li><li>除了异常运算结果外,matlab还提供了特定函数Inf和NaN来创建指定数值类型的无穷量和非数值量,生成结果默认为双精度浮点类型中还有一种特殊的指数类型的数据叫做非数,通常表示运算得到的数值结果超出了运算范围,非数的实部用NaN表示,虚部用Inf表示</li></ol><h3 id="逻辑类型"><a href="#逻辑类型" class="headerlink" title="逻辑类型"></a>逻辑类型</h3><p>matlab把任何非零数值当做真,把零当做假.</p><p>所有关系和逻辑表达式的输出:对于真,输出1;对于假,输出0</p><div class="table-container"><table><thead><tr><th style="text-align:center">关系操作符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">&lt;</td><td style="text-align:center">小于</td></tr><tr><td style="text-align:center">&lt;=</td><td style="text-align:center">小于等于</td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:center">大于</td></tr><tr><td style="text-align:center">&gt;=</td><td style="text-align:center">大于等于</td></tr><tr><td style="text-align:center">==</td><td style="text-align:center">等于</td></tr><tr><td style="text-align:center">~=</td><td style="text-align:center">不等于</td></tr></tbody></table></div><p>matlab关系操作符能用来比较两个同样大小的数组,或用来比较一个数组和一个标量,在后一种情况中,标量和数组中的每一个元素相比较,结果与数组大小一样</p><div class="table-container"><table><thead><tr><th style="text-align:center">逻辑运算符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">&amp;</td><td style="text-align:center">与</td></tr><tr><td style="text-align:center">丨</td><td style="text-align:center">或</td></tr><tr><td style="text-align:center">~</td><td style="text-align:center">非</td></tr><tr><td style="text-align:center">xor(x,y)</td><td style="text-align:center">异或</td></tr><tr><td style="text-align:center">any(x)</td><td style="text-align:center">判断是否为零向量或者零矩阵</td></tr></tbody></table></div><h3 id="字符和字符串"><a href="#字符和字符串" class="headerlink" title="字符和字符串"></a>字符和字符串</h3><ol><li>在matlab中,<strong>文本</strong>当做特征字符串或简单地当做字符串</li><li>字符串能够<strong>显示在屏幕上</strong>,也可以<strong>用来构成一些命令</strong>,这些命令在其他的命令中用于求值或者被执行</li><li>一个字符串是存储在一个行向量中的文本,这个行向量中的每一个元素代表一个字符,实际上,元素中存放的是字符的ASCII码</li><li>在屏幕上显示字符变量的值时,显示出来的是文本,而不是ASCII数字</li><li>由于字符串是以向量的形式来存储的,因此可以通过它的下标对字符串中的任何一个元素进行访问,字符矩阵也可以通过下标索引进行访问,但是矩阵的每行字符数必须相同</li><li>一个字符串是由<strong>单引号</strong>括起来的简单文本</li><li>在字符串里的每个字符是数组里的一个元素,字符串的存储要求<strong>每个字符占8个字节</strong></li><li>字符串基本操作(以s=‘123456789’ 为例)</li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:left">输出</th></tr></thead><tbody><tr><td style="text-align:center">u=abs(s)</td><td style="text-align:left">u =[49,50,51,52,53,54,55,56,57]</td></tr><tr><td style="text-align:center">s=s+0</td><td style="text-align:left">s =[49,50,51,52,53,54,55,56,57]</td></tr><tr><td style="text-align:center">u=s(4:9)</td><td style="text-align:left">u=‘456789’</td></tr><tr><td style="text-align:center">u=s(9:-2:3)</td><td style="text-align:left">u=‘9753’</td></tr><tr><td style="text-align:center">输入s=I’’am Bob.</td><td style="text-align:left">s=I’m Bob</td></tr><tr><td style="text-align:center">u=[s ‘87654321’]</td><td style="text-align:left">u=‘12345678987654321’</td></tr></tbody></table></div><h3 id="函数句柄"><a href="#函数句柄" class="headerlink" title="函数句柄"></a>函数句柄</h3><p>在matlab中调用函数分为直接调用和间接调用</p><ul><li><p>直接调用</p><ul><li>被调函数被称为子函数</li><li>子函数只能被与其M文件同名的主函数或在M文件中的其他函数所调用</li><li>在一个文件中只能有一个主函数</li></ul></li><li><p>间接调用(函数句柄)</p><ul><li>避免了直接调用的限制(第二条)</li><li>创建函数句柄时需要用到操作符@</li><li>对任意函数都可以创造函数句柄</li><li>创建函数句柄的一般语法格式<ul><li>Function_Handle = @Function_Filename</li><li>Function_Filename是函数所对应的M文件的名称或matlab内部函数的名称</li><li>@是句柄创建操作符</li><li>Function_Handle变量保存了这一函数句柄,并在后续的运算中作为数据流进行传递</li><li>例:F_Handle=@cos 就创建了matlab内部函数cos的句柄,并将其保存在F_Handle变量中,后续的运算过程中就可以通过F_Handle(x)来实现cos(x)的功能</li><li>通过函数句柄调用函数时,也需要指定函数的输入参数(跟原来的那个函数调用一致)</li></ul></li></ul></li><li>函数句柄的操作函数</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">函数名称</th><th style="text-align:left">函数功能</th></tr></thead><tbody><tr><td style="text-align:center">functions(funhandle)</td><td style="text-align:left">返回一个结构体<br>包含函数的名称(function),函数类型(type),以及函数M文件的位置(file)</td></tr><tr><td style="text-align:center">func2str(funhandle)</td><td style="text-align:left">将函数句柄转换为函数名称的字符串</td></tr><tr><td style="text-align:center">str2func(str)</td><td style="text-align:left">将字符串代表的函数转换为函数句柄</td></tr><tr><td style="text-align:center">save filename.mat funhandle</td><td style="text-align:left">将函数句柄保存在*.mat文件中</td></tr><tr><td style="text-align:center">load filename.mat funhandle</td><td style="text-align:left">把*.mat文件中存储的函数句柄加载到工作区</td></tr><tr><td style="text-align:center">isa(var,’function_handle’)</td><td style="text-align:left">检测变量var是否是函数句柄</td></tr><tr><td style="text-align:center">isequal(funhandle1,funhandle2)</td><td style="text-align:left">检测两个函数句柄是否对应于同一个函数</td></tr></tbody></table></div><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><ul><li><p>创建结构体</p><ul><li><p>直接通过赋值语句给结构体的字段赋值</p><figure class="hljs highlight Matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Matlab">student.name=<span class="hljs-string">'sam'</span>;<br>student.grade=<span class="hljs-number">6</span>;<br>student.subject=&#123;<span class="hljs-string">'Chinese'</span>,<span class="hljs-string">'Math'</span>,<span class="hljs-string">'English'</span>&#125;;<br>student.result=&#123;<span class="hljs-number">99</span>,<span class="hljs-number">99</span>,<span class="hljs-number">99</span>&#125;;<br></code></pre></td></tr></table></figure><p><strong>注意</strong></p></li></ul><ol><li>在进行字段赋值时,没有明确赋值的字段,matlab默认赋值为空数组</li><li>通过圆括号索引进行字段赋值,还可以创建任意尺寸的结构体数组</li><li>同一个结构体数组中所有结构体对象具有相同的字段组合</li></ol><ul><li>利用struct函数创建结构体<ul><li>node = struct(‘field1’,var1,’field2’,var2,…,’fieldn’,varn)</li><li>数组  node(2) =struct(‘field1’,var1,’field2’,var2,…,’fieldn’,varn)</li><li>重复写入node = repmat(struct(‘day’,’thursday’,’time’),==1,2==)</li></ul></li></ul></li></ul><h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><p>matlab中进行运算的所有数据类型,都是按照数组及矩阵的形式进行存储和运算的,而二者在matlab中的基本运算性质不同,陈列强调元素对元素的运算,而矩阵则采用线性代数的运算方式</p><ul><li>数组定义 a=[1 2 3 4 5]</li><li>冒号定义<ul><li>a=1:10<br>a=[1 2 3 4 5 6 7 8 9 10]</li><li>a=1:2:10<br>a=[1 3 5 7 9]</li><li>a=linspace(a,b,100)<br>在区间[a,b]上创建一个有100个元素的向量,这100个数把整个区间线性分隔</li></ul></li></ul><h3 id="单元数组类型"><a href="#单元数组类型" class="headerlink" title="单元数组类型"></a>单元数组类型</h3><p>单元(cell)数组是一种无所不包的广义矩阵,组成单元数组的每一个元素称为一个单元,每一个单元可以包括一个任意数组,如数值数组,字符串数组,结构体数组或另外一个单元数组,因而每一个单元可以具有不同的尺寸和内存占用空间.</p><p><strong>注意</strong>:<strong>和一般的数值数组一样,单元数组的维数不受限制,可以是一维,二维或多维</strong></p><h4 id="单元数组的创建"><a href="#单元数组的创建" class="headerlink" title="单元数组的创建"></a>单元数组的创建</h4><ol><li><p>使用赋值语句创建单元数组</p><p>单元数组使用花括号”{}”来创建,使用逗号”,”或空格来分隔每一个单元,使用”;”来分行</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">c=&#123;<span class="hljs-string">'haha'</span>,[<span class="hljs-number">1</span>;<span class="hljs-number">2</span>;<span class="hljs-number">3</span>];<span class="hljs-number">10</span>,<span class="hljs-built_in">pi</span>&#125;<br></code></pre></td></tr></table></figure></li><li><p>利用cell函数创建空单元数组</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">cellname=cell(m,n)<br></code></pre></td></tr></table></figure><p>该函数创建一个m*n的空单元数组,其每一个单元均为空矩阵</p></li></ol><h4 id="单元数组的寻访"><a href="#单元数组的寻访" class="headerlink" title="单元数组的寻访"></a>单元数组的寻访</h4><p>在单元数组中,单元和单元中的内容是两个不同范畴的东西,因此,寻访单元和单元中的内容是两个不同的操作,matlab为上述两种操作设计了相对应的操作对象:单元外标识(Cell Indexing)和单元内编址(Content Addressing)</p><p>对于单元数组c,c(m,n)指的是单元数组中第m行第n列的单元,而c{m,n}指的是单元数组中第m行第n列单元中的内容</p><h4 id="单元数组的操作"><a href="#单元数组的操作" class="headerlink" title="单元数组的操作"></a>单元数组的操作</h4><ol><li><p>单元数组的合并</p><p><code>c={a b}</code></p></li><li><p>单元数组的删除</p><p>如果要删除单元数组中指定的某个单元,只需把空矩阵赋给该单元即可</p><p><code>c{m,n}=[]</code></p></li><li><p>使用reshape函数改变单元数组的形状</p><p><code>trimc = reshape(c,M,N)</code></p><p>该函数将单元数组c改变成一个具有M行N列的新单元数组</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab学习笔记(1)</title>
      <link href="/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/"/>
      <url>/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</url>
      
        <content type="html"><![CDATA[<p><strong>matlab学习笔记(1)主要介绍了以下内容</strong></p><ol><li>matlab的命令行通用命令</li><li>如何设置matlab调用文件的搜索路径</li><li>matlab的帮助系统</li></ol><a id="more"></a><h2 id="命令行通用命令"><a href="#命令行通用命令" class="headerlink" title="命令行通用命令"></a>命令行通用命令</h2><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">命令说明</th></tr></thead><tbody><tr><td style="text-align:center">cd</td><td style="text-align:center">显示或改变当前文件夹的地址</td></tr><tr><td style="text-align:center">dir</td><td style="text-align:center">显示当前文件夹或指定目录下的文件</td></tr><tr><td style="text-align:center">clc</td><td style="text-align:center">清除命令行中命令</td></tr><tr><td style="text-align:center">home</td><td style="text-align:center">将当前输入放到最上面</td></tr><tr><td style="text-align:center">clf</td><td style="text-align:center">清除图形窗口</td></tr><tr><td style="text-align:center">type</td><td style="text-align:center">显示文件内容</td></tr><tr><td style="text-align:center">clear</td><td style="text-align:center">清理工作区变量</td></tr><tr><td style="text-align:center">load</td><td style="text-align:center">加载指定文件的变量</td></tr><tr><td style="text-align:center">diary</td><td style="text-align:center">日志文件命令</td></tr><tr><td style="text-align:center">!</td><td style="text-align:center">调用dos命令</td></tr><tr><td style="text-align:center">exit</td><td style="text-align:center">退出matlab</td></tr><tr><td style="text-align:center">pack</td><td style="text-align:center">收集内存碎片</td></tr><tr><td style="text-align:center">hold</td><td style="text-align:center">图形保持开关</td></tr><tr><td style="text-align:center">path</td><td style="text-align:center">显示搜索目录</td></tr><tr><td style="text-align:center">save</td><td style="text-align:center">保存工作区变量到指定文件</td></tr></tbody></table></div><h3 id="标点"><a href="#标点" class="headerlink" title="标点"></a>标点</h3><div class="table-container"><table><thead><tr><th style="text-align:center">标点</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">:</td><td style="text-align:center">冒号,具有多种应用功能</td></tr><tr><td style="text-align:center">;</td><td style="text-align:center">分号,区分行及取消运行结果显示</td></tr><tr><td style="text-align:center">,</td><td style="text-align:center">逗号,区分列及函数参数分隔符</td></tr><tr><td style="text-align:center">()</td><td style="text-align:center">括号,指定运算的优先级</td></tr><tr><td style="text-align:center">[]</td><td style="text-align:center">方括号,定义矩阵</td></tr><tr><td style="text-align:center">{}</td><td style="text-align:center">大括号,构造单元数组</td></tr><tr><td style="text-align:center">%</td><td style="text-align:center">百分号,注释</td></tr><tr><td style="text-align:center">!</td><td style="text-align:center">感叹号,赋值标记</td></tr><tr><td style="text-align:center">=</td><td style="text-align:center">等号,赋值标记</td></tr><tr><td style="text-align:center">‘</td><td style="text-align:center">单引号,字符串的标识符</td></tr><tr><td style="text-align:center">.</td><td style="text-align:center">小数点及对象域访问</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">续行符号</td></tr></tbody></table></div><h2 id="设置matlab调用文件的搜索路径"><a href="#设置matlab调用文件的搜索路径" class="headerlink" title="设置matlab调用文件的搜索路径"></a>设置matlab调用文件的搜索路径</h2><ol><li><p>为什么要设置</p><p>一般情况下,matlab系统的函数,包括工具箱函数,都是在系统默认的搜索路径之中的,但是用户设计的函数有可能没有保存到搜索路径下,很多情况容易造成matlab误认为该函数不存在,因此需要把程序所在的目录扩展成matlab的搜索路径即可.</p></li><li><p>如何设置</p><p>点击主页窗口的<code>设置路径</code>,点击<code>添加文件夹</code>,然后选择你的函数文件夹即可,建议建立一个大的文件夹,把所有的函数都放进去.</p><p><strong>注意:只有在matlab搜索路径中的函数才能被识别(可以调用path命令来查看搜索路径).并且当某一文件夹的父文件夹在搜索路径中而其本身不在搜索路径中时,则此文件夹不会被搜索到.</strong></p></li></ol><h2 id="帮助系统"><a href="#帮助系统" class="headerlink" title="帮助系统"></a>帮助系统</h2><ol><li><p>help命令</p><p>调用格式(以sin函数作为例子)</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">help <span class="hljs-built_in">sin</span><br></code></pre></td></tr></table></figure><p>调用后会显示简洁用法,以及详细的参考页,可以调用的不单单只是函数,还可以调用<code>pi</code>等常数</p></li><li><p>demos帮助</p><p>直接在命令行中输入<code>demo</code>,用户可以更加直观,快速地学习matlab实用知识.</p></li><li><p>帮助导航浏览器</p><p>帮助导航浏览器是matlab专门提供的一个独立的帮助子系统,该系统包含的所有帮助文件都存储在matlab安装目录下的help子目录下</p><p>打开方式:命令行中直接输入<code>doc</code></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
