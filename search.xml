<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Go</title>
      <link href="/2020/11/26/Go-%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/11/26/Go-%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>Go 语言也称Golang，兼具<strong>效率</strong>、<strong>性能</strong>、<strong>安全</strong>、<strong>健壮</strong>等特性。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/usergroups.png"></p><a id="more"></a><h1 id="Go-语言简介"><a href="#Go-语言简介" class="headerlink" title="Go 语言简介"></a>Go 语言简介</h1><p>Go 语言（Golang）起源于 2007 年，并在 2009 年正式对外发布。</p><ul><li><p>主要目标：兼具 <strong>Python 等动态语言的开发速度</strong>和<strong>C/C++等编译型语言的性能与安全性</strong>。</p></li><li><p>用途：网络编程、系统编程、并发编程、分布式编程。</p></li><li><p>优势：不损失应用性能的情况下降低代码的复杂性，“部署简单、并发性好、语言设计良好、执行性能好”</p></li></ul><p>Go 从C语言继承了相似的<strong>表达式语法、控制流结构、基础数据类型、调用参数传值、指针</strong>等很多思想，还有C语言一直所看中的<strong>编译后机器码的运行效率</strong>以及<strong>和现有操作系统的无缝适配</strong>。</p><h2 id="Go-是编译型语言"><a href="#Go-是编译型语言" class="headerlink" title="Go 是编译型语言"></a>Go 是编译型语言</h2><p>Go 使用编译器来编译代码。</p><p>编译器将源代码编译成二进制（或字节码）格式；</p><p>在编译代码时，编译器检查错误、优化性能并输出可在不同平台上运行的二进制文件。</p><p>创建并运行 Go 程序，需要如下步骤：</p><ol><li>使用文本编辑器创建 Go 程序；</li><li>保存文件；</li><li>编译程序；</li><li>运行编译得到的可执行文件。</li></ol><p>这不同于 Python、Ruby 和 JavaScript 等语言，它们不包含编译步骤。</p><p>Go 自带了编译器，因此无须单独安装编译器。</p><h1 id="Go-语言特性"><a href="#Go-语言特性" class="headerlink" title="Go 语言特性"></a>Go 语言特性</h1><p>静态强类型、编译型、并发型、并具有垃圾回收功能的编程语言。</p><ul><li>语法简单：规则严谨，没有歧义。</li><li>并发模型<ul><li>从根本上将一切都并发化，运行时用 Goroutine 运行所有的一切，包括 main.main 入口函数。</li><li>用<strong>类协程</strong>的方式处理并发单元，在运行时层面做了更深度的优化处理（无需处理回调，无需关注协程切换）。</li><li>搭配 channel，实现 CSP 模型。将并发单元间的数据解耦。</li></ul></li><li>内存分配<ul><li><code>tcmalloc</code>内存分配组件。</li></ul></li><li>垃圾回收<ul><li>并发标记，引入三色标记和写屏障</li></ul></li><li>静态链接<ul><li>只需编译后的一个可执行文件，无须附加任何东西就能部署。</li></ul></li><li>标准库<ul><li>标准库极为丰富。</li></ul></li><li>工具链</li></ul><h1 id="Go-基本语法"><a href="#Go-基本语法" class="headerlink" title="Go 基本语法"></a>Go 基本语法</h1><h2 id="运行-Go"><a href="#运行-Go" class="headerlink" title="运行 Go"></a>运行 Go</h2><ol><li>通过 Go 命令运行，保存为 <strong>hello.go</strong> 文件。</li></ol><figure class="hljs highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   fmt.Println(<span class="hljs-string">"Hello, World!"</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>hello.go</code>目录下运行命令：<code>go run hello.go</code>，即可。</p><ol><li>编译运行</li></ol><p>Go 代码可以直接编译成<code>exe 文件</code>或者<code>二进制文件</code>直接运行。</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">go build hello.go<br>./hello<br></code></pre></td></tr></table></figure><ol><li>在浏览器中运行，输入<a href="https://play.golang.org/" target="_blank" rel="noopener">链接</a>。</li></ol><h2 id="格式化输入输出"><a href="#格式化输入输出" class="headerlink" title="格式化输入输出"></a>格式化输入输出</h2><h3 id="输入输出语法方法"><a href="#输入输出语法方法" class="headerlink" title="输入输出语法方法"></a>输入输出语法方法</h3><figure class="hljs highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//  %[标记][宽度][.精度][arg索引]动词`</span><br><span class="hljs-comment">//  `Print(arg列表)`、`Println(arg列表)`、`Printf(格式字符串, arg列表)</span><br><br><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">"fmt"</span><br><span class="hljs-string">"time"</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">"Hello World!"</span>)<br>fmt.Println(<span class="hljs-string">"The time is"</span>, time.Now())<br>&#125;<br><br>-----------------------------------------------<br>Hello World!<br>The time is <span class="hljs-number">2020</span><span class="hljs-number">-11</span><span class="hljs-number">-26</span> <span class="hljs-number">16</span>:<span class="hljs-number">03</span>:<span class="hljs-number">49.841453</span> +<span class="hljs-number">0800</span> CST m=+<span class="hljs-number">0.000125104</span><br></code></pre></td></tr></table></figure><h3 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h3><figure class="hljs highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined">+ 总打印数值的正负号；对于%q（%+q）保证只输出ASCII编码的字符。<br><br>- 在右侧而非左侧填充空格（左对齐该区域）<br><br># 备用格式：为八进制添加前导 <span class="hljs-number">0</span>（%#o），为十六进制添加前导 <span class="hljs-number">0</span>x（%#x）或<br>  <span class="hljs-number">0</span>X（%#X），为 %p（%#p）去掉前导 <span class="hljs-number">0</span>x；对于 %q，若 strconv.CanBackquote<br>  返回 true，就会打印原始（即反引号围绕的）字符串；如果是可打印字符，<br>  %U（%#U）会写出该字符的Unicode编码形式（如字符 x 会被打印成 U+<span class="hljs-number">0078</span> <span class="hljs-string">'x'</span>）。<br>  <br><span class="hljs-string">' '</span> （空格）为数值中省略的正负号留出空白（% d）；<br>  以十六进制（% x, % X）打印字符串或切片时，在字节之间用空格隔开<br>  <br><span class="hljs-number">0</span>  填充前导的<span class="hljs-number">0</span>而非空格；对于数字，这会将填充移到正负号之后<br></code></pre></td></tr></table></figure><ul><li>其中 <code>0</code> 和 <code>-</code> 不能同时使用，优先使用 <code>-</code> 而忽略 <code>0</code>。</li><li>标记有时会被占位符忽略，所以不要指望它们。例如十进制没有备用格式，因此 <code>%#d</code> 与 <code>%d</code> 的行为相同。</li></ul><h3 id="宽度和精度"><a href="#宽度和精度" class="headerlink" title="宽度和精度"></a>宽度和精度</h3><p><code>[宽度][.精度]</code>都可以写成以下三种形式：<code>数值</code>，<code>*</code>，<code>arg索引*</code></p><ul><li><code>数值</code> 表示使用指定的数值作为宽度值或精度值</li><li><code>*</code> 表示使用当前正在处理的 arg 的值作为宽度值或精度值，如果这样的话，要格式化的 arg 将自动跳转到下一个。</li><li><code>arg索引*</code> 表示使用指定 arg 的值作为宽度值或精度值，如果这样的话，要格式化的 arg 将自动跳转到指定 arg 的下一个。</li></ul><p>注意事项：</p><ul><li>宽度值：用于设置最小宽度。</li><li>精度值：对于浮点型，用于控制小数位数，对于字符串或字节数组，用于控制字符数量（不是字节数量）。</li><li>对于浮点型而言，动词 g/G 的精度值比较特殊，在适当的情况下，g/G 会设置总有效数字，而不是小数位数。</li></ul><h3 id="arg-索引"><a href="#arg-索引" class="headerlink" title="arg 索引"></a>arg 索引</h3><p>由中括号和 arg 序号组成（就像这个实例<code>&quot;abc%+ #8.3[3]vdef&quot;</code>中的[3])，用于指定当前要处理的 arg 的序号，序号从 1 开始：<code>&#39;[&#39; + arg序号 + &#39;]&#39;</code></p><h3 id="动词-通用动词"><a href="#动词-通用动词" class="headerlink" title="动词/通用动词"></a>动词/通用动词</h3><ul><li><code>v</code>：默认格式，不同类型的默认格式如下：</li></ul><blockquote><p><strong>布尔型</strong>：<code>t</code> </p><ul><li>输出 true 或 false 字符串。</li></ul><p><strong>整　型</strong>：<code>d</code> </p><ul><li><code>b/o/d</code>：输出 2/8/10 进制格式</li><li><code>x/X</code>：输出 16 进制格式（小写/大写）</li><li><code>c</code>：输出数值所表示的 Unicode 字符</li><li><code>q</code>：输出数值所表示的 Unicode 字符（带单引号）。对于无法显示的字符，将输出其转义字符。</li><li><code>U</code>：输出 Unicode 码点（例如 U+1234，等同于字符串 “U+%04X” 的显示结果）</li></ul><p>对于 o/x/X：</p><ul><li>如果使用 “#” 标记，则会添加前导 0 或 0x。</li></ul><p>对于 U：</p><ul><li>如果使用 “#” 标记，则会在 Unicode 码点后面添加相应的 ‘字符’（前提是该字符必须可显示）</li></ul><p><strong>浮点型</strong>：<code>g</code> </p><ul><li><code>b</code>：科学计数法（以 2 为底）</li><li><code>e/E</code>：科学计数法（以 10 为底，小写 e/大写 E）</li><li><code>f/F</code>：普通小数格式（两者无区别）</li><li><code>g/G</code>：大指数（指数 &gt;= 6）使用 %e/%E，其它情况使用 %f/%F</li></ul><p><strong>复数型</strong>：<code>g</code> </p><p><strong>字符串</strong>：<code>s</code> </p><ul><li><code>s</code> ：普通字符串</li><li><code>q</code> ：双引号引起来的 Go 语法字符串<ul><li>如果使用了 <code>+</code> 标记，则将所有非 ASCII 字符都进行转义处理。</li><li>如果使用了 <code>#</code> 标记，则输出反引号引起来的字符串（前提是</li><li>字符串中不包含任何制表符以外的控制字符，否则忽略 # 标记）</li></ul></li><li><code>x/X</code>：十六进制编码（小写/大写，以字节为元素进行编码，而不是字符）<ul><li>如果使用了 “ “ 标记，则在每个元素之间添加空格。</li><li>如果使用了 “#” 标记，则在十六进制格式之前添加 0x 前缀。</li></ul></li></ul><p><strong>通　道</strong>：<code>p</code> </p><p><strong>指　针</strong>：<code>p</code></p><ul><li><p><code>p</code> ：带 0x 前缀的十六进制地址值。</p></li><li><p><code>#p</code>：不带 0x 前缀的十六进制地址值。</p></li><li><p>Go 没有指针运算。</p></li><li><p>Go 具有指针。 指针保存了变量的内存地址。</p></li><li><p>类型 *T 是指向类型 T 的值的指针。其零值是 nil </p><p>  <code>var p *int</code></p></li><li><p>&amp; 符号会生成一个指向其作用对象的指针。</p><p>  <code>i := 42</code></p><p>  <code>p = &amp;i</code></p></li><li><p><code>*</code>符号表示指针指向的底层的值。</p><p>  <code>fmt.Println(*p)</code>   // 通过指针 p 读取 i</p><p>  <code>*p = 21</code>   // 通过指针 p 设置 i</p></li></ul><p><strong>复合类型</strong>：</p><ul><li>结构体：{字段1  字段2  …}</li><li>数组或切片：[元素0  元素1  …]</li><li>映射：map[键1:值1  键2:值2  …]</li></ul><p>指向复合元素的指针：<code>&amp;{}</code>, <code>&amp;[]</code>, <code>&amp;map[]</code> 复合类型本身没有动词，动词将应用到复合类型的元素上。 结构体可以使用 “+v” 同时输出字段名。</p></blockquote><ul><li><p><code>#v</code>：默认格式，以符合 Go 语法的方式输出。</p><p>  特殊类型的 Go 语法格式如下：</p><blockquote><p>无符号整型：x</p></blockquote></li><li><p><code>T</code>：输出 arg 的类型而不是值（使用 Go 语法格式）。</p></li></ul><p>注意事项：<code>动词</code>不能省略，不同的数据类型支持的动词不一样。</p><h3 id="格式化输入"><a href="#格式化输入" class="headerlink" title="格式化输入"></a>格式化输入</h3><figure class="hljs highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 格式化输入：从输入端读取字符串（以空白分隔的值的序列），</span><br><span class="hljs-comment">// 并解析为具体的值存入相应的 arg 中，arg 必须是变量地址。</span><br><span class="hljs-comment">// 字符串中的连续空白视为单个空白，换行符根据不同情况处理。</span><br><span class="hljs-comment">// \r\n 被当做 \n 处理。</span><br><br><span class="hljs-comment">// 以动词 v 解析字符串，换行视为空白</span><br>Scan(arg列表)<br><span class="hljs-comment">// 以动词 v 解析字符串，换行结束解析</span><br>Scanln(arg列表)<br><span class="hljs-comment">// 根据格式字符串中指定的格式解析字符串</span><br><span class="hljs-comment">// 格式字符串中的换行符必须和输入端的换行符相匹配。</span><br>Scanf(格式字符串, arg列表)<br><br><span class="hljs-comment">// Scan 类函数会返回已处理的 arg 数量和遇到的错误信息。</span><br></code></pre></td></tr></table></figure><h2 id="编程基础"><a href="#编程基础" class="headerlink" title="编程基础"></a>编程基础</h2><h3 id="内置关键字"><a href="#内置关键字" class="headerlink" title="内置关键字"></a>内置关键字</h3><figure class="hljs highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">break</span>      <span class="hljs-keyword">default</span>       <span class="hljs-function"><span class="hljs-keyword">func</span>      <span class="hljs-title">interface</span>    <span class="hljs-title">select</span><br><span class="hljs-title">case</span>       <span class="hljs-title">defer</span>         <span class="hljs-title">go</span>        <span class="hljs-title">map</span>          <span class="hljs-title">struct</span><br><span class="hljs-title">chan</span>       <span class="hljs-title">else</span>          <span class="hljs-title">goto</span>      <span class="hljs-title">package</span>      <span class="hljs-title">switch</span><br><span class="hljs-title">const</span>      <span class="hljs-title">fallthrough</span>   <span class="hljs-title">if</span>        <span class="hljs-title">range</span>        <span class="hljs-title">type</span><br><span class="hljs-title">continue</span>   <span class="hljs-title">for</span>           <span class="hljs-title">import</span>    <span class="hljs-title">return</span>       <span class="hljs-title">var</span></span><br></code></pre></td></tr></table></figure><h3 id="预定义标识符"><a href="#预定义标识符" class="headerlink" title="预定义标识符"></a>预定义标识符</h3><figure class="hljs highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">append</span>  <span class="hljs-keyword">bool</span>    <span class="hljs-keyword">byte</span>    <span class="hljs-built_in">cap</span>     <span class="hljs-built_in">close</span>  <span class="hljs-built_in">complex</span> <span class="hljs-keyword">complex64</span> <span class="hljs-keyword">complex128</span> <span class="hljs-keyword">uint16</span><br><span class="hljs-built_in">copy</span>    <span class="hljs-literal">false</span>   <span class="hljs-keyword">float32</span> <span class="hljs-keyword">float64</span> <span class="hljs-built_in">imag</span>   <span class="hljs-keyword">int</span>     <span class="hljs-keyword">int8</span>      <span class="hljs-keyword">int16</span>      <span class="hljs-keyword">uint32</span><br><span class="hljs-keyword">int32</span>   <span class="hljs-keyword">int64</span>   <span class="hljs-literal">iota</span>    <span class="hljs-built_in">len</span>     <span class="hljs-built_in">make</span>   <span class="hljs-built_in">new</span>     <span class="hljs-literal">nil</span>       <span class="hljs-built_in">panic</span>      <span class="hljs-keyword">uint64</span><br><span class="hljs-built_in">print</span>   <span class="hljs-built_in">println</span> <span class="hljs-built_in">real</span>    <span class="hljs-built_in">recover</span> <span class="hljs-keyword">string</span> <span class="hljs-literal">true</span>    <span class="hljs-keyword">uint</span>      <span class="hljs-keyword">uint8</span>      <span class="hljs-keyword">uintptr</span><br></code></pre></td></tr></table></figure><h3 id="行分割符"><a href="#行分割符" class="headerlink" title="行分割符"></a>行分割符</h3><ul><li>在 Go 程序中，一行代表一个语句结束，不需要分隔符。</li><li>打算将多个语句写在同一行，它们则必须使用 <code>;</code> 人为区分，并不鼓励这种做法。</li></ul><h3 id="注释方法"><a href="#注释方法" class="headerlink" title="注释方法"></a>注释方法</h3><figure class="hljs highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 单行注释</span><br><br><span class="hljs-comment">/*<br>  多行注释<br>*/</span><br></code></pre></td></tr></table></figure><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><ul><li>标识符用来命名变量、类型等程序实体。</li><li>第一个字符必须是字母或下划线而不能是数字</li></ul><p>有效标识符</p><figure class="hljs highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">mahesh   kumar   abc   move_name   a_123<br>myname50   _temp   j   a23b9   retVal<br></code></pre></td></tr></table></figure><p>无效标识符</p><figure class="hljs highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">1</span>ab  #（以数字开头）<br><span class="hljs-keyword">case</span> #（Go 语言的关键字）<br>a+b  #（运算符是不允许的）<br></code></pre></td></tr></table></figure><h3 id="包引用"><a href="#包引用" class="headerlink" title="包引用"></a>包引用</h3><figure class="hljs highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">"os"</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">"io"</span><br></code></pre></td></tr></table></figure><p>简写方式如下</p><figure class="hljs highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>  <span class="hljs-string">"fmt"</span><br>  <span class="hljs-string">"os"</span><br>  <span class="hljs-string">"io"</span><br>)<br></code></pre></td></tr></table></figure><p><strong>包引用介绍</strong></p><figure class="hljs highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">.<br>├── cal<br>│   ├── add.<span class="hljs-keyword">go</span><br>│   ├── multi<br>│   │   └── multiply.<span class="hljs-keyword">go</span><br>│   └── subtract.<span class="hljs-keyword">go</span><br>└── main.<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fundamentals of Computer Graphics 4 Raster Images</title>
      <link href="/2020/11/16/Fundamentals-of-Computer-Graphics-4-Raster-Images/"/>
      <url>/2020/11/16/Fundamentals-of-Computer-Graphics-4-Raster-Images/</url>
      
        <content type="html"><![CDATA[<p>本文主要讨论光栅图像和显示器的基础</p><a id="more"></a><h1 id="光栅化设备"><a href="#光栅化设备" class="headerlink" title="光栅化设备"></a>光栅化设备</h1><p>分类：</p><ul><li>输出<ul><li>Display<ul><li>投射型（Transmissive）：liquid crystal display (LCD)</li><li>发射型（Emissive）：light-emitting diode (LED) display</li></ul></li><li>Hardcopy<ul><li>Binary：喷墨打印机（ink-jet printer）</li><li>Continuous tone：染料升华打印机（dye sublimation printer）</li></ul></li></ul></li><li>输入<ul><li>2D 阵列传感器：digital camera</li><li>1D 阵列传感器：平板扫描仪（flatbed scanner）</li></ul></li></ul><h2 id="显示器"><a href="#显示器" class="headerlink" title="显示器"></a>显示器</h2><p> <strong>emissive displays</strong>: use pixels that directly emit controllable amounts of light</p><p><strong>transmissive displays</strong>: the pixels themselves don’t emit light but instead vary the amount of light that they allow to pass through them.</p>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
            <tag> 基础学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HRV学习</title>
      <link href="/2020/11/11/HRV%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/11/11/HRV%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>Heart rate variability（HRV）is about beat-to-beat variability in RR intervals.</p><p>Heart rate variability is a commonly used tool when trying to assess the functioning of cardiac autonomic regulation.</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86/%E5%8C%BB%E5%AD%A6/RR.png" width="50%"></p><a id="more"></a><h1 id="Respiratory-Sinus-Arrhythmia-RSA"><a href="#Respiratory-Sinus-Arrhythmia-RSA" class="headerlink" title="Respiratory Sinus Arrhythmia(RSA)"></a>Respiratory Sinus Arrhythmia(RSA)</h1><ul><li><p><strong>HRV consists of two periodic components</strong></p><ul><li><p><strong>High frequency（HF，0.15-0.5Hz）</strong></p><p>  <strong>HF component</strong>, also knows as <strong>respiratory sinus arrhythmia</strong>, reflects parasympathetic nervous activity.（Peaks at respiratory frequency）</p></li><li><p><strong>Low frequency（LF，0.04-0.15Hz）</strong></p><p>  <strong>LF component</strong> reflects both sympathetic and parasympathetic nervous activities.</p></li></ul></li><li><p><strong>During inspiration</strong></p><ul><li>Diaphragm contracts and moves downward</li><li>Chest cavity expands</li><li>Intra-thoracic pressure lowers and air flows into the lungs</li><li>Arterial blood pressure is also lowered, which activates baroreceptors</li><li>Vagal tone is suppressed</li><li><strong>Heart rate increases</strong></li></ul></li><li><strong>During expiration</strong><ul><li>Diaphragm relaxes and moves upward</li><li>Chest cavity size decreases</li><li>Intra-thoracic pressure increases and air flows out from the lungs</li><li>Arterial blood pressure is also increased, which deactivates baroreceptor activity </li><li>Vagal tone not suppressed</li><li><strong>Heart rate decrease</strong></li></ul></li></ul><h1 id="Preprocessing-of-HRV-DATA"><a href="#Preprocessing-of-HRV-DATA" class="headerlink" title="Preprocessing of HRV DATA"></a>Preprocessing of HRV DATA</h1><p><strong>Careful preprocessing of HRV data is very important before applying any HRV analysis methods.</strong></p><p> Any artefact in the RR interval time series may <strong>significantly interfere</strong> the analysis of these signals.</p><p> The artefacts within HRV signals can be divided into <strong>technical and physiological artefacts</strong></p><ul><li><strong>The technical artifacts</strong> include missing, extra or misaligned beat detections. These artefacts may be due to measurement noise or due to inaccuracy of the detection algorithm. </li><li><strong>Physiological artefacts</strong> include ectopic beats and arrhythmic events. </li></ul><p>In order to avoid the interference of such artefacts, the ECG recording and the corresponding event series should always <strong>be manually checked for artefacts and only artefact-free sections should be included in the analysis</strong>. </p><p>Alternatively, if the amount of artefact-free data is insufficient, proper <strong>interpolation methods</strong> can be used to reduce these artefacts,</p><p>In addition to artefacts, slow changes in mean <strong>HR</strong> during the recording can have undesirable effects on certain heart rate variability analysis parameters. </p><ul><li>Such slow nonstationarities are characteristic for HRV signals and should be considered before the analysis. </li><li>The slow nonstationary trends can be easily removed from the HRV time series before analysis. </li></ul><h2 id="Kubios-HRV-beat-correction-methods"><a href="#Kubios-HRV-beat-correction-methods" class="headerlink" title="Kubios HRV beat correction methods"></a>Kubios HRV beat correction methods</h2><p>Kubios HRV software provides excellent tools for handling artefacts. </p><ol><li><p>First, beat detections can be corrected manually when <strong>raw ECG (or PPG) data is available</strong>. Such beat correction provides true beat intervals but is reasonable only when data includes a limited number of misdetections. </p></li><li><p>Secondly, the software includes <strong>two beat correction methods</strong>: </p><p> 1) Threshold based beat correction</p><p> 2) Automatic beat correction</p></li></ol><h3 id="Threshold-based-beat-correction-algorithm"><a href="#Threshold-based-beat-correction-algorithm" class="headerlink" title="Threshold based beat correction algorithm"></a>Threshold based beat correction algorithm</h3><p>The threshold based beat correction algorithm <strong>compares every RR interval value against a local average interval</strong>. </p><p>The local average is obtained by median filtering the RR interval time series, and thus, <strong>the local average is not affected by single outliers in RR interval time series</strong>. </p><p>If an RR interval differs from the local average more than a specified threshold value, the interval is identified as an artefact and is marked for correction. </p><p>The threshold value can be selected from:</p><ul><li>Very low: 0.45 sec (threshold in seconds)</li><li>Low: 0.35 sec</li><li>Medium: 0.25 sec</li><li>Strong: 0.15 sec</li><li>Very strong: 0.05 sec</li><li>Custom, for setting a custom threshold in seconds</li></ul><p>For example, the “Medium” correction level will identify all RR intervals that are larger/smaller than 0.25 seconds compared to the local average. </p><p>The correction is made by replacing the identified artefacts with interpolated values using a <strong>cubic spline interpolation</strong>. </p><p>It should be noted, that <strong>these threshold are adjusted with mean heart rate</strong>. That is, thresholds shown above are for HR of 60 beats/min, but for higher HR the thresholds are smaller (because the variability is expected to decrease when HR increases) and vice versa for lower heart rates.</p><p>Because the artefacts are identified by simple thresholding and normal heart rate variability level is highly individual, <strong>the correction level should be adjusted individually</strong> as follows. </p><ul><li>First, identify if there are any beat intervals that should be corrected. </li><li>If there are such intervals, then select the lowest possible correction level, which corrects the abnormal beats but does not over correct the data.</li></ul><h3 id="Automatic-beat-correction-algorithm"><a href="#Automatic-beat-correction-algorithm" class="headerlink" title="Automatic beat correction algorithm"></a>Automatic beat correction algorithm</h3><p>In automatic beat correction algorithm, artefacts are detected from <strong>dRR series</strong>, which is a time series consisting of differences between <strong>successive RR intervals</strong>. <a href="https://www.kubios.com/hrv-preprocessing/#Lipponen2019" target="_blank" rel="noopener">Lipponen &amp; Tarvainen 2019</a></p><p>The dRR series provides a robust way to <strong>separate ectopic and misplaced beats</strong> from the normal sinus rhythm. </p><p>To separate ectopic and normal beats, <strong>time varying threshold (Th)</strong> is used. To ensure <strong>adaptation to different HRV levels</strong>, the threshold is estimated from the time-varying distribution of dRR series. </p><p>For each beat, <strong>quartile deviation of the 90 surrounding beats</strong> is calculated and multiplied by factor 5.2. Beats within this range cover 99.95% of all beats if RR series is normally distributed. </p><p>However, RR interval series <strong>is not often normally distributed</strong>, and thus, also some of the normal beats exceed the threshold. Therefore, decision algorithm is needed to detect artefact beats.</p><div class="table-container"><table><thead><tr><th style="text-align:center">Beat types</th><th style="text-align:center">Nbr of beats</th><th style="text-align:center">Mean $\Delta t(ms)$</th><th style="text-align:center">Detection(%)</th></tr></thead><tbody><tr><td style="text-align:center">Sinus beats</td><td style="text-align:center">61 757</td><td style="text-align:center">—-</td><td style="text-align:center">99.963%</td></tr><tr><td style="text-align:center">Missed beats</td><td style="text-align:center">610</td><td style="text-align:center">—-</td><td style="text-align:center">100%</td></tr><tr><td style="text-align:center">Extra beats</td><td style="text-align:center">610</td><td style="text-align:center">—-</td><td style="text-align:center">100%</td></tr><tr><td style="text-align:center">Misaligned beats(q=2)</td><td style="text-align:center">610</td><td style="text-align:center">58 ms</td><td style="text-align:center">53.9%</td></tr><tr><td style="text-align:center">Misaligned beats(q=4)</td><td style="text-align:center">610</td><td style="text-align:center">119 ms</td><td style="text-align:center">99.3%</td></tr><tr><td style="text-align:center">Misaligned beats(q=8)</td><td style="text-align:center">610</td><td style="text-align:center">238 ms</td><td style="text-align:center">100%</td></tr></tbody></table></div><p>Ectopic beats form <strong>negative-positive-negative (NPN)</strong> or <strong>positive-negative-positive (PNP)</strong> patterns to the dRR series. Similarly long beats form <strong>positive-negative (PN)</strong> and short beats <strong>negative-positive (NP)</strong> patterns to the dRR series. Only dRR segments containing these patterns are classified as artefact beats. </p><p>Missed or extra beats are detected by <strong>comparing current RR value with median of the surrounding 10 RR interval values (medRR)</strong>. A missed beat is detected if current RR interval (RR(i)) satisfies condition</p><script type="math/tex; mode=display">\left|\frac{RR(i)}{2}-medRR(i)\right|  \tag{1} < 2Th</script><p>and an <strong>extra beat is detected</strong> if two successive RR intervals (RR(i) and RR(i+1)) satisfies condition</p><script type="math/tex; mode=display">|RR(i)+RR(i+1)-medRR(i)|<2Th \tag{2}</script><p><strong>Correction of detected artefacts</strong>: Detected ectopic beats are corrected by <strong>replacing corrupted RR times by interpolated RR values</strong>. </p><p>Similarly too long and short beats are corrected by <strong>interpolating new values</strong> to the RR time series. </p><p>Missed beats are corrected by <strong>adding new R-wave occurrence time</strong> and extra beats are simply corrected by removing extra R-wave detection and recalculating RR interval series.</p><h2 id="Detrending-of-RR-interval-data"><a href="#Detrending-of-RR-interval-data" class="headerlink" title="Detrending of RR interval data"></a>Detrending of RR interval data</h2><p>To <strong>avoid the effect of slow nonstationary trends</strong> (slow changes in mean HR basically) over HRV analysis results, such trends by default are removed in Kubios HRV software using a <strong>smoothness priors method</strong>. </p><p>The theory behind the smoothness priors detrending method is described shortly here.  <a href="https://www.kubios.com/hrv-preprocessing/#Tarvainen2002" target="_blank" rel="noopener">Tarvainen et al. 2002</a>.</p><p>Let $z\in N$ denote <strong>the RR interval time series</strong> which can be considered to consist of two components</p><script type="math/tex; mode=display">z=z_{stat}+z_{trend} \tag{3}</script><p>$z_{stat}$ is <strong>the nearly stationary RR interval series of interest</strong>, $z_{trend}$ is <strong>the low frequency aperiodic trend component</strong>, and $N$ is <strong>the number of RR intervals</strong>. </p><p>Suppose that <strong>the trend component</strong> can be modeled with a linear observation model as</p><script type="math/tex; mode=display">z_{trend}=H\theta+e    \tag{4}</script><p>where $H\in N\times p$ is <strong>the observation matrix</strong>, $\theta\in p$ are <strong>the regression parameters</strong>, and $e$ is the <strong>observation error</strong>. </p><p>The task is then to <strong>estimate the parameters</strong> by some fitting procedure so that $\hat{z}_{trend}=H\hat{\theta}$ can be used as <strong>the estimate of the trend</strong>. </p><p>The properties of the estimate depend strongly on the properties of the basis vectors (columns of the matrix $H$) in the fitting. A widely used method for the solution of the estimate $\hat{\theta}$ is <strong>the least squares method</strong>. </p><p>However, a more general approach for the estimation of $\hat{\theta}$ is used here. That is, the so-called regularized least squares solution</p><script type="math/tex; mode=display">\hat{\theta}_{\lambda}=\arg \min \limits_{\theta}\{\|z-H\theta\|^2+\lambda^2\|D_2(H\theta)\|^2\}    \tag{5}</script><p>where $\lambda$ is the <strong>regularization parameter</strong> and $D_2$ indicates <strong>the discrete approximation of 2nd order derivative</strong>. </p><p>This is a modification of the ordinary <strong>least squares solution</strong>, dragging the solution to the direction in which the norm $|D_2(H\theta)|$ gets smaller. </p><p>In this way, prior information about the predicted trend $H\theta$ can be implemented to the estimation. The solution of previous equation can be written in the form</p><script type="math/tex; mode=display">\hat{\theta}_{\lambda}=(H^TH+\lambda^2H^TD_2^TD_2H)^{-1}H^{T}z    \tag{6}</script><p>and the estimate for <strong>the trend</strong> which is to be removed can be written</p><script type="math/tex; mode=display">\hat{z}_{trend}=H\hat{\theta}_{\lambda}    \tag{7}</script><p>The selection of the observation matrix $H$ can be implemented according to some known properties of the data $z$. </p><p>However, here we use a trivial choice of identity matrix $H=I\in N\times N$. In this case, the regularization part of the minimized function simply draws the solution towards a curve for which the 2nd order difference is zero, i.e. towards first order linear curve. With these specific choices, the detrended nearly stationary RR series can be written as</p><script type="math/tex; mode=display">\hat{z}_{stat}=z-H\hat{\theta}_{\lambda}=(I-(I+{\lambda}^2D^T_2D_2)^{-1})z  \tag{8}</script><p>This detrending method works like <strong>a time-varying highpass filter</strong>, where the cutoff frequency can be adjusted by changing the smoothing parameter $\lambda$. </p><p>In Kubios HRV Premium software, <strong>the cutoff frequency</strong> related to the given smoothing parameter is presented. <strong>The smoothing parameter</strong> is by default selected to remove only VLF frequency components from the RR time series.</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol><li>G.G. Berntson, J.T. Bigger Jr., D.L. Eckberg, P. Grossman, P.G. Kaufmann, M. Malik, H.N. Nagaraja, S.W. Porges, J.P. Saul, P.H. Stone, and M.W. Van Der Molen. Heart rate variability: Origins, methods, and interpretive caveats. Psychophysiol, 34:623–648, 1997.</li><li>N. Lippman, K.M. Stein, and B.B. Lerman. Nonlinear predictive interpolation: a new method for the correction of ectopic beats for heart rate variability analysis. J Electrocardiol, 26:S14–S19, 1993.</li><li>N. Lippman, K.M. Stein, and B.B. Lerman. Comparison of methods for removal of ectopy in measurement of heart rate variability. Am J Physiol, 267(1):H411–H418, July 1994.</li><li>J.A. Lipponen and M.P. Tarvainen. A robust algorithm for heart rate variability time series artefact correction using novel beat classification. J Med Eng Technol, 43(3):173-181, 2019.</li><li>D.A. Litvack, T.F. Oberlander, L.H. Carney, and J.P. Saul. Time and frequency domain methods for heart rate variability analysis: a methodological comparison. Psychophysiol, 32:492–504, 1995.</li><li>J. Mateo and P. Laguna. Analysis of heart rate variability in the presence of ectopic beats using the heart timing signal. IEEE Trans Biomed Eng, 50(3):334–343, March 2003.</li><li>I.P. Mitov. A method for assessment and processing of biomedical signals containing trend and periodic components. Med Eng Phys, 20(9):660–668, November-December 1998.</li><li>S.W. Porges and R.E. Bohrer. The analysis of periodic processes in psychophysiological research. In J.T. Cacioppo and L.G. Tassinary, editors, Principles of Psychophysiology: Physical Social and Inferential Elements, pages 708–753. Cambridge University Press, 1990.</li><li>M.P. Tarvainen, P.O. Ranta-aho, and P.A. Karjalainen. An advanced detrending method with application to HRV analysis. IEEE Trans Biomed Eng, 49(2):172–175, February 2002.</li><li>Task force of the European society of cardiology and the North American society of pacing and electrophysiology. Heart rate variability – standards of measurement, physiological interpretation, and clinical use. Circulation, 93(5):1043–1065, March 1996.</li></ol><h1 id="HRV-Analysis-Methods"><a href="#HRV-Analysis-Methods" class="headerlink" title="HRV Analysis Methods"></a>HRV Analysis Methods</h1><p><a href="https://www.kubios.com/hrv-analysis-methods/#Taskforce1996" target="_blank" rel="noopener">Task Force 1996</a></p><p><strong>Four categories</strong></p><ul><li>time-domain</li><li>frequency-domain</li><li>nonlinear</li><li>time-varying</li></ul><h2 id="Time-domain-HRV-analysis-methods"><a href="#Time-domain-HRV-analysis-methods" class="headerlink" title="Time-domain HRV analysis methods"></a>Time-domain HRV analysis methods</h2><h3 id="Energy-expenditure-and-training-load"><a href="#Energy-expenditure-and-training-load" class="headerlink" title="Energy expenditure and training load"></a>Energy expenditure and training load</h3><p>Heart rate based energy expenditure models, provide a reliable estimates of daily energy expenditure.</p><p>In Kubios HRV software the energy expenditure is divided into: </p><ol><li><strong>basal metabolic rate (BMR)</strong> computed using the Mifflin-St Jeor equation<a href="https://www.kubios.com/hrv-analysis-methods/#Mifflin1990" target="_blank" rel="noopener">Mifflin et al. 1990</a> </li><li><strong>activity related energy expenditure (EE)</strong> computed using the Keytel’s formula<a href="https://www.kubios.com/hrv-analysis-methods/#Keytel2005" target="_blank" rel="noopener">Keytel et al. 2005</a>. </li></ol><p><strong>The energy expenditure</strong> computations are based on <strong>heart rate</strong>, <strong>body weight</strong>, <strong>height</strong> and <strong>age</strong>. </p><p>In Kubios HRV, we compute the EE using <strong>beat-to-beat HR values</strong>, and thus, <strong>the instantaneous EE (kcal/min) can be realiably derived</strong>. The instantaneous values of EE can be used to assess how energy expenditure is distributed throughout the day.</p><p>Training impulse (TRIMP) is a rather commonly used index for training volume. The TRIMP can be computed according to <strong>exponential Banister’s model</strong> <a href="https://www.kubios.com/hrv-analysis-methods/#Morton1990" target="_blank" rel="noopener">Morton et al. 1990</a>, which is defined for male and female subjects separately as</p><script type="math/tex; mode=display">TRIMP=T\times \Delta{HR}\times 0.64e^{1.92\times \Delta HR} \tag{Male}</script><script type="math/tex; mode=display">TRIMP=T\times \Delta{HR}\times 0.86e^{1.67\times \Delta HR} \tag{Feale}</script><p>where $T$ is duration of exercise and $\Delta HR=\frac{HR_{ex}-HR_{rest}}{HR_{max}-HR_{rest}}$ is a <strong>heart rate reserve ratio</strong>. </p><p>TRIMP accumulation <strong>rate increases exponentially</strong> as a function of exercise intensity, modelling lactate accumulation during exercise.</p><p>In Kubios HRV, we compute the TRIMP using <strong>beat-to-beat HR values</strong>, and thus, <strong>instantaneous value of TRIMP (TRIMP/min)</strong> can be reliably derived. </p><p>TRIMP/min can be used as an index of training intensity. <strong>The cumulative sum of TRIMP/min</strong>, on the other hand, gives an index of training load accumulation. The link between TRIMP/min values and training intensity is shown below. The figure also shows for a 60-min training session the link between TRIMP value and training load.</p><center>      <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86/%E5%8C%BB%E5%AD%A6/Trimp-levels.png">      <br>      <div style="color:orange; border-bottom: 1px solid #d9d9d9;                  display: inline-block;                  color: #999;                  padding: 2px;">Figure 1: Training intensity levels corresponding to different Instantaneous TRIMP/min values (top panel) and training load levels corresponding to different cumulative TRIMP values over a 60-min training session (bottom panel).    </div></center><h3 id="Mean-RR-SDNN-RMSSD-and-pNN50"><a href="#Mean-RR-SDNN-RMSSD-and-pNN50" class="headerlink" title="Mean RR, SDNN, RMSSD and pNN50"></a>Mean RR, SDNN, RMSSD and pNN50</h3><p><strong>The time-domain methods</strong> are derived from the beat-to-beat RR interval values in time domain. </p><p>Let the RR interval time series include $N$ successive beat intervals, i.e. $RR=(RR_1,RR_2,…,RR_N)$. The mean RR interval ($\overline{RR}$) and the mean heart rate ($\overline{HR}$) are then defined as</p><script type="math/tex; mode=display">\overline{RR} = \frac{1}{N}\sum^{N}_{n=1}RR_n, \qquad \overline{HR}=\frac{60}{\overline{RR}}    \tag{9}</script><p>where $RR_n$ denotes the value of $n$th RR interval. </p><p>Several <strong>heart rate variability parameters</strong> that measure the variability within the RR time intervals in time-domain exist. <strong>The standard deviation of RR intervals (SDNN)</strong> is defined as</p><script type="math/tex; mode=display">SDNN=\sqrt{\frac{1}{N-1}\sum^{N}_{n=1}(RR_n-\overline{RR})^2}    \tag{10}</script><p><strong>SDNN</strong> reflects <strong>the overall (both short-term and long-term) variation</strong> within the RR interval time series, whereas <strong>the standard deviation of successive RR interval differences(SDSD)</strong> given by</p><script type="math/tex; mode=display">SDSD=\sqrt{E\{\Delta RR_n^2\}-E\{\Delta RR_n\}^2}    \tag{11}</script><p>is a measure of short-term (beat-by-beat) variability. For stationary RR series $E\{\Delta RR_n\}=E\{RR_{n+1}\}-E\{RR_n\}=0$ and <strong>SDSD equals the root mean square of successive differences (RMSSD)</strong> given by</p><script type="math/tex; mode=display">RMSSD=\sqrt{\frac{1}{N-1}\sum^{N-1}_{n=1}(RR_{n+1}-RR_n)^2}    \tag{12}</script><p>Another measure calculated from <strong>successive RR interval differences</strong> is <strong>the NN50</strong> which is the number of successive intervals differing <strong>more than 50 ms or the corresponding relative amount</strong></p><script type="math/tex; mode=display">pNN50=\frac{NN50}{N-1}\times 100%        \tag{13}</script><h3 id="Geometric-measures"><a href="#Geometric-measures" class="headerlink" title="Geometric measures"></a>Geometric measures</h3><p>In addition to the above statistical measures, there are <strong>some geometric measures that are calculated from the RR interval histogram</strong>. The HRV triangular index is obtained as the integral of the histogram (i.e. <strong>total number of RR intervals</strong>) divided by the height of the histogram which depends on the selected bin width. </p><ul><li>In order to obtain comparable results, <strong>a bin width of 1/128 seconds</strong> is recommended <a href="https://www.kubios.com/hrv-analysis-methods/#Taskforce1996" target="_blank" rel="noopener">Task Force 1996</a>. </li><li>Another geometric measure is the TINN which is <strong>the baseline width of the RR histogram evaluated through triangular interpolation</strong>, see Fig. 2A.</li></ul><p>The Baevsky’s stress index (SI) is computed according to the formula <a href="https://www.kubios.com/hrv-analysis-methods/#Baevsky2009" target="_blank" rel="noopener">Baevsky 2009</a></p><center>      <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86/%E5%8C%BB%E5%AD%A6/GeometricMeasures-small.png">      <br>      <div style="color:orange; border-bottom: 1px solid #d9d9d9;                  display: inline-block;                  color: #999;                  padding: 2px;">Figure 2: Computation of geometric measures of HRV: A) triangular index (HRVi) and triangular interpolation of RR intervals (TINN), and B) Baevsky’s stress index.    </div></center><h3 id="HR-deceleration-and-acceleration-capacity"><a href="#HR-deceleration-and-acceleration-capacity" class="headerlink" title="HR deceleration and acceleration capacity"></a>HR deceleration and acceleration capacity</h3><p>Deceleration capacity (DC) of heart rate is a measure of cardiac parasympathetic modulation as it captures the lengthening of RR interval within 2-4 successive beats as explained below. Acceleration capacity (AC) of heart rate captures the opposite, i.e. shortening of RR interval within few successive beats. These parameters were originally proposed in <a href="https://www.kubios.com/hrv-analysis-methods/#Bauer2006" target="_blank" rel="noopener">Bauer et al. 2006</a> and refined in <a href="https://www.kubios.com/hrv-analysis-methods/#Nasario-Junior2014" target="_blank" rel="noopener">Nasario-Junior et al. 2014</a>.</p><p>Computation of DC (AC) is performed as follows. First, one RR interval value from every deceleration (acceleration) phase of RR interval time series is identified as an anchor interval. The anchor intervals are those that show steepest change compared to previous RR interval value, i.e. strongest deceleration (acceleration) within every deceleration-acceleration phase (see Fig. 3).</p><center>      <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86/%E5%8C%BB%E5%AD%A6/DC_AC.png">      <br>      <div style="color:orange; border-bottom: 1px solid #d9d9d9;                  display: inline-block;                  color: #999;                  padding: 2px;">Figure 3: Illustration of heart rate deceleration capacity (DC) and acceleration capacity (AC) computations. The anchor RR intervals (●) and the surrounding RR intervals (○).    </div></center><p>Next, all deceleration (acceleration) phases found from the RR interval data are aligned at the anchor points and an ensemble average is computed, i.e. phase rectified signal averaging (PRSA) is applied. Fig. 2 shows the ensemble average (black lines) and the standard deviation intervals (light-blue and light-grey areas) for both deceleration and acceleration phases. DC and AC are calculated from the ensemble averaged deceleration and acceleration phases as follows</p><script type="math/tex; mode=display">DC = [RR(0)+RR(1)-RR(-1)-RR(-2)]/2 \\AC = [RR(0)+RR(1)-RR(-1)-RR(-2)]/2    \tag{14}</script><p>That is, DC and AC are computed as a four point difference from the deceleration and acceleration PRSA signals, respectively. To better capture the instantaneous deceleration and acceleration, a modified DC and AC parameters are also computed according to<a href="https://www.kubios.com/hrv-analysis-methods/#nasario-junior2014" target="_blank" rel="noopener">Nasario-Junior et al. 2014</a> as follows</p><script type="math/tex; mode=display">DC_{mod}=[RR(0)-RR(-1)]    \\AC_{mod}=[RR(0)-RR(-1)]    \tag{15}</script><p><strong>Summary of time-domain HRV parameters calculated by Kubios HRV software.</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">PARAMETER</th><th style="text-align:center">UNITS</th><th style="text-align:left">DESCRIPTION</th></tr></thead><tbody><tr><td style="text-align:center">$EE$</td><td style="text-align:center">[kcal/min]</td><td style="text-align:left">Energy expenditure (EE) divided into Basal Metabolic Rate (BMR) and activity related energy expenditure. BMR is estimated with Mifflin-St Jeor formula and energy expenditure (EE) using Keytel’s model<a href="https://www.kubios.com/hrv-analysis-methods/#Mifflin1990" target="_blank" rel="noopener">Mifflin et al. 1990</a>, <a href="https://www.kubios.com/hrv-analysis-methods/#Keytel2005" target="_blank" rel="noopener">Keytel et al. 2005</a></td></tr><tr><td style="text-align:center">$TRIMP$</td><td style="text-align:center">[1/min]</td><td style="text-align:left">Training impulse (TRIMP) is estimated using the exponential Banister’s model<a href="https://www.kubios.com/hrv-analysis-methods/#Morton1990" target="_blank" rel="noopener">Morton et al. 1990</a></td></tr><tr><td style="text-align:center">$\overline{RR}$</td><td style="text-align:center">[ms]</td><td style="text-align:left">The mean of RR intervals</td></tr><tr><td style="text-align:center">$STD$ $RR$（$SDNN$）</td><td style="text-align:center">[ms]</td><td style="text-align:left">Standard deviation of RR intervals</td></tr><tr><td style="text-align:center">$\overline{HR}$</td><td style="text-align:center">[beats/min]</td><td style="text-align:left">The mean heart rate</td></tr><tr><td style="text-align:center">$Min$ &amp; $Max$ $HR$</td><td style="text-align:center">[beats/min]</td><td style="text-align:left">Minimum and maximum HR computed using N beat moving average (default value: N=5)</td></tr><tr><td style="text-align:center">$RMSSD$</td><td style="text-align:center">[ms]</td><td style="text-align:left">Square root of the mean squared differences between successive RR intervals</td></tr><tr><td style="text-align:center">$NNxx$</td><td style="text-align:center">[beats]</td><td style="text-align:left">Number of successive RR interval pairs that differ more than xx ms (default value: xx=50)</td></tr><tr><td style="text-align:center">$pNNxx$</td><td style="text-align:center">[%]</td><td style="text-align:left">NNxx divided by the total number of RR intervals</td></tr><tr><td style="text-align:center">$HRV$ $triangular$ $index$</td><td style="text-align:center">-</td><td style="text-align:left">The integral of the RR interval histogram divided by the height of the histogram</td></tr><tr><td style="text-align:center">$TINN$</td><td style="text-align:center">[ms]</td><td style="text-align:left">Baseline width of the RR interval histogram<a href="https://www.kubios.com/hrv-analysis-methods/#Taskforce1996" target="_blank" rel="noopener">Task Force 1996</a></td></tr><tr><td style="text-align:center">$Stress$ $index$</td><td style="text-align:center">-</td><td style="text-align:left">Square root of Baevsky’s stress index<a href="https://www.kubios.com/hrv-analysis-methods/#Baevsky2009" target="_blank" rel="noopener">Baevsky 2009</a></td></tr><tr><td style="text-align:center">$DC, AC$</td><td style="text-align:center">[ms]</td><td style="text-align:left">Deceleration capacity (DC) and acceleration capacity (AC) of heart rate computed as a four-point difference<a href="https://www.kubios.com/hrv-analysis-methods/#Bauer2006" target="_blank" rel="noopener">Bauer et al. 2006</a>, <a href="https://www.kubios.com/hrv-analysis-methods/#Nasario-Junior2014" target="_blank" rel="noopener">Nasario-Junior et al. 2014</a></td></tr><tr><td style="text-align:center">$DC_{mod}$,$ AC_{mod}$</td><td style="text-align:center">[ms]</td><td style="text-align:left">Modified DC and AC computed as a two-point difference<a href="https://www.kubios.com/hrv-analysis-methods/#Bauer2006" target="_blank" rel="noopener">Bauer et al. 2006</a>, <a href="https://www.kubios.com/hrv-analysis-methods/#Nasario-Junior2014" target="_blank" rel="noopener">Nasario-Junior et al. 2014</a></td></tr><tr><td style="text-align:center">$SDANN$</td><td style="text-align:center">[ms]</td><td style="text-align:left">Standard deviation of the averages of RR intervals in 5-min segments<a href="https://www.kubios.com/hrv-analysis-methods/#Taskforce1996" target="_blank" rel="noopener">Task Force 1996</a></td></tr><tr><td style="text-align:center">$SDNNI$</td><td style="text-align:center">[ms]</td><td style="text-align:left">Mean of the standard deviations of RR intervals in 5-min segments<a href="https://www.kubios.com/hrv-analysis-methods/#Taskforce1996" target="_blank" rel="noopener">Task Force 1996</a></td></tr></tbody></table></div><h2 id="Frequency-domain-HRV-analysis-methods"><a href="#Frequency-domain-HRV-analysis-methods" class="headerlink" title="Frequency-domain HRV analysis methods"></a>Frequency-domain HRV analysis methods</h2><p>In the frequency-domain methods, a <strong>power spectrum density (PSD)</strong> estimate is calculated for the RR interval series. </p><p>The regular spectrum estimators implicitly assume <strong>equidistant sampling</strong> and, thus, the RR interval series is converted to equidistantly sampled series by <strong>interpolation methods</strong> prior to spectrum estimation.In Kubios HRV software, a <strong>cubic spline interpolation method</strong> is used. </p><p>In HRV analysis, the spectrum is generally estimated using either a <strong>Fast Fourier transformation (FFT)</strong> based methods or <strong>parametric autoregressive (AR) modeling</strong> based methods. For details on these methods see, e.g., <a href="https://www.kubios.com/hrv-analysis-methods/#Marple1987" target="_blank" rel="noopener">Marple 1987</a>. </p><p><strong>The advantage of FFT</strong> based methods is the simplicity of implementation, while <strong>the AR spectrum yields improved resolution especially for short samples</strong>. Another property of AR spectrum that has made it popular in HRV analysis is that it can <strong>be factorized into separate spectral components</strong>.</p><p>In Kubios HRV software, the HRV spectrum is calculated with <strong>FFT based Welch’s periodogram method</strong> and with <strong>the AR method</strong> (see Fig. 4). Spectrum factorization in AR method is optional. In the Welch’s periodogram method the HRV sample is divided into overlapping segments. <strong>The spectrum is then obtained by averaging the spectra of these segments, which decreases the variance of the FFT spectrum</strong>.</p><p>Kubios HRV software includes also the Lomb-Scargle periodogram <a href="https://www.kubios.com/hrv-analysis-methods/#VanDongen1999" target="_blank" rel="noopener">van Dongen et al. 1999</a>, which differs from the Welch’s periodogram in the sense that it does not assume equidistant sampling and is thus <strong>computed directly from the non-interpolated RR interval time series</strong>. The variance of the Lomb-Scargle periodogram is decreased by smoothing the periodogram using MA-filering (the window width of the MA-filter can be adjusted in software preferences).</p><center>      <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86/%E5%8C%BB%E5%AD%A6/HRVspectrum.png">      <br>      <div style="color:orange; border-bottom: 1px solid #d9d9d9;                  display: inline-block;                  color: #999;                  padding: 2px;">Figure 4: HRV spectrum estimates using FFT based Welch’s periodogram method (left) and autoregressive (AR) modelling based spectrum estimation method.    </div></center><p>The generalized frequency bands in case of short-term HRV recordings are the <strong>very low frequency (VLF, 0–0.04 Hz)</strong>, <strong>low frequency (LF, 0.04–0.15 Hz)</strong>, and <strong>high frequency (HF, 0.15–0.4 Hz)</strong>. </p><p>The frequency-domain measures extracted from a spectrum estimate for each frequency band include absolute and relative powers of <strong>VLF, LF and HF bands</strong>; LF and HF band powers in normalized units; the LF/HF power ratio; and peak frequencies for each band. </p><ul><li>In the case of FFT spectrum, absolute power values for each frequency band are obtained by simply integrating the spectrum over the band limits. </li><li>In the case of AR spectrum, on the other hand, <ul><li>if factorization is enabled distinct spectral components emerge for each frequency band with a proper selection of the model order and the absolute power values are obtained directly as the powers of these components. </li><li>If factorization is disabled the AR spectrum powers are calculated as for the FFT spectrum. The band powers in relative and normalized units are obtained from the absolute values as described in <a href="https://www.kubios.com/hrv-analysis-methods/#Tab2" target="_blank" rel="noopener">Table 2</a>.</li></ul></li></ul><p><strong>Table 2:</strong> Summary of frequency-domain HRV parameters calculated by Kubios HRV software.</p><div class="table-container"><table><thead><tr><th style="text-align:center">PARAMETER</th><th style="text-align:center">UNITS</th><th style="text-align:center">DESCRIPTION</th></tr></thead><tbody><tr><td style="text-align:center">Peak frequency</td><td style="text-align:center">[Hz]</td><td style="text-align:center">VLF, LF, and HF band peak frequencies</td></tr><tr><td style="text-align:center">Absolute power</td><td style="text-align:center">[ms^2^]</td><td style="text-align:center">Absolute powers of VLF, LF, and HF bands</td></tr><tr><td style="text-align:center">Absolute power</td><td style="text-align:center">[log]</td><td style="text-align:center">Natural logarithm transformed values of absolute powers of VLF, LF, and HF bands</td></tr><tr><td style="text-align:center">Relative power</td><td style="text-align:center">[%]</td><td style="text-align:center">Relative powers of VLF, LF, and HF bands:<br>VLF [%] = VLF [ms^2^] / total power [ms^2^] x 100%<br>LF [%] = LF [ms^2^] / total power [ms^2^] x 100%<br>HF [%] = HF [ms^2^] / total power [ms^2^] x 100%</td></tr><tr><td style="text-align:center">Normalized power</td><td style="text-align:center">[n.u.]</td><td style="text-align:center">Powers of LF and HF bands in normalised units:<br>LF [n.u.] = LF [ms^2^] / (total power [ms^2^] – VLF [ms^2^]) x 100%<br>HF [n.u.] = HF [ms^2^] / (total power [ms^2^] – VLF [ms^2^]) x 100%</td></tr><tr><td style="text-align:center">LF/HF</td><td style="text-align:center">-</td><td style="text-align:center">Ratio between LF and HF band powers</td></tr><tr><td style="text-align:center">EDR</td><td style="text-align:center">[Hz]</td><td style="text-align:center">ECG derived respiration (available only if ECG data is used for HRV analysis)</td></tr></tbody></table></div><h2 id="Nonlinear-HRV-analysis-methods"><a href="#Nonlinear-HRV-analysis-methods" class="headerlink" title="Nonlinear HRV analysis methods"></a>Nonlinear HRV analysis methods</h2><p>Considering the complex control systems of the heart it is reasonable to assume that <strong>nonlinear mechanisms</strong> are involved in heart rate regulation. </p><p>The nonlinear properties of HRV have been analysed using measures such as:</p><ul><li><strong>Poincaré plot</strong> , <a href="https://www.kubios.com/hrv-analysis-methods/#Carrasco2001" target="_blank" rel="noopener">Carrasco et al. 2001</a></li><li><strong>approximate and sample entropy</strong> , <a href="https://www.kubios.com/hrv-analysis-methods/#Fusheng2001" target="_blank" rel="noopener">Fusheng et al. 2001</a></li><li><strong>detrended fluctuation analysis</strong> , <a href="https://www.kubios.com/hrv-analysis-methods/#Penzel2003" target="_blank" rel="noopener">Penzel et al. 2003</a></li><li><strong>correlation dimension</strong> , <a href="https://www.kubios.com/hrv-analysis-methods/#Henry2001" target="_blank" rel="noopener">Henry et al. 2001</a></li><li><strong>recurrence plots</strong> <a href="https://www.kubios.com/hrv-analysis-methods/#Webber1994" target="_blank" rel="noopener">Webber et al. 1994</a>, <a href="https://www.kubios.com/hrv-analysis-methods/#Trulla1996" target="_blank" rel="noopener">Trulla et al. 1996</a>, <a href="https://www.kubios.com/hrv-analysis-methods/#Zbilut2002" target="_blank" rel="noopener">Zbilut et al. 2002</a>. </li></ul><p>During the last years, the number of studies utilizing such methods have increased substantially. The downside of these methods is still, however, the difficulty of physiological interpretation of the results.</p><h3 id="Poincare-plot"><a href="#Poincare-plot" class="headerlink" title="Poincaré plot"></a>Poincaré plot</h3><p>One commonly used nonlinear method that is simple to interpret is the so-called <strong>Poincaré plot</strong>. It is a graphical representation of the correlation between successive RR intervals, i.e. plot of $RR_{n+1}$ as a function of $RR_n$. The shape of the plot is essential and a common approach to <strong>parameterize the shape</strong> is to fit an ellipse to the plot as shown in the figure below.</p><center>      <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86/%E5%8C%BB%E5%AD%A6/PoincarePlot.png">      <br>      <div style="color:orange; border-bottom: 1px solid #d9d9d9;                  display: inline-block;                  color: #999;                  padding: 2px;">Figure 5: Poincaré plot analysis with the ellipse fitting procedure. SD1 and SD2 are the standard deviations perpendicular to and along the the line-of-identity RR_n=RR_{n+1}, respectively.    </div></center><p>The ellipse is oriented according to the line-of-identity ($RR_n=RR_{n+1}$). <strong>The standard deviation of the points perpendicular to the line-of-identity</strong> denoted by SD1 describes short-term variability which is mainly caused by RSA. It can be shown that SD1 is related to the <strong>time-domain measure SDSD</strong> according to<a href="https://www.kubios.com/hrv-analysis-methods/#Brennan2001" target="_blank" rel="noopener">Brennan et al. 2001</a></p><script type="math/tex; mode=display">SD1^2=\frac{1}{2}SDSD^2    \tag{16}</script><p>where SDSD is defined as $SDSD=\sqrt{E[\Delta RR_n^2]-\overline{\Delta RR_n}^2}$, which is equal to RMSSD for <strong>stationary time series</strong>. </p><p>The standard deviation along the line-of-identity denoted by SD2, on the other hand, describes <strong>long-term variability</strong> and has been shown to be related to time-domain measures SDNN and SDSD by <a href="https://www.kubios.com/hrv-analysis-methods/#Brennan2001" target="_blank" rel="noopener">Brennan et al. 2001</a></p><script type="math/tex; mode=display">SD^2=2SDNN^2-\frac{1}{2}SDSD^2    \tag{17}</script><ul><li><strong>The standard Poincaré plot</strong> can be considered to be of the first order. </li><li><strong>The second order plot</strong> would be a three dimensional plot of values ($RR_n,RR_{n+1},RR_{n+2}$). In addition, the lag can be bigger than 1, e.g., the plot ($RR_n,RR_{n+2}$).</li></ul><h3 id="Approximate-entropy"><a href="#Approximate-entropy" class="headerlink" title="Approximate entropy"></a>Approximate entropy</h3><p><strong>Approximate entropy (ApEn)</strong> measures the complexity or irregularity of the signal <a href="https://www.kubios.com/hrv-analysis-methods/#Richman2000" target="_blank" rel="noopener">Richman &amp; Moorman 2000</a>, <a href="https://www.kubios.com/hrv-analysis-methods/#Fusheng2001" target="_blank" rel="noopener">Fusheng et al. 2001</a>. </p><p>Large values of ApEn indicate <strong>high irregularity</strong> and <strong>smaller values of ApEn more regular signal</strong>. The ApEn is computed as follows.</p><ol><li>First, a set of length $m$ vectors  $u_j$ is formed</li></ol><script type="math/tex; mode=display">u_j=(RR_j,RR_{j+1},...,RR_{j+m-1}), j=1,2,...,N-m+1    \tag{18}</script><p>where $m$ is called <strong>the embedding dimension</strong> and $N$ is <strong>the number of measured RR intervals</strong>. </p><p>The distance between these vectors is defined as <strong>the maximum absolute difference between the corresponding elements</strong>, i.e.</p><script type="math/tex; mode=display">d(u_j,u_k)=\max\{|RR_{j+l}-RR_{k+l}|\},l=0,...,m-1  \tag{19}</script><ol><li>Next, for each $u_j$ the relative number of vectors $u_k$ for which $d(u_j,u_k)\le r$ is calculated. This index is denoted with $C^m_j(r)$ and can be written in the form</li></ol><script type="math/tex; mode=display">C^m_j(r)=\frac{nbr\quad of\quad \{u_k|d(u_j,u_k)\le r\}}{N-m+1}, \forall k \tag{20}</script><p>Due to the normalization, the value of $C^m_j(r)$ is always smaller or equal to 1. Note that the value is, however, at least $1/(N-m+1)$ since $u_j$ is also included in the count. Then, take the natural logarithm of each $C^m_j(r)$ and average over $j$ to yield</p><script type="math/tex; mode=display">\Phi^m(r)=\frac{1}{N-m+1}\sum^{N-m+1}_{j=1}\ln C_j^m(r)    \tag{21}</script><ol><li>Finally, the approximate entropy is obtained as</li></ol><script type="math/tex; mode=display">ApEn(m,r,N)=\Phi^m(r)-\Phi^{m+1}(r)    \tag{22}</script><p>Thus, the value of the estimate ApEn depends on three parameters:</p><ul><li>the length $m$ of the vectors $u_j$</li><li>the tolerance value $r$</li><li>the data length $N$</li></ul><p>In Kubios HRV software <strong>the default value of $m$ is set to be $m=2$</strong>. The length $N$ of the data also affects ApEn. <strong>When $N$ is increased the ApEn approaches its asymptotic value</strong>. The tolerance $r$ has a strong effect on ApEn and <strong>it should be selected as a fraction of the standard deviation</strong> of the RR interval data (SDNN). </p><p>This selection enables the comparison of RR data from different subjects. A common selection for $r$ is $r=0.2SDNN$, which is also the default value in Kubios HRV software.</p><h3 id="Sample-entropy"><a href="#Sample-entropy" class="headerlink" title="Sample entropy"></a>Sample entropy</h3><p>Sample entropy (SampEn) is similar to ApEn, but there are <strong>two important differences</strong> in its calculation <a href="https://www.kubios.com/hrv-analysis-methods/#Richman2000" target="_blank" rel="noopener">Richman &amp; Moorman 2000</a>, <a href="https://www.kubios.com/hrv-analysis-methods/#Lake2002" target="_blank" rel="noopener">Lake et al. 2002</a>. </p><p>For ApEn, in the calculation of the number of vectors $u_k$ for which $d(u_j,u_k)\le r$ also the vector $u_j$ itself is included. </p><p>This ensures that $C_j^m(r)$ is always larger than 0 and the logarithm can be applied, but at the same time <strong>it causes bias to ApEn</strong>. In sample entropy the self-comparison of $u_j$ is eliminated by calculating $C_j^m(r)$ as</p><script type="math/tex; mode=display">C^m_j(r)=\frac{nbr\quad of\quad \{u_k|d(u_j,u_k)\le r\}}{N-m}, \forall k \ne j \tag{23}</script><p>Now the value of $C^m_j(r)$ will be between $0$ and $1$. Next, the values of $C^m_j(r)$ are averaged to yield</p><script type="math/tex; mode=display">C^m(r)=\frac{1}{N-m+1}\sum^{N-m+1}_{j=1}C^m_j(r)    \tag{24}</script><p>and the sample entropy is obtained as</p><script type="math/tex; mode=display">SampEn(m,r,N)=\ln (C^m(r)/C^{m+1}(r))    \tag{25}</script><p>The default values set for the embedding dimension $m$ and for the tolerance parameter $r$ in Kubios HRV software are the same as those for the ApEn computation. </p><p>Both ApEn and SampEn are estimates for the negative natural logarithm of the conditional probability that a data of length $N$, having repeated itself within a tolerance $r$ for $m$ points, will also repeat itself for $m+1$ points. SampEn was designed to reduce the bias of ApEn and has a closer agreement with the theory for data with known probabilistic content <a href="https://www.kubios.com/hrv-analysis-methods/#Lake2002" target="_blank" rel="noopener">Lake et al. 2002</a>.</p><h3 id="Multiscale-entropy-MSE"><a href="#Multiscale-entropy-MSE" class="headerlink" title="Multiscale entropy (MSE)"></a>Multiscale entropy (MSE)</h3><p><strong>Multiscale entropy (MSE)</strong> is an extension of SampEn in the sense that it incorporates two procedures <a href="https://www.kubios.com/hrv-analysis-methods/#Costa2005" target="_blank" rel="noopener">Costa et al. 2005</a></p><ol><li>A coarse-graining process is applied to the RR interval time series. Multiple coarse-grained time series are constructed for the time series by averaging the data points within non-overlapping windows of increasing length $\tau$, where $\tau$ represents the scale factor and is selected to range between $\tau=1,2,…,20$. The length of each coarse-grained time series is $N/\tau$, where $N$ is the number of RR intervals in the data. For scale $\tau=1$, the coarse-grained time series is simply the original beat-to-beat RR interval time series.</li><li>SampEn is calculated for each coarse-grained time series. SampEn as a function of the scale factor produces the MSE. MSE for scale factor $\tau=1$ returns standard SampEn (computed from the original data points).</li></ol><h3 id="Detrended-fluctuation-analysis"><a href="#Detrended-fluctuation-analysis" class="headerlink" title="Detrended fluctuation analysis"></a>Detrended fluctuation analysis</h3><p><strong>Detrended fluctuation analysis (DFA)</strong> measures the correlation within the signal. The correlation is extracted for different time scales as follows <a href="https://www.kubios.com/hrv-analysis-methods/#Peng1995" target="_blank" rel="noopener">Peng et al. 1995</a>. </p><p>First, the RR interval time series is integrated</p><script type="math/tex; mode=display">y(k)=\sum^k_{j=1}(RR_j-\overline{RR}),k=1,...,N    \tag{26}</script><p>where $\overline{RR}$ is the average RR interval. </p><p>Next, the integrated series is divided into segments of equal length $n$. Within each segment, a least squares line is fitted into the data. Let $y_n(k)$ denote these regression lines. </p><p>Next the integrated series $y(k)$ is detrended by subtracting the local trend within each segment and the root-mean-square fluctuation of this integrated and detrended time series is calculated by</p><script type="math/tex; mode=display">F(n)=\sqrt{\frac{1}{N}\sum^N_{k=1}(y(k)-y_n(k))^2}    \tag{27}</script><p>This computation is repeated over different segment lengths to yield the index $F(n)$ as a function of segment length $n$. Typically $F(n)$ increases with segment length. </p><p>A linear relationship on a double log graph indicates presence of fractal scaling and the fluctuations can be characterized by scaling exponent $\alpha$ (the slope of the regression line relating $\log F(n)$ to $\log n$. Different values of $\alpha$ indicate the following</p><ul><li>$\alpha = 1.5$: Brown noise (integral of white noise)</li><li>$1 &lt; \alpha &lt; 1.5$: Different kinds of noise</li><li>$\alpha = 1$: $1/f$ noise</li><li>$0.5 &lt; \alpha &lt; 1$: Large values are likely to be followed by large value and vice versa</li><li>$\alpha = 0.5$: White noise</li><li>$0 &lt; \alpha &lt; 0.5$: Large value is likely to be followed by small value and vice versa  s</li></ul><p>Typically, in DFA the correlations are divided into <strong>short-term and long-term fluctuations</strong>. </p><p>In Kubios HRV software, the short-term fluctuations are characterized by the slope $\alpha_1$ obtained from the ($ \log n$, $\log F(n)$) graph within range $4\le n \le 12$ (default values). Correspondingly, the slope $\alpha_2$ obtained by default from the range $13\le n \le 64$ characterizes long-term fluctuations, see Fig. 6.</p><center>      <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86/%E5%8C%BB%E5%AD%A6/DFAplot.png">      <br>      <div style="color:orange; border-bottom: 1px solid #d9d9d9;                  display: inline-block;                  color: #999;                  padding: 2px;">Figure 6: Detrended fluctuation analysis. A double log plot of the index F(n) as a function of segment length n. \alpha_1 and \alpha_2 are the short term and long term fluctuation slopes, respectively.    </div></center><h3 id="Correlation-dimension"><a href="#Correlation-dimension" class="headerlink" title="Correlation dimension"></a>Correlation dimension</h3><p>Another method for measuring the complexity or strangeness of the time series is <strong>the correlation dimension</strong> which was proposed in <a href="https://www.kubios.com/hrv-analysis-methods/#Grassberger1983" target="_blank" rel="noopener">Grassberger et al. 1983</a>. </p><p>The correlation dimension is expected to give information on the minimum number of dynamic variables needed to model the underlying system and it can be obtained as follows.</p><p>Similarly as in the calculation of approximate and sample entropies, form length $m$ vectors $u_j$</p><script type="math/tex; mode=display">u_j=(RR_j,RR_{j+1},...,RR_{j+m-1}),j=1,2,...,N-m+1    \tag{28}</script><p>and calculate the number of vectors $u_k$ for which $d(u_j,u_k)\le r$, that is</p><script type="math/tex; mode=display">C^m_j(r)=\frac{nbr\quad of \quad {u_k|d(u_j,u_k)\le r}}{N-m+1} \qquad \forall k    \tag{29}</script><p>where the distance function $d(u_j,u_k)$ is now defined as</p><script type="math/tex; mode=display">d(u_j,u_k)=\sqrt{\sum^m_{l=1}(u_j(l)-u_k(l))^2)}    \tag{30}</script><p>Next, an average of the term $C^m_j(r)$ is taken</p><script type="math/tex; mode=display">C^m(r)=\frac{1}{N-m+1}\sum^{N-m+1}_{j=1}C^m_j(r)    \tag{31}</script><p>which is the so-called correlation integral. The correlation dimension $D_2$ is defined as the limit value</p><script type="math/tex; mode=display">D_2(m)= \lim \limits_{r\rightarrow 0} \lim \limits_{N\rightarrow \infty}\frac{\log C^m(r)}{\log r}    \tag{32}</script><p>In practice this limit value is approximated by the slope of the regression curve $(\log r,\log C^m(r))$ <a href="https://www.kubios.com/hrv-analysis-methods/#Henry2001" target="_blank" rel="noopener">Henry et al. 2001</a>. </p><p>The slope is calculated from the linear part of <strong>the log-log plot</strong> (see Fig. 7). The slope of the regression curves tend to saturate on the finite value of $D_2$ when $m$ is increased. In the software, a default value of $m=10$ was selected for the embedding.</p><center>      <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86/%E5%8C%BB%E5%AD%A6/CorrelationDimension.png">      <br>      <div style="color:orange; border-bottom: 1px solid #d9d9d9;                  display: inline-block;                  color: #999;                  padding: 2px;">Figure 7: Approximation of the correlation dimension D_2 from the (\log r, \log C^m(r)) plot    </div></center><h3 id="Recurrence-plot-analysis"><a href="#Recurrence-plot-analysis" class="headerlink" title="Recurrence plot analysis"></a>Recurrence plot analysis</h3><p>Yet another approach, included in the software, for analyzing the complexity of the time series is the so-called recurrence plot (RP) analysis. In this approach, vectors</p><script type="math/tex; mode=display">u_j=(RR_j,RR_{j+\tau},...,RR_{j+(m-1)\tau}),j=1,2,...,N-(m-1)\tau    \tag{33}</script><p>where $m$ is the embedding dimension and $\tau$ the embedding lag. The vectors $u_j$ then represent the $RR$ interval time series as a trajectory in $m$ dimensional space. </p><p>A recurrence plot is a symmetrical $[N-(m-1)\tau]\times[N-(m-1)\tau]$ matrix of zeros and ones. The element in the $j$‘th row and $k$‘th column of the $RP$ matrix, i.e. , $RP(j,k)$ is 1 if the point $u_j$ on the trajectory is close to point $u_k$. That is</p><script type="math/tex; mode=display">RP(j,k)=\left \{    \begin{array}{**lr**}    1, d(u_j-u_k) \le r  \\    0, otherwise    \end{array}\right.\tag{34}</script><p>where $d(u_j,u_k)$ is the Euclidean distance (see above) and $r$ is a fixed threshold. </p><p>The structure of the RP matrix usually shows short line segments of ones parallel to the main diagonal. The lengths of these diagonal lines describe the duration of which the two points are close to each other. An example RP for heart rate variability time series is presented in figure below.</p><center>      <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86/%E5%8C%BB%E5%AD%A6/RPimage.png">      <br>      <div style="color:orange; border-bottom: 1px solid #d9d9d9;                  display: inline-block;                  color: #999;                  padding: 2px;">Figure 8: Recurrence plot matrix for HRV time series (black = 1 and white = 0).    </div></center><p>In Kubios HRV software, the embedding dimension and lag were selected to be $m=10$ (default value) and $\tau=1$ (fixed), respectively. The threshold distance $r$ was selected to be $\sqrt{m}SD$ (default value), where SD is the standard deviation of the RR time series. </p><p>These selection are similar to those made in<a href="https://www.kubios.com/hrv-analysis-methods/#Dabire1998" target="_blank" rel="noopener">Dabire et al 1998</a>. Methods for quantifying recurrence plots were proposed in <a href="https://www.kubios.com/hrv-analysis-methods/#Webber1994" target="_blank" rel="noopener">Webber et al. 1994</a>. The methods included in Kubios HRV software are introduced below.</p><p>The first quantitative measure of RP is the recurrence rate (REC) which is simply the ratio of ones and zeros in the RP matrix. The number of elements in the RP matrix for $\tau=1$ is equal to $N-m+1$ and the recurrence rate is simply given as</p><script type="math/tex; mode=display">RCE=\frac{1}{(N-m+1)^2}\sum^{N-m+1}_{j,k=1}RP(j,k)    \tag{35}</script><p>The recurrence rate can also be calculated separately for each diagonal parallel to the line-of-identity (main diagonal). The trend of REC as a function of the time distance between these diagonals and the line-of-identity describes the fading of the recurrences for points further away.</p><p>The rest of the RP measures consider the lengths of the diagonal lines. A threshold $l_{min}=2$ is used for excluding the diagonal lines formed by tangential motion of the trajectory. The maximum line length is denoted $l_{max}$ and its inverse, the divergence,</p><script type="math/tex; mode=display">DIV=\frac{1}{l_{max}}    \tag{36}</script><p>has been shown to correlate with the largest positive Lyapunov exponent<a href="https://www.kubios.com/hrv-analysis-methods/#Trulla1996" target="_blank" rel="noopener">Trulla et al. 1996</a>. The average diagonal line length, on the other hand, is obtained as</p><script type="math/tex; mode=display">l_{mean}=\frac{\sum^{l_{max}}_{l=l_{min}}lN_l}{\sum^{l_{max}}_{l=l_{min}}N_l}    \tag{37}</script><p>where $N_l$ is the number of length $l$ lines. The determinism of the time series is measured by the variable</p><script type="math/tex; mode=display">DET=\frac{\sum^{l_{max}}_{l=l_{min}}lN_l}{\sum^{N-m+1}_{j,k=1}RP(j,k)}    \tag{38}</script><p>Finally, the Shannon information entropy of the line length distribution is defined as</p><script type="math/tex; mode=display">ShanEn=-\sum^{l_{max}}_{l=l_{min}}n_l\ln n_l    \tag{39}</script><p>where $n_l$ is the number of length $l$ lines divided by the total number of lines, that is</p><script type="math/tex; mode=display">n_l=\frac{N_l}{\sum^{l_{max}}_{l'=l_{min}}N_{l'}}    \tag{40}</script><p><strong>Table 3:</strong> Summary of nonlinear HRV parameters calculated by Kubios HRV software.</p><div class="table-container"><table><thead><tr><th style="text-align:center">PARAMETER</th><th style="text-align:center">UNITS</th><th style="text-align:center">DESCRIPTION</th></tr></thead><tbody><tr><td style="text-align:center">SD1</td><td style="text-align:center">[ms]</td><td style="text-align:center">In Poincaré plot, the standard deviation perpendicular to the line-of-identity <a href="https://www.kubios.com/hrv-analysis-methods/#Brennan2001" target="_blank" rel="noopener">Brennan et al. 2001</a>, <a href="https://www.kubios.com/hrv-analysis-methods/#Carrasco2001" target="_blank" rel="noopener">Carrasco et al. 2001</a></td></tr><tr><td style="text-align:center">SD2</td><td style="text-align:center">[ms]</td><td style="text-align:center">In Poincaré plot, the standard deviation along the line-of-identity</td></tr><tr><td style="text-align:center">SD1/SD2</td><td style="text-align:center">-</td><td style="text-align:center">Ratio between SD2 and SD1</td></tr><tr><td style="text-align:center">ApEn</td><td style="text-align:center">-</td><td style="text-align:center">Approximate entropy<a href="https://www.kubios.com/hrv-analysis-methods/#Richman2000" target="_blank" rel="noopener">Richman &amp; Moorman 2000</a>, <a href="https://www.kubios.com/hrv-analysis-methods/#Fusheng2001" target="_blank" rel="noopener">Fusheng et al. 2001</a></td></tr><tr><td style="text-align:center">SampEn</td><td style="text-align:center">-</td><td style="text-align:center">Sample entropy<a href="https://www.kubios.com/hrv-analysis-methods/#Richman2000" target="_blank" rel="noopener">Richman &amp; Moorman 2000</a></td></tr><tr><td style="text-align:center">DFA，$\alpha_1$</td><td style="text-align:center">-</td><td style="text-align:center">In detrended fluctuation analysis, short term fluctuation slope<a href="https://www.kubios.com/hrv-analysis-methods/#Peng1995" target="_blank" rel="noopener">Peng et al. 1995</a>, <a href="https://www.kubios.com/hrv-analysis-methods/#Penzel2003" target="_blank" rel="noopener">Penzel et al. 2003</a></td></tr><tr><td style="text-align:center">DFA，$\alpha_2$</td><td style="text-align:center">-</td><td style="text-align:center">In detrended fluctuation analysis, long term fluctuation slope</td></tr><tr><td style="text-align:center">$D_2$</td><td style="text-align:center">-</td><td style="text-align:center">Correlation dimension<a href="https://www.kubios.com/hrv-analysis-methods/#Guzzetti1996" target="_blank" rel="noopener">Guzzetti et al. 1996</a>, <a href="https://www.kubios.com/hrv-analysis-methods/#Henry2001" target="_blank" rel="noopener">Henry et al. 2001</a></td></tr><tr><td style="text-align:center">RPA</td><td style="text-align:center"></td><td style="text-align:center">Recurrence plot analysis<a href="https://www.kubios.com/hrv-analysis-methods/#Webber1994" target="_blank" rel="noopener">Webber et al. 1994</a>, <a href="https://www.kubios.com/hrv-analysis-methods/#Dabire1998" target="_blank" rel="noopener">Dabire et al. 1998</a>, <a href="https://www.kubios.com/hrv-analysis-methods/#Zbilut2002" target="_blank" rel="noopener">Zbilut et al. 2002</a></td></tr><tr><td style="text-align:center">Lmean</td><td style="text-align:center">[beats]</td><td style="text-align:center">Mean line length</td></tr><tr><td style="text-align:center">Lmax</td><td style="text-align:center">[beats]</td><td style="text-align:center">Maximum line length</td></tr><tr><td style="text-align:center">REC</td><td style="text-align:center">[%]</td><td style="text-align:center">Recurrence rate</td></tr><tr><td style="text-align:center">DET</td><td style="text-align:center">[%]</td><td style="text-align:center">Determinism</td></tr><tr><td style="text-align:center">ShanEn</td><td style="text-align:center">-</td><td style="text-align:center">Shannon entropy</td></tr><tr><td style="text-align:center">MSE</td><td style="text-align:center">-</td><td style="text-align:center">Multiscale entropy for scale factor values τ=1,2,…,20 <a href="https://www.kubios.com/hrv-analysis-methods/#Costa2005" target="_blank" rel="noopener">Costa et al. 2005</a></td></tr></tbody></table></div><h2 id="References-1"><a href="#References-1" class="headerlink" title="References"></a>References</h2><ol><li>R. M. Baevsky. Methodical recommendations use kardivar system for determination of the stress level and estimation of the body adaptability standards of measurements and physiological interpretation. 2009.</li><li>A. Bauer, J.W. Kantelhardt, P. Barthel, R. Schneider, T. Mäkikallio, K. Ulm, K. Hnatkova, A. Schöming, H. Huikuri, A. Bundle, M. Malik, and G. Schmidt. Deceleration capacity of heart rate as a predictor of mortality after myocardial infarction: cohort study. Lancet, 367:1647–81, 2006.</li><li>M. Brennan, M. Palaniswami, and P. Kamen. Do existing measures of Poincaré plot geometry reflect nonlinear features of heart rate variability. IEEE Trans Biomed Eng, 48(11):1342–1347, 2001.</li><li>S. Carrasco, M.J. Caitán, R. González, and O. Yánez. Correlation among Poincaré plot indexes and time and frequency domain measures of heart rate variability. J Med Eng Technol, 25(6):240–248, November/December 2001.</li><li>M. Costa, A.L. Goldberger, and C.-K. Peng. Multiscale entropy analysis of biological signals. Physical Rev E, 71:021906, 2005.</li><li>H. Dabire, D. Mestivier, J. Jarnet, M.E. Safar, and N. Phong Chau. Quantification of sympathetic and parasympathetic tones by nonlinear indexes in normotensive rats. amj, 44:H1290–H1297, 1998.</li><li>Y. Fusheng, H. Bo, and T. Qingyu. Approximate entropy and its application in biosignal analysis. In M. Akay, editor, Nonlinear Biomedical Signal Processing: Dynamic Analysis and Modeling, volume II, chapter 3, pages 72–91. IEEE Press, New York, 2001.</li><li>P. Grassberger and I. Procaccia. Characterization of strange attractors. Phys Rev Lett, 50:346–349, 1983.</li><li>S. Guzzetti, M.G. Signorini, C. Cogliati, S. Mezzetti, A. Porta, S. Cerutti, and A. Malliani. Non-linear dynamics and chaotic indices in heart rate variability of normal subjects and heart-transplanted patients. Cardiovascular Research, 31:441–446, 1996.</li><li>B. Henry, N. Lovell, and F. Camacho. Nonlinear dynamics time series analysis. In M. Akay, editor, Nonlinear Biomedical Signal Processing: Dynamic Analysis and Modeling, volume II, chapter 1, pages 1–39. IEEE Press, New York, 2001.</li><li>L.R. Keytel, J.H. Goedecke, T.D. Noakes, H. Hiilloskorpi, R. Laukkanen, L. Van Der Merwe, and E.V. Lambert. Prediction of energy expenditure from heart rate monitoring during submaximal exercise. J Sports Sci, 23(3):289–297, 2005.</li><li>D.E. Lake, J.S. Richman, M.P. Griffin, and J.R. Moorman. Sample entropy analysis of neonatal heart rate variability. ajp, 283:R789–R797, September 2002.</li><li>S.L. Marple. Digital Spectral Analysis. Prentice-Hall International, 1987.</li><li>M.D. Mifflin, S.T. St Jeor, L.A. Hill, B.J. Scott, S.A. Daugherty, and Y.O. Koh. A new predictive equation for resting energy expenditure in healthy individuals. Am J Clin Nutr, 51:241-7, 1990.</li><li>R.H. Morton, J.R. Fitz-Clarke and E.W. Banister. Modeling human performance in running. J Appl Physiol, 69(3):1171-7, 1990.</li><li>O. Nasario-Junior, P.R. Benchimol-Barbosa, and J. Nadal. Refining the deceleration capacity index in phase-rectified signal averaging to assess physical conditioning level. J Electrocardiol, 47(3):306–310, 2014.</li><li>C.-K. Peng, S. Havlin, H.E. Stanley, and A.L. Goldberger. Quantification of scaling exponents and crossover phenomena in nonstationary heartbeat time series. Chaos, 5:82–87, 1995.</li><li>T. Penzel, J.W. Kantelhardt, L. Grote, J.-H. Peter, and A. Bunde. Comparison of detrended fluctuation analysis and spectral analysis for heart rate variability in sleep and sleep apnea. IEEE Trans Biomed Eng, 50(10):1143–1151, October 2003.</li><li>J.A. Richman and J.R. Moorman. Physiological time-series analysis using approximate entropy and sample entropy. Am J Physiol, 278:H2039–H2049, 2000.</li><li>M.P. Tarvainen, P.O. Ranta-aho, and P.A. Karjalainen. An advanced detrending method with application to HRV analysis. IEEE Trans Biomed Eng, 49(2):172–175, February 2002.</li><li>Task force of the European society of cardiology and the North American society of pacing and electrophysiology. Heart rate variability – standards of measurement, physiological interpretation, and clinical use. Circulation, 93(5):1043–1065, March 1996.</li><li>L.L. Trulla, A. Giuliani, J.P. Zbilut, and C.L. Webber Jr. Recurrence quantification analysis of the logistic equation with transients. Phys Lett A, 223(4):255–260, 1996.</li><li>H.P.A. Van Dongen, E. Olofsen, J.H. VanHartevelt, and E.W. Kruyt. Searching for biological rhythms: peak detection in the periodogram of unequally spaced data. J Bioloogical Rhythms, 14(6):617–620, 1999.</li><li>C.L. Webber Jr. and J.P. Zbilut. Dynamical assessment of physiological systems and states using recurrence plot strategies. J Appl Physiol, 76:965–973, 1994.</li><li>J.P. Zbilut, N. Thomasson, and C.L. Webber. Recurrence quantification analysis as a tool for the nonlinear exploration of nonstationary cardiac signals. Med Eng Phys, 24:53–60, 2002.</li></ol><h1 id="HRV-IN-EVALUATING-ANS-FUNCTION"><a href="#HRV-IN-EVALUATING-ANS-FUNCTION" class="headerlink" title="HRV IN EVALUATING ANS FUNCTION"></a>HRV IN EVALUATING ANS FUNCTION</h1><p>Heart rate variability (HRV) reflects variations between consecutive inter-beat-intervals (RR intervals). Both sympathetic and parasympathetic branches of the autonomic nervous system (ANS) are involved in the regulation of heart rate (HR). Parasympathetic nervous system (PNS) activity (vagal stimulation) is known to decrease heart rate and increase heart rate variability. The sympathetic nervous system (SNS) activity has more or less the opposite effect on heart rate and heart rate variability, i.e. it increases HR and decreases HRV. Therefore, HR is lowest and HRV is highest when we are in rest and fully recovered. During stressful situations when sympathetic nervous activity is increased, resting heart rate is elevated and and heart rate variability is decreased.</p><h2 id="Parasympathetic-nervous-system-PNS-index"><a href="#Parasympathetic-nervous-system-PNS-index" class="headerlink" title="Parasympathetic nervous system (PNS) index"></a>Parasympathetic nervous system (PNS) index</h2><p>Parasympathetic cardiac activity is known to 1) decrease heart rate (i.e. increase the time interval between successive heart beats), 2) increase HRV via enhanced respiratory sinus arrhythmia (RSA) component (i.e. increasing the quick changes in RR interval linked to respiration – shortening of RR intervals during inhalation and lengthening of RR intervals during exhalation), and 3) decrease the ratio between lower frequency and higher frequency oscillations in HRV time series (i.e. increase the relative amount of quick RSA originated fluctuations in HRV compared to slower short-term fluctuations) <a href="https://www.kubios.com/hrv-ans-function/#Taskforce1996" target="_blank" rel="noopener">Task Force 1996</a>, <a href="https://www.kubios.com/hrv-ans-function/#Berntson1997" target="_blank" rel="noopener">Berntson et al. 1997</a>, <a href="https://www.kubios.com/hrv-ans-function/#Acharya2006" target="_blank" rel="noopener">Acharya et al. 2006</a>.</p><p>Based on the above, the parasympathetic nervous system index (PNS index) is computed in Kubios HRV software based on the following three parameters:</p><ol><li><strong>Mean RR</strong> interval. Longer mean RR interval means lower heart rate and higher parasympathetic cardiac activation.</li><li><strong>Root mean square of successive RR interval differences (RMSSD)</strong>, which is a commonly used time-domain HRV parameter that captures the quick beat-to-beat changes in RR interval, and therefore, strongly linked to RSA component magnitude. High values of RMSSD indicate strong RSA component and high parasympathetic cardiac activation.</li><li><strong>Poincaré plot index SD1 in normalized units</strong>. A commonly used approach for estimating the sympathovagal balance of the ANS is to compute the low frequency (LF) to high frequency (HF) power ration from HRV spectrum. However, in case of spontaneous breathing, especially when the natural breathing rate of the subject is low (below 0.15 Hz or 9 breaths/min), the RSA component is partially or even completely overlapping with the LF component. In such cases the LF/HF ratio gives invalid interpretation of ANS status. Since Poincare plot index SD1 is known to be linked to RMSSD <a href="https://www.kubios.com/hrv-ans-function/#Brennan2001" target="_blank" rel="noopener">Brennan et al. 2001</a> and the ratio SD2/SD1 correlates with LF/HF ratio, the normalized SD1 value is used in Kubios HRV as the third input parameter for the PNS index computation.</li></ol><p>Each parameter value is first compared to their normal population values as presented in <a href="https://www.kubios.com/hrv-ans-function/#Nunan2010" target="_blank" rel="noopener">Nunan et al. 2010</a>. The normal value for the SD1 is derived based on its dependency on the time-domain variable RMSSD as described in <a href="https://www.kubios.com/hrv-ans-function/#Brennan2001" target="_blank" rel="noopener">Brennan et al. 2001</a>. The parameter values are then scaled with the standard deviations of normal population and finally a proprietary weighting is applied to obtain robust and reliable PNS index value.</p><p>The interpretation of the PNS index is straightforward. A PNS index value of zero means that the three parameters reflecting parasympathetic activity are on average equal to the normal population average. Correspondingly, a positive PNS index value tells how many SDs above the normal population average the parameter values are, whereas a negative value tells how many SDs below the normal population average the parameter values are. Please note that the normal values presented in Nunan et al. 2010 are extracted from resting HRV measurements. Thus in rest, the PNS index is typically (with 95% of population) between -2 and +2, i.e. within ±2SD of the normal population distribution (see Fig. 1). During stress or during high intensity exercise much lower PNS index values can be expected.</p><center>      <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86/%E5%8C%BB%E5%AD%A6/PNSindex_mod.png">     <br>      <div style="color:orange; border-bottom: 1px solid #d9d9d9;                  display: inline-block;                  color: #999;                  padding: 2px;">Figure 1: Parasympathetic nervous system (PNS) index.    </div></center><h2 id="Sympathetic-nervous-system-SNS-index"><a href="#Sympathetic-nervous-system-SNS-index" class="headerlink" title="Sympathetic nervous system (SNS) index"></a>Sympathetic nervous system (SNS) index</h2><p>Sympathetic cardiac activity is known to 1) increase heart rate, 2) decrease HRV, reducing especially quick RSA related changes in RR interval, and 3) increase the ratio between lower frequency and higher frequency oscillations in HRV data<a href="https://www.kubios.com/hrv-ans-function/#Taskforce1996" target="_blank" rel="noopener">Task Force 1996</a>, <a href="https://www.kubios.com/hrv-ans-function/#Berntson1997" target="_blank" rel="noopener">Berntson et al. 1997</a>, <a href="https://www.kubios.com/hrv-ans-function/#Acharya2006" target="_blank" rel="noopener">Acharya et al. 2006</a>.</p><p>Based on the above, the sympathetic nervous system index (SNS index) is computed in Kubios HRV software based on the following three parameters:</p><ol><li><strong>Mean HR</strong> interval. Higher heart rate is linked to higher sympathetic cardiac activation.</li><li><strong>Baevsky’s stress index (SI)</strong>, which is a geometric measure of HRV reflecting cardiovascular system stress. High values of SI indicate reduced variability and high sympathetic cardiac activation.</li><li><strong>Poincaré plot index SD2 in normalized units</strong>. As mentioned above (in PNS index description) LF/HF power ratio is commonly used assessing sympathovagal balance of the ANS, which however is sensitive to breathing rate. Thus normalized Poincare plot index SD2, which is known to be linked to SDNN <a href="https://www.kubios.com/hrv-ans-function/#Brennan2001" target="_blank" rel="noopener">Brennan et al. 2001</a> and to correlate with LF/HF ratio, is used in Kubios HRV as the third input parameter for the SNS index computation.</li></ol><p>Each parameter value is first compared to their normal population values as presented in <a href="https://www.kubios.com/hrv-ans-function/#Nunan2010" target="_blank" rel="noopener">Nunan et al. 2010</a>. The normal value for the SD2 is derived based on its dependency on the time-domain variable SDNN as described in <a href="https://www.kubios.com/hrv-ans-function/#Brennan2001" target="_blank" rel="noopener">Brennan et al. 2001</a>. The normal values for the Baevsky’s stress index are taken from <a href="https://www.kubios.com/hrv-ans-function/#Baevsky2009" target="_blank" rel="noopener">Baevsky 2009</a>. The parameter values are then scaled with the standard deviations of normal population and finally a proprietary weighting (taking into account associations between exercise intensity, heart rate and heart rate variability) is applied to obtain the SNS index value (see Fig. 2).</p><p>The interpretation of the SNS index is similar to PNS index. A SNS index value of zero means that the three parameters reflecting sympathetic activity are on average equal to the normal population average. Correspondingly, a positive SNS index value tells how many SDs above the normal population average the parameter values are, a negative value tells how many SDs below the normal population average the parameter values are. During stress or high intensity exercise SNS index can have values as high as 5-35.</p><center>      <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86/%E5%8C%BB%E5%AD%A6/SNSindex_mod.png">     <br>      <div style="color:orange; border-bottom: 1px solid #d9d9d9;                  display: inline-block;                  color: #999;                  padding: 2px;">Figure 2: Sympathetic nervous system (SNS) index.    </div></center><h2 id="Assessing-stress-and-recovery-using-Kubios-HRV-analysis"><a href="#Assessing-stress-and-recovery-using-Kubios-HRV-analysis" class="headerlink" title="Assessing stress and recovery using Kubios HRV analysis"></a>Assessing stress and recovery using Kubios HRV analysis</h2><p>By using time-varying analysis (available in Kubios HRV Premium), time trends for different HRV analysis parameters can be obtained.  A good choice for the analysis window is 5-10 minutes <a href="https://www.kubios.com/hrv-ans-function/#Taskforce1996" target="_blank" rel="noopener">Task Force 1996</a>, which provides sufficient time resolution for analyzing long-term (24-hours or more) measurements and enables accurate estimation of HRV parameters. For shorter term measurements, the analysis window can be shortened to increase the time resolution, i.e. to capture smaller details in HRV dynamics. Note that the accuracy of some HRV parameters (especially the nonlinear parameters) decreases when shortening the analysis window.</p><p>An example of time-varying analysis for assessing stress and recovery using Kubios HRV analysis is presented in Fig. 3. The figure illustrates time-varying HRV analysis results for a 48-hour HRV recording from a healthy young male subject. The results (taken from Kubios HRV Premium report) show heart rate, PNS index and SNS index graphs and their statistics. Recovery during sleep can be observed as high levels of PNS index.</p><center>      <img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86/%E5%8C%BB%E5%AD%A6/stress-and-recovery.png">     <br>      <div style="color:orange; border-bottom: 1px solid #d9d9d9;                  display: inline-block;                  color: #999;                  padding: 2px;">Figure 3: An example of stress and recovery monitoring. The figure shows time-varying analysis of 48-hour HRV recording (using Kubios HRV Premium software) for a young healthy male subject.    </div></center><h2 id="References-2"><a href="#References-2" class="headerlink" title="References"></a>References</h2><ol><li>U.R. Acharya, K.P. Joseph, N. Kannathal, C.M. Lim, and J.S. Suri. Heart rate variability: a review. Med Biol Eng Comput, 44:1031–1051, 2006.</li><li>R. M. Baevsky. Methodical recommendations use kardivar system for determination of the stress level and estimation of the body adaptability standards of measurements and physiological interpretation. 2009.</li><li>G.G. Berntson, J.T. Bigger Jr., D.L. Eckberg, P. Grossman, P.G. Kaufmann, M. Malik, H.N. Nagaraja, S.W. Porges, J.P. Saul, P.H. Stone, and M.W. Van Der Molen. Heart rate variability: Origins, methods, and interpretive caveats. Psychophysiol, 34:623–648, 1997.</li><li>M. Brennan, M. Palaniswami, and P. Kamen. Do existing measures of Poincaré plot geometry reflect nonlinear features of heart rate variability. IEEE Trans Biomed Eng, 48(11):1342–1347, 2001.</li><li>D. Nunan, G.R.H. Sandercock, and D.A. Brodie. A quantitative systematic review of normal values for short-term heart rate variability in healthy adults. PACE, 33:1407–1417, November 2010.</li><li>Task force of the European society of cardiology and the North American society of pacing and electrophysiology. Heart rate variability – standards of measurement, physiological interpretation, and clinical use. Circulation, 93(5):1043–1065, March 1996.</li></ol>]]></content>
      
      
      <categories>
          
          <category> 其他知识 </category>
          
          <category> 医学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HRV </tag>
            
            <tag> 心率变异性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vulkan学习</title>
      <link href="/2020/10/28/Vulkan%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/10/28/Vulkan%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>记录Vulkan学习，<a href="https://vulkan-tutorial.com/Introduction" target="_blank" rel="noopener">网址</a>。</p><a id="more"></a><h1 id="三角形绘制"><a href="#三角形绘制" class="headerlink" title="三角形绘制"></a>三角形绘制</h1>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
          <category> Vulkan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
            <tag> Vulkan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity Shader基础</title>
      <link href="/2020/09/26/Unity-Shader%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/09/26/Unity-Shader%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>Shader其实就是渲染流水线中的某些特定阶段，如顶点着色器阶段、片元着色器阶段。</p><p>unity的出现改善了Shader的状况，它提供了一个地方能够让开发者更加轻松地管理着色器代码以及渲染设置（如开启/关闭混合、深度测试、设置渲染顺序等），而不需要管理多个文件和函数。</p><p>Unity提供这个“方便的地方”就是Unity Shader。</p><a id="more"></a><h1 id="Unity-Shader-概述"><a href="#Unity-Shader-概述" class="headerlink" title="Unity Shader 概述"></a>Unity Shader 概述</h1><h2 id="一对好兄弟：材质和Unity-Shader"><a href="#一对好兄弟：材质和Unity-Shader" class="headerlink" title="一对好兄弟：材质和Unity Shader"></a>一对好兄弟：材质和Unity Shader</h2><p>在Unity中我们需要使用<strong>材质（Material）</strong>和<strong>Unity Shader</strong>才能达到需要的效果。</p><p>【流程】</p><ol><li>创建一个材质；</li><li>创建一个Unity Shader，并把它赋给上一步中创建的材质；</li><li>把材质赋给要渲染的对象；</li><li>在材质面板中调整Unity Shader的属性，以得到满意的结果。</li></ol><p>Unity Shader定义了渲染所需的各种代码（如顶点着色器和片元着色器）、属性（如使用哪些纹理）和指令（渲染和标签设置等），而材质则允许我们调节这些属性，并将其最终赋给某些模型。</p><h2 id="Unity中的材质"><a href="#Unity中的材质" class="headerlink" title="Unity中的材质"></a>Unity中的材质</h2><p>Unity中的材质需要结合一个GameObject的<strong>Mesh</strong>或者<strong>Particle Systems</strong>组件来工作。</p><p>创建一个新的材质：Assets-&gt;Create-&gt;Material</p><p>可以通过把材质直接拖曳到<strong>Scene</strong>视图中的对象上来实现，或者在该对象的<strong>Mesh Renderer</strong>组件中直接赋值。</p><h2 id="Unity中的Shader"><a href="#Unity中的Shader" class="headerlink" title="Unity中的Shader"></a>Unity中的Shader</h2><p>创建Unity Shader：Assets-&gt;Create-&gt;Shader</p><p>Unity一共提供了4种Unity Shader模板：</p><ul><li>Standard Surface Shader（产生一个包含了标准光照模型的表面着色器模板）</li><li>Unlit shader（产生一个不包含光照（但包含雾效）的基本的顶点/片元着色器）</li><li>Image Effect Shader（为我们实现各种屏幕后处理效果提供了一个基本模板）</li><li>Compute Shader（产生一种特殊的Shader文件，意在利用GPU的并行性来进行一些与常规渲染流水线无关的计算）</li></ul><p>Unity Shader必须与材质结合起来才能发挥作用。</p><p>Unity Shader本质上是一个文本文件，和Unity中的很多外部文件类似，Unity Shader也有<strong>导入设置（Import Settings）</strong>面板，在<strong>Project</strong>视图中选中某个Unity Shader即可看到。</p><p>在导入设置面板上：</p><ul><li><strong>Default Maps：</strong>指定该Unity Shader使用默认纹理，当任何材质第一次使用该Unity Shader时，这些纹理就会自动被赋予到相应的属性上。</li><li><strong>Surface shader：</strong>是否是一个表面着色器</li><li><strong>Fixed function：</strong>是否是一个固定函数着色器。</li></ul><p>还有一些信息时和我们在Unity Shader中的标签设置有关，例如：是否会投射阴影、使用渲染队列、LOD值等。</p><p>导入面板还可以方便地查看其使用的渲染队列（Render queue）、是否关闭批处理（Disable batching）、属性列表（Properties）等信息。</p><h1 id="Unity-Shader基础：ShaderLab"><a href="#Unity-Shader基础：ShaderLab" class="headerlink" title="Unity Shader基础：ShaderLab"></a>Unity Shader基础：ShaderLab</h1><blockquote><p>计算机科学中的任何问题都可以通过增加一层抽象来解决。——大卫·惠勒</p></blockquote><p>通常情况下，为了自定义渲染效果往往需要和很多文件和设置打交道，这些过程很容易消磨掉初学者的耐心。同时一些细节问题也往往需要开发者花费较多的时间去解决。</p><p>Unity为了解决上述问题，提供了一层抽象——Unity Shader。</p><p>我们和这层抽象打交道的途径就是使用Unity提供的一种专门为Unity Shader服务的语言——ShaderLab。</p><h2 id="ShaderLab"><a href="#ShaderLab" class="headerlink" title="ShaderLab"></a>ShaderLab</h2><blockquote><p>ShaderLab is a friend you can afford.——Nicholas Francis</p></blockquote><p>Unity Shader是Unity为开发者提供的高层级的渲染抽象层。</p><ul><li>没有使用Unity Shader（左图）：开发者需要和很多文件和设置打交道，才能让画面呈现出想要的效果。</li><li>使用Unity Shader（右图）：开发者只需要使用ShaderLab来编写Unity Shader文件就可以完成所有的工作。</li></ul><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Unity%20Shader%E5%9F%BA%E7%A1%80/ShaderLab%E4%BD%BF%E7%94%A8%E6%AF%94%E8%BE%83.png"></p><p>在Unity中，所有的Unity Shader都是用ShaderLab来编写的。</p><p>ShaderLab是Unity提供的编写Unity Shader的一种说明性语言，它使用了一些嵌套在花括号内部的<strong>语义（syntax）</strong>来描述一个Unity Shader文件的结构。</p><p>这些结构包含了许多渲染所需的数据，例如<code>Properties</code>语句块中定义了着色器所需的各种属性，这些属性将会出现在材质面板中。</p><p>从设计上来说，<strong>ShaderLab类似于CgFX和Direct3D Effects（.FX）语言</strong>，它们都定义了要显示一个材质所需的所有东西，而<strong>不仅仅是着色器代码</strong>。</p><p>Unity Shader的基础结构如下：</p><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">Shader <span class="hljs-string">"ShaderName"</span>&#123;<br>    Properties&#123;<br>        <span class="hljs-comment">// 属性   </span><br>    &#125;<br>    SubShader&#123;<br>        <span class="hljs-comment">// 显卡A使用的子着色器</span><br>    &#125;<br>    SubShader&#123;<br>        <span class="hljs-comment">// 显卡B使用的子着色器</span><br>    &#125;<br>    Fallback <span class="hljs-string">"VertexLit"</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Unity在背后会<strong>根据使用的平台来把这些结构编译成真正的代码和Shader文件</strong>，而开发者只需要和Unity Shader打交道即可。</p><h1 id="Unity-Shader的结构"><a href="#Unity-Shader的结构" class="headerlink" title="Unity Shader的结构"></a>Unity Shader的结构</h1><h2 id="给Shader起个名字"><a href="#给Shader起个名字" class="headerlink" title="给Shader起个名字"></a>给Shader起个名字</h2><p>每个Unity Shader文件的第一行都需要通过<code>Shader</code>语义来指定该<strong>Unity Shader</strong>的名字（由字符串定义）。</p><p>当为材质选择使用的Unity Shader时，这些名称就会出现在材质面板的下拉列表里。</p><p>通过在字符串中添加斜杠（”/“），可以控制Unity Shader在材质面板中出现的位置。</p><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">Shader <span class="hljs-string">"Custom/MyShader"</span><br></code></pre></td></tr></table></figure><p>则这个Unity Shader在材质面板中的位置就是：Shader-&gt;Custom-&gt;MyShader。</p><h2 id="材质和Unity-Shader的桥梁：Properties"><a href="#材质和Unity-Shader的桥梁：Properties" class="headerlink" title="材质和Unity Shader的桥梁：Properties"></a>材质和Unity Shader的桥梁：Properties</h2><p><code>Properties</code>语义块中包含了一系列<strong>属性（Property）</strong>，这些属性将会出现在材质面板中。</p><p><code>Properties</code>语义块的定义通常如下：</p><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">Properties&#123;<br>    Name &#123;<span class="hljs-string">"display name"</span>, PropertyType&#125; = DefaultValues<br>    Name &#123;<span class="hljs-string">"display name"</span>, PropertyType&#125; = DefaultValues<br>    <span class="hljs-comment">// 更多属性</span><br>&#125;<br></code></pre></td></tr></table></figure><p>声明这些属性是为了在材质面板中能够方便地调整各种材质属性。</p><p>如果需要在Shader中访问它们，则需要使用每个属性的<strong>名字（Name）</strong>，在Unity中，这些属性的名字通常由一个下划线开始。</p><p><strong>显示的名称（display name）</strong>则是出现在材质面板上的名字。</p><p>我们需要为每个属性指定它的<strong>类型（PropertyType）</strong>，常见的类型如下表所示：</p><div class="table-container"><table><thead><tr><th style="text-align:center">属性类型</th><th style="text-align:center">默认值的定义语法</th><th style="text-align:center">例子</th></tr></thead><tbody><tr><td style="text-align:center">Int</td><td style="text-align:center">number</td><td style="text-align:center">_Int(“Int”,Int)=2</td></tr><tr><td style="text-align:center">Float</td><td style="text-align:center">number</td><td style="text-align:center">_Float(“Float”,Float)=1.5</td></tr><tr><td style="text-align:center">Range(min,max)</td><td style="text-align:center">number</td><td style="text-align:center">_Range(“Range”,Range(0.0,5.0))=3.0</td></tr><tr><td style="text-align:center">Color</td><td style="text-align:center">(number,number,number,number)</td><td style="text-align:center">_Color(“Color”,Color)</td></tr><tr><td style="text-align:center">Vector</td><td style="text-align:center">(number,number,number,number)</td><td style="text-align:center">_Vector(“Vector”,Vector)=(2,3,6,1)</td></tr><tr><td style="text-align:center">2D</td><td style="text-align:center">“defaulttexture”{}</td><td style="text-align:center">_2D(“2D”,2D)=””{}</td></tr><tr><td style="text-align:center">Cube</td><td style="text-align:center">“defaulttexture”{}</td><td style="text-align:center">_Cube(“Cube”,Cube)=”white”{}</td></tr><tr><td style="text-align:center">3D</td><td style="text-align:center">“defaulttexture”{}</td><td style="text-align:center">_3D(“3D”,3D)=”black”{}</td></tr></tbody></table></div><ul><li><strong>Int</strong>、<strong>Float</strong>、<strong>Range</strong>这些数字类型的属性，默认是一个单独的数字；</li><li><strong>Color</strong>和<strong>Vector</strong>这类属性，默认值是用圆括号包围的一个四维向量；</li><li><strong>2D</strong>、<strong>Cube</strong>、<strong>3D</strong>这3种纹理类型，默认值是通过一个字符串后跟一个花括号来指定的，其中，字符串要么是空的，要么是内置的纹理名称，如“white”、“black”、“gray”或者“bump”。</li></ul><p>展示所有属性类型的例子：</p><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++">Shader <span class="hljs-string">"Custom/ShaderLabProperties"</span>&#123;<br>    Properties&#123;<br>        <span class="hljs-comment">// Numbers and Sliders</span><br>        _Int(<span class="hljs-string">"Int"</span>, Int) = <span class="hljs-number">2</span><br>        _Float(<span class="hljs-string">"Float"</span>, Float) = <span class="hljs-number">1.5</span><br>        _Range(<span class="hljs-string">"Range"</span>, Range(<span class="hljs-number">0.0</span>, <span class="hljs-number">5.0</span>)) = <span class="hljs-number">3.0</span><br>        <br>        <span class="hljs-comment">// Colors and Vectors</span><br>        _Color(<span class="hljs-string">"Color"</span>, Color) = (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br>        _Vector(<span class="hljs-string">"Vector"</span>, Vector) = (<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>)<br>        <br>        <span class="hljs-comment">// Textures</span><br>        _2D(<span class="hljs-string">"2D"</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">""</span> &#123;&#125;<br>        _Cube(<span class="hljs-string">"Cube"</span>, Cube) = <span class="hljs-string">"white"</span> &#123;&#125;<br>        _3D(<span class="hljs-string">"3D"</span>, <span class="hljs-number">3</span>D) = <span class="hljs-string">"black"</span> &#123;&#125;<br>    &#125;<br>    FallBack <span class="hljs-string">"Diffuse"</span><br>&#125;<br></code></pre></td></tr></table></figure><p>有时想在材质面板上显示更多类型的变量，例如使用布尔变量来控制Shader中使用哪种计算。</p><p>Unity允许我们重建默认的材质编辑面板，以提供更多自定义的数据类型。</p><h2 id="重量级成员：SubShader"><a href="#重量级成员：SubShader" class="headerlink" title="重量级成员：SubShader"></a>重量级成员：SubShader</h2><p>每一个Unity Shader文件可以包含多个SubShader语义块，但最少要有一个。</p><p>当Unity需要加载这个Unity Shader时，Unity会扫描所有的SubShader语义块，然后选择第一个能够在目标平台上运行的SubShader。</p><p>如果都不支持的话，Unity就会使用<code>Fallback</code>语义指定的Unity Shader。</p><p>SubShader语义块中包含的定义如下：</p><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">SubShader&#123;<br>    <span class="hljs-comment">// 可选的</span><br>    [tag]<br>    <br>    <span class="hljs-comment">// 可选的</span><br>    [RenderSetup]<br>    <br>    Pass&#123;<br>    <br>    &#125;<br>    <span class="hljs-comment">// Other Passes</span><br>&#125;<br></code></pre></td></tr></table></figure><p>SubShader定义了一系列Pass以及可选的<strong>状态（RenderSetup）</strong>和<strong>标签（Tags）</strong>。</p><p>每个Pass定义了一次完整的渲染流程，如果Pass数目过多，往往会造成渲染性能下降。（尽量使用最小数目的Pass）</p><p>可以在Pass中设置RenderSetup和Tags，如果在Pass外设置，则会用于所有的Pass。</p><h3 id="状态设置（RenderSetup）"><a href="#状态设置（RenderSetup）" class="headerlink" title="状态设置（RenderSetup）"></a>状态设置（RenderSetup）</h3><p>ShaderLab提供了一系列渲染状态的设置指令，这些指令可以设置显卡的各种状态（例如是否开启混合/深度测试等）。</p><div class="table-container"><table><thead><tr><th style="text-align:center">状态名称</th><th style="text-align:center">设置指令</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">Cull</td><td style="text-align:center">Cull Back\</td><td style="text-align:center">Front\</td><td>Off</td><td>设置剔除模式：剔除背面/正面/关闭剔除</td></tr><tr><td style="text-align:center">ZTest</td><td style="text-align:center">ZTest Less Greater\</td><td style="text-align:center">LEqual\</td><td>GEqual\</td><td>Equal\</td><td>NotEqual\</td><td>Always</td><td>设置深度测试时使用的函数</td></tr><tr><td style="text-align:center">ZWrite</td><td style="text-align:center">ZWrite On\</td><td style="text-align:center">Off</td><td>开启/关闭深度写入</td></tr><tr><td style="text-align:center">Blend</td><td style="text-align:center">Blend SrcFactor DstFactor</td><td style="text-align:center">开启并设置混合模式</td></tr></tbody></table></div><h3 id="标签（Tags）"><a href="#标签（Tags）" class="headerlink" title="标签（Tags）"></a>标签（Tags）</h3><p>SubShader的标签（Tags）是一个<strong>键值对（Key/Value Pair）</strong>，它的键和值都是字符串类型。</p><p>这些键值对是SubShader和渲染引擎之间的沟通桥梁，它们用来告诉Unity的渲染引擎：SubShader我希望怎样以及何时渲染这个对象。</p><p>标签的结构如下：</p><figure class="hljs highlight C++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">Tags&#123;<span class="hljs-string">"TagName1"</span>=<span class="hljs-string">"Value1"</span> <span class="hljs-string">"TagName2"</span>=<span class="hljs-string">"Value2"</span>&#125;<br></code></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center">标签类型</th><th style="text-align:center">说明</th><th style="text-align:center">例子</th></tr></thead><tbody><tr><td style="text-align:center">Queue</td><td style="text-align:center">控制渲染顺序，指定该物体属于哪一个渲染队列，通过这种方式可以保证所有的透明物体可以在所有不透明物体后面被渲染，也可以自定义使用的渲染队列来控制物体的渲染顺序。</td><td style="text-align:center">Tags{“Queue”=”Transparent”}</td></tr><tr><td style="text-align:center">RenderType</td><td style="text-align:center">对着色器进行分类，例如是否为透明着色器，可以被用于着色器替换（Shader Replacement）功能。</td><td style="text-align:center">Tags{“RenderType”=”Opaque”}</td></tr><tr><td style="text-align:center">DisableBatching</td><td style="text-align:center">可以通过该标签来直接指明是否对该SubShader使用批处理。</td><td style="text-align:center">Tags{“DisableBatching”=”True”}</td></tr><tr><td style="text-align:center">ForceNoShadowCasting</td><td style="text-align:center">控制使用该SubShader的物体是否会投射阴影。</td><td style="text-align:center">Tags{“ForceNoShadowCasting”=”True”}</td></tr><tr><td style="text-align:center">IgnoreProjector</td><td style="text-align:center">若该标签值为“True”，则使用该SubShader的物体将不会受Projector影响。通常用于半透明物体</td><td style="text-align:center">Tags{“IgnoreProjector”=”True”}</td></tr><tr><td style="text-align:center">CanUseSpriteAtlas</td><td style="text-align:center">当该SubShader是用于sprites时，将该标签设置为“False”</td><td style="text-align:center">Tags{“CanUseSpriteAtlas”=”False”}</td></tr><tr><td style="text-align:center">PreviewType</td><td style="text-align:center">指明材质面板将如何预览该材质。默认情况下，材质将显示为一个球形，可以通过把该标签的值设为“Plane”“SkyBox”来改变预览类型</td><td style="text-align:center">Tags{“PreviewType”=”Plane”}</td></tr></tbody></table></div><p>注意：上述标签仅可以在SubShader中声明，而不可以在Pass块中声明。</p><h3 id="Pass语义块"><a href="#Pass语义块" class="headerlink" title="Pass语义块"></a>Pass语义块</h3><p>Pass语义块包含的语义如下：</p><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">Pass&#123;<br>    [Name]<br>    [Tags]<br>    [RenderSetup]<br>    <span class="hljs-comment">// Other code</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以在Pass中定义该Pass的名称，例如</p><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">Name <span class="hljs-string">"MyPassName"</span><br></code></pre></td></tr></table></figure><p>之后，可以使用ShaderLab的UsePass命令来直接使用其他Unity Shader中的Pass，例如：</p><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">UsePass <span class="hljs-string">"MyShader/MYPASSNAME"</span><br></code></pre></td></tr></table></figure><p>注意，Unity内部会把所有Pass的名称转换成大写字母的表示，因此，在使用UsePass命令时必须使用大写形式的名字。</p><p>Pass标签：</p><div class="table-container"><table><thead><tr><th style="text-align:center">标签类型</th><th style="text-align:center">说明</th><th style="text-align:center">例子</th></tr></thead><tbody><tr><td style="text-align:center">LightMode</td><td style="text-align:center">定义该Pass在Unity的渲染流水线中的角色</td><td style="text-align:center">Tags{“LightMode”=”ForwardBase”}</td></tr><tr><td style="text-align:center">RequireOptions</td><td style="text-align:center">用于指定当满足某些条件时才渲染该Pass，它的值是一个由空格分隔的字符串。目前，Unity支持的选项有：SoftVegetation。后续版本会增加更多的选项。</td><td style="text-align:center">Tags{“RequireOptions”=”SoftVegetation”}</td></tr></tbody></table></div><h2 id="Fallback（留一条后路）"><a href="#Fallback（留一条后路）" class="headerlink" title="Fallback（留一条后路）"></a>Fallback（留一条后路）</h2><p>Fallback在各个SubShader语义块后面，它用于告诉Unity，“如果上面所有的SubShader在这块显卡上都不能运行，那么就使用这个最低级的Shader吧！”</p><p>语义定义：</p><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">Fallback <span class="hljs-string">"name"</span><br><span class="hljs-comment">// 或者</span><br>Fallback Off<br></code></pre></td></tr></table></figure><p>可以给Fallback起名字，也可以关闭Fallback功能。</p><h1 id="Unity-Shader的形式"><a href="#Unity-Shader的形式" class="headerlink" title="Unity Shader的形式"></a>Unity Shader的形式</h1><p>Unity Shader最重要的任务是指定各种着色器所需的代码。</p><p>这些着色器代码可以写在SubShader语义块中（表面着色器的做法），也可以写在Pass语义块中（顶点/片元着色器和固定函数着色器的做法）。</p><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++">Shader <span class="hljs-string">"MyShader"</span>&#123;<br>    Properties&#123;<br>        <span class="hljs-comment">// 所需的各种属性</span><br>    &#125;<br>    SubShader&#123;<br>        <span class="hljs-comment">// 真正意义上的Shader代码会出现在这里</span><br>        <span class="hljs-comment">// 表面着色器（Surface Shader）或者</span><br>        <span class="hljs-comment">// 顶点/片元着色器（Vertex/Fragment Shader）或者</span><br>        <span class="hljs-comment">// 固定函数着色器（Fixed Function Shader）</span><br>    &#125;<br>    SubShader&#123;<br>        <span class="hljs-comment">// 和上一个SubShader类似</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="表面着色器（Surface-Shader）"><a href="#表面着色器（Surface-Shader）" class="headerlink" title="表面着色器（Surface Shader）"></a>表面着色器（Surface Shader）</h2><p>Unity自创的一种着色器代码类型，需要的代码量很少，Unity在背后做了很多工作（背后仍旧把它转换成对应的顶点/片元着色器），但渲染的代价比较大。</p><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++">Shader <span class="hljs-string">"Custom/Simple Surface Shader"</span>&#123;<br>    SubShader &#123;<br>        Tags&#123;<span class="hljs-string">"RenderType"</span> = <span class="hljs-string">"Opaque"</span>&#125;<br>        CGPROGRAM<br>        #pragma surface surf Lambert<br>        struct Input&#123;<br>            float4 color : COLOR;<br>        &#125;;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">surf</span><span class="hljs-params">(Input IN, inout SurfaceOutput o)</span></span>&#123;<br>            o.Albedo = <span class="hljs-number">1</span>;<br>        &#125;<br>        ENDCG<br>    &#125;<br>    Fallback <span class="hljs-string">"Diffuse"</span><br>&#125;<br></code></pre></td></tr></table></figure><p>表面着色器定义在SubShader语义块（而非Pass语义块）中的<strong>CGPROGRAM</strong>和<strong>ENDCG</strong>之间。</p><p>原因：表面着色器不需要开发者关心使用多少个Pass、每个Pass如何渲染等问题，Unity会在背后为我们做好这些事情。</p><p><strong>CGPROGRAM</strong>和<strong>ENDCG</strong>之间的代码是使用<strong>CG/HLSL</strong>编写的，即，我们需要把CG/GLSL语言嵌套在ShaderLab语言中。</p><p>如果想和各种光源打交道，使用表面着色器，但需要小心它在移动平台的性能表现。</p><h2 id="顶点-片元着色器（Vertex-Fragment-Shader）"><a href="#顶点-片元着色器（Vertex-Fragment-Shader）" class="headerlink" title="顶点/片元着色器（Vertex/Fragment Shader）"></a>顶点/片元着色器（Vertex/Fragment Shader）</h2><p>Unity中可是使用CG/HLSL语言来编写顶点/片元着色器。</p><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++">Shader "Custom/Simple VertexFragment Shader"&#123;<br>    SubShader &#123;<br>        Pass&#123;<br>            CGPROGRAM<br>            #pragma vertex vert<br>            #pragma fragment frag<br>            <br>            float4 vert(float4 v: POSITION): SV_POSITION&#123;<br>                return mul(UNITY_MATRIX_MVP, v);<br>            &#125;<br>            <br>            fixed4 frag(): SV_Target&#123;<br>                return fixed4(1.0, 0.0, 0.0, 1.0);<br>            &#125;<br>            ENDCG<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>顶点/片元着色器的代码也需要定义在<strong>CGPROGRAM</strong>和<strong>ENDCG</strong>之间。</p><p>但需要注意，顶点/片元着色器时写在Pass语义块内，而非SubShader内的。</p><p>如果有很多自定义的渲染效果，则使用顶点/片元着色器。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
          <category> unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
            <tag> Shader </tag>
            
            <tag> unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渲染流水线</title>
      <link href="/2020/09/24/%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/"/>
      <url>/2020/09/24/%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<p>Shader（着色器）。</p><p>渲染流水线的最终目的在于生成或者说是渲染一张二维纹理（显示器上看到的效果），它的输入是一个虚拟摄像机、一些光源、一些Shader以及纹理等。</p><a id="more"></a><h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p>渲染流水线的工作任务在于由一个三维场景出发、生成（渲染）一张二维图像。即，计算机需要从一系列的顶点数据、纹理等信息出发，把这些信息最终转换成一张人眼可以看到的图像。（由CPU和GPU共同完成。）</p><p>渲染流程三阶段：应用阶段（Application Stage）、几何阶段（Geometry Stage）、光栅化阶段（Rasterizer Stage）。</p><h2 id="应用阶段（程序员）"><a href="#应用阶段（程序员）" class="headerlink" title="应用阶段（程序员）"></a>应用阶段（程序员）</h2><p>由程序员主导（绝对控制权），CPU负责实现。</p><p>最重要的输出是渲染所需的几何信息，即<strong>渲染图元（rendering primitives）</strong>，包括点、线、三角面等。</p><p>主要任务：</p><ol><li>准备场景数据（摄像机位置、视锥体、场景模型、光源）</li><li>粗粒度剔除（culling），把不可见的物体剔除出去，提高渲染性能</li><li>设置每个模型的渲染状态：材质（漫反射颜色、高光反射颜色）、纹理、Shader</li></ol><h2 id="几何阶段（GPU）"><a href="#几何阶段（GPU）" class="headerlink" title="几何阶段（GPU）"></a>几何阶段（GPU）</h2><p>出来了所有要绘制的几何相关的事情，例如：决定绘制哪些图元，如何绘制，哪里绘制。</p><p>在GPU上进行。</p><p>负责和每个渲染图元打交道，进行逐顶点、逐多边形的操作。</p><p>把顶点坐标变换到屏幕空间中，再交给光栅器进行处理。</p><p>输出：屏幕空间的二维顶点坐标、顶点深度值、着色信息</p><h2 id="光栅化阶段（GPU）"><a href="#光栅化阶段（GPU）" class="headerlink" title="光栅化阶段（GPU）"></a>光栅化阶段（GPU）</h2><p>渲染最终图像。</p><p>GPU进行。</p><p>决定每个渲染图元中的哪些像素应该被绘制在屏幕上。</p><p>对上阶段的逐顶点数据（纹理坐标、顶点颜色）进行插值，再进行逐像素处理。</p><h1 id="CPU和GPU之间的通信"><a href="#CPU和GPU之间的通信" class="headerlink" title="CPU和GPU之间的通信"></a>CPU和GPU之间的通信</h1><p><strong>应用阶段</strong>分为三个阶段：</p><ol><li>把数据加载到显存中</li><li>设置渲染状态</li><li>调用Draw Call</li></ol><h2 id="把数据加载到显存中"><a href="#把数据加载到显存中" class="headerlink" title="把数据加载到显存中"></a>把数据加载到显存中</h2><p>所有渲染所需的数据都需要从<strong>硬盘</strong>（Hard Disk Drive, HDD）中加载到系统<strong>内存</strong>（Random Access Memory, RAM）中，之后，顶点位置、颜色、法线、网格和纹理等数据又被加载到<strong>显存</strong>（Video Random Access Memory, VRAM）中。</p><p>之后，开发者需要通过CPU来设置渲染状态，指导GPU进行渲染工作。</p><h2 id="设置渲染状态"><a href="#设置渲染状态" class="headerlink" title="设置渲染状态"></a>设置渲染状态</h2><p>渲染状态定义了场景中的网格是怎样被渲染的，例如：使用哪个顶点着色器（Vertex Shader）/ 片元着色器（Fragment Shader）、光源属性、材质等。</p><p>如果没有改变渲染状态，则所有网格都将使用同一种渲染状态。</p><h2 id="调用Draw-Call"><a href="#调用Draw-Call" class="headerlink" title="调用Draw Call"></a>调用Draw Call</h2><p>渲染命令：Draw Call</p><p>发起方：CPU，接收方：GPU</p><p>这个命令仅仅会指向一个需要被渲染的图元（primitives）列表，而不会再包含任何材质信息（在上一阶段已经做过）。</p><p>当给定了一个Draw Call时，GPU就会根据渲染状态（材质、纹理、着色器等）和所有输入的顶点数据来进行计算，最终输出成屏幕上显示的哪些漂亮的像素。</p><h1 id="GPU流水线"><a href="#GPU流水线" class="headerlink" title="GPU流水线"></a>GPU流水线</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>GPU渲染的过程就是<strong>GPU流水线</strong>。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/GPU%E6%B5%81%E6%B0%B4%E7%BA%BF.png" width="80%"></p><p>几何阶段和光栅化阶段可以分为若干更小的流水线阶段，这些流水线阶段由GPU来实现。</p><p>每个阶段GPU提供了不同的可配置性或可编程性。</p><p>图中可以看出，GPU的渲染流水线接收<strong>顶点数据</strong>作为输入，这些顶点数据由应用阶段加载到显存中，再由Draw Call指定，随后被传递给顶点着色器。</p><p><strong>几何阶段：</strong></p><ul><li><strong>顶点着色器（Vertex Shader）</strong>：完全可编程，实现顶点的空间变换、顶点着色。</li><li><strong>曲面细分着色器（Tessellation Shader）</strong>：可选着色器，用于细分图元。</li><li><strong>几何着色器（Geometry Shader）</strong>：可选着色器，执行逐图元（Per-Primitive）着色操作。</li><li><strong>裁剪（Clipping）</strong>：将那些不在摄像机视野内的顶点裁掉，同时剔除某些三角图元的面片。该阶段可配置，例如，使用自定义裁剪平面配置裁剪区域，或通过指令控制裁剪三角图元的正面还是背面。</li><li><strong>屏幕映射（Screen Mapping）</strong>：不可配置和编程，负责把每个图元的坐标转换到屏幕坐标系中。</li></ul><p><strong>光栅化阶段：</strong></p><ul><li><strong>三角形设置（Triangle Setup）</strong></li><li><strong>三角形遍历（Triangle Traversal）</strong></li><li><strong>片元着色器（Fragment Shader）</strong>：完全可编程，实现逐片元（Per-Fragment）的着色操作</li><li><strong>逐片元操作（Per-Fragment Operations）</strong>：修改颜色、深度缓冲、进行混合等，不可编程，但具有很高的可配置性。</li></ul><h2 id="顶点着色器（Vertex-Shader）"><a href="#顶点着色器（Vertex-Shader）" class="headerlink" title="顶点着色器（Vertex Shader）"></a>顶点着色器（Vertex Shader）</h2><p>流水线第一个阶段，输入来自CPU。</p><p>顶点着色器的处理单位是<strong>顶点</strong>，即，输入进来的每个顶点都会调用一次顶点着色器。</p><p>顶点着色器本身不创建或者销毁任何顶点，而且无法得到顶点与顶点之间的关系。例如，无法得知两个顶点是否属于同一个三角网格。正是由于这个相互独立性，GPU可以利用本身的特性并行化处理每一个顶点，处理速度会很快。</p><p>主要工作：<strong>坐标变换</strong>（把顶点从模型空间转换到齐次裁剪空间，再由硬件做透视除法后，最终得到归一化的设备坐标，Normalized Device Coordinates，NDC）和<strong>逐顶点光照</strong>，还可以输出后续阶段所需的数据。</p><p>顶点着色器可以有不同的输出方式，最常见的输出路径是<strong>经光栅化后交给片元着色器</strong>进行处理。</p><h2 id="裁剪（Clipping）"><a href="#裁剪（Clipping）" class="headerlink" title="裁剪（Clipping）"></a>裁剪（Clipping）</h2><p>由于场景可能会很大，而摄像机的视野范围很有可能不会覆盖所有的场景物体，因此那些不在摄像机视野范围的物体不需要被处理。<strong>裁剪</strong>就是为了完成这个目的而被提出来的。</p><p>图元与摄像机视野的关系：</p><ol><li><strong>完全在视野内</strong>：继续传给下一个流水线阶段。</li><li><strong>部分在视野内</strong>：裁剪处理。例如，一条线段的一个顶点在视野内，另一个顶点在视野外，则在视野外部的顶点应该使用一个新的顶点来代替，这个新的顶点位于这条线段和视野边界的交点处。</li><li><strong>完全在视野外</strong>：不会继续向下传递，因为它们不需要被渲染。</li></ol><p>和顶点着色器不同，这一步是不可编程的，即无法通过编程来控制裁剪的过程，而是硬件上的固定操作，但我们可以自定义一个裁剪操作来对这一步进行配置。</p><h2 id="屏幕映射（Screen-Mapping）"><a href="#屏幕映射（Screen-Mapping）" class="headerlink" title="屏幕映射（Screen Mapping）"></a>屏幕映射（Screen Mapping）</h2><p>输入的坐标是三维坐标系下的坐标（范围在单位立方体内）。</p><p>任务：把每个图元的$x$和$y$坐标转换到屏幕坐标系（Screen Coordinates）。</p><p>缩放的过程。</p><p>屏幕映射不会对输入的$z$坐标做任何处理。</p><p>屏幕坐标系和$z$坐标一起构成了一个坐标系，叫做<strong>窗口坐标系（Window Corrdinates）</strong>，这些值会一起被传递到光栅化阶段。</p><ul><li><strong>OpenGL</strong>：把屏幕<strong>左下角</strong>当成最小的窗口坐标值。</li><li><strong>DirectX</strong>：把屏幕<strong>左上角</strong>当成最小的窗口坐标值。</li></ul><p>时刻小心这样的差异，<strong>如果发现得到的图像是倒转的</strong>，那么很有可能就是这个原因造成的。</p><h2 id="三角形设置（Triangle-Setup）"><a href="#三角形设置（Triangle-Setup）" class="headerlink" title="三角形设置（Triangle Setup）"></a>三角形设置（Triangle Setup）</h2><p>这一步开始进入光栅化阶段。</p><p>光栅化阶段目标：计算每个图元覆盖了哪些像素，以及为这些像素计算它们的颜色。</p><p>该阶段会计算光栅化一个三角网格所需的信息。</p><p>光栅化的第一个流水线阶段是<strong>三角形设置（Triangle Setup）</strong>。</p><p>该阶段会计算光栅化一个三角网格所需的信息。</p><p>上一阶段输出的都是三角网格的顶点，即得到的是三角网格每条边的两个顶点，但如果要得到整个三角网格对像素的覆盖情况，就必须计算每条边上的像素坐标。</p><p>为了能够计算边界像素的坐标信息，需要得到三角形边界的表示方式。</p><p>这样一个计算三角网格表示数据的过程叫做三角形设置。</p><h2 id="三角形遍历（Triangle-Traversal）"><a href="#三角形遍历（Triangle-Traversal）" class="headerlink" title="三角形遍历（Triangle Traversal）"></a>三角形遍历（Triangle Traversal）</h2><p>检查每个像素是否被一个三角网格所覆盖，如果被覆盖，就会生成一个片元（fragment），并使用三角网格3个顶点的顶点信息对整个覆盖区域的像素进行插值。</p><p>这个阶段也被称为<strong>扫描变换（Scan Conversion）</strong>。</p><p>这一步的输出可以得到一个<strong>片元序列</strong>。</p><p>一个片元并不是真正意义上的像素，而是<strong>包含了很多状态（屏幕坐标、深度信息、顶点信息、法线、纹理坐标）的集合</strong>，这些状态用于计算每个像素的最终颜色。</p><h2 id="片元着色器（Fragment-Shader）"><a href="#片元着色器（Fragment-Shader）" class="headerlink" title="片元着色器（Fragment Shader）"></a>片元着色器（Fragment Shader）</h2><p>可编程着色器阶段。</p><p>在DirectX中，片元着色器被称为<strong>像素着色器（Pixel Shader）</strong>。</p><ul><li>片元着色器的输入：上一个阶段对顶点信息插值得到的结果，即那些从顶点着色器中输出的数据插值得到的。</li><li>片元着色器的输出：一个或者多个颜色值。</li></ul><p>该阶段可以完成多个重要的渲染技术，其中最重要的技术之一就是<strong>纹理采样（通常会在顶点着色器阶段输出每个顶点对应的纹理坐标，然后经过光栅化阶段对三角网格的3个顶点对应的纹理坐标进行插值后，就可以得到其覆盖的偏远的纹理坐标了）</strong>。</p><p>局限性：仅可以影响单个片元，即，当执行片元着色器时，不可以将自己的任何结果直接发送给它的邻居们。<strong>但有一个情况例外</strong>：片元着色器可以访问到导数信息（gradient/derivative）。</p><h2 id="逐片元操作（Per-Fragment-Operations）"><a href="#逐片元操作（Per-Fragment-Operations）" class="headerlink" title="逐片元操作（Per-Fragment Operations）"></a>逐片元操作（Per-Fragment Operations）</h2><ul><li><strong>OpenGL：</strong>逐片元操作（Per-Fragment Operations）</li><li><strong>DirectX：</strong>输出合并阶段（Output-Merger）</li></ul><p><strong>主要任务：</strong></p><ol><li>决定每个片元的可见性。涉及很多测试工作，例如：深度测试、模板测试等。</li><li>如果一个片元通过了所有的测试，就需要把这个片元的颜色值和已经存储在颜色缓冲区中的颜色进行合并或混合。</li></ol><p>逐片元操作是高度<strong>可配置性</strong>的，即我们可以设置每一步的操作细节。</p><p>该阶段首先需要解决每个片元的可见性问题（获取和颜色缓冲区进行合并的资格），如果不可见，则这个片元就会被舍弃掉（之前所做的工作都白费了）。</p><p><strong>操作过程：</strong></p><p>片元—&gt;模板测试—&gt;深度测试—&gt;混合—&gt;颜色缓冲区</p><p><strong>【模板测试（Stencil Test）】</strong></p><p>与之相关的是<strong>模板缓冲（Stencil Buffer）</strong>，模板缓冲与颜色缓冲、深度缓冲是一类东西。</p><p>如果开启了模板测试，GPU会首先读取（使用读取掩码）模板缓冲区中该片元位置的模板值，然后将该值和读取（使用读取掩码）到的参考值（reference value）进行比较，这个比较函数可由开发者指定（例如：小于时舍弃该片元，或者大于等于时舍弃该片元）。</p><p>不管一个片元有没有通过模板测试，都可以根据模板测试和下面的深度测试结果来修改模板缓冲区，这个修改操作是由开发者指定的。</p><p>开发者可以设置不同结果下的修改操作，例如：在失败时模板缓冲区保持不变，通过时将模板缓冲区中对应位置的值加1等。</p><p>模板测试通常用于限制渲染的区域，还可以进行渲染阴影，轮廓渲染等。</p><p><strong>【深度测试（Depth Test）】</strong></p><p>可以高度配置。</p><p>若开启了深度测试，GPU会把该片元的深度值和已经存在于深度缓冲区中的深度值进行比较。该比较函数也可由开发者设置（通常设置为小于等于的关系，即如果该片元深度值大于等于当前深度缓存区中的值，则舍弃它，因为，我们总想只显示出离摄像机最近的物体，而那些被其他物体遮挡的就不需要出现在屏幕上）。</p><p>测试顺序不是惟一的，对于大多数GPU来说，它们会尽可能在执行片元着色器之前就进行这些测试（防止：当GPU在片元着色器阶段花了很大力气终于计算出片元的颜色后，却发现这个片元根本没有通过这些检验，则之前花费的计算成本全部浪费了）。</p><p>将深度测试提前执行的技术称为：Early-Z技术。</p><p>为了避免我们看到那些正在进行光栅化的图元，GPU会使用<strong>双重缓冲（Double Buffering）</strong>，即，对场景的渲染是在幕后发生的，即在<strong>后置缓冲（Back Buffer）</strong>中，一旦场景已经被渲染到了后置缓冲中，GPU就会交换后置缓冲区和<strong>前置缓冲（Front Buffer）</strong>中的内容，由此可以保证看到的图像总是连续的。</p><h1 id="OpenGL-DirectX"><a href="#OpenGL-DirectX" class="headerlink" title="OpenGL/DirectX"></a>OpenGL/DirectX</h1><p>图像应用编程接口，这些接口用于渲染二维或三维图形。</p><p>架起了上层应用程序和底层GPU的沟通桥梁。</p><p>一个应用程序向这些接口发送渲染命令，而这些接口会依次向显卡驱动（Graphics Driver）发送渲染命令，显卡驱动真正和GPU通信，将函数调用翻译成GPU能够听懂的语言，同时也负责将纹理等数据转换成GPU所支持的格式。</p><p>由于显卡驱动的存在，几乎所有的GPU都既可以和OpenGL合作，也可以和DirectX合作。</p><h1 id="HLSL-GLSL-CG"><a href="#HLSL-GLSL-CG" class="headerlink" title="HLSL/GLSL/CG"></a>HLSL/GLSL/CG</h1><p>在可编程管线出现之前，为了编写着色器代码，开发者需要用汇编语言。</p><p>为了方便开发者，就出现了更高级的<strong>着色语言（Shading Language）</strong>。</p><p>着色语言是专门用于编写着色器的，常见的着色语言有<strong>DirectX的HLSL</strong>（High Level Shading Language）、<strong>OpenGL的GLSL</strong>（OpenGL Shading Language）以及<strong>NVIDIA的CG</strong>（C for Graphic）。</p><p>这些语言会被编译成与机器无关的汇编语言，也被称为<strong>中间语言（Intermediate Language，IL）</strong>。</p><p>这些中间语言再交给显卡驱动来翻译成真正的机器语言，即GPU可以理解的语言。</p><p><strong>【GLSL】</strong></p><p>跨平台性，由于OpenGL没有提供着色器编译器，而是由显卡驱动来完成着色器的编译工作。即，只要显卡驱动支持对GLSL的编译它就可以运行。</p><p>好处：供应商完全了解自己的硬件构造，他们知道怎样做可以发挥出最大的作用。即，GLSL是依赖硬件，而非操作系统层级的。</p><p>但硬件提供商有很多（NVIDIA、ATI等），他们对GLSL的编译实现不尽相同，这可能会造成编译结果不一致的情况。</p><p><strong>【HLSL】</strong></p><p>微软控制着色器的编译，就算使用了不同的硬件，同一个着色器的编译结果也是一样的（版本相同的情况下）。</p><p>但是他支持的平台相比有限，几乎都是微软的产品（由于其他平台没有可以编译HLSL的编译器）。</p><p><strong>【CG】</strong></p><p>CG是真正意义上的跨平台。他会根据平台的不同，编译成相应的中间语言。</p><p>CG语言的跨平台性很大原因取决于微软的合作，这也导致CG语言的语法和HLSL非常相像，CG语言可以无缝移植成HLSL代码。</p><p>但缺点是可能无法完全发挥出OpenGL的最新特性。</p><p>在Unity Shader中，我们可以选择使用“CG/HLSL”或者“GLSL”，注意Unity里这些着色语言并不是真正意义上的对应的着色语言，尽管它们的语法几乎一样。</p><h1 id="Draw-Call"><a href="#Draw-Call" class="headerlink" title="Draw Call"></a>Draw Call</h1><p>CPU调用图像编程接口，例如：OpenGL中的<code>glDrawElements</code>或DirectX中的<code>DrawIndexedPrimitive</code>命令，以命令GPU进行渲染的操作。</p><h2 id="CPU和GPU如何实现并行工作"><a href="#CPU和GPU如何实现并行工作" class="headerlink" title="CPU和GPU如何实现并行工作"></a>CPU和GPU如何实现并行工作</h2><p>使用一个<strong>命令缓冲区（Command Buffer）</strong></p><p>命令缓冲区包含一个<strong>命令队列</strong>，由CPU向其中添加命令，而由GPU从中读取命令。（添加和读取的过程是互相独立的）</p><p>当CPU需要渲染一些对象时，它可以向命令缓冲区中添加命令，而当GPU完成了上一次的渲染任务后，它就可以从命令队列中再取出一个命令并执行它。</p><p>命令缓冲区中的命令有很多种类，<code>Draw Call</code>只是其中一种，其他命令还有改变渲染状态（改变使用的着色器、使用不同的纹理）等。</p><h2 id="为什么Draw-Call多了会影响帧率"><a href="#为什么Draw-Call多了会影响帧率" class="headerlink" title="为什么Draw Call多了会影响帧率"></a>为什么Draw Call多了会影响帧率</h2><p>在每次调用<code>Draw Call</code>之前，CPU需要向GPU发送很多内容，包括数据、状态和命令等。</p><p>在这一阶段，CPU需要完成很多工作，例如：检查渲染状态等。</p><p>一旦CPU完成了这些准备工作，GPU就可以开始本次渲染，GPU的渲染能力是很强的，渲染200个还是2000个三角网格通常没有什么区别，因此渲染速度往往快于CPU提交命令的速度。</p><p>如果<code>Draw Call</code>的数量太多，CPU就会把大量时间花费在提交<code>Draw Call</code>上，造成CPU过载。</p><h2 id="如果减少Draw-Call"><a href="#如果减少Draw-Call" class="headerlink" title="如果减少Draw Call"></a>如果减少Draw Call</h2><p><strong>批处理（Batching）</strong>：把很多小的<code>Draw Call</code>合并成一个大的<code>Draw Call</code>。</p><p>由于我们需要在CPU的内存中合并网格，而合并的过程是消耗时间的。因此，批处理技术更加适合于那些<strong>静态的物体</strong>，例如不会移动的大地，石头等，对于这些静态的物体，我们只需要合并一次即可。</p><p>如果对动态物体进行批处理，由于物体是不断运动的，因此每一帧都需要重新进行合并然后再发给GPU，这对空间和时间都会造成一定的影响。</p><ul><li>避免使用大量很小的网格。当不可避免地需要使用很小的网格结构时，考虑是否可以合并它们。</li><li>避免使用过多的材质。尽量在不同的网格之间共用同一个材质。</li></ul><h1 id="固定管线渲染"><a href="#固定管线渲染" class="headerlink" title="固定管线渲染"></a>固定管线渲染</h1><p>固定管线，又称<strong>固定函数的流水线（Fixed-Function Pipeline）</strong></p><p>指在较旧的GPU上实现的渲染流水线。这种流水线只给开发者提供一些配置操作，但开发者没有对流水线阶段的完全控制权。</p><p>固定管线通常提供了一系列接口（由开发者控制），这些接口包含了一个<strong>函数入口点（Function Entry Points）集合</strong>，这些函数入口点会匹配GPU上的一个特定的逻辑功能。</p><p>固定渲染管线是只可配置的管线。</p><p>随着GPU流水线越来越朝着更高的灵活性和可控性方向发展，可编程渲染管线应运而生，固定管线逐渐退出历史舞台。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
          <category> 基本概念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
            <tag> 渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fundamentals of Computer Graphics 4 数学基础</title>
      <link href="/2020/09/24/Fundamentals%20of%20Computer%20Graphics%204%20%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/09/24/Fundamentals%20of%20Computer%20Graphics%204%20%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>主要介绍第二章的数学基础</p><a id="more"></a><h1 id="集合与映射（Sets-and-Mappings）"><a href="#集合与映射（Sets-and-Mappings）" class="headerlink" title="集合与映射（Sets and Mappings）"></a>集合与映射（Sets and Mappings）</h1><p><strong>映射（Mapping</strong>），也被称为<strong>函数（Functions）</strong>，是数学与编程的基础。</p><p>就像编程中的<strong>函数</strong>，数学中的<strong>映射</strong>接收一个类型并将其映射（返回）特定类型的对象。</p><p>在程序中，我们称之为类型（type），但在数学中，我们称之为集合（set）。</p><p>当某个对象属于一个集合时，我们使用$\in$符号，例如：</p><script type="math/tex; mode=display">a\in S \tag{1.1}</script><p>读作“$a$是集合$S$的成员”。</p><p>给定两个集合$A$和$B$，可以通过笛卡尔积（Cartesian product）来生成第三个集合，记为$A\times B$。</p><p>集合$A\times B$由序列对$(a,b)$组成，其中$a\in A$，$b\in B$。</p><p>简化地，可以用$A^2$代表$A\times A$。</p><p>可以扩展笛卡尔积，三个集合创建所有可能的有序三元组，以此类推，可从任意多组中获取任意长度的有序元组。</p><p>常见的集合：</p><ul><li>$\R$：实数</li><li>$\R^+$：非负实数（包括$0$）</li><li>$\R^2$：$2$维平面序列对</li><li>$\R^n$：$n$维坐标点集</li><li>$\Z$：整数</li><li>$S^2$：单位球上$3$维点集</li></ul><p>注意：尽管$S^2$是属于$3$维空间，但是它们在单位球体表面上，因此可以用两个变量表示，所以它可以认为是一个$2$维集合。</p><p>映射使用箭头和冒号，例如：</p><script type="math/tex; mode=display">f:\R\mapsto \Z \tag{1.2}</script><p>读作：函数$f$接收一个实数输入，将其映射为一个整数。</p><p>箭头左边被称为函数的域，右边被称为目标。</p><p>可以将上式$(1.2)$，等价为如下表述：</p><script type="math/tex; mode=display">integer\quad f(real) \quad\quad  \leftarrow equivalent \rightarrow \quad \quad f:\R\mapsto \Z    \tag{1.3}</script><h2 id="逆映射（Inverse-Mappings）"><a href="#逆映射（Inverse-Mappings）" class="headerlink" title="逆映射（Inverse Mappings）"></a>逆映射（Inverse Mappings）</h2><p>对于一个函数$f:A\mapsto B$，$b=f(a)$，存在一个逆函数$f^{-1}:B\mapsto A$，$a=f^{-1}(b)$。</p><p>上述定义只在如下情况生效：</p><p>对任意$b\in B$，是一些点在$f$上的映射（即范围等于目标），如果只有一个这样的点（即只有一个$a$使得$f(a)=b$），这样的映射或函数被称为双射（bijections）。</p><p>例如有一群骑手和马，如果每个人可以骑一匹马，且每匹马都被一个人骑，则这样就被称为<strong>双射</strong>。</p><p>如果函数不满足双射，则它没有逆。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Fundamentals%20of%20Computer%20Graphics/%E5%8F%8C%E5%B0%84.png" width="50%"></p><p>一个双射函数例子：$f:\R\mapsto \R$，$f(x)=x^3$，则$f^{-1}=\sqrt[3]{x}$。</p><p>一个非双射函数的例子：$f:\R\mapsto \R$，$sqr(x)=x^2$。主要原因有两个：</p><ol><li>$x^2=(-x)^2$</li><li>$sqr(x)$无法找到一个负数与$x^2$映射。</li></ol><p>如果严格定义域的范围为$\R^+$，则$\sqrt{x}$是一个合法的双射。</p><h2 id="边界（Intervals）"><a href="#边界（Intervals）" class="headerlink" title="边界（Intervals）"></a>边界（Intervals）</h2><p>通常我们指定一个函数用于处理有严格限制范围的实数，含有这样的限制范围称为边界。</p><p>例如，一个$0-1$实数边界，不包含$0$和$1$，可以表示为$(0,1)$，它没有包含端点，称为<strong>开区间</strong>。</p><p>相应的，<strong>闭区间</strong>包含端点，用方括号表示：$[0,1]$。</p><p>这些符号可以混合使用，例如：$[0,1)$，$(0,1]$。</p><p>当写了一个边界$[a,b]$，则默认$a\le b$。</p><p>下图中有三种常见的区间表达方式：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Fundamentals%20of%20Computer%20Graphics/%E5%8C%BA%E9%97%B43%E7%A7%8D%E8%A1%A8%E8%BE%BE%E6%96%B9%E5%BC%8F.png" width="30%"></p><p>笛卡尔积也经常在边界中使用，例如，表示一个$3$维正立方体上的$x$点，可以表示：$x\in [0,1]^3$。</p><p>边界经常在集合的结合操作时用到：$\cap$交集（intersection），$\cup$并集（union），$-$差集（difference）。</p><ul><li>$\cap$交集是两个边界的共同点集，$[3,5)\cap[4,6]=[4,5)$。</li><li>$\cup$并集是两个边界均包含的点集，$[3,5)\cup[4,6]=[3,6]$。</li><li>差集与参与运算的集合顺序有关，返回值是左边集合含有而右边集合不含有，$[3,5)-[4,6]=[3,4)$，$[4,6]-[3,5)=[5,6]$。</li></ul><h2 id="对数（logarithms）"><a href="#对数（logarithms）" class="headerlink" title="对数（logarithms）"></a>对数（logarithms）</h2><p>对数常用在包含指数项的方程中。</p><p>通过定义，每个质数都有一个底（base）$a$，以$a$为底$x$的对数可表示为：$log_ax$，其本质是，$a$变为$x$所需要的指数，即：</p><script type="math/tex; mode=display">y=log_ax \leftrightarrow a^y=x \tag{1.4}</script><p>注意如下等式：</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}a^{log_a(x)} &= x;\\log_a(a^x) &= x;\\log_a(xy) &= log_ax+log_ay;\\log_a(x/y) &= log_ax-log_ay;\\log_ax &= log_ab\times log_bx;\\\end{aligned}\end{equation}\tag{1.5}</script><p>当应用微积分来计算对数时，通常会出现自然常数$e=2.718…..$。</p><p>以$e$为底被称为<strong>自然对数</strong>，通常可以简写为：$lnx\equiv log_ex$。</p><p>其中，符号$\equiv$表示在<strong>定义上相等</strong>。</p><p>很多领域会使用一个特殊的底（除了自然常数$e$）表示$logx$，例如天文学家以$10$为低，理论计算机科学家以$2$为低，由于计算机图形学是从其他领域引来的技术，因此需要避免这些简写。</p><p>对数和指数的导数解释了为什么自然对数被称为自然：</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}\frac{d}{dx}log_xa=\frac{1}{xlna}    \\\frac{d}{dx}a^x=a^xlna\end{aligned}\end{equation}\tag{1.6}</script><h1 id="二次方程解法（Solving-Quadratic-Equations）"><a href="#二次方程解法（Solving-Quadratic-Equations）" class="headerlink" title="二次方程解法（Solving Quadratic Equations）"></a>二次方程解法（Solving Quadratic Equations）</h1><p>二次方程一般可表示为：</p><script type="math/tex; mode=display">Ax^2+Bx+C=0 \tag{1.7}</script><p>其中，$x$是未知量，$A$，$B$和$C$是已知常量。</p><p>如果你想象一个$2$维$xy$图$y=Ax^2+Bx+C$，则上述方程的解$x$为$y$与$0$的交点。</p><p>由于$y=Ax^2+Bx+C$是一个抛物线，因此与$x$轴会有$0$，$1$或$2$个交点。</p><h2 id="求解过程"><a href="#求解过程" class="headerlink" title="求解过程"></a>求解过程</h2><ol><li>两边同除以$A$：</li></ol><script type="math/tex; mode=display">x^2+\frac{B}{A}x+\frac{C}{A}=0    \tag{1.8}</script><ol><li>配完全平方项：</li></ol><script type="math/tex; mode=display">\left(x+\frac{B}{2A}\right)^2-\frac{B^2}{4A^2}+\frac{C}{A}=0 \tag{1.9}</script><ol><li>将常量移动到方程右边，并开方：</li></ol><script type="math/tex; mode=display">x+\frac{B}{2A}=\pm \sqrt{\frac{B^2}{4A^2}-\frac{C}{A}}    \tag{1.10}</script><ol><li>两边同减去$\frac{B}{2A}$，并以$2A$为分母合并：</li></ol><script type="math/tex; mode=display">x=\frac{-B\pm\sqrt{B^2-4AC}}{2A}    \tag{1.11}</script><p>其中，$\pm$代表有两个解，一个是加号，一个是负号。</p><p>判断实根的方程是：$D\equiv B^2-4AC$。</p><ol><li>如果$D&gt;0$，则有两个实根。</li><li>如果$D=0$，则只有一个实根。</li><li>如果$D&lt;0$，则没有实根。</li></ol><h1 id="三角学（Trigonometry）"><a href="#三角学（Trigonometry）" class="headerlink" title="三角学（Trigonometry）"></a>三角学（Trigonometry）</h1><h2 id="角（Angles）"><a href="#角（Angles）" class="headerlink" title="角（Angles）"></a>角（Angles）</h2><p>虽然我们会认为角是理所当然的，但是我们应该回到它的定义上来，这样我们可以将角的概念扩展到球体上。</p><p>一个角被弧长所截单位圆的长度所定义。</p><p>一般取较小的角，因此所有角的范围为：$[-\pi,\pi]$。</p><p>由于一个单位圆的长度为$2\pi$，因此所截两个角的大小为$2\pi$。</p><p>弧长的单位为<strong>弧度制</strong>。</p><p>另一个单位为<strong>角度制</strong>。</p><p>$\pi$弧度等于$180^o$，$degrees=\frac{180}{\pi}radians$，$radians=\frac{\pi}{180}degrees$，</p><h2 id="三角函数（Trigonometric-Functions）"><a href="#三角函数（Trigonometric-Functions）" class="headerlink" title="三角函数（Trigonometric Functions）"></a>三角函数（Trigonometric Functions）</h2><p>给一个直角三角形（right triangle），$a$，$o$和$h$，其中$h$为斜边（hypotenuse），它们的关系可以由<strong>毕达哥拉斯定理（Pythagorean theorem）</strong>得出：$a^2+o^2=h^2$。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Fundamentals%20of%20Computer%20Graphics/%E6%AF%95%E8%BE%BE%E5%93%A5%E6%8B%89%E6%96%AF%E5%AE%9A%E7%90%86.png" width="30%"></p><p>$(a+o)^2=a^2+o^2+2ao$，$4$个三角形的面积$2ao$，因此：$h^2=a^2+o^2$。</p><p>三角函数：</p><ul><li>$\sin\phi\equiv \frac{o}{h}$</li><li>$\csc\phi\equiv \frac{h}{o}$</li><li>$\cos\phi\equiv \frac{a}{h}$</li><li>$\sec\phi\equiv \frac{h}{a}$</li><li>$\tan\phi\equiv \frac{o}{a}$</li><li>$\cot\phi\equiv \frac{a}{o}$</li></ul><h2 id="公式（Useful-Identities）"><a href="#公式（Useful-Identities）" class="headerlink" title="公式（Useful Identities）"></a>公式（Useful Identities）</h2><h3 id="移动公式（shifting-identities）"><a href="#移动公式（shifting-identities）" class="headerlink" title="移动公式（shifting identities）"></a>移动公式（shifting identities）</h3><ul><li>$\sin(-A)=-\sin A$</li><li>$\cos(-A)=\cos A$</li><li>$\tan(-A)=-\tan A$</li><li>$\sin(\pi/2-A)=\cos A$</li><li>$\cos(\pi/2-A)=\sin A$</li><li>$\tan(\pi/2-A)=\cot A$</li></ul><h3 id="毕达哥拉斯公式（Pythagorean-identities）"><a href="#毕达哥拉斯公式（Pythagorean-identities）" class="headerlink" title="毕达哥拉斯公式（Pythagorean identities）"></a>毕达哥拉斯公式（Pythagorean identities）</h3><ul><li>$\sin^2A+\cos^2A=1$</li><li>$\sec^2A-\tan^2A=1$</li><li>$\csc^2A-\cot^2A=1$</li></ul><h3 id="加法和减法公式（Addition-and-subtraction-identities）"><a href="#加法和减法公式（Addition-and-subtraction-identities）" class="headerlink" title="加法和减法公式（Addition and subtraction identities）"></a>加法和减法公式（Addition and subtraction identities）</h3><ul><li>$\sin(A+B)=\sin A\cos B+\cos A\sin B$</li><li>$\sin(A-B)=\sin A\cos B-\cos A\sin B$</li><li>$\sin(2A)=2\sin A\cos A$</li><li>$\cos(A+B)=\cos A\cos B-\sin A\sin B$</li><li>$\cos(A-B)=\cos A\cos B+\sin A\sin B$</li><li>$\cos(2A)=\cos^2 A-\sin^2 A$</li><li>$\tan(A+B)=\frac{\tan A+\tan B}{1-\tan A\tan B}$</li><li>$\tan(A-B)=\frac{\tan A-\tan B}{1+\tan A\tan B}$</li><li>$\tan(2A)=\frac{2\tan A}{1-\tan^2 A}$</li></ul><h3 id="半角公式（Half-angle-identities）"><a href="#半角公式（Half-angle-identities）" class="headerlink" title="半角公式（Half-angle identities）"></a>半角公式（Half-angle identities）</h3><ul><li>$\sin^2(A/2)=\frac{1-\cos A}{2}$</li><li>$\cos^2(A/2)=\frac{1+\cos A}{2}$</li></ul><h3 id="乘积公式（Product-identities）"><a href="#乘积公式（Product-identities）" class="headerlink" title="乘积公式（Product identities）"></a>乘积公式（Product identities）</h3><ul><li>$\sin A\sin B=-\frac{\cos(A+B)-\cos(A-B)}{2}$</li><li>$\sin A\cos B=\frac{\sin(A+B)+\sin(A-B)}{2}$</li><li>$\cos A\cos B=\frac{\cos(A+B)+\cos(A-B)}{2}$</li></ul><h3 id="正弦公式（Law-of-sines）"><a href="#正弦公式（Law-of-sines）" class="headerlink" title="正弦公式（Law of sines）"></a>正弦公式（Law of sines）</h3><ul><li>$\frac{\sin A}{a}=\frac{\sin B}{b}=\frac{\sin C}{c}$</li></ul><h3 id="余弦公式（Law-of-cosines）"><a href="#余弦公式（Law-of-cosines）" class="headerlink" title="余弦公式（Law of cosines）"></a>余弦公式（Law of cosines）</h3><ul><li>$c^2=a^2+b^2-2ab\cos C$</li></ul><h3 id="正切公式（Law-of-tangents）"><a href="#正切公式（Law-of-tangents）" class="headerlink" title="正切公式（Law of tangents）"></a>正切公式（Law of tangents）</h3><ul><li>$\frac{a+b}{a-b}=\frac{\tan(\frac{A+B}{2})}{\tan(\frac{A-B}{2})}$</li></ul><h3 id="三角形面积"><a href="#三角形面积" class="headerlink" title="三角形面积"></a>三角形面积</h3><ul><li>$S=\frac{1}{4}\sqrt{(a+b+c)(-a+b+c)(a-b+c)(a+b-c)}$</li><li>$S=\frac{1}{2}(x_ay_b+x_by_c+x_cy_a-x_ay_c-x_by_a-x_cy_b)$</li></ul><h2 id="重心坐标（Barycentric-Coordinates）"><a href="#重心坐标（Barycentric-Coordinates）" class="headerlink" title="重心坐标（Barycentric Coordinates）"></a>重心坐标（Barycentric Coordinates）</h2><p>三角形$3$个点$a,b,c$，点$p$可以表示为：$p=a+\beta(b-a)+\gamma(c-a)$</p><ol><li><p>简化后：$p=(1-\beta-\gamma)a+\beta b+\gamma c$</p></li><li><p>$\alpha=1-\beta-\gamma$</p></li><li><p>若$0&lt;\alpha,\beta,\gamma&lt;1$，则点$p$在三角形内</p></li><li><p>如果$\alpha,\beta,\gamma$中有一个为 $0$，其他两个在 $0$ 和 $1$ 之间，则该点在边上。</p><p> 如果$\alpha,\beta,\gamma$中有两个个为 $0$，另外一个在 $0$ 和 $1$ 之间，则该点在顶点上。</p></li><li><p>重心坐标的求解</p><ol><li>解线性方程</li></ol></li></ol><script type="math/tex; mode=display">p=(1-\beta-\gamma)a+\beta b+\gamma c  \tag{1.12}</script><script type="math/tex; mode=display">\left[ \begin{matrix}   x_b-x_a & x_c-x_a \\   y_b-y_a & y_c-y_a \\  \end{matrix}  \right]   \left[ \begin{matrix}    \beta \\  \gamma \\  \end{matrix}  \right]  =  \left[ \begin{matrix}    x_p-x_a \\  y_p-y_a \\  \end{matrix}  \right]  \tag{1.13}</script><p>​         2. 几何方法</p><script type="math/tex; mode=display">f_{ab}(x,y)\equiv (y_a-y_b)x+(x_b-x_a)y+x_ay_b-x_by_a=0    \tag{1.14}</script><script type="math/tex; mode=display">\gamma = \frac{(y_a-y_b)x+(x_b-x_a)y+x_ay_b-x_by_a}{(y_a-y_b)x_c+(x_b-x_a)y_c+x_ay_b-x_by_a}    \tag{1.15}</script><script type="math/tex; mode=display">\beta = \frac{(y_a-y_c)x+(x_c-x_a)y+x_ay_c-x_cy_a}{(y_a-y_c)x_c+(x_c-x_a)y_c+x_ay_c-x_cy_a}    \tag{1.16}</script><script type="math/tex; mode=display">\alpha=1-\beta-\gamma \tag{1.17}</script><p>​         3. 面积法</p><script type="math/tex; mode=display">\alpha = A_a/A,\quad \beta=A_b/A,\quad \gamma=A_c/A    \tag{1.18}</script><p>​         4. 3D</p><script type="math/tex; mode=display">n=(b-a)\times(c-a) \\area=\frac{1}{2}\|(b-a)\times(c-a)\| \\a\cdot b=\|a\|\|b\|\cos\phi \\n_a=(c-b)\times(p-b) \\n_b=(a-c)\times(p-c) \\n_c=(b-a)\times(p-a) \\\alpha = \frac{n\cdot n_a}{\|n\|^2}    \\\beta = \frac{n\cdot n_b}{\|n\|^2}    \\\gamma = \frac{n\cdot n_c}{\|n\|^2}    \tag{1.19}</script><h1 id="向量（Vector）"><a href="#向量（Vector）" class="headerlink" title="向量（Vector）"></a>向量（Vector）</h1><h2 id="点乘（Dot-Product）"><a href="#点乘（Dot-Product）" class="headerlink" title="点乘（Dot Product）"></a>点乘（Dot Product）</h2><p>几何形式：$a\cdot b=|a||b|\cos \phi$</p><p>坐标形式：$a\cdot b=x_ax_b+y_ay_b+z_az_b$</p><p>投影计算（$a$在$b$上的投影）：$a\rightarrow b=|a|\cos\phi=\frac{a\cdot b}{|b|}$</p><h2 id="叉乘（Cross-Product）"><a href="#叉乘（Cross-Product）" class="headerlink" title="叉乘（Cross Product）"></a>叉乘（Cross Product）</h2><p>几何形式：$|a\times b|=|a||b|\sin\phi$，方向：四指与$a$同方向，之后转向$b$，则大拇指的方向就是$a\times b$的方向。</p><p>坐标形式：$a\times b=(y_az_b-z_ay_b,z_ax_b-x_az_b,x_ay_b-y_ax_b)$</p><h2 id="单位正交基（Orthonormal-bases）"><a href="#单位正交基（Orthonormal-bases）" class="headerlink" title="单位正交基（Orthonormal bases）"></a>单位正交基（Orthonormal bases）</h2><p>$2$维单位正交基$u$，$v$，满足：$|u|=|v|=1$，$u\cdot v=0$。</p><p>$3$维单位正交基$u$，$v$，$w$，满足：$|u|=|v|=|w|=1$，$u\cdot v=v\cdot w=w\cdot u=0$，$w=u\times v$。</p><p>在$3$维坐标系下，若$u,v,w$为单位正交基，$b(u_b,v_b,w_b)$可以通过坐标点乘来获取相应的系数：</p><p>$u\cdot b=u_b(u\cdot u)+v_b(v\cdot v)+w_b(w\cdot w)=u_b$</p><h2 id="向量构造基（Constructing-a-Basis）"><a href="#向量构造基（Constructing-a-Basis）" class="headerlink" title="向量构造基（Constructing a Basis）"></a>向量构造基（Constructing a Basis）</h2><h3 id="单向量构造基（Constructing-a-Basis-from-a-Single-Vector）"><a href="#单向量构造基（Constructing-a-Basis-from-a-Single-Vector）" class="headerlink" title="单向量构造基（Constructing a Basis from a Single Vector）"></a>单向量构造基（Constructing a Basis from a Single Vector）</h3><p>给定一个向量$a$，构造单位正交基$u,v,w$，其中$w$与$a$方向一致。</p><ol><li>取$w=\frac{a}{|a|}$。</li><li>选择一个向量$t$，不与$w$重合，通常是令$w$的坐标中值最小的那个基为$1$，例如$w=(1/\sqrt{2},-1/\sqrt{2},0)$，则$t=(1/\sqrt{2},-1/\sqrt{2},1)$，使用叉乘获取$u=\frac{t\times w}{|t\times w|}$。</li><li>计算$v=w\times u$。</li></ol><h3 id="双向量构造基（Constructing-a-Basis-from-Two-Vectors）"><a href="#双向量构造基（Constructing-a-Basis-from-Two-Vectors）" class="headerlink" title="双向量构造基（Constructing a Basis from Two Vectors）"></a>双向量构造基（Constructing a Basis from Two Vectors）</h3><p>给定两个向量$a$和$b$（不重合），构造单位正交基$u,v,w$，其中$w$与$a$方向一致。</p><ol><li>取$w=\frac{a}{|a|}$。</li><li>$u=\frac{b\times w}{|b\times w|}$。</li><li>$v=w\times u$。</li></ol><h1 id="曲线和曲面（Curves-and-Surfaces）"><a href="#曲线和曲面（Curves-and-Surfaces）" class="headerlink" title="曲线和曲面（Curves and Surfaces）"></a>曲线和曲面（Curves and Surfaces）</h1><h2 id="2维隐式曲线（2D-Implicit-Curves）"><a href="#2维隐式曲线（2D-Implicit-Curves）" class="headerlink" title="2维隐式曲线（2D Implicit Curves）"></a>2维隐式曲线（2D Implicit Curves）</h2><p>$f(x,y)=0$</p><h2 id="2维梯度（The-2D-Gradient）"><a href="#2维梯度（The-2D-Gradient）" class="headerlink" title="2维梯度（The 2D Gradient）"></a>2维梯度（The 2D Gradient）</h2><p>$\nabla f(x,y)=\left(\frac{\partial f}{\partial x},\frac{\partial f}{\partial y}\right)$</p><p>$\frac{\partial f}{\partial f}\equiv \lim\limits_{\Delta x\to0}\frac{f(x+\Delta x,y)-f(x,y)}{\Delta x}  $</p><h2 id="2维直线方程"><a href="#2维直线方程" class="headerlink" title="2维直线方程"></a>2维直线方程</h2><p>直线方程：$Ax+By+C=0$</p><p><strong>求$A,B,C$的值：</strong></p><ol><li><p>直线的梯度为：$\nabla f(x,y)=\left(\frac{\partial f}{\partial x},\frac{\partial f}{\partial y}\right)=(A,B)$</p></li><li><p>对于两个点$(x_0,y_0)$和$(x_1,y_1)$，则直线向量为$(x_1-x_0,y_1-y_0)$，由于直线的梯度与直线的向量垂直，则可以求出：$(A,B)=(y_0-y_1,x_1-x_0)$</p></li><li><p>带入$(x_0,y_0)$，求出：$C=x_0y_1-x_1y_0$</p></li><li><p>最后得到直线方程：$(y_0-y_1)x+(x_1-x_0)y+x_0y_1-x_1y_0=0$</p></li><li>归一化：$f(x,y)=\frac{y_0-y_1}{\sqrt{(x_1-x_0)^2+(y_0-y_1)^2}}x+\frac{x_1-x_0}{\sqrt{(x_1-x_0)^2+(y_0-y_1)^2}}y+\frac{x_0y_1-x_1y_0}{\sqrt{(x_1-x_0)^2+(y_0-y_1)^2}}$</li></ol><p>斜截式形式：$y=\frac{y_1-y_0}{x_1-x_0}x+\frac{x_1y_0-x_0y_1}{x_1-x_0}$</p><p><strong>求点到直线的距离：</strong></p><ol><li>直线梯度向量$AB$可以求出其长度为：$\sqrt{A^2+B^2}$</li><li>则直线外任意一点到该直线的距离为$k$倍的梯度向量$AB$模长：$distance=k\sqrt{A^2+B^2}$</li><li>任意点可表示为$(a,b)=(x,y)+k(A,B)$，其值为：$f(x+kA,y+kB)=Ax+kA^2+By+kB^2+C$</li><li>由于$(x,y)$为直线上一点，所以$f(x,y)=Ax+By+C=0$，所以$f(x+kA,y+kB)=k(A^2+B^2)$</li><li>最后得出该点到直线的距离为：$distance=\frac{f(a,b)}{\sqrt{A^2+B^2}}$</li></ol><h2 id="3维隐式曲面（3D-Implicit-Surfaces）"><a href="#3维隐式曲面（3D-Implicit-Surfaces）" class="headerlink" title="3维隐式曲面（3D Implicit Surfaces）"></a>3维隐式曲面（3D Implicit Surfaces）</h2><p>$f(x,y,z)=0$</p><h2 id="3维梯度（The-3D-Gradient）"><a href="#3维梯度（The-3D-Gradient）" class="headerlink" title="3维梯度（The 3D Gradient）"></a>3维梯度（The 3D Gradient）</h2><p>$n=\nabla f(p)=\left(\frac{\partial f(p)}{\partial x},\frac{\partial f(p)}{\partial y},\frac{\partial f(p)}{\partial z}\right)$</p><p>$n$为$p$的法向量</p><h1 id="线性插值（Linear-Interpolation）"><a href="#线性插值（Linear-Interpolation）" class="headerlink" title="线性插值（Linear Interpolation）"></a>线性插值（Linear Interpolation）</h1><p>$p=(1-t)a+tb$</p><p>$f(x)=y_i+\frac{x-x_i}{x_{i+1}-x_i}(y_{i+1}-y_i)$</p><p>$t=\frac{x-x_i}{x_{i+1}-x_i}$</p>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
            <tag> 基础学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多项式求解</title>
      <link href="/2020/08/04/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E8%A7%A3/"/>
      <url>/2020/08/04/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>求解一条直线与一个平面之间的交点，通常需要计算一个关于$t$的$n$阶多项式的根。</p><p>直线的表达式：$P(t)=S+tV$</p><ul><li>由平面组成的表面，多项式的阶数为$1$；</li><li>由球面或者圆柱面等二次曲面组成的表面，多项式的阶数为$2$；</li><li>对于更复杂的表面，如<strong>样条曲面</strong>和<strong>圆环面</strong>，多项式的阶数为$3$或$4$。</li></ul><p>本文介绍<strong>二次、三次和四次多项式</strong>的解析，同时介绍<strong>牛顿迭代法</strong>。</p><a id="more"></a><h1 id="二次多项式"><a href="#二次多项式" class="headerlink" title="二次多项式"></a>二次多项式</h1><p>二次多项式求解过程：</p><script type="math/tex; mode=display">at^2+bt+c=0 \tag{1}</script><p>两边减$c$，再除以$a$，可得：</p><script type="math/tex; mode=display">t^2+\frac{b}{a}t=-\frac{c}{a}    \tag{2}</script><p>方程两边同加$\frac{b^2}{4a^2}$，可将左边成为完全平方式的展开形式：</p><script type="math/tex; mode=display">t^2+\frac{b}{a}t+\frac{b^2}{4a^2}=-\frac{c}{a}+\frac{b^2}{4a^2} \tag{3}</script><p>将左边写成平方的形式，右边利用公分母通分，可得：</p><script type="math/tex; mode=display">\left(t+\frac{b}{2a}\right)^2=\frac{b^2-4ac}{4a^2}    \tag{4}</script><p>求平方根，并从方程两边同减$\frac{b}{2a}$，可得：</p><script type="math/tex; mode=display">t=\frac{-b\pm \sqrt{b^2-4ac}}{2a}    \tag{5}</script><p>令$D=b^2-4ac$，称为多项式解的判别式：</p><ol><li>若$D&gt;0$，则多项式有两个实根；</li><li>若$D=0$，则多项式有一个实根；</li><li>若$D&lt;0$，则多项式没有实根；</li></ol><p>利用判别式，可以在不计算光线与对象表面的实际交点的情况下，判断光线与对象表面的相交情况。</p><h1 id="三次多项式"><a href="#三次多项式" class="headerlink" title="三次多项式"></a>三次多项式</h1><p>三次多项式求解过程：</p><script type="math/tex; mode=display">t^3+at^2+bt+c=0    \tag{6}</script><p>令$t=x-\frac{a}{3}$，则可以消去二次项，因为：</p><script type="math/tex; mode=display">\left(x-\frac{a}{3}\right)^3=x^3-3x^2\times \frac{a}{3}+3x\times\frac{a^2}{9}-\frac{a^3}{27}=x^3-ax^2+\frac{a^2x}{3}-\frac{a^3}{27}    \tag{7}</script><p>带入后可得表达式为：</p><script type="math/tex; mode=display">x^3+px+q=0    \tag{8}</script><p>其中：</p><script type="math/tex; mode=display">p=-\frac{1}{3}a^2+b     \tag{9}</script><script type="math/tex; mode=display">q=-\frac{2}{27}a^3-\frac{1}{3}ab+c    \tag{10}</script><p>故可先求解$x$，将其减去$\frac{a}{3}$可得到解$t$。</p><p>三次多项式的解的判别式$D$如下：</p><script type="math/tex; mode=display">D=-4p^3-27q^2    \tag{11}</script><p>令：</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}    r &= \sqrt[3]{-\frac{1}{2}q+\sqrt{-\frac{1}{108}D}}    \\    s &= \sqrt[3]{-\frac{1}{2}q-\sqrt{-\frac{1}{108}D}}\end{aligned}\end{equation}\tag{12}</script><p>则方程$(8)$的三个复数根为：</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}    x_1 &= r + s    \\    x_2 &= \rho r + \rho^2s \\    x_3 &= \rho^2r + \rho s\end{aligned}\end{equation}\tag{13}</script><p>这里$\rho$是完全立方根，$\rho=-\frac{1}{2}+\frac{\sqrt{3}}{2}i$，而$\rho^2=-\frac{1}{2}-\frac{\sqrt{3}}{2}i$。</p><p>通过以下替代，可以化简根的判别式$D$：</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}    p'&=\frac{p}{3}=-\frac{1}{9}a^2+\frac{1}{3}b    \\    q'&=\frac{q}{2}=\frac{1}{27}a^3-\frac{1}{6}ab+\frac{1}{2}c\end{aligned}\end{equation}\tag{14}</script><p>替换后，$D$的表达式：</p><script type="math/tex; mode=display">D=-108(p'^3+q'^2)    \tag{15}</script><p>令：</p><script type="math/tex; mode=display">D'=\frac{D}{108}=-(p'^3+q'^2)    \tag{16}</script><p>则$r$和$s$可表示为：</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}    r &= \sqrt[3]{-q'+\sqrt{-D'}}    \\    s &= \sqrt[3]{-q'-\sqrt{-D'}}\end{aligned}\end{equation}\tag{17}</script><p>对于判别式$D’$：</p><ol><li>若$D’&lt;0$，则方程$(8)$仅有一个实数根，为式$(13)$中的$x_1$；</li><li>若$D’=0$，则$r=s$，则方程$(8)$有两个不同实数根，$x_1=2r$，$x_2,x_3=(\rho+\rho^2)r=-r$；</li><li>若$D’&gt;0$，则方程$(8)$有三个不同实数根，为式$(13)$中所述，需要进行复数运算求解。</li></ol><p>下面讲解巧妙方法求解三个不同根，主要利用三角恒等式（可用欧拉公式验证：$e^{\alpha i} =\cos\alpha+i\sin\alpha$）：</p><script type="math/tex; mode=display">4\cos^3\theta-3\cos\theta=\cos(3\theta)    \tag{18}</script><p>令$m=\sqrt{-\frac{p}{3}}$，将$x=2m\cos\theta$，带入方程$(8)$，可得：</p><script type="math/tex; mode=display">8m^3\cos^3\theta+2pm\cos\theta+q=0    \tag{19}</script><p>为了保证$D’$是正数，$p$必须是负数，令$p=-3m^2$，同时提取前两项公因数$2m^3$，可得：</p><script type="math/tex; mode=display">2m^3(4\cos^3\theta-3\cos\theta)+q=0    \tag{20}</script><p>带入式$(18)$，求解该关于$\cos3\theta$的方程，可得：</p><script type="math/tex; mode=display">\cos3\theta=\frac{-q}{2m^3}=\frac{-q/2}{\sqrt{-p^3/27}}=\frac{-q'}{\sqrt{-p'^3}}    \tag{21}</script><p>由于$D’&gt;0$，则从式$(16)$可得：$q’^2&lt;-p’^3$，因此，可保证式$(21)$右边的绝对值总小于$1$。</p><p>由反余弦函数的定义，可以求出$\theta$：</p><script type="math/tex; mode=display">\theta=\frac{1}{3}\cos^{-1}\left(\frac{-q'}{\sqrt{-p'^3}}\right)    \tag{22}</script><p>因此，方程$(8)$的一个解为：</p><script type="math/tex; mode=display">x_1=2m\cos\theta=2\sqrt{-p'}\cos\theta    \tag{23}</script><p>对任意整数$k$，$\cos(3\theta+2\pi k)=\cos(3\theta)$，可得：</p><script type="math/tex; mode=display">\theta_k=\frac{1}{3}\cos^{-1}\left(\frac{-q'}{\sqrt{-p'^3}}\right)-\frac{2\pi}{3}k    \tag{24}</script><p>通过选择$3$个分别与$0,1,2$除以$3$同余的不同整数$k$，可以获得$\cos\theta_k$的$3$个不同值。</p><p>则令$k=\pm 1$，可得方程$(8)$的两个解，最后整理可以得到三个解为：</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}    x_1 &= 2\sqrt{-p'}\cos\theta\\    x_2 &= 2\sqrt{-p'}\cos(\theta+\frac{2\pi}{3})\\    x_3 &= 2\sqrt{-p'}\cos(\theta-\frac{2\pi}{3})\end{aligned}\end{equation}\tag{25}</script><h1 id="四次多项式"><a href="#四次多项式" class="headerlink" title="四次多项式"></a>四次多项式</h1><p>四次多项式求解过程：</p><script type="math/tex; mode=display">t^4+at^3+bt^2+ct+d=0    \tag{26}</script><p>令$t=x-\frac{a}{4}$，可将三次项消去，带入式中可得：</p><script type="math/tex; mode=display">x^4+px^2+qx+r=0    \tag{27}</script><p>其中：</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}    p &= -\frac{3}{8}a^2+b\\    q &= \frac{1}{8}a^3-\frac{1}{2}ab+c\\    r &= -\frac{3}{256}a^4+\frac{1}{16}a^2b-\frac{1}{4}ac+d\end{aligned}\end{equation}\tag{28}</script><p>要获取四次方程的根，首先需求解以下三次方程的根：</p><script type="math/tex; mode=display">y^3-\frac{p}{2}y^2-ry+\frac{4rp-q^2}{8}=0    \tag{29}</script><p>令$y$是该方程的任意实数解：</p><ol><li>若$q\ge 0$，则四次方程的解等于以下两个二次方程的解：</li></ol><script type="math/tex; mode=display">\begin{equation}\begin{aligned}    x^2+x\sqrt{2y-p}+y-\sqrt{y^2-r} &= 0\\    x^2-x\sqrt{2y-p}+y+\sqrt{y^2-r} &= 0\end{aligned}\end{equation}\tag{30}</script><ol><li>若$q&lt;0$，则四次方程的解等于以下两个二次方程的解：</li></ol><script type="math/tex; mode=display">\begin{equation}\begin{aligned}    x^2+x\sqrt{2y-p}+y+\sqrt{y^2-r} &= 0\\    x^2-x\sqrt{2y-p}+y-\sqrt{y^2-r} &= 0\end{aligned}\end{equation}\tag{31}</script><h1 id="牛顿迭代法"><a href="#牛顿迭代法" class="headerlink" title="牛顿迭代法"></a>牛顿迭代法</h1><p>牛顿迭代法（Newton-Raphson），是求任意连续函数的根的数值计算方法。</p><p>该方法通过将与该函数及其导数相关的一个公式进行迭代计算而获得所需的根。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>对于下图中所示的函数$f$，计算它的根。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/3D%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%87%A0%E4%BD%95%E5%AD%A6/img11.png" width="50%"></p><p>假设已知该函数的一个初始猜测根$x_0$，函数$f$的曲线在点$(x_0,f(x_0))$的切线的斜率等于导数$f’(x_0)$，根据直线的点斜式表示法，可得切线方程的表达式：</p><script type="math/tex; mode=display">y-f(x_0)=f'(x_0)(x-x_0)    \tag{32}</script><p>可以看出，该切线与$x$轴的交点距离函数$f$的真正根比初始猜测值$x_0$更近。</p><p>当$y=0$时，可求得：</p><script type="math/tex; mode=display">x_{i+1}=x_i-\frac{f(x_i)}{f'(x_i)}    \tag{33}</script><p>其中，将$x$表示成$x_{i+1}$，$x_0$表示成$x_i$。</p><p>重复式$(33)$可得到一个数值系列$x_0，x_1，x_2，…$，在正确条件下，该数值系列逐渐逼近函数$f$的根。</p><p>牛顿迭代法收敛的速度非常快，经过很少的几步迭代就可达到所需的精度，具有<strong>平方收敛</strong>的特性。</p><p>【证明】</p><p>首先，令：</p><script type="math/tex; mode=display">g(x)=\frac{f(x)}{f'(x)}    \tag{34}</script><p>再令$r$是函数$f$的实际根，即<strong>收敛目标</strong>，定义$\varepsilon_i$为第$i$个近似值$x_i$与根$r$之间的误差。</p><script type="math/tex; mode=display">\varepsilon_i=x_i-r    \tag{35}</script><p>带入式$(33)$得：</p><script type="math/tex; mode=display">\varepsilon_{i+1}=\varepsilon_i-g(x_i)    \tag{36}</script><p>可用Taylor级数的前三项近似表示函数$g(x_i)$：</p><script type="math/tex; mode=display">g(x_i)=g(r+\varepsilon_i)\approx g(r)+\varepsilon_ig'(r)+\frac{\varepsilon_i^2}{2}g''(r)    \tag{37}</script><p>函数$g(x)$的一阶和二阶导数如下式：</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}    g'(x) &= 1-\frac{f(x)f''(x)}{[f'(x)]^2}\\    g''(x) &= \frac{2f(x)f'(x)[f''(x)]^2-[f'(x)]^2[f(x)f'''(x)+f'(x)f''(x)]}{[f'(x)]^4}\end{aligned}\end{equation}\tag{38}</script><p>由于$f(r)=0$，以上表达式在$x=r$时，可很大程度地简化。</p><p>函数$g$及其一阶和二阶导数在$r$处的值如下：</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}    g(r) &= 0\\    g'(r) &= 1    \\    g''(r) &= -\frac{f''(r)}{f'(r)}\end{aligned}\end{equation}\tag{39}</script><p>将以上值带入方程$(37)$，可得：</p><script type="math/tex; mode=display">g(x_i)\approx \varepsilon_i-\frac{\varepsilon_i^2}{2}\frac{f''(r)}{f'(r)}    \tag{40}</script><p>最后，将上式带入方程$(36)$可得：</p><script type="math/tex; mode=display">\varepsilon_{i+1}\approx \frac{\varepsilon_i^2}{2}\frac{f''(r)}{f'(r)}    \tag{41}</script><p>【注意】</p><ul><li>牛顿迭代法不能总是保证收敛到方程的一个解。</li><li>当初始猜测值被选在函数导数为$0$的一点时，该点的切线是水平的，不与$x$轴相交，迭代中止。</li><li>为了保证收敛，尽量选在离函数的真实根近的初始猜测值。</li><li>当计算光线与一个复杂对象表面的交点时，通常首先计算光线与复杂对象的包围盒的交点，并以该点对应的数值作为初始猜测值。（例如：如果计算光线$P(t)=S+tV$与圆环的交点，可首先计算光线与圆环的包围盒的交点处的$t$值，并将其作为与圆环交点的初始猜测值。）</li></ul><h1 id="倒数与平方根的精细化"><a href="#倒数与平方根的精细化" class="headerlink" title="倒数与平方根的精细化"></a>倒数与平方根的精细化</h1><p>现代大多数CPU和图形硬件都具有倒数和平方根倒数的近似计算指令，可将一个数的倒数和平方根倒数近似到至少几位的精度，这些指令产生的结果可用牛顿迭代法精确到更高的精度。</p><p>通过计算以下方程的根可得到一个数$r$的倒数：</p><script type="math/tex; mode=display">f(x)=x^{-1}-r    \tag{42}</script><p>由于$f(\frac{1}{r})=0$，带入方程$(33)$得：</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}    x_{n+1}    &= x_n-\frac{x_n^{-1}-r}{-x_n^{-2}}    \\                    &= x_n(2-rx_n)\end{aligned}\end{equation}\tag{43}</script><p>若$x_i&gt;0$，对该式进行迭代可获得数$r$的高精度倒数，这是因为函数$f(x)$在$x=0$处为<strong>奇点</strong>。</p><p>利用该条件，由第一次迭代的计算结果$x_1$可知初始近似值$x_0$的所在区间。</p><p>由于$x_1$必定大于$0$，则有：</p><script type="math/tex; mode=display">x_0(2-rx_0)>0    \tag{44}</script><p>由上式可知$x_0$的约束条件：</p><script type="math/tex; mode=display">0<x_0<\frac{2}{r}    \tag{45}</script><p>因此，初始近似值不能大于$r$的倒数的两倍。</p><p>一个数$r$的平方根的倒数可通过计算以下方程的正根得到：</p><script type="math/tex; mode=display">f(x)=x^{-2}-r    \tag{46}</script><p>将上式带入方程$(33)$得：</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}    x_{n+1}    &= x_n-\frac{x_n^{-2}-r}{-2x_n^{-3}}    \\                    &= \frac{1}{2}x_n(3-rx_n^2)\end{aligned}\end{equation}\tag{47}</script><p>如果所有$x_i&gt;0$，则该序列收敛，初始近似值$x_0$必须满足下式：</p><script type="math/tex; mode=display">0<x_0<\sqrt{\frac{3}{r}}    \tag{48}</script><p>一旦平方根的倒数达到所要的精度，数$r$的平方根可通过一次乘法得到，这是因为$\sqrt{r}=r\cdot(1/\sqrt{r})$。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
          <category> 数学概念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 多项式求解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视锥</title>
      <link href="/2020/07/27/%E8%A7%86%E9%94%A5/"/>
      <url>/2020/07/27/%E8%A7%86%E9%94%A5/</url>
      
        <content type="html"><![CDATA[<p>三维空间中，视锥是包含所有可视内容的空间体。</p><p>视锥的形状像一个四棱锥，其顶点位于虚拟相机，表示相机通过一个矩形框看到的空间，这个矩形框就是计算机屏幕。</p><p>视锥的边界由$6$个平面组成，其中$4$个与屏幕的边对应，分别称为左锥面、右锥面、顶锥面和底锥面，其余$2$个平面分别称为近锥面和远锥面，这两个锥平面定义了场景中可见对象对相机可见的最近和最远距离。</p><p>视锥与相机空间（视察空间）对齐，相机位于坐标原点，$x$轴向右，$y$轴向上，$z$轴方向则与$3D$图形库有关（OpenGL中$z$轴方向与相机指向相反：右手坐标系，DirectX3D中$z$轴方向与相机指向相同：左手坐标系）。</p><a id="more"></a><h1 id="视场"><a href="#视场" class="headerlink" title="视场"></a>视场</h1><p>投影平面是一个与相机指向垂直的平面，该平面与相机的距离为$e$（焦距），左锥面与右锥面分别与该平面在$x=-1$和$x=1$处相交，两锥面之间的夹角$\alpha$被称为水平视场角。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/3D%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%87%A0%E4%BD%95%E5%AD%A6/img7.png" width="40%"></p><p>对于给定的水平视场角$\alpha$，到投影平面的距离$e$可由以下三角关系表达式给出：</p><script type="math/tex; mode=display">e=\frac{1}{\tan{(\alpha/2)}}    \tag{1}</script><p>焦距越短，则视场越大。视场角越小，相机则进行放大成像，焦距变大。</p><p>底锥面和顶锥面与投影平面在$y=\pm a$处相交，$a$为显示器的高宽比，如下图三角形所示，则垂直视场角$\beta$的表达式如下：</p><script type="math/tex; mode=display">\beta=2\tan^{-1}(a/e)    \tag{2}</script><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/3D%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%87%A0%E4%BD%95%E5%AD%A6/img8.png" width="60%"></p><p>视锥的$4$个边平面在从投影平面切出一个长方形，该长方形与相机距离为$e$，它的四条边分别位于$x=\pm 1$和$y=\pm a$处。</p><p>在OpenGL中，函数<code>glFrustum()</code>需要用户定义一个与相机距离为$n$的长方形，其中$n$是近锥面距离。</p><p>用比例系数$\frac{n}{e}$缩放该长方形，则它的左边位于$x=-\frac{n}{e}$，右边位于$x=\frac{n}{e}$，底边位于$y=-\frac{an}{e}$，顶边位于$y=\frac{an}{e}$。</p><h1 id="锥平面"><a href="#锥平面" class="headerlink" title="锥平面"></a>锥平面</h1><p>$6$个视锥平面在相机空间的法向量如下图所示，其中$4$个边锥平面的法向量向内，指向视锥内部，可以通过将边平面中的边的方向向里旋转$90^o$获得。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/3D%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%87%A0%E4%BD%95%E5%AD%A6/img9.png" width="40%"></p><p>由于每个边锥平面都经过坐标系原点，其平面四维表达式中的$D=0$。</p><ul><li>近锥面与原点距离为$n$，与原点的相对方向与其法向量相同，所以$D=-n$。</li><li>远锥面与原点距离为$f$，与原点的相对方向与其法向量相反，所以$D=f$。</li></ul><p>下表总结了视锥的$6$个锥平面的四维平面表示向量，其中$4$个边锥平面的法向量已经规范化成长度为单位长度的向量。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/3D%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%87%A0%E4%BD%95%E5%AD%A6/img10.png"></p><p>其中，$e$为焦距，$a$为高宽比，$n$为近锥面距离，$f$为远锥面距离。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
          <category> 数学概念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
            <tag> 三维空间 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 视锥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三维空间中的平面</title>
      <link href="/2020/07/25/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E4%B8%AD%E7%9A%84%E5%B9%B3%E9%9D%A2/"/>
      <url>/2020/07/25/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E4%B8%AD%E7%9A%84%E5%B9%B3%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>一个三维点$P$与法向量$N$，则过点$P$并与$N$垂直的平面可以定义为满足$N\cdot (Q-P)=0$的点$Q$的集合。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/3D%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%87%A0%E4%BD%95%E5%AD%A6/img3.png" width="40%"></p><p>平面方程通常表示为：$。Ax+By+Cz+D=0$，其中，$A$，$B$和$C$是法向量$N$的$x$，$y$和$z$分量，$D=-N\cdot P$。</p><p>值$\frac{|D|}{|N|}$是过原点与该平面平行的平面到该平面的偏移距离。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/3D%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%87%A0%E4%BD%95%E5%AD%A6/img4.png" width="40%"></p><p>法向量$N$通常规范化为单位长度，可使以下方程成立：</p><script type="math/tex; mode=display">d=N\cdot Q+D \tag{1}</script><p>$d$为从任一点$Q$到该平面的符号距离。</p><ul><li>若$d=0$，则点$Q$位于平面上；</li><li>若$d&gt;0$，则点$Q$位于平法向量所指的一侧；</li><li>若$d&lt;0$，则点$Q$位于平面的负向侧。</li></ul><p>平面可简单表示为一个四维向量的形式，用缩写符号$<n,d>$可表示由满足条件$N\cdot Q+D=0$的$Q$点组成的平面。</n,d></p><p>若将三维点看成$w$坐标为$1$的四维齐次坐标点，则可写成：$d=L\cdot Q$，其中：$L=<n,d>$，若$L\cdot Q=0$，则点$Q$位于平面上。</n,d></p><h1 id="直线和平面的交点"><a href="#直线和平面的交点" class="headerlink" title="直线和平面的交点"></a>直线和平面的交点</h1><p>求直线与平面交点在<strong>多边形裁剪</strong>中被广泛使用。</p><ul><li>令$P(t)=S+tV$表示包含点$S$并与方向$V$平行的直线。</li><li>用法向量$N$和到原点的符号距离$D$定义的平面。</li></ul><p>对以下关于$t$的方程求解，即可获得直线与平面的交点。</p><script type="math/tex; mode=display">N\cdot P(t)+D=0 \tag{2}</script><p>带入$P(t)=S+tV$，可得：</p><script type="math/tex; mode=display">N\cdot S+(N\cdot V)t+D=0 \tag{3}</script><p>可以求得$t$的结果，即：</p><script type="math/tex; mode=display">t=\frac{-(N\cdot S+D)}{N\cdot V} \tag{4}</script><p>将$t$带入直线方程$P(t)=S+tV$即可得到交点。</p><p>若$N\cdot V=0$，则直线与平面平行，平面法向量$N$与直线方向向量$V$垂直，此时，若$N\cdot S+D=0$，则直线位于平面内，否则无交点。</p><p>式$(4)$给出的$t$值可以写成四维平面表示形式，若平面的四维表示形式为$L=<n,d>$，则有：</n,d></p><script type="math/tex; mode=display">t=-\frac{L\cdot S}{L\cdot V} \tag{5}</script><p>由于$S$为一点，其$w$坐标为$1$，而$V$为方向向量，表示成齐次坐标时，其$w$坐标为$0$，因此可保证式$(4)$和式$(5)$成立。</p><h1 id="三个平面斜交"><a href="#三个平面斜交" class="headerlink" title="三个平面斜交"></a>三个平面斜交</h1><p>一个<strong>空间区域</strong>通常表示成<strong>由一系列平面为边界的凸多面体的形式</strong>，该多面体的边和顶点可以通过执行多次三个平面的求交运算得出。</p><p>令$L_1=<n_1,d_1>$，$L_2=<n_2,d_2>$和$L_3=<n_3,d_3>$为三个任意平面，通过以下方程组可以求出三个平面的交点。</n_3,d_3></n_2,d_2></n_1,d_1></p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}\left\{\begin{array}{**lr**}          L_1\cdot Q = 0  \\        L_2\cdot Q = 0  \\        L_3\cdot Q = 0\end{array}\right.\end{aligned}\end{equation}\tag{6}</script><p>写成矩阵形式：</p><script type="math/tex; mode=display">MQ=\left[\begin{matrix}    -D_1 \\    -D_2 \\    -D_3\end{matrix}\right]\tag{7}</script><p>矩阵$M$的表达式如下：</p><script type="math/tex; mode=display">M=\left[\begin{matrix}    (N_1)_x & (N_1)_y & (N_1)_z \\    (N_2)_x & (N_2)_y & (N_2)_z \\    (N_3)_x & (N_3)_y & (N_3)_z \\\end{matrix}\right]\tag{8}</script><p>假设矩阵$M$可逆，按下式可计算三个平面的唯一交点$Q$：</p><script type="math/tex; mode=display">Q=M^{-1}\left[\begin{matrix}    -D_1 \\    -D_2 \\    -D_3 \\\end{matrix}\right]\tag{9}</script><p>若矩阵$M$为奇异矩阵（即$detM=0$），这三个平面不相交于一点，此时三个平面法向量位于同一平面。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/3D%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%87%A0%E4%BD%95%E5%AD%A6/img5.png" width="40%"></p><p>当两个不平行的平面$L_1=<n_1,d_1>$和$L_2=<n_2,d_2>$相交于一条直线时，交线的方向$V$与两个平面的法向量都垂直，克表示为$V=N_1\times N_2$。</n_2,d_2></n_1,d_1></p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/3D%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%87%A0%E4%BD%95%E5%AD%A6/img6.png" width="50%"></p><p>为了获得交线的完整表达式，还需要直线上一点。构造经过原点法向量为$V$的第三个平面$L_3=<v,0>$，这可确保三个平面交于一点，该点即为两个不平行平面$L_1$和$L_2$交线上的一点。</v,0></p><p>利用式$(9)$可得到该点$Q$，表达式如下：</p><script type="math/tex; mode=display">Q=\left[\begin{matrix}    (N_1)_x & (N_1)_y & (N_1)_z \\    (N_2)_x & (N_2)_y & (N_2)_z \\    V_x & V_y & V_z\end{matrix}\right]^{-1}\left[\begin{matrix}    -D_1 \\    -D_2 \\    0\end{matrix}\right]\tag{10}</script><p>则平面$L_1$和$L_2$交线的表达式为$P(t)=Q+tV$。</p><h1 id="平面变换"><a href="#平面变换" class="headerlink" title="平面变换"></a>平面变换</h1><p>用一个$3\times 3$<strong>矩阵$M$</strong>和一个三维<strong>平移向量$T$</strong>去变换一个平面。</p><p>已知原始平面中一点$P$，变换后平面到原点的符号距离可通过下式计算：</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}    D' &= -[(M^{-1})^TN]\cdot(MP+T) \\       &= -[(M^{-1})^TN]^TMP-[(M^{-1})^TN]^TT \\       &= -N^TM^{-1}MP-N^TM^{-1}T \\       &= D-N\cdot M^{-1}T\end{aligned}\end{equation}\tag{11}</script><p>由$3\times 3$矩阵$M$和三维平移向量$T$合成的$4\times 4$矩阵$F$的逆矩阵表达式如下：</p><script type="math/tex; mode=display">F^{-1}=    \left[    \begin{array}{c|c}    M^{-1} & -M^{-1}T \\ \hline          0 &        1    \end{array}    \right]    =    \left[    \begin{array}{c|c}    \begin{matrix}    M_{11}^{-1} & M_{12}^{-1} & M_{13}^{-1} \\    M_{21}^{-1} & M_{22}^{-1} & M_{33}^{-1} \\    M_{31}^{-1} & M_{32}^{-1} & M_{33}^{-1}     \end{matrix}    &    \begin{matrix}    -(M^{-1}T)_x\\    -(M^{-1}T)_y\\    -(M^{-1}T)_z    \end{matrix}     \\ \hline      0   &   1    \end{array}    \right]    \tag{12}</script><p>其转置矩阵为：</p><script type="math/tex; mode=display">(F^{-1})^T=\left[    \begin{array}{c|c}    (M^{-1})^T & 0 \\ \hline          -M^{-1}T &     1    \end{array}    \right]    \tag{13}</script><p>可以看出：$D-N\cdot M^{-1}T$正好等于$(F^{-1})^T$的第四行与四维向量$<n_x,n_y,n_z,d>$之间的内积。</n_x,n_y,n_z,d></p><p>因此，平面的变换可以像三维法向量变换那样进行四维向量的变换，唯一不同的是平面变换中使用$4\times 4$逆转矩阵。</p><p>采用$4\times 4$矩阵的平面变换公式如下：</p><script type="math/tex; mode=display">L'=(F^{-1})^{T}L  \tag{14}</script>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
          <category> 数学概念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
            <tag> 三维空间 </tag>
            
            <tag> 平面 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三维空间中的直线</title>
      <link href="/2020/07/25/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E4%B8%AD%E7%9A%84%E7%9B%B4%E7%BA%BF/"/>
      <url>/2020/07/25/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E4%B8%AD%E7%9A%84%E7%9B%B4%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<p>3D空间中两点$P_1$和$P_2$，通过这两点的直线参数化表达式：$P(t)=(1-t)P_1+tP_2$。</p><p>此处，$t$可为任意实数，若连接$P_1$至$P_2$的线段，则$t$值为$[0,1]$。</p><p>射线只有一个端点$S$，并沿着某一方向$V$无限延伸，射线的参数方程为：$P(t)=S+tV$。</p><p>此处，$t$是大于等于$0$的实数。</p><p>若令$S=P_1$，$V=P_2-P_1$，则可表示为一条直线。</p><a id="more"></a><h1 id="点与直线间的距离"><a href="#点与直线间的距离" class="headerlink" title="点与直线间的距离"></a>点与直线间的距离</h1><p>已知由端点$S$和方向$V$定义的直线，从点$Q$到该直线的距离$d$等于向量$Q-S$中与该直线垂直的分量的大小。</p><p>根据毕达哥拉斯定理（Pythagorean定理），从点$Q$到直线距离的平方等于$Q-S$在方向$V$上投影的平方。</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}           d^2 &=(Q-S)^2-[proj_v(Q-S)]^2 \\                  &=(Q-S)^2-\left[\frac{(Q-S)\cdot V}{\|V\|}\cdot\frac{V}{\|V\|}\right]^2 \\\end{aligned}\end{equation}\tag{1}</script><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/3D%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%87%A0%E4%BD%95%E5%AD%A6/img1.png" width="40%"></p><h1 id="直线间的距离"><a href="#直线间的距离" class="headerlink" title="直线间的距离"></a>直线间的距离</h1><p>三维空间中两条直线关系：平行（点到直线距离）、相交（距离为$0$）和异面（下述方法求）。</p><p>【求异面直线距离】</p><p>假设有两条直线，参数化方程分别为：</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}          P_1(t_1)=S_1+t_1V_1 \\          P_2(t_2)=S_2+t_2V_2\end{aligned}\end{equation}\tag{2}</script><p>其中，$t_1$和$t_2$可为任意实数，则<strong>直线$P_1(t_1)$上的点与直线$P_2(t_2)$上的点之间的距离和平方</strong>可以写成如下表示：</p><script type="math/tex; mode=display">f(t_1,t_2)=\|P_1(t_1)-P_2(t_2)\|^2  \tag{3}</script><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/3D%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E5%87%A0%E4%BD%95%E5%AD%A6/img2.png" width="40%"></p><p>展开平方，并带入式$(2)$可得：</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}          f(t_1,t_2)&=P_1(t_1)^2+P_2(t_2)^2-2P_1(t_1)\cdot P_2(t_2) \\                    &=(S_1+t_1V_1)^2+(S_2+t_2V_2)^2\\                    &\quad-2(S_1\cdot S_2+t_1V_1\cdot S_2+t_2V_2\cdot S_1+t_1t_2V_1\cdot V_2) \\                    &=S_1^2+t_1^2V_1^2+2t_1S_1\cdot V_1+S_2^2+t_2^2V_2^2+2t_2S_2\cdot V_2\\                    &\quad-2(S_1\cdot S_2+t_1V_1\cdot S_2+t_2V_2\cdot S_1+t_1t_2V_1\cdot V_2)\end{aligned}\end{equation}\tag{4}</script><p>函数$f(t_1,t_2)$的最小值可以通过令其相对于$t_1$和$t_2$的偏导数为$0$得到，据此可得下式：</p><script type="math/tex; mode=display">\frac{\partial f}{\partial t_1}=2t_1V_1^2+2S_1\cdot V_1-2V_1\cdot S_2-2t_2V_1\cdot V_2=0 \tag{5}</script><p>和</p><script type="math/tex; mode=display">\frac{\partial f}{\partial t_2}=2t_2V_2^2+2S_2\cdot V_2-2V_2\cdot S_1-2t_1V_1\cdot V_2=0 \tag{6}</script><p>两边同时除以$2$，将以上等式写成矩阵形式：</p><script type="math/tex; mode=display">\left [\begin{matrix}        V_1^2 & -V_1\cdot V_2 \\        V_1\cdot V_2 & -V_2^2\end{matrix}\right ]\left [\begin{matrix}        t_1 \\        t_2 \end{matrix}\right ]=\left [\begin{matrix}        (S_2-S_1)\cdot V_1 \\        (S_2-S_1)\cdot V_2 \end{matrix}\right ]\tag{7}</script><p>两边左方同时乘以系数矩阵的逆矩阵，可解关于$t_1$和$t_2$的方程：</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}\left [\begin{matrix}        t_1 \\        t_2 \end{matrix}\right ]&=\left [\begin{matrix}        V_1^2 & -V_1\cdot V_2 \\        V_1\cdot V_2 & -V_2^2\end{matrix}\right ]^{-1}\left [\begin{matrix}        (S_2-S_1)\cdot V_1 \\        (S_2-S_1)\cdot V_2 \end{matrix}\right ]\\&= \frac{1}{(V_1\cdot V_2)^2-V_1^2V_2^2}\left [\begin{matrix}        -V_2^2 & V_1\cdot V_2 \\    -V_1\cdot V_2 &    V_1^2\end{matrix}\right ]\left [\begin{matrix}        (S_2-S_1)\cdot V_1 \\        (S_2-S_1)\cdot V_2 \end{matrix}\right ]\end{aligned}\end{equation}\tag{8}</script><p>将$t_1$和$t_2$的值带入函数$f$可得到<strong>两条直线之间的最短距离的平方</strong>。</p><p>若方向向量$V_1$和$V_2$是单位向量，则$V_1^2=V_2^2=1$，设夹角为$\theta$，带入式$(8)$将其化简。</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}\left [\begin{matrix}        t_1 \\        t_2 \end{matrix}\right ]&= \frac{1}{(V_1\cdot V_2)^2-V_1^2V_2^2}\left [\begin{matrix}        -V_2^2 & V_1\cdot V_2 \\    -V_1\cdot V_2 &    V_1^2\end{matrix}\right ]\left [\begin{matrix}        (S_2-S_1)\cdot V_1 \\        (S_2-S_1)\cdot V_2 \end{matrix}\right ]\\&=\frac{1}{-\sin^2\theta}\left [\begin{matrix}        -1 & \cos\theta \\    -\cos\theta &    1\end{matrix}\right ]\left [\begin{matrix}        (S_2-S_1)\cdot V_1 \\        (S_2-S_1)\cdot V_2 \end{matrix}\right ]\end{aligned}\end{equation}\tag{9}</script><p>若$(V_1\cdot V_2)^2-V_1^2V_2^2=0$，则<strong>两条直线平行</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
          <category> 数学概念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
            <tag> 三维空间 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 直线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四元数</title>
      <link href="/2020/07/24/%E5%9B%9B%E5%85%83%E6%95%B0/"/>
      <url>/2020/07/24/%E5%9B%9B%E5%85%83%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>四元数是3D图形程序中用来表示旋转的数学方法。</p><p>优点：</p><ul><li>所需的存储空间比矩阵少。</li><li>合并四元数所需的代数操作少。</li><li>对四元数的插值更容易实现，从而可以产生更连续的动画。</li></ul><a id="more"></a><h1 id="四元数的数学"><a href="#四元数的数学" class="headerlink" title="四元数的数学"></a>四元数的数学</h1><p>四元数集合称为<strong>Hamilton四元数环</strong>，表示为$\H$，可以看做四维空间向量。</p><p>元素$q$可表示为</p><script type="math/tex; mode=display">q=<w,x,y,z>=w+xi+yj+zk \tag{1}</script><p>四元数通常可以写成：$q=s+v$，$s$表示$w$对应的标量部分，$v$是$x$，$y$和$z$对应的向量部分。</p><p>四元数集合是对复数集合的自然扩展，<strong>乘法可以用一般分配律</strong>计算。</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}        &i^2+j^2+k^2=-1 \\      &ij=-ji=k \\      &jk=-kj=i \\      &ki=-ik=j                                \end{aligned}\end{equation}\tag{2}</script><p>四元数<strong>乘法不满足交换律</strong>。</p><p>给定两个四元数：$q_1=w_1+x_1i+y_1j+z_1k$和$q_2=w_2+x_2i+y_2j+z_2k$，它们的乘积$q_1q_2$可表示为：</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}        q_1q_2 &=(w_1w_2-x_1x_2-y_1y_2-z_1z_2) \\                  &+(w_1x_2+x_1w_2+y_1z_2-z_1y_2)i \\                  &+(w_1y_2+y_1w_2+z_1x_2-x_1z_2)j \\                  &+(w_1z_2+z_1w_2+x_1y_2-y_1x_2)k \\\end{aligned}\end{equation}\tag{3}</script><p>给定两个四元数：$q_1=s_1+v_1$和$q_2=s_2+v_2$，它们的乘积$q_1q_2$可表示为：</p><script type="math/tex; mode=display">q_1q_2=s_1s_2-v_1\cdot{v_2}+s_1v_2+s_2v_1+v_1\times v_2\tag{4}</script><p>四元数具有<strong>共轭性质</strong>。</p><p>【定义】四元数$q=s+v$的共轭可以表示为$\bar{q}$，且$\bar{q}=s-v$。</p><p>四元数$q$和它的共轭$\bar{q}$的乘积等于$q$与自己的内积，即<strong>$q$的大小的平方</strong>。</p><script type="math/tex; mode=display">q\bar{q}=\bar{q}q=q\cdot q=\|q\|^2=q^2  \tag{5}</script><p>由此可以得到四元数倒数的计算方法</p><p>【定理】非$0$四元数$q$的倒数可表示为$q^{-1}$，计算公式如下：</p><script type="math/tex; mode=display">q^{-1}=\frac{\bar{q}}{q^2} \tag{6}</script><p><strong>证明</strong></p><script type="math/tex; mode=display">qq^{-1}=\frac{q\bar{q}}{q^2}=\frac{q^2}{q^2}=1 \tag{7}</script><p>即：</p><script type="math/tex; mode=display">q^{-1}q=\frac{\bar{q}q}{q^2}=\frac{q^2}{q^2}=1 \tag{8}</script><p><strong>证毕</strong></p><h1 id="四元数旋转"><a href="#四元数旋转" class="headerlink" title="四元数旋转"></a>四元数旋转</h1><h2 id="三维空间"><a href="#三维空间" class="headerlink" title="三维空间"></a>三维空间</h2><p>三维空间的旋转可以看成函数$\varphi$在三维向量空间$\R^3$内的映射变换，由于是旋转变换，需保持长度、角度和偏手性不变，即，下式成立，则函数$\varphi$可保持旋转向量的长度不变性。</p><script type="math/tex; mode=display">\|\varphi(P)\|=\|P\|  \tag{9}</script><p>对于$P_1$和$P_2$两点，连接坐标系<strong>原点与这两个点的线段之间的夹角</strong>如果满足以下条件，则在旋转过程中可保持不变。</p><script type="math/tex; mode=display">\varphi(P_1)\cdot\varphi(P_2)=P_1\cdot P_2 \tag{10}</script><p>若下式成立，旋转过程中可保持偏手性不变。</p><script type="math/tex; mode=display">\varphi(P_1)\times\varphi(P_2)=\varphi(P_1\times P_2) \tag{11}</script><h2 id="四维空间"><a href="#四维空间" class="headerlink" title="四维空间"></a>四维空间</h2><p>将函数$\varphi$扩展到四维向量空间$\H$，需$\varphi(s+v)=s+\varphi(v)$成立，则式$(10)$可写成如下形式：</p><script type="math/tex; mode=display">\varphi(P_1)\cdot\varphi(P_2)=\varphi(P_1\cdot P_2) \tag{12}</script><p>其中，$P_1$和$P_2$可以看成标量部分为$0$的四元数，由于$P_1P_2=-P_1\cdot P_2+P_1\times P_2$，则式$(11)$和式$(12)$可组合在一起，得到同时保持<strong>角度不变性</strong>和<strong>偏手性不变</strong>的条件，即：</p><script type="math/tex; mode=display">\varphi(P_1)\varphi(P_2)=\varphi(P_1P_2) \tag{13}</script><p>其中，满足式$(13)$的函数$\varphi$称为<strong>同态函数</strong>。</p><p>同态函数$\varphi$满足以下条件：</p><script type="math/tex; mode=display">\varphi_q(p)=qPq^{-1} \tag{14}</script><p>其中，$q$为非$0$的四元数，同态函数满足式$(9)$和式$(13)$，表示<strong>旋转变换函数的集合</strong>。</p><p>可以证明，<strong>函数$\varphi_q$可保持长度不变性</strong>，即：</p><script type="math/tex; mode=display">\|\varphi_q(P)\|=\|qPq^{-1}\|=\|q\|\|P\|\|q^{-1}\|=\|P\|\frac{\|q\|\|\bar{q}\|}{q^2}=\|P\| \tag{15}</script><p>由下式可得$\varphi_q$是同态函数：</p><script type="math/tex; mode=display">\varphi_q(P_1)\varphi_q(P_2)=qP_1q^{-1}qP_2q^{-1}=qP_1P_2q^{-1}=\varphi_q(P_1P_2) \tag{16}</script><h3 id="绕轴-A-旋转-theta-角对应的四元数-q-表达式"><a href="#绕轴-A-旋转-theta-角对应的四元数-q-表达式" class="headerlink" title="绕轴$A$旋转$\theta$角对应的四元数$q$表达式"></a>绕轴$A$旋转$\theta$角对应的四元数$q$表达式</h3><p>因为$\varphi_q$为同态函数，对于标量$a\ne 0$，有$\varphi_{aq}=\varphi_q$，下面以单位四元数为示例。</p><p>令$q=s+v$为一个单位四元数，则$q^{-1}=s-v$，对于点$P$，有</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}        qPq^{-1} &=(s+v)P(s-v) \\                    &=(-v\cdot P + sP + v\times P)(s-v) \\                    &=-sv\cdot P + s^2P + sv\times P + (v\cdot P)v - sPv - (v\times P)v \\                    &=s^2P + 2sv\times P + (v\cdot P)v - v\times P \times v \\\end{aligned}\end{equation}\tag{17}</script><p>因为$v\times P\times v=v^2P-(v\cdot P)v$，则：</p><script type="math/tex; mode=display">qPq^{-1}=(s^2-v^2)P+2sv\times P + 2(v\cdot P)v \tag{18}</script><p>令$v=tA$，其中$A$为单位向量，则式$(18)$变为：</p><script type="math/tex; mode=display">qPq^{-1}=(s^2-t^2)P+2stA\times P + 2t^2(A\cdot P)A \tag{19}</script><p>与绕任意轴旋转的旋转公式：$P’=P\cos\theta+(A\times P)\sin\theta+A(A\cdot P)(1-\cos\theta)$相比，可得如下等式：</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}        s^2-t^2 &= \cos\theta \\               2st &= \sin\theta \\           2t^2 &= 1-\cos\theta \\\end{aligned}\end{equation}\tag{20}</script><p>由式$(20)$的第三个等式可得：</p><script type="math/tex; mode=display">t=\sqrt{\frac{1-\cos\theta}{2}}=\sin\frac{\theta}{2}  \tag{21}</script><p>由式$(20)$的第一个和第三个等式可得：$s^2+t^2=1$，因此：$s=\cos\frac{\theta}{2}$，根据三角等式：$\sin2\theta=2\sin\theta\cos\theta$，可得：$2st=2\sin\frac{\theta}{2}\cos\frac{\theta}{2}=\sin\theta$，满足第二个等式。</p><p>至此，可得<strong>绕轴$A$旋转$\theta$角对应的单位四元数$q$</strong>的表达式如下：</p><script type="math/tex; mode=display">q=\cos\frac{\theta}{2}+A\sin\frac{\theta}{2}  \tag{22}</script><p>避免欧拉角表示法中的<strong>万向锁问题</strong>。</p><h3 id="标量乘以四元数表示相同旋转操作"><a href="#标量乘以四元数表示相同旋转操作" class="headerlink" title="标量乘以四元数表示相同旋转操作"></a>标量乘以四元数表示相同旋转操作</h3><p><strong>任意标量乘以四元数$q$都表示相同的旋转操作</strong>，因为：</p><script type="math/tex; mode=display">(aq)P(aq)^{-1}=aqP\frac{q^{-1}}{a}=qPq^{-1}  \tag{23}</script><h3 id="多个四元数乘积表示旋转操作"><a href="#多个四元数乘积表示旋转操作" class="headerlink" title="多个四元数乘积表示旋转操作"></a>多个四元数乘积表示旋转操作</h3><p>两个四元数$q_1$和$q_2$的乘积也表示旋转操作，对于乘积$q_1q_2$来说，表示先进行$q_2$旋转，再进行$q_1$旋转，即：</p><script type="math/tex; mode=display">q_1(q_2Pq_2^{-1})q_1^{-1}=(q_1q_2)P(q_1q_2)^{-1}  \tag{24}</script><p>由上式可知，可以<strong>将多个四元数合并成一个表示所有变换的四元数</strong>。</p><p>计算<strong>两个四元数的乘积只需要16次乘加运算</strong>，而计算<strong>两个$3\times3$矩阵的乘积需要27次乘加运算</strong>。</p><p>因此，当对一个对象进行多个旋转操作时，使用四元数进行变换可以提高计算效率。</p><h3 id="四元数转换成-3-times3-旋转矩阵"><a href="#四元数转换成-3-times3-旋转矩阵" class="headerlink" title="四元数转换成$3\times3$旋转矩阵"></a>四元数转换成$3\times3$旋转矩阵</h3><p>将对物体进行的变换传递到3D图形库时，需要此操作。</p><p>对于一个四元数$q=s+tA$，组合下式：</p><script type="math/tex; mode=display">P\times Q=\left[                    \begin{matrix}                    0   & -P_z &  P_y \\                    P_z &    0 & -P_x \\                 -P_y & -P_x &    0 \\                \end{matrix}                    \right]                    \left[                    \begin{matrix}                    Q_x \\                    Q_y \\                  Q_z \\                \end{matrix}                    \right]                    \tag{25}</script><script type="math/tex; mode=display">proj_QP=\frac{1}{\|Q\|^2}                \left[                \begin{matrix}                Q_x^2  &    Q_xQ_y &    Q_xQ_z \\                Q_xQ_y &    Q_y^2  &    Q_yQ_z \\                Q_xQ_z &    Q_yQ_z  &    Q_z^2 \\                \end{matrix}                \right]                \left[                \begin{matrix}                P_x \\                P_y \\                P_z\\                \end{matrix}                \right]                \tag{26}</script><script type="math/tex; mode=display">qPq^{-1}=(s^2-t^2)P+2stA\times P + 2t^2(A\cdot P)A \tag{27}</script><p>可以获得其所对应的变换矩阵表达式，如下：</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}qPq^{-1}&=\left[                    \begin{matrix}                    s^2-t^2&      0&      0 \\                          0&s^2-t^2&      0 \\                        0&      0&s^2-t^2 \\                \end{matrix}                    \right]                    P                    +                    \left[                    \begin{matrix}                          0&-2stA_z& 2stA_y \\                     2stA_z&      0&-2stA_x   \\                  -2stA_y& 2stA_x&      0 \\                \end{matrix}                    \right]                    P \\                    &+                    \left[                    \begin{matrix}                      2t^2A_x^2&2t^2A_xA_y&2t^2A_xA_z \\                     2t^2A_xA_y& 2t^2A_y^2&2t^2A_yA_z \\                     2t^2A_xA_z&2t^2A_yA_z& 2t^2A_z^2 \\                \end{matrix}                    \right]                    P\end{aligned}\end{equation}\tag{28}</script><p>将四元数写成四维向量的形式$q=<w,x,y,z>$，则$w=s$，$x=tA_x$，$y=tA_y$和$z=tA_z$，由于$A$是一个单位向量，则：</w,x,y,z></p><script type="math/tex; mode=display">x^2+y^2+z^2=t^2A^2=t^2  \tag{29}</script><p>则式$(28)$写成$w$，$x$，$y$，$z$的表达式，如下：</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}qPq^{-1}&=\left[                    \begin{matrix}                    w^2-x^2-y^2-z^2&      0&      0 \\                          0&w^2-x^2-y^2-z^2&      0 \\                        0&      0&w^2-x^2-y^2-z^2 \\                \end{matrix}                    \right]                    P \\                    &+                    \left[                    \begin{matrix}                          0&-2wz& 2wy \\                     2wz&      0&-2wx   \\                  -2wy& 2wx&      0 \\                \end{matrix}                    \right]                    P                    +                    \left[                    \begin{matrix}                      2x^2&2xy&2xz \\                     2xy& 2y^2&2yz \\                     2xz&2yz& 2z^2 \\                \end{matrix}                    \right]                    P\end{aligned}\end{equation}\tag{30}</script><p>由于$q$是一个单位四元数，有$w^2+x^2+y^2+z^2=1$，所以：</p><script type="math/tex; mode=display">w^2-x^2-y^2-z^2=1-2x^2-2y^2-2z^2 \tag{31}</script><p>利用上式将式$(30)$中的三个矩阵合并可得与四元数$q$对应的旋转矩阵$R_q$，即：</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}R_q&=\left[                    \begin{matrix}                    1-2y^2-2z^2&    2xy-2wz&    2xz+2wy \\                        2xy+2wz&1-2x^2-2z^2&    2yz-2wx \\                      2xz-2wy&    2yz+2wx&1-2x^2-2y^2 \\                \end{matrix}                    \right]                    P\end{aligned}\end{equation}\tag{32}</script><h1 id="球型线性插值"><a href="#球型线性插值" class="headerlink" title="球型线性插值"></a>球型线性插值</h1><p>球型线性插值：由起点$p_1$和终点$p_2$两个基向量所构成的平面中，从一个端点到另一个端点的移动过程。</p><p>由于四元数表示成向量的形式，它们非常适用于插值操作。</p><p>在对象的动画过程中，<strong>插值可以产生对象在已计算好的关键帧之间的中间方向</strong>。</p><h2 id="线性插值"><a href="#线性插值" class="headerlink" title="线性插值"></a>线性插值</h2><p>对于给定的两个四元数$q_1$和$q_2$，它们的线性插值$q(t)$等于：</p><script type="math/tex; mode=display">q(t)=(1-t)q_1+tq_2 \tag{33}</script><p>当$t$从$0$到$1$时，函数$q(t)$将沿着连接$q_1$和$q_2$两点的线段平滑变化。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E/%E6%95%B0%E5%AD%A6%E6%A6%82%E5%BF%B5/%E5%9B%9B%E5%85%83%E6%95%B0/%E5%9B%9B%E5%85%83%E6%95%B0%E7%9A%84%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC.png" width="40%"></p><p>如图所示，在式$(33)$中，$q(t)$不会保持$q_1$和$q_2$的单位长度，可以用下式保持$q(t)$规范化。</p><script type="math/tex; mode=display">q(t)=\frac{(1-t)q_1+tq_2}{\|(1-t)q_1+tq_2\|} \tag{34}</script><p>该函数的插值结果可以在$q_1$和$q_2$两点之间形成一个圆弧，，上图为该<strong>函数在四维单位超球表面插值结果的二维截面形式</strong>。</p><p>线性插值存在缺点：式$(34)$给出的插值函数$q(t)$随变量$t$的变化而变化的速率不是常数，如下图所示：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E/%E6%95%B0%E5%AD%A6%E6%A6%82%E5%BF%B5/%E5%9B%9B%E5%85%83%E6%95%B0/%E5%87%BD%E6%95%B0%E6%9B%B2%E7%BA%BF.png" width="40%"></p><p>从函数$\cos^{-1}(q(t)\cdot q_1)$曲线可以看出，$q(t)$与$q_1$之间的夹角可以表示变化速率，该角在$t=0$和$t=1$的两个端点处变化最慢，而在$t=\frac{1}{2}$处变化最快。</p><h2 id="如何寻找一个好的插值函数-q-t"><a href="#如何寻找一个好的插值函数-q-t" class="headerlink" title="如何寻找一个好的插值函数$q(t)$"></a>如何寻找一个好的插值函数$q(t)$</h2><p>寻找一个插值函数$q(t)$，对四元数$q_1$和$q_2$进行插值的时候，可以<strong>保持四元数的单位长度</strong>，也可以<strong>保持从$q_1$和$q_2$之间的角度变化速率为常数</strong>。</p><p>若$q_1$和$q_2$之间的夹角为$\theta$，则该函数产生的四元数$q(t)$与$q_1$之间的夹角$\theta t$随$t$从$1$到$0$变化而变化。</p><p>如下图所示，四元数$q(t)$位于连接$q_1$和$q_2$的圆弧上，与$q_1$之间的夹角为$\theta t$，与$q_2$之间的夹角为$\theta(1-t)$，则$q(t)$的表达式如下：</p><script type="math/tex; mode=display">q(t)=a(t)q_1+b(t)q_2 \tag{35}</script><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E/%E6%95%B0%E5%AD%A6%E6%A6%82%E5%BF%B5/%E5%9B%9B%E5%85%83%E6%95%B0/%E7%9B%B8%E4%BC%BC%E4%B8%89%E8%A7%92%E5%BD%A2%E6%B1%82%E5%88%86%E9%87%8F.png" width="60%"></p><p>此处，$a(t)$表示$q(t)$沿$q_1$方向分量的长度，$b(t)$表示$q(t)$沿$q_2$方向分量的长度。</p><p>如图$(a)$所示，通过构造相似的三角形，可计算长度$a(t)$，已知$q_1$到原点与$q_2$连接的垂直距离为$|q_1|\sin\theta$，$q(t)$到该线段的垂直距离为$|q(t)|\sin[\theta(1-t)]$，利用相似三角形的性质，可得：</p><script type="math/tex; mode=display">\frac{a(t)}{\|q_1\|}=\frac{\|q(t)\|\sin[\theta(1-t)]}{\|q_1\|\sin\theta} \tag{36}</script><p>由于$|q_1|=1$和$|q(t)|=1$，上式可化简为：</p><script type="math/tex; mode=display">a(t)=\frac{\sin[\theta(1-t)]}{\sin\theta}  \tag{37}</script><p>如图$(b)$所示，利用相同过程可以得到长度$b(t)$的表达式如下：</p><script type="math/tex; mode=display">b(t)=\frac{\sin(\theta t)}{\sin\theta}  \tag{38}</script><p>由此，可得球型线性插值函数$q(t)$定义如下：</p><script type="math/tex; mode=display">q(t)=\frac{\sin[\theta(1-t)]}{\sin\theta}q_1+\frac{\sin(\theta t)}{\sin\theta}q_2 \tag{39}</script><p>其中，$\theta$为：</p><script type="math/tex; mode=display">\theta=\cos^{-1}(q_1\cdot q_2)  \tag{40}</script><p>也可以写成：</p><script type="math/tex; mode=display">\sin\theta=\sqrt{1-(q_1\cdot q_2)^2}  \tag{41}</script><p>由于四元数$q$和$-q$表示相同的旋转，所以$q_1$和$q_2$的符号的选取应保证$q_1\cdot q_2\ge 0$，这可保证沿着$q_1$到$q_2$的最短路径插值。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
          <category> 数学概念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 四元数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员画图软件Graphviz</title>
      <link href="/2020/07/07/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%94%BB%E5%9B%BE%E8%BD%AF%E4%BB%B6Graphviz/"/>
      <url>/2020/07/07/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%94%BB%E5%9B%BE%E8%BD%AF%E4%BB%B6Graphviz/</url>
      
        <content type="html"><![CDATA[<p>Graphviz 是英文“Graph Visualization”的缩略词，是一个开源的，跨平台的自动绘图工具，<a href="http://www.graphviz.org" target="_blank" rel="noopener">官网</a>，<a href="https://en.wikipedia.org/wiki/Graphviz" target="_blank" rel="noopener">维基百科</a>，<a href="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B7%A5%E5%85%B7/graphviz/dotguide.pdf" target="_blank" rel="noopener">文档</a>。</p><a id="more"></a><h1 id="Graphviz-能干啥？"><a href="#Graphviz-能干啥？" class="headerlink" title="Graphviz 能干啥？"></a>Graphviz 能干啥？</h1><p>“绘图工具”有很多种，Graphviz 主要是用来绘制【关系图】。所以它更类似于微软的 Visio。但是它与 Visio 有一个【本质上】的差异：</p><ul><li>用 Visio 画图是【手动】的 — — 你需要动用你的肉眼和手指头。</li><li>用 Graphviz 画图是【自动】的 — — 你只需要告诉 Graphviz 这张图包含哪些元素，元素之间有啥关系，然后 Graphviz 可以【自动】帮你画出来。</li></ul><p>那么，你如何告诉 Graphviz 你要画的图形包含哪些元素捏？这就需要用到一个名叫 DOT 的描述语言。</p><h1 id="支持的输出格式"><a href="#支持的输出格式" class="headerlink" title="支持的输出格式"></a>支持的输出格式</h1><p>上述命令行中的 -Tpng 表示生成的文件类型是png图片。如果你需要生成其它格式，也可以。目前 Graphviz 支持很多种格式，<br>图片格式【至少】支持：png、jpg、gif、bmp、tiff、ico、svg<br>文档格式【至少】支持：pdf、ps/eps</p><p>完整的输出格式如下：</p><div class="table-container"><table><thead><tr><th>Command-line parameter</th><th>Format</th></tr></thead><tbody><tr><td><a href="http://www.graphviz.org/doc/info/output.html#d:bmp" target="_blank" rel="noopener">bmp</a></td><td>Windows Bitmap Format</td></tr><tr><td><a href="http://www.graphviz.org/doc/info/output.html#d:canon" target="_blank" rel="noopener">canon</a> <a href="http://www.graphviz.org/doc/info/output.html#d:dot" target="_blank" rel="noopener">dot</a> <a href="http://www.graphviz.org/doc/info/output.html#d:gv" target="_blank" rel="noopener">gv</a> <a href="http://www.graphviz.org/doc/info/output.html#d:xdot" target="_blank" rel="noopener">xdot</a> <a href="http://www.graphviz.org/doc/info/output.html#d:xdot1.2" target="_blank" rel="noopener">xdot1.2</a> <a href="http://www.graphviz.org/doc/info/output.html#d:xdot1.4" target="_blank" rel="noopener">xdot1.4</a></td><td>DOT</td></tr><tr><td><a href="http://www.graphviz.org/doc/info/output.html#d:cgimage" target="_blank" rel="noopener">cgimage</a></td><td>CGImage bitmap format</td></tr><tr><td><a href="http://www.graphviz.org/doc/info/output.html#d:cmap" target="_blank" rel="noopener">cmap</a></td><td>Client-side imagemap (deprecated)</td></tr><tr><td><a href="http://www.graphviz.org/doc/info/output.html#d:eps" target="_blank" rel="noopener">eps</a></td><td>Encapsulated PostScript</td></tr><tr><td><a href="http://www.graphviz.org/doc/info/output.html#d:exr" target="_blank" rel="noopener">exr</a></td><td>OpenEXR</td></tr><tr><td><a href="http://www.graphviz.org/doc/info/output.html#d:fig" target="_blank" rel="noopener">fig</a></td><td>FIG</td></tr><tr><td><a href="http://www.graphviz.org/doc/info/output.html#d:gd" target="_blank" rel="noopener">gd</a> <a href="http://www.graphviz.org/doc/info/output.html#d:gd2" target="_blank" rel="noopener">gd2</a></td><td>GD/GD2 formats</td></tr><tr><td><a href="http://www.graphviz.org/doc/info/output.html#d:gif" target="_blank" rel="noopener">gif</a></td><td>GIF</td></tr><tr><td><a href="http://www.graphviz.org/doc/info/output.html#d:gtk" target="_blank" rel="noopener">gtk</a></td><td>GTK canvas</td></tr><tr><td><a href="http://www.graphviz.org/doc/info/output.html#d:ico" target="_blank" rel="noopener">ico</a></td><td>Icon Image File Format</td></tr><tr><td><a href="http://www.graphviz.org/doc/info/output.html#d:imap" target="_blank" rel="noopener">imap</a> <a href="http://www.graphviz.org/doc/info/output.html#d:cmapx" target="_blank" rel="noopener">cmapx</a></td><td>Server-side and client-side imagemaps</td></tr><tr><td><a href="http://www.graphviz.org/doc/info/output.html#d:imap_np" target="_blank" rel="noopener">imap_np</a> <a href="http://www.graphviz.org/doc/info/output.html#d:cmapx_np" target="_blank" rel="noopener">cmapx_np</a></td><td>Server-side and client-side imagemaps</td></tr><tr><td><a href="http://www.graphviz.org/doc/info/output.html#d:ismap" target="_blank" rel="noopener">ismap</a></td><td>Server-side imagemap (deprecated)</td></tr><tr><td><a href="http://www.graphviz.org/doc/info/output.html#d:jp2" target="_blank" rel="noopener">jp2</a></td><td>JPEG 2000</td></tr><tr><td><a href="http://www.graphviz.org/doc/info/output.html#d:jpg" target="_blank" rel="noopener">jpg</a> <a href="http://www.graphviz.org/doc/info/output.html#d:jpeg" target="_blank" rel="noopener">jpeg</a> <a href="http://www.graphviz.org/doc/info/output.html#d:jpe" target="_blank" rel="noopener">jpe</a></td><td>JPEG</td></tr><tr><td><a href="http://www.graphviz.org/doc/info/output.html#d:json" target="_blank" rel="noopener">json</a> <a href="http://www.graphviz.org/doc/info/output.html#d:json0" target="_blank" rel="noopener">json0</a> <a href="http://www.graphviz.org/doc/info/output.html#d:dot_json" target="_blank" rel="noopener">dot_json</a> <a href="http://www.graphviz.org/doc/info/output.html#d:xdot_json" target="_blank" rel="noopener">xdot_json</a></td><td>Dot graph represented in JSON format</td></tr><tr><td><a href="http://www.graphviz.org/doc/info/output.html#d:pct" target="_blank" rel="noopener">pct</a> <a href="http://www.graphviz.org/doc/info/output.html#d:pict" target="_blank" rel="noopener">pict</a></td><td>PICT</td></tr><tr><td><a href="http://www.graphviz.org/doc/info/output.html#d:pdf" target="_blank" rel="noopener">pdf</a></td><td>Portable Document Format (PDF)</td></tr><tr><td><a href="http://www.graphviz.org/doc/info/output.html#d:pic" target="_blank" rel="noopener">pic</a></td><td>Kernighan’s PIC graphics language</td></tr><tr><td><a href="http://www.graphviz.org/doc/info/output.html#d:plain" target="_blank" rel="noopener">plain</a> <a href="http://www.graphviz.org/doc/info/output.html#d:plain-ext" target="_blank" rel="noopener">plain-ext</a></td><td>Simple text format</td></tr><tr><td><a href="http://www.graphviz.org/doc/info/output.html#d:png" target="_blank" rel="noopener">png</a></td><td>Portable Network Graphics format</td></tr><tr><td><a href="http://www.graphviz.org/doc/info/output.html#d:pov" target="_blank" rel="noopener">pov</a></td><td>POV-Ray markup language (prototype)</td></tr><tr><td><a href="http://www.graphviz.org/doc/info/output.html#d:ps" target="_blank" rel="noopener">ps</a></td><td>PostScript</td></tr><tr><td><a href="http://www.graphviz.org/doc/info/output.html#d:ps2" target="_blank" rel="noopener">ps2</a></td><td>PostScript for PDF</td></tr><tr><td><a href="http://www.graphviz.org/doc/info/output.html#d:psd" target="_blank" rel="noopener">psd</a></td><td>PSD</td></tr><tr><td><a href="http://www.graphviz.org/doc/info/output.html#d:sgi" target="_blank" rel="noopener">sgi</a></td><td>SGI</td></tr><tr><td><a href="http://www.graphviz.org/doc/info/output.html#d:svg" target="_blank" rel="noopener">svg</a> <a href="http://www.graphviz.org/doc/info/output.html#d:svgz" target="_blank" rel="noopener">svgz</a></td><td>Scalable Vector Graphics</td></tr><tr><td><a href="http://www.graphviz.org/doc/info/output.html#d:tga" target="_blank" rel="noopener">tga</a></td><td>Truevision TGA</td></tr><tr><td><a href="http://www.graphviz.org/doc/info/output.html#d:tif" target="_blank" rel="noopener">tif</a> <a href="http://www.graphviz.org/doc/info/output.html#d:tiff" target="_blank" rel="noopener">tiff</a></td><td>TIFF (Tag Image File Format)</td></tr><tr><td><a href="http://www.graphviz.org/doc/info/output.html#d:tk" target="_blank" rel="noopener">tk</a></td><td>TK graphics</td></tr><tr><td><a href="http://www.graphviz.org/doc/info/output.html#d:vml" target="_blank" rel="noopener">vml</a> <a href="http://www.graphviz.org/doc/info/output.html#d:vmlz" target="_blank" rel="noopener">vmlz</a></td><td>Vector Markup Language (VML)</td></tr><tr><td><a href="http://www.graphviz.org/doc/info/output.html#d:vrml" target="_blank" rel="noopener">vrml</a></td><td>VRML</td></tr><tr><td><a href="http://www.graphviz.org/doc/info/output.html#d:wbmp" target="_blank" rel="noopener">wbmp</a></td><td>Wireless BitMap format</td></tr><tr><td><a href="http://www.graphviz.org/doc/info/output.html#d:webp" target="_blank" rel="noopener">webp</a></td><td>Image format for the Web</td></tr><tr><td><a href="http://www.graphviz.org/doc/info/output.html#d:xlib" target="_blank" rel="noopener">xlib</a> <a href="http://www.graphviz.org/doc/info/output.html#d:x11" target="_blank" rel="noopener">x11</a></td><td>Xlib canvas</td></tr></tbody></table></div><h1 id="DOT-命令行的使用"><a href="#DOT-命令行的使用" class="headerlink" title="DOT 命令行的使用"></a>DOT 命令行的使用</h1><p>假设你已经用 DOT 语言写好了一个关系图的描述文件，假设这个文件名是 test.gv 那么你可以进入 <strong>test.gv</strong> 所在的目录，然后用如下命令生成【png图片】</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dot test.gv -T png -o test.png<br></code></pre></td></tr></table></figure><h1 id="DOT-语言入门"><a href="#DOT-语言入门" class="headerlink" title="DOT 语言入门"></a>DOT 语言入门</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>通过 DOT 语言来描述一个关系图，然后 Graphviz 根据这个 DOT 语言的描述来自动生成图形。</p><p>从原则上讲，DOT语言只描述三种东西，分别是：<strong>点（node）、线（edge）、图形（graph）</strong>。</p><p>可以通过 DOT 语言定义这三种东西的属性（比如：颜色、形状）。</p><p>图、节点和边的属性看这个<a href="http://www.graphviz.org/doc/info/attrs.html" target="_blank" rel="noopener">链接</a>。</p><h2 id="两种图：有向图（digraph）-VS-无向图（graph）"><a href="#两种图：有向图（digraph）-VS-无向图（graph）" class="headerlink" title="两种图：有向图（digraph） VS 无向图（graph）"></a>两种图：有向图（digraph） VS 无向图（graph）</h2><p>DOT 语言支持两种图形，分别是“有向图 和 无向图”。</p><p>定义一个无向图：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">graph simple<br>&#123;<br>    a -- b -- c;<br>    b -- d;<br>&#125;<br>// 这是个无向图<br></code></pre></td></tr></table></figure><p>上述代码的效果图如下：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B7%A5%E5%85%B7/graphviz/%E6%97%A0%E5%90%91%E5%9B%BE.png" width="20%"></p><p>定义一个有向图：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">digraph simple<br>&#123;<br>    a -&gt; b -&gt; c;<br>    b -&gt; d;<br>&#125;<br>/* 这是个有向图 */<br></code></pre></td></tr></table></figure><p>上述代码的效果图如下：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B7%A5%E5%85%B7/graphviz/%E6%9C%89%E5%90%91%E5%9B%BE.png" width="20%"></p><p><strong>graph</strong> 用来表示一个无向图；<strong>digraph</strong> 用来表示一个有向图。<strong>simple</strong> 表示图的名称。图的名称可以是【英文字母、下划线、数字、中文】。最好【不要包含】其它英文的标点符号（也就是【半角符号】），可能会导致一些语法错误。但是中文标点符号（也就【全角符号】）没有关系。</p><p><strong>花括号/大括号</strong> 里面的语句表示【图的定义】 — — 这张图包含哪些内容。每一条语句以【分号】结尾（类似于 C、C++、Java 的语法）。</p><p>顺便提一下 DOT 语言的注释（其注释的语法与 C、C++、Java 类似），包括如下两种：<br>【单行注释】 — — 以 <strong>//</strong> 表示：【该行】后续的内容为注释<br>【多行注释】 — — 以 <strong>/*</strong> 和 <strong>*/</strong> 包含起来的内容为注释</p><h2 id="节点（node）"><a href="#节点（node）" class="headerlink" title="节点（node）"></a>节点（node）</h2><p>在上面两个例子中， a b c d 都是【节点名】，分别代表节点。</p><p>在图的定义中，相同名称就代表同一个节点。</p><p>当 DOT 编译器碰到一个新的名称，就认为这是一个新的节点。</p><p>节点的命名规范类似于图的命名规范。</p><p>如果某个节点没有设置 label 属性（关于【属性】，下面会聊到），那么图形中就用节点名作为该节点的标题 — — 就好比前面两幅简单的示意图。</p><h3 id="节点（node）的属性"><a href="#节点（node）的属性" class="headerlink" title="节点（node）的属性"></a>节点（node）的属性</h3><p>在节点名之后可以使用 <strong>方括号/中括号</strong> 来定义该节点的属性，属性之间用半角逗号分隔。</p><p>属性的定义采用如下形式：</p><blockquote><p>属性名 半角等于号 属性值</p></blockquote><p>（如果属性值会包含空格，需用引号把属性值引用起来）</p><p>常用的【属性名】包括如下：</p><blockquote><p>label — — 标题<br>color — — 颜色<br>style — — 样式<br>shape — — 形状</p></blockquote><p>给一个示例代码及效果图：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">digraph node_attr<br>&#123;<br>    shape1 [shape=box, label=<span class="hljs-string">"矩形节点"</span>];<br>    shape2 [shape=circle, label=<span class="hljs-string">"圆形节点"</span>];<br>    shape3 [shape=ellipse, label=<span class="hljs-string">"椭圆形节点"</span>];<br>    shape4 [shape=polygon, sides=4, skew=0.4, label=<span class="hljs-string">"平行四边形节点"</span>];<br>    shape5 [shape=none, label=<span class="hljs-string">"无边框节点"</span>];<br>    shape1 -&gt; shape2 -&gt; shape3 -&gt; shape4 -&gt; shape5<br>    color1 [color=<span class="hljs-string">"blue"</span>, label=<span class="hljs-string">"蓝色边框"</span>]<br>    color2 [color=<span class="hljs-string">"green"</span>, style=filled, label=<span class="hljs-string">"绿色填充"</span>]<br>    color3 [color=<span class="hljs-string">"#ff0000"</span>, style=filled, fillcolor=<span class="hljs-string">"yellow"</span>, label=<span class="hljs-string">"红色边框+黄色填充"</span>]<br>    color4 [color=<span class="hljs-string">"#0000FF"</span> style=filled, fillcolor=<span class="hljs-string">"green:red"</span>, label=<span class="hljs-string">"蓝色边框+从绿色到红色渐变填充"</span>]<br>    /* 上面两个节点采用 HTML 的颜色语法，dot 支持 这种语法 */<br>    color1 -&gt; color2 -&gt; color3 -&gt; color4<br>    text1 [shape=box, fontsize=12, label=<span class="hljs-string">"小字体"</span>]<br>    text2 [shape=box, fontsize=24, label=<span class="hljs-string">"大字体"</span>]<br>    text3 [shape=box, fontcolor=<span class="hljs-string">"blue"</span>, label=<span class="hljs-string">"蓝色文字"</span>]<br>    text4 [shape=box, label=&lt;&lt;br/&gt;&lt;b&gt;粗体&lt;/b&gt; &lt;i&gt;斜体&lt;/i&gt;&lt;u&gt;下划线&lt;/u&gt;&gt;]<br>    // 注意：text4 使用 HTML 风格的 label，无需引号，但必须用尖括号<br>    text1 -&gt; text2 -&gt; text3 -&gt; text4<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B7%A5%E5%85%B7/graphviz/%E7%A4%BA%E4%BE%8B%E5%9B%BE1.png" width="80%"></p><h2 id="连线（edge）"><a href="#连线（edge）" class="headerlink" title="连线（edge）"></a>连线（edge）</h2><p>无向图的连线用 — 表示，有向图的连线用 -&gt; 表示，非常形象。</p><p>定义连线的语句也是以分号结尾。</p><p>连线与节点的关键差异之处在于 — — 节点有名称而【连线没有名称】。</p><h3 id="连线（edge）的属性"><a href="#连线（edge）的属性" class="headerlink" title="连线（edge）的属性"></a>连线（edge）的属性</h3><p>连线也可以设置属性，其属性写在定义连线的语句末尾，语法类似节点属性。</p><p>常用的【属性名】包括如下：</p><blockquote><p>label — — 标题<br>color — — 颜色<br>style — — 线条的样式<br>dir — — 连线的方向（仅用于有向图，可设置：正向箭头、反向箭头、双向箭头）<br>arrowhead — — 前端的样式<br>arrowtail — — 末端的样式</p></blockquote><p>示例</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">digraph edge_attr<br>&#123;<br>    style0[label=<span class="hljs-string">"以下是样式的示例"</span>];<br>    style1[label=<span class="hljs-string">""</span>] style2[label=<span class="hljs-string">""</span>] style3[label=<span class="hljs-string">""</span>] style4[label=<span class="hljs-string">""</span>];<br>    style0 -&gt; style1 [style=solid, label=<span class="hljs-string">"实线"</span>];<br>    style1 -&gt; style2 [style=bold, label=<span class="hljs-string">"粗线"</span>];<br>    style2 -&gt; style3 [style=dashed, label=<span class="hljs-string">"短划线"</span>];<br>    style3 -&gt; style4 [style=dotted, label=<span class="hljs-string">"虚线"</span>];<br>    arrow0[label=<span class="hljs-string">"以下是箭头的示例"</span>];<br>    arrow1[label=<span class="hljs-string">""</span>] arrow2[label=<span class="hljs-string">""</span>] arrow3[label=<span class="hljs-string">""</span>] arrow4[label=<span class="hljs-string">""</span>] arrow5[label=<span class="hljs-string">""</span>] arrow6[label=<span class="hljs-string">""</span>];<br>    arrow0 -&gt; arrow1 [dir=both, label=<span class="hljs-string">"双向箭头"</span>];<br>    arrow1 -&gt; arrow2 [arrowsize=2.0, label=<span class="hljs-string">"大箭头"</span>];<br>    arrow2 -&gt; arrow3 [arrowhead=<span class="hljs-string">"open"</span>, label=<span class="hljs-string">"带倒钩的箭头"</span>];<br>    arrow3 -&gt; arrow4 [arrowhead=<span class="hljs-string">"halfopen"</span>, label=<span class="hljs-string">"单边倒钩"</span>];<br>    arrow4 -&gt; arrow5 [arrowhead=<span class="hljs-string">"ediamond"</span>, label=<span class="hljs-string">"菱形箭头"</span>];<br>    arrow5 -&gt; arrow6 [arrowhead=<span class="hljs-string">"dot"</span>, label=<span class="hljs-string">"圆形箭头"</span>];<br>    color0[label=<span class="hljs-string">"以下是颜色的示例"</span>];<br>    color1[label=<span class="hljs-string">""</span>] color2[label=<span class="hljs-string">""</span>] color3[label=<span class="hljs-string">""</span>];<br>    color0 -&gt; color1 [color=<span class="hljs-string">"blue"</span>, label=<span class="hljs-string">"蓝色"</span>];<br>    color1 -&gt; color2 [color=<span class="hljs-string">"red:blue"</span>, label=<span class="hljs-string">"双色"</span>];<br>    color2 -&gt; color3 [color=<span class="hljs-string">"green:red;0.4:blue"</span>, label=<span class="hljs-string">"颜色分段"</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B7%A5%E5%85%B7/graphviz/%E7%A4%BA%E4%BE%8B%E5%9B%BE2.png" width="80%"></p><h2 id="图的属性"><a href="#图的属性" class="headerlink" title="图的属性"></a>图的属性</h2><p>常用的【属性名】包括如下：</p><blockquote><p>label — — 标题<br>bgcolor — — 颜色<br>fontname — — 字体名称（【不】影响节点和连线）<br>fontsize — — 字体大小（【不】影响节点和连线）<br>fontcolor — — 字体颜色（【不】影响节点和连线）<br>center — — 是否居中绘制</p></blockquote><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">digraph graph_attr<br>&#123;<br>    graph[bgcolor=<span class="hljs-string">"cadetblue"</span> label=<span class="hljs-string">"图的标题"</span> fontsize=24 fontcolor=<span class="hljs-string">"green"</span>];<br>    node0 -&gt; node1;<br>    node0 -&gt; node2;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B7%A5%E5%85%B7/graphviz/%E7%A4%BA%E4%BE%8B%E5%9B%BE3.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机工具 </category>
          
          <category> Graphviz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 画图 </tag>
            
            <tag> 计算机工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Taichi编程语言学习</title>
      <link href="/2020/06/03/Taichi%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/06/03/Taichi%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>本文是基于GAMES201：高级物理引擎实战指南，学习编程语言Taichi所记录的部分例子代码。</p><a id="more"></a><h1 id="Taichi数据"><a href="#Taichi数据" class="headerlink" title="Taichi数据"></a>Taichi数据</h1><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> taichi <span class="hljs-keyword">as</span> ti<br><br>ti.init(arch=ti.metal)<br><br>a = ti.var(dt=ti.f32, shape=(<span class="hljs-number">42</span>, <span class="hljs-number">63</span>))  <span class="hljs-comment"># A tensor of 42x63 scalars</span><br>b = ti.Vector(<span class="hljs-number">3</span>, dt=ti.f32, shape=<span class="hljs-number">4</span>)  <span class="hljs-comment"># A tensor of 4x3D vectors</span><br>C = ti.Matrix(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, dt=ti.f32, shape=(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>))  <span class="hljs-comment"># A tensor of 3x5 2x2 matrices</span><br><br>loss = ti.var(dt=ti.f32, shape=())  <span class="hljs-comment"># A (0-D) tensor of a single scalar</span><br><br>a[<span class="hljs-number">3</span>, <span class="hljs-number">4</span>] = <span class="hljs-number">1</span><br>print(<span class="hljs-string">'a[3, 4] = '</span>, a[<span class="hljs-number">3</span>, <span class="hljs-number">4</span>])  <span class="hljs-comment"># "a[3, 4] = 1.000000"</span><br><br>b[<span class="hljs-number">0</span>] = [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]<br>print(<span class="hljs-string">'b[0] = '</span>, b[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], b[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], b[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>])  <span class="hljs-comment"># print(b[0]) is not supported</span><br><br>loss[<span class="hljs-literal">None</span>] = <span class="hljs-number">3</span><br>print(loss[<span class="hljs-literal">None</span>])  <span class="hljs-comment"># 3</span><br></code></pre></td></tr></table></figure><h1 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h1><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> taichi <span class="hljs-keyword">as</span> ti<br><br>ti.init(arch=ti.metal)<br><br><span class="hljs-meta">@ti.kernel</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calc</span><span class="hljs-params">()</span> -&gt; ti.i32:</span><br>    s = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):<br>        s += i<br>    <span class="hljs-keyword">return</span> s<br><br>print(calc())<br></code></pre></td></tr></table></figure><h1 id="Debug-mode"><a href="#Debug-mode" class="headerlink" title="Debug mode"></a>Debug mode</h1><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> taichi <span class="hljs-keyword">as</span> ti<br><br>ti.init(debug=<span class="hljs-literal">True</span>, arch=ti.metal)<br><br><br>a = ti.var(ti.i32, shape=(<span class="hljs-number">10</span>))<br>b = ti.var(ti.i32, shape=(<span class="hljs-number">10</span>))<br><br><br><span class="hljs-meta">@ti.kernel</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">shift</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):<br>        a[i] = b[i+<span class="hljs-number">1</span>]  <span class="hljs-comment"># Runtime error in debug mode</span><br><br><br>shift()<br></code></pre></td></tr></table></figure><h1 id="蝙蝠"><a href="#蝙蝠" class="headerlink" title="蝙蝠"></a>蝙蝠</h1><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> taichi <span class="hljs-keyword">as</span> ti<br><br><span class="hljs-comment"># Initialization</span><br>ti.init(arch=ti.metal)<br><br><span class="hljs-comment"># Tensor Allocation</span><br>n = <span class="hljs-number">320</span><br>pixels = ti.var(dt=ti.f32, shape=(n * <span class="hljs-number">2</span>, n))<br><br><span class="hljs-comment"># Computation Kernel</span><br><span class="hljs-meta">@ti.func</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">complex_sqr</span><span class="hljs-params">(z)</span>:</span><br>    <span class="hljs-keyword">return</span> ti.Vector([z[<span class="hljs-number">0</span>] * z[<span class="hljs-number">0</span>] - z[<span class="hljs-number">1</span>], z[<span class="hljs-number">1</span>] * z[<span class="hljs-number">0</span>] * <span class="hljs-number">2</span>])<br><br><span class="hljs-meta">@ti.kernel</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">paint</span><span class="hljs-params">(t: ti.f32)</span>:</span><br>    <span class="hljs-keyword">for</span> i ,j <span class="hljs-keyword">in</span> pixels:<br>        c = ti.Vector([<span class="hljs-number">-0.8</span>, ti.sin(t) * <span class="hljs-number">0.2</span>])<br>        z = ti.Vector([float(i) / n - <span class="hljs-number">1</span>, float(j) / n - <span class="hljs-number">0.5</span>]) * <span class="hljs-number">2</span><br>        iterations = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> z.norm() &lt; <span class="hljs-number">20</span> <span class="hljs-keyword">and</span> iterations &lt; <span class="hljs-number">50</span>:<br>            z = complex_sqr(z) + c<br>            iterations += <span class="hljs-number">1</span><br>        pixels[i, j] = <span class="hljs-number">1</span> - iterations * <span class="hljs-number">0.02</span><br><br><br><span class="hljs-comment"># Main program &amp; Visualization</span><br>gui = ti.GUI(<span class="hljs-string">"Fractal"</span>, (n * <span class="hljs-number">2</span>, n))<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1000000</span>):<br>    paint(i * <span class="hljs-number">0.03</span>)<br>    gui.set_image(pixels)<br>    gui.show()<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Taichi/%E8%9D%99%E8%9D%A0.png" width="80%"></p><h1 id="分形"><a href="#分形" class="headerlink" title="分形"></a>分形</h1><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> taichi <span class="hljs-keyword">as</span> ti<br><br>ti.init(arch=ti.metal)<br><br><br>n = <span class="hljs-number">320</span><br>pixels = ti.var(dt=ti.f32, shape=(n * <span class="hljs-number">2</span>, n))<br><br><br><span class="hljs-meta">@ti.func</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">complex_sqr</span><span class="hljs-params">(z)</span>:</span><br>    <span class="hljs-keyword">return</span> ti.Vector([z[<span class="hljs-number">0</span>]**<span class="hljs-number">2</span> - z[i]**<span class="hljs-number">2</span>, z[<span class="hljs-number">1</span>] * z[<span class="hljs-number">0</span>] * <span class="hljs-number">2</span>])<br><br><br><span class="hljs-meta">@ti.kernel</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">paint</span><span class="hljs-params">(t: ti.f32)</span>:</span><br>    <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> pixels:  <span class="hljs-comment"># Parallelized over all pixels</span><br>        c = ti.Vector([<span class="hljs-number">-0.8</span>, ti.cos(t) * <span class="hljs-number">0.2</span>])<br>        z = ti.Vector([i / n - <span class="hljs-number">1</span>, j / n - <span class="hljs-number">0.5</span>]) * <span class="hljs-number">2</span><br>        iterations = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> z.norm() &lt; <span class="hljs-number">20</span> <span class="hljs-keyword">and</span> iterations &lt; <span class="hljs-number">50</span>:<br>            z = complex_sqr(z) + c<br>            iterations += <span class="hljs-number">1</span><br>        pixels[i, j] = <span class="hljs-number">1</span> - iterations * <span class="hljs-number">0.02</span><br><br><br>gui = ti.GUI(<span class="hljs-string">"Julia Set"</span>, res=(n * <span class="hljs-number">2</span>, n))<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1000000</span>):<br>    paint(i * <span class="hljs-number">0.03</span>)<br>    gui.set_image(pixels)<br>    gui.show()<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Taichi/%E5%88%86%E5%BD%A2.png" width="80%"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
          <category> Taichi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> 计算机图形学 </tag>
            
            <tag> Taichi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>直线扫描转换算法</title>
      <link href="/2020/05/29/%E7%9B%B4%E7%BA%BF%E6%89%AB%E6%8F%8F%E8%BD%AC%E6%8D%A2%E7%AE%97%E6%B3%95/"/>
      <url>/2020/05/29/%E7%9B%B4%E7%BA%BF%E6%89%AB%E6%8F%8F%E8%BD%AC%E6%8D%A2%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>数值微分算法(DDA)，Bresenham算法。</p><a id="more"></a><h1 id="数值微分算法-DDA"><a href="#数值微分算法-DDA" class="headerlink" title="数值微分算法(DDA)"></a>数值微分算法(DDA)</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>数值微分法(Digital Differential Analyzer，DDA)，一种直接从直线的微分方程生成直线的方法。</p><p>通过给定直线的两端点坐标$P_0(x_0,y_0)$和$P_1(x_1,y_1)$，可以直接得到直线的微分方程：</p><script type="math/tex; mode=display">\frac{dy}{dx}=\frac{\triangle{y}}{\triangle{x}}=\frac{y_1-y_0}{x_1-x_0}=k \tag{1}</script><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E7%9B%B4%E7%BA%BF%E6%89%AB%E6%8F%8F%E8%BD%AC%E6%8D%A2%E7%AE%97%E6%B3%95/1.png" width="80%"></p><p>当$\epsilon$足够小时，精度会足够高。</p><p>由于设备的精度是有限的，因此通常令$\epsilon=\frac{1}{\max(|\triangle{x}|,|\triangle{y}|)}$，使得$\epsilon\triangle{x}$或$\epsilon\triangle{y}$中会有一个变成单位步长，算法在<strong>最大位移方向</strong>上，每次总是走一步，这样可以防止点与点之间的间距过大，产生一系列离散的点。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E7%9B%B4%E7%BA%BF%E6%89%AB%E6%8F%8F%E8%BD%AC%E6%8D%A2%E7%AE%97%E6%B3%95/2.png" width="80%"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DDAline</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x0, <span class="hljs-keyword">int</span> y0, <span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> y1)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> dx, dy, eps1, k;<br>    <span class="hljs-keyword">float</span> x, y, xIncre, yIncre;<br><br>    dx = x1 - x0; dy = y1 - y0;<br>    x = x0; y = y0;<br><br>  <span class="hljs-comment">// 最大位移方向判断</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(dx) &gt; <span class="hljs-built_in">abs</span>(dy)) eps1 = <span class="hljs-built_in">abs</span>(dx);<br>    <span class="hljs-keyword">else</span> eps1 = <span class="hljs-built_in">abs</span>(dy);<br><br>  <span class="hljs-comment">// x，y方向上增量的计算</span><br>    xIncre = (<span class="hljs-keyword">float</span>)dx / (<span class="hljs-keyword">float</span>)eps1;<br>    yIncre = (<span class="hljs-keyword">float</span>)dy / (<span class="hljs-keyword">float</span>)eps1;<br><br>  <span class="hljs-comment">// 输出最佳逼近的像素点</span><br>    <span class="hljs-keyword">for</span>(k = <span class="hljs-number">0</span>; k &lt;= eps1; k++)&#123;<br>        putpixel((<span class="hljs-keyword">int</span>)(x + <span class="hljs-number">0.5</span>), (<span class="hljs-keyword">int</span>)(y + <span class="hljs-number">0.5</span>));<br>        x += xIncre;<br>        y += yIncre;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="算法特点"><a href="#算法特点" class="headerlink" title="算法特点"></a>算法特点</h2><p>在一个迭代算法中，如果每一个$x$，$y$值是用前一步的值加上一个增量来获得的，那么，这种算法就称为增量算法。因此，DDA算法是一个<strong>增量算法</strong>。</p><p><strong>优点：</strong>DDA算法直观，易实现。</p><p><strong>缺点：</strong>有浮点数和浮点运算，效率不高。</p><h1 id="Bresenham算法"><a href="#Bresenham算法" class="headerlink" title="Bresenham算法"></a>Bresenham算法</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>输入：</strong>直线两个端点的坐标$P_0(x_0,y_0)$和$P_1(x_1,y_1)$。</p><p><strong>输出：</strong>最佳逼近这条直线的像素点集。</p><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>通过给定直线的两端点坐标$P_0(x_0,y_0)$和$P_1(x_1,y_1)$，可得到直线斜截式表示：$y=kx+b$，它的隐式方程为：$F(x,y)=y-kx-b=0$，其中$k=\frac{\triangle{y}}{\triangle{x}}=\frac{y_1-y_0}{x_1-x_0}$。</p><p>选取中点$M(x_{i}+1,y_{i}+0.5)$，判断直线在$x_{i}+1$上的值与$y_i+0.5$的大小关系。</p><p><strong>构造判别式：</strong>$d=F(x_M,y_M)=F(x_i+1,y_i+0.5)=y_i+0.5-k(x_i+1)-b$</p><ol><li>当$d&lt;0$时，取右上方$P_u$，$y_{i+1}=y_i+1$；</li><li>当$d=0$时，任取一个，约定取$P_d$，$y_{i+1}=y_i$；</li><li>当$d&gt;0$时，取正右方的$P_d$，$y_{i+1}=y_i$。</li></ol><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E7%9B%B4%E7%BA%BF%E6%89%AB%E6%8F%8F%E8%BD%AC%E6%8D%A2%E7%AE%97%E6%B3%95/3.png" width="60%"></p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E7%9B%B4%E7%BA%BF%E6%89%AB%E6%8F%8F%E8%BD%AC%E6%8D%A2%E7%AE%97%E6%B3%95/4.png" width="60%"></p><p><strong>$d$的初值</strong></p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}    d &= F(x_0+1,y_0+0.5)    \\      &= y_0+0.5-k(x_0+1)-b \\      &= y_0-kx_0-b-k+0.5 \\      &= 0.5-k\end{aligned}\end{equation}\tag{2}</script><p><strong>误差项递推</strong></p><ol><li>当$d&lt;0$时，下一个点的递推：</li></ol><script type="math/tex; mode=display">\begin{equation}\begin{aligned}    d &= F(x_i+2,y_i+1.5)    \\      &= y_i+1.5-k(x_i+2)-b \\      &= y_i+1.5-k(x_i+1)-b-k \\      &= d+1-k\end{aligned}\end{equation}\tag{3}</script><ol><li>当$d\geq 0$时，下一个点的递推：</li></ol><script type="math/tex; mode=display">\begin{equation}\begin{aligned}    d &= F(x_i+2,y_i+0.5)    \\      &= y_i+0.5-k(x_i+2)-b \\      &= y_i+0.5-k(x_i+1)-b-k \\      &= d-k\end{aligned}\end{equation}\tag{4}</script><p>由于$d$只用来判断正负，因此可以把$d$转化为整数方便计算。</p><p>$d$中有$0.5$和$k(k=\frac{\triangle{y}}{\triangle{x}})$，可以将$d$放大$2\triangle{x}$倍将其变为整数。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>在$0\leq k\leq 1$情况下的整数的中点Bresenham算法：</p><ol><li><p>输入直线的两端点$P_0(x_0,y_0)$和$P_1(x_1,y_1)$；</p></li><li><p>计算初始值$\triangle{x}$，$\triangle{y}$，$d=\triangle{x}-2\triangle{y}$，$x=x_0$，$y=y_0$；</p></li><li><p>绘制点$(x,y)$，判断$d$的符号：</p><ol><li>当$d&lt;0$时，$(x，y)$更新为$(x+1,y+1)$，$d$=$d+2\triangle{x}-2\triangle{y}$；</li><li>当$d\geq 0$时，$(x，y)$更新为$(x+1,y)$，$d$=$d-2\triangle{y}$；</li></ol></li><li><p>重复步骤$3$至直线画完。</p></li></ol><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><strong>起点：</strong>$P_0(0,0)$，<strong>终点：</strong>$P_1(8.5)$</p><p>$d_0=\triangle{x}-2\triangle{y}=8-2\times 5=-2$</p><p>当$d&lt;0$时，往右上方时的增量为：$2\triangle{x}-2\triangle{y}=2\times 8-2\times 5=6$；</p><p>当$d\geq 0$时，往右上方时的增量为：$-2\triangle{y}=-2\times 5=-10$；</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E7%9B%B4%E7%BA%BF%E6%89%AB%E6%8F%8F%E8%BD%AC%E6%8D%A2%E7%AE%97%E6%B3%95/5.png" width="80%"></p><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p><strong>改进一：</strong></p><ol><li><p>$d$的初值：$d_0=0$，令$e=d-0.5$，$e$的初值$e_0=-0.5$</p></li><li><p>$e$的变换及如何取点</p><p> $e=e+k$，$x_{i+1}=x_i+1$，$e&gt;0,y_{i+1}=y_i+1,e=e-1$，$e\leq0,y_{i+1}=y_i$</p></li></ol><p><strong>改进二：</strong></p><ol><li><p>$e$的初值$e_0=-\triangle{x}$</p></li><li><p>$e$的变换及如何取点</p><p> $e=e+2\triangle{y}$，$x_{i+1}=x_i+1$，$e&gt;0,y_{i+1}=y_i+1,e=e-e\triangle{x}$，$e\leq0,y_{i+1}=y_i$</p></li></ol><p><strong>过程：</strong></p><p>在$0\leq k\leq 1$情况下改进的Bresenham算法：</p><ol><li><p>输入直线的两端点$P_0(x_0,y_0)$和$P_1(x_1,y_1)$；</p></li><li><p>计算初始值$\triangle{x}$，$\triangle{y}$，$e=-\triangle{x}$，$x=x_0$，$y=y_0$；</p></li><li>绘制点$(x,y)$；</li><li><p>$e$更新为$e+2\triangle{y}$，判断$e$的符号：</p><ol><li>当$e&gt;0$时，$(x，y)$更新为$(x+1,y+1)$，同时将$e$更新为$e-2\triangle{x}$</li><li>当$e\leq 0$时，$(x，y)$更新为$(x+1,y)$</li></ol></li><li><p>重复步骤$3$和$4$至直线画完。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
            <tag> 直线生成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL绘制一个三角形</title>
      <link href="/2020/05/29/OpenGL%E7%BB%98%E5%88%B6%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2/"/>
      <url>/2020/05/29/OpenGL%E7%BB%98%E5%88%B6%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了如何用OpenGL绘制一个三角形，大致分为5个步骤。</p><ol><li>初始化: 初始化GLFW和GLAD</li><li>数据处理: 生成和绑定VBO和VAO, 设置属性指针</li><li>着色器: 顶点和片段着色器</li><li>渲染</li><li>善后工作</li></ol><a id="more"></a><h2 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h2><p><strong>注意：</strong>头文件顺序：先<code>glad/glad.h</code>再<code>GLFW/glfw3.h</code>，否则会报如下错误：</p><p><code>#error :  OpenGL header already included, remove this include, glad already provides it</code></p><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;glad/glad.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;GLFW/glfw3.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>    <span class="hljs-comment">// 在窗口中绘制一个三角形</span><br>    <span class="hljs-comment">// 1. 初始化: 初始化GLFW和GLAD</span><br>    <span class="hljs-comment">// 2. 数据处理: 生成和绑定VBO和VAO, 设置属性指针</span><br>    <span class="hljs-comment">// 3. 着色器: 顶点和片段着色器</span><br>    <span class="hljs-comment">// 4. 渲染</span><br>    <span class="hljs-comment">// 5. 善后工作</span><br><br>    <span class="hljs-comment">/**<br>     ** 初始化初始化GLFW和GLAD<br>     **/</span><br><br>    glfwInit();  <span class="hljs-comment">// 初始化GLFW</span><br><br>    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="hljs-number">3</span>);  <span class="hljs-comment">// OpenGL主版本号为3</span><br>    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="hljs-number">3</span>);  <span class="hljs-comment">// OpenGL次版本号为3</span><br><br>    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);  <span class="hljs-comment">// 使用核心模式(无需向后兼容性)</span><br>    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);   <span class="hljs-comment">// Mac OS X系统加这句话</span><br><br>    glfwWindowHint(GLFW_RESIZABLE, <span class="hljs-literal">false</span>);  <span class="hljs-comment">// 不可改变窗口大小</span><br><br>    <span class="hljs-comment">// 窗口宽高</span><br>    <span class="hljs-keyword">int</span> screen_width = <span class="hljs-number">1280</span>;<br>    <span class="hljs-keyword">int</span> screen_height = <span class="hljs-number">720</span>;<br><br>    <span class="hljs-comment">// 创建窗口(宽/高/窗口名称)</span><br>    <span class="hljs-keyword">auto</span> window = glfwCreateWindow(screen_width, screen_height, <span class="hljs-string">"Computer Graphics"</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-comment">// 如果窗口创建失败, 输出Failed to Create OpenGL Context</span><br>    <span class="hljs-keyword">if</span>(window == <span class="hljs-literal">nullptr</span>)&#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Failed to Create OpenGL Context"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>        glfwTerminate();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 将窗口的上下文设置为当前线程的主上下文</span><br>    glfwMakeContextCurrent(window);<br><br>    <span class="hljs-comment">// 初始化GLAD, 加载OpenGL函数指针地址的函数</span><br>    <span class="hljs-keyword">if</span>(!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))&#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Failed to initialize GLAD"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 创建视口, 指定当前视口尺寸, 前两个参数为左下角位置, 后两个参数是渲染窗口宽和高</span><br>    glViewport(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, screen_width, screen_height);<br><br><br>    <span class="hljs-comment">/**<br>     ** 数据处理: 生成和绑定VBO和VAO, 设置属性指针<br>     **/</span><br><br>    <span class="hljs-comment">// 三角形的顶点数据, 规范化(x,y,z)都要映射到[-1,1]之间</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> triangle[] = &#123;<br>        <span class="hljs-comment">// 位置</span><br>        <span class="hljs-number">-0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// 左下</span><br>         <span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// 右下</span><br>         <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>   <span class="hljs-comment">//正上</span><br>    &#125;;<br><br>    <span class="hljs-comment">// 生成并绑定立方体的VAO和VBO</span><br>    <span class="hljs-comment">// 核心模式需要使用VAO, 渲染时只需要调用一次VAO即可</span><br>    GLuint vertex_array_object; <span class="hljs-comment">// VAO</span><br>    glGenVertexArrays(<span class="hljs-number">1</span>, &amp;vertex_array_object);<br>    glBindVertexArray(vertex_array_object);<br><br>    GLuint vertex_buffer_object; <span class="hljs-comment">// VBO</span><br>    glGenBuffers(<span class="hljs-number">1</span>, &amp;vertex_buffer_object);<br>    glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer_object);<br><br>    <span class="hljs-comment">// 将顶点数据绑定到当前默认的缓冲中, 好处是不用将顶点数据一个一个地发送到显卡上, 可以借助VBO一次性发送所有顶点数据</span><br>    <span class="hljs-comment">// GL_STATIC_DRAW表示顶点数据不会被改变</span><br>    glBufferData(GL_ARRAY_BUFFER, <span class="hljs-keyword">sizeof</span>(triangle), triangle, GL_STATIC_DRAW);<br><br>    <span class="hljs-comment">// 设置顶点属性指针</span><br>    <span class="hljs-comment">// 第一个参数0: 顶点着色器的位置值</span><br>    <span class="hljs-comment">// 第二个参数3: 位置属性是一个三分量的向量</span><br>    <span class="hljs-comment">// 第三个参数: 顶点的类型</span><br>    <span class="hljs-comment">// 第四个参数: 是否希望数据标准化,映射到[0,1]</span><br>    <span class="hljs-comment">// 第五个参数: 步长,表示连续顶点属性之间的间隔,下一组的数据再3个float之后</span><br>    <span class="hljs-comment">// 第六个参数: 数据的偏移量, 位置属性在开头, 因此为0, 还需要强制类型转换</span><br>    glVertexAttribPointer(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">float</span>), (<span class="hljs-keyword">void</span> *)<span class="hljs-number">0</span>);<br>    glEnableVertexAttribArray(<span class="hljs-number">0</span>); <span class="hljs-comment">// 开启0通道</span><br><br>    <span class="hljs-comment">// 解绑VAO和VBO: 防止之后绑定VAO或VBO后, 对当前VAO和VBO产生影响, 使代码更加灵活规范</span><br>    glBindVertexArray(<span class="hljs-number">0</span>);<br>    glBindBuffer(GL_ARRAY_BUFFER, <span class="hljs-number">0</span>);<br><br><br>    <span class="hljs-comment">/**<br>     ** 着色器: 顶点和片段着色器<br>     **/</span><br><br>    <span class="hljs-comment">// 着色器源码 -&gt; 生成并编译着色器 -&gt; 链接着色器到着色器程序 -&gt; 删除着色器</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *vertex_shader_source =<br>            <span class="hljs-string">"#version 330 core\n"</span><br>            <span class="hljs-string">"layout(location = 0) in vec3 aPos;\n"</span> <span class="hljs-comment">// 位置变量属性设置为0</span><br>            <span class="hljs-string">"void main()\n"</span><br>            <span class="hljs-string">"&#123;\n"</span><br>            <span class="hljs-string">"    gl_Position = vec4(aPos, 1.0);\n"</span><br>            <span class="hljs-string">"&#125;\n\0"</span>;<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *fragment_shader_source =<br>            <span class="hljs-string">"#version 330 core\n"</span><br>            <span class="hljs-string">"out vec4 FragColor;\n"</span><br>            <span class="hljs-string">"void main()\n"</span><br>            <span class="hljs-string">"&#123;\n"</span><br>            <span class="hljs-string">"    FragColor = vec4(1.0f, 0.0f, 0.0f, 1.0f);\n"</span><br>            <span class="hljs-string">"&#125;\n\0"</span>;<br><br>    <span class="hljs-comment">// 生成并编译着色器</span><br>    <span class="hljs-comment">// 顶点着色器</span><br>    <span class="hljs-keyword">int</span> vertex_shader = glCreateShader(GL_VERTEX_SHADER);<br>    glShaderSource(vertex_shader, <span class="hljs-number">1</span>, &amp;vertex_shader_source, <span class="hljs-literal">NULL</span>);<br>    glCompileShader(vertex_shader);<br><br>    <span class="hljs-keyword">int</span> success;<br>    <span class="hljs-keyword">char</span> info_log[<span class="hljs-number">512</span>];<br><br>    <span class="hljs-comment">// 检查着色器是否成功编译, 如果编译失败, 打印错误信息</span><br>    glGetShaderiv(vertex_shader, GL_COMPILE_STATUS, &amp;success);<br>    <span class="hljs-keyword">if</span>(!success)&#123;<br>        glGetShaderInfoLog(vertex_shader, <span class="hljs-number">512</span>, <span class="hljs-literal">NULL</span>, info_log);<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ERROR::SHADER::VERTEX::COMPILATION_FAIILED\n"</span> &lt;&lt; info_log &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 片段着色器</span><br>    <span class="hljs-keyword">int</span> fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);<br>    glShaderSource(fragment_shader, <span class="hljs-number">1</span>, &amp;fragment_shader_source, <span class="hljs-literal">NULL</span>);<br>    glCompileShader(fragment_shader);<br><br>    <span class="hljs-comment">// 检查着色器是否成功编译, 如果编译失败, 打印错误信息</span><br>    glGetShaderiv(fragment_shader, GL_COMPILE_STATUS, &amp;success);<br>    <span class="hljs-keyword">if</span>(!success)&#123;<br>        glGetShaderInfoLog(fragment_shader, <span class="hljs-number">512</span>, <span class="hljs-literal">NULL</span>, info_log);<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ERROR::SHADER::FRAGMENT::COMPILATION_FAIILED\n"</span> &lt;&lt; info_log &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 链接顶点和片段着色器至一个着色器程序</span><br>    <span class="hljs-keyword">int</span> shader_program = glCreateProgram();<br>    glAttachShader(shader_program, vertex_shader);<br>    glAttachShader(shader_program, fragment_shader);<br><br>    glLinkProgram(shader_program);<br><br>    <span class="hljs-comment">// 检查着色器是否成功链接, 如果链接失败, 打印错误信息</span><br>    glGetProgramiv(shader_program, GL_LINK_STATUS, &amp;success);<br>    <span class="hljs-keyword">if</span>(!success)&#123;<br>        glGetProgramInfoLog(shader_program, <span class="hljs-number">512</span>, <span class="hljs-literal">NULL</span>, info_log);<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ERROR::SHADER::PROGRAM::LINKING_FAIILED\n"</span> &lt;&lt; info_log &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 删除顶点和片段着色器</span><br>    glDeleteShader(vertex_shader);<br>    glDeleteShader(fragment_shader);<br><br><br>    <span class="hljs-comment">/**<br>     ** 渲染<br>     **/</span><br><br>    <span class="hljs-keyword">while</span>(!glfwWindowShouldClose(window)) &#123;<br>        <span class="hljs-comment">// 清空颜色缓冲</span><br>        glClearColor(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>);   <span class="hljs-comment">// 用黑色背景色来清空</span><br>        glClear(GL_COLOR_BUFFER_BIT);<br><br>        <span class="hljs-comment">// 使用着色器程序</span><br>        glUseProgram(shader_program);<br><br>        <span class="hljs-comment">// 绘制三角形</span><br>        glBindVertexArray(vertex_array_object); <span class="hljs-comment">// 绑定VAO</span><br>        glDrawArrays(GL_TRIANGLES, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 绘制三角形, 绘制三角形, 顶点起始索引值, 绘制数量</span><br>        glBindVertexArray(<span class="hljs-number">0</span>); <span class="hljs-comment">// 解除绑定</span><br><br>        <span class="hljs-comment">// 交换缓冲并且检查是否有触发时间(比如键盘输入, 鼠标移动等)</span><br>        <span class="hljs-comment">// 双缓冲, 前置缓冲(保存输出图像), 后置缓冲/离屏缓冲(渲染指令在这里进行)</span><br>        glfwSwapBuffers(window);<br>        glfwPollEvents();   <span class="hljs-comment">// 检测是否会触发一些其他函数</span><br>    &#125;<br><br><br>    <span class="hljs-comment">/**<br>     ** 善后工作<br>     **/</span><br>    <span class="hljs-comment">// 删除VAO和VBO</span><br>    glDeleteVertexArrays(<span class="hljs-number">1</span>, &amp;vertex_array_object);<br>    glDeleteBuffers(<span class="hljs-number">1</span>, &amp;vertex_buffer_object);<br><br>    <span class="hljs-comment">// 清理所有的资源并正确退出程序</span><br>    glfwTerminate();<br><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="CMakeLists-txt"><a href="#CMakeLists-txt" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h2><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++">cmake_minimum_required(VERSION <span class="hljs-number">3.14</span>)<br>project(Learn-OpenGL)<br><br><span class="hljs-built_in">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">14</span>)<br><br>find_package(OpenCV)<br>include_directories($&#123;OpenCV_INCLUDE_DIRS&#125;)<br><br># 添加头文件<br><span class="hljs-built_in">set</span>(GLEW_H /usr/local/Cellar/glew/<span class="hljs-number">2.1</span><span class="hljs-number">.0</span>_1/include)<br><span class="hljs-built_in">set</span>(GLFW_H /usr/local/Cellar/glfw/<span class="hljs-number">3.3</span><span class="hljs-number">.2</span>/include)<br><span class="hljs-built_in">set</span>(GLAD_H /usr/local/include)<br>include_directories($&#123;GLEW_H&#125; $&#123;GLFW_H&#125; $&#123;GLAD_H&#125;)<br><br><br># 添加目标链接<br><span class="hljs-built_in">set</span>(GLEW_LINK /usr/local/Cellar/glew/<span class="hljs-number">2.1</span><span class="hljs-number">.0</span>_1/lib/libGLEW<span class="hljs-number">.2</span><span class="hljs-number">.1</span>.dylib)<br><span class="hljs-built_in">set</span>(GLFW_LINK /usr/local/Cellar/glfw/<span class="hljs-number">3.3</span><span class="hljs-number">.2</span>/lib/libglfw<span class="hljs-number">.3</span>.dylib)<br>link_libraries($&#123;OPENGL&#125; $&#123;GLEW_LINK&#125; $&#123;GLFW_LINK&#125;)<br><br><br># 执行编译命令<br><span class="hljs-built_in">set</span>(SOURCE_FILES glad.c main.cpp)<br>add_executable(ccc $&#123;SOURCE_FILES&#125;)<br><br>target_link_libraries(ccc $&#123;OpenCV_LIBS&#125;) # 链接库<br><br><span class="hljs-keyword">if</span> (APPLE)<br>    target_link_libraries(ccc <span class="hljs-string">"-framework OpenGL"</span>)<br>endif()<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
          <category> OpenGL </category>
          
          <category> 应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>向量</title>
      <link href="/2020/05/19/%E5%90%91%E9%87%8F/"/>
      <url>/2020/05/19/%E5%90%91%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了向量的一些基本性质、内积(点积/标量积)、外积(叉积/向量积)、向量空间(Gram-Schmidt正交化算法)。</p><a id="more"></a><h1 id="向量性质"><a href="#向量性质" class="headerlink" title="向量性质"></a>向量性质</h1><h2 id="向量表示"><a href="#向量表示" class="headerlink" title="向量表示"></a>向量表示</h2><p>用实数的$n$元组表示向量，其中$n$一般为2、3或4.</p><p>一个$n$维向量可以表示为：</p><script type="math/tex; mode=display">V=(V_1,V_2,...,V_n)\tag{1}</script><p>其中，数值$V_i$被称为向量$V$的分量。这里的下标为数字下标，实际应用中常用分量对应的坐标轴的名称作为下标，例如三维点向量$P$的分量常表示为$P_x$，$P_y$和$P_z$。</p><p>方程$(1)$中的向量也可以表示成仅有一列$n$行的矩阵：</p><script type="math/tex; mode=display">V= \left[   \begin{matrix}     V1 \\     V2  \\     ... \\     V_n    \end{matrix}   \right] \tag{2}</script><h2 id="转置向量"><a href="#转置向量" class="headerlink" title="转置向量"></a>转置向量</h2><script type="math/tex; mode=display">V^T=\left [        \begin{matrix}        V1 & V2 & ... & V_n        \end{matrix}        \right ]        \tag{3}</script><h2 id="向量与标量乘积"><a href="#向量与标量乘积" class="headerlink" title="向量与标量乘积"></a>向量与标量乘积</h2><p>向量可以乘以一个标量变成一个新的向量，而<strong>向量中的各个分量的相对值不变</strong>。标量$a$与向量$V$的乘积定义如下：</p><script type="math/tex; mode=display">aV=Va=(aV_1,aV_2,...,aV_n) \tag{4}</script><p>当$a=-1$时，可以用简化符号$-V$表示向量$V$的反向量。</p><h2 id="向量加法"><a href="#向量加法" class="headerlink" title="向量加法"></a>向量加法</h2><p>向量的加法和减法是按分量逐个相加或相减完成的。</p><script type="math/tex; mode=display">P+Q=(P_1+Q_1,P_2+Q_2,...,P_n+Q_n) \tag{5}</script><p>两个向量的差可以写作$P-Q$，实际上是两个向量和$P+(-Q)$的简化表示。</p><h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><p>给定任意两个标量$a$和$b$，三个向量$P$、$Q$和$R$，以下性质成立：</p><ol><li>$P+Q=Q+P$</li><li>$(P+Q)+R=P+(Q+R)$</li><li>$(ab)P=a(bP)$</li><li>$a(P+Q)=aP+aQ$</li><li>$(a+b)P=aP+bP$</li></ol><p>利用实数的交换律和结合律，以上性质可以通弄过直接计算得到验证。</p><h2 id="向量绝对值（范数-长度）"><a href="#向量绝对值（范数-长度）" class="headerlink" title="向量绝对值（范数/长度）"></a>向量绝对值（范数/长度）</h2><p>$n$维向量$V$的绝对值是一个标量，用$|V|$表示，计算公式如下：</p><script type="math/tex; mode=display">\|V\|=\sqrt{\sum^{n}_{i=1}V_i^2} \tag{6}</script><p>绝对值为1的向量被称为单位长度向量或者简单称为单位向量，当向量$V$表示一个三维点或者方向时，公式$(6)$可以写为：</p><script type="math/tex; mode=display">\|V\|=\sqrt{V_x^2+V_y^2+V_z^2} \tag{7}</script><p>对于一个至少含有一个非零分量的向量$V$，通过给该向量乘以$\frac{1}{|V|}$，可以将其变成一个单位长度向量，该操作被称为<strong>向量的规范化</strong>，在3D图形学中经常用到。</p><p>注意：向量的规范化与法向量无关，法向量是在某点与表面垂直的向量。</p><h3 id="定理-1"><a href="#定理-1" class="headerlink" title="定理"></a>定理</h3><p>给定任意标量$a$和两个任意向量$P$、$Q$，以下性质成立：</p><ol><li>$|P|\geq0$</li></ol><p><strong>证明</strong></p><p>因为式$(6)$中被开平方的数是平方数的和，所以$|P|\geq0$。</p><ol><li>当且仅当$P=(0,0,0,…,0)$，$|P|=0$</li></ol><p><strong>证明</strong></p><p>若$P=(0,0,0,…,0)$，则式$(6)$中的被开平方数等于0，因此$|P|=0$。相反，若$|P|=0$，则向量$P$的每个分量必须为$0$，否则式$(6)$中平方和为正数，与$|P|=0$矛盾。</p><ol><li>$|aP|=|a||P|$</li></ol><p><strong>证明</strong></p><p>根据式$(6)$可得，</p><script type="math/tex; mode=display">\|aP\|=\sqrt{\sum^n_{i=1}a^2P_i^2}=\sqrt{a^2\sum^n_{i=1}P_i^2}=|a|\sqrt{\sum^n_{i=1}P_i^2}=|a|\|P\| \tag{8}</script><ol><li>$|P+Q|\leq|P|+|Q|$</li></ol><p><strong>证明</strong></p><p>方法1：</p><p>如果将向量$P$和$Q$看成三角形的两个边，可用几何学的原理证明$|P+Q|\leq|P|+|Q|$，该式也被称为三角不等式。$P+Q$可以构成三角形的第三条边，该边的长度不可能大于其他两条边的长度之和。</p><p>方法2：</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}\|P+Q\|^2 &=(P+Q)\cdot(P+Q) \\ &= P^2+Q^2+2P\cdot Q \\ &= P^2+Q^2+2\|P\|\|Q\| \\ &=(\|P\|+\|Q\|)^2\end{aligned}\end{equation}\tag{16}</script><p>式$(16)$开平方，可得到不等式，证毕。</p><h1 id="内积-点积-标量积"><a href="#内积-点积-标量积" class="headerlink" title="内积(点积/标量积)"></a>内积(点积/标量积)</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>内积主要用于计算两个向量的方向差。</p><p>两个$n$维向量$P$和$Q$的内积可以表示为$P\cdot Q$，是一个标量，由以下公式计算：</p><script type="math/tex; mode=display">P\cdot Q=\sum^n_{i=1}P_iQ_i \tag{9}</script><p>两个向量的内积是每个分量乘积的和，对于三维向量，其内积可表示为：</p><script type="math/tex; mode=display">P\cdot Q=P_xQ_x+P_yQ_y+P_zQ_z \tag{10}</script><p>向量$P$和$Q$的内积$P\cdot Q$也可以表示成矩阵乘积：</p><script type="math/tex; mode=display">P^T\cdot Q=\left[                     \begin{matrix}                      P_1 & P_2 & ... &P_n                     \end{matrix}                     \right]                     \left[                     \begin{matrix}                      Q_1 \\            Q_2 \\            ... \\            Q_n                     \end{matrix}                     \right]                     \tag{11}</script><p>式$(11)$的结果为一个$1\times1$矩阵，即标量。</p><h3 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h3><p>给定任意两个$n$维向量$P$和$Q$，内积$P\cdot Q$满足以下等式：</p><script type="math/tex; mode=display">P\cdot Q=\|P\|\|Q\|\cos\alpha \tag{12}</script><p>其中，$\alpha$是坐标原点分别与向量$P$和$Q$对应的点之间连线的平面夹角。</p><p><strong>证明</strong></p><p>如图所示，令其中$\alpha$为向量$P$和$Q$之间的夹角，根据余弦定理可得：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%90%91%E9%87%8F/1.png" width="30%" div align="c"></p><script type="math/tex; mode=display">\|P-Q\|^2=\|P\|^2+\|Q\|^2-2\|P\|\|Q\|\cos\alpha \tag{13}</script><p>展开可得：</p><script type="math/tex; mode=display">\sum^n_{i=1}(P_i-Q_i)^2=\sum^n_{i=1}P_i^2+\sum^n_{i=1}Q_i^2-2\|P\|\|Q\|\cos\alpha \tag{14}</script><p>消去所有$P_i^2$和$Q_i^2$得：</p><script type="math/tex; mode=display">\sum^n_{i=1}-2P_iQ_i=-2\|P\|\|Q\|\cos\alpha \tag{15}</script><p>两边同除以$-2$，得式$(12)$。</p><p><strong>证毕</strong></p><p>由定理1可以得出两个重要结论：</p><ol><li>如果$P\cdot Q=0$，则两个向量$P$和$Q$互相垂直，因为$90^\circ$角的余弦值等于0，两个内积为$0$的向量称为<strong>正交向量</strong>，约定零向量$0=(0,0,0,…,0)$与任意向量$P$垂直，这是因为$0\cdot P$一定等于$0$。</li><li>向量内积的正负反映两个向量的指向方向，如下图所示，假设一个平面过原点，并与向量$P$垂直，则与向量$P$位于该平面同侧的任意向量与$P$的内积为正，而位于该平面另一侧的任意向量与$P$的内积为负。</li></ol><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%90%91%E9%87%8F/2.png" width="30%" div align="c"></p><h3 id="定理2"><a href="#定理2" class="headerlink" title="定理2"></a>定理2</h3><p>给定任意标量$a$和任意三个向量$P$、$Q$和$R$，向量内积具有以下性质：</p><ol><li>$P\cdot Q=Q\cdot Q$</li><li>$(aP)\cdot Q=a(P\cdot Q)$</li><li>$P\cdot(Q+R)=P\cdot Q+P\cdot R$</li><li>$P\cdot P=|P|^2$</li></ol><p><strong>证明</strong></p><p>由式$(6)|V|=\sqrt{\sum^{n}_{i=1}V_i^2}$和式$(9)P\cdot Q=\sum^n_{i=1}P_iQ_i$得出。</p><ol><li>$|P\cdot Q|\leq |P||Q|$（Cauchy-Schwarz不等式）</li></ol><p><strong>证明</strong></p><p>由$P\cdot Q=|P||Q|\cos\alpha$，$|\cos\alpha|\leq 1$得出。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>在实际应用中，经常要将向量$P$分解为另一向量$Q$垂直或平行的分量，如下图所示：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%90%91%E9%87%8F/3.png" width="30%" div align="c"></p><p>如果将向量$P$当做一个直角三角形的斜边，则其在向量$Q$上的垂直投影就为向量$P$和$Q$的夹角$\alpha$的邻边。</p><p>根据基本三角学原理可知，角$\alpha$的邻边长度为$|P|\cos\alpha$，根据定理1可得，不用计算角$\alpha$的数值也可算出角$\alpha$邻边的长度，如下式：</p><script type="math/tex; mode=display">\|P\|\cos\alpha=\frac{P\cdot Q}{\|Q\|} \tag{17}</script><p>与向量$Q$平行，而大小不同的向量，可以用该向量的长度乘以单位向量$\frac{Q}{|Q|}$获得。向量$P$在向量$Q$上的投影$proj_QP$可表示为：</p><script type="math/tex; mode=display">proj_QP=\frac{P\cdot Q}{\|Q\|^2}Q \tag{18}</script><p>向量$P$相对于向量$Q$的垂直向量可表示为$perp_QP$，等于原始向量$P$减去式$(18)$中所示的平行分量的差：</p><script type="math/tex; mode=display">perp_QP=P-proj_QP=P-\frac{P\cdot Q}{\|Q\|^2}Q \tag{19}</script><p>向量$P$在向量$Q$上的投影是向量$P$的线性变换，可以表示成矩阵向量乘积的形式，在三维情况下，$proj_QP$可用以下等式计算：</p><script type="math/tex; mode=display">proj_QP=\frac{1}{\|Q\|^2}                \left[                \begin{matrix}                Q_x^2  &    Q_xQ_y &    Q_xQ_z \\                Q_xQ_y &    Q_y^2  &    Q_yQ_z \\                Q_xQ_z &    Q_yQ_z  &    Q_z^2 \\                \end{matrix}                \right]                \left[                \begin{matrix}                P_x \\                P_y \\                P_z\\                \end{matrix}                \right]                \tag{20}</script><h1 id="外积-叉积-向量积"><a href="#外积-叉积-向量积" class="headerlink" title="外积(叉积/向量积)"></a>外积(叉积/向量积)</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>给定两个三维向量$P$和$Q$，它们的外积可写为$P\times Q$，其结果也是一个向量，如下式所示：</p><script type="math/tex; mode=display">P\times Q = (P_yQ_z-P_zQ_y,P_zQ_x-P_xQ_z,P_xQ_y-P_yQ_x) \tag{21}</script><p>两个向量的外积产生一个与这两个向量都垂直的新向量。</p><p>若外积不为零向量，则必定是一个与这两个向量都垂直的向量，满足条件的向量有两个，它们方向相反。</p><p>向量外积计算遵循右手定律，若右手手指的方向与向量$P$的方向对齐，手掌朝向向量$Q$的方向，则拇指所指的方向就是向量$P\times Q$的方向。</p><p>一个应用就是根据给定物体表面上某一点的两个不同切向量，<strong>计算出物体表面在该点的法向量</strong>。</p><p>外积的公式也可谢伟一个伪行列式（第一行为向量，其他行为标量）的计算：</p><script type="math/tex; mode=display">P\times Q=\left|                    \begin{matrix}                    i   &   j &   k \\                    P_x & P_y & P_z \\                    Q_x & Q_y & Q_z \\                \end{matrix}                    \right|                    = i(P_yQ_z-P_zQ_y)-j(P_xQ_z-P_zQ_x)+k(P_xQ_y-P_yQ_x)                    \tag{22}</script><p>其中，$i$，$j$，$k$分别是与坐标系的$x$，$y$和$z$轴平行的单位向量。</p><script type="math/tex; mode=display">i=(1,0,0) \\j=(0,1,0) \\ k=(0,0,1)\tag{23}</script><p>将这三个向量组成一个循环，令$i$在$j$前面，$j$在$k$前面，$k$在$i$前面，则相邻两个向量按此次序的外积为第三个向量，如下式所示：</p><script type="math/tex; mode=display">i\times j = k \\j\times k = i \\ k\times i = j\tag{32}</script><p>相邻两个向量的相反次序的外积为第$3$个向量的相反向量，如下式所示：</p><script type="math/tex; mode=display">j\times i = -k \\k\times j = -i \\ i\times k = -j\tag{32}</script><p>外积$P\times Q$也可以表示成对向量$Q$进行的一个基于向量$P$的线性变化，如下所示：</p><script type="math/tex; mode=display">P\times Q=\left[                    \begin{matrix}                    0   & -P_z &  P_y \\                    P_z &    0 & -P_x \\                 -P_y & -P_x &    0 \\                \end{matrix}                    \right]                    \left[                    \begin{matrix}                    Q_x \\                    Q_y \\                  Q_z \\                \end{matrix}                    \right]                    \tag{24}</script><h2 id="定理1-1"><a href="#定理1-1" class="headerlink" title="定理1"></a>定理1</h2><p>令两个向量$P$和$Q$为三维向量，则$(P\times Q)\cdot P=0$，并且$(P\times Q)\cdot Q=0$。</p><p><strong>证明</strong></p><p>根据向量的内积和外积的定义可得：</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}(P\times Q)\cdot P &=(P_yQ_z-P_zQ_y,P_zQ_x-P_xQ_z,P_xQ_y-P_yQ_x)\cdot P \\                                     &=P_xP_yQ_z-P_xP_zQ_y+P_yP_zQ_x-P_yP_xQ_z+P_zP_xQ_y-P_zP_yQ_x \\                                             &=0\end{aligned}\end{equation}\tag{25}</script><p>同理可证，$(P\times Q)\cdot Q=0$。</p><p><strong>证毕</strong></p><p>定理1可以判断$3$个三维向量$P$，$Q$和$R$的关系。</p><script type="math/tex; mode=display">(P\times Q)\cdot R= \left|                    \begin{matrix}                    P_x & P_y & P_z \\                    Q_x & Q_y & Q_z \\                    R_x & R_y & R_z \\                    \end{matrix}                    \right|                    \tag{26}</script><p>如果$3$个三维向量$P$，$Q$和$R$中任意一个向量可以表示成另外两个向量的线性组合，该行列式的值为0，这时$R=P$或者$R=Q$。</p><h2 id="定理2-1"><a href="#定理2-1" class="headerlink" title="定理2"></a>定理2</h2><p>给定两个三维向量$P$和$Q$，外积$P\times Q$满足以下方程：</p><script type="math/tex; mode=display">\|P\times Q\|=\|P\|\|Q\|\sin\alpha \tag{27}</script><p>其中，$\alpha$是坐标原点分别与向量$P$和$Q$对应的点之间连线的平面夹角。</p><p><strong>证明</strong></p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}\|P\times Q\|^2 &= \|(P_yQ_z-P_zQ_y,P_zQ_x-P_xQ_z,P_xQ_y-P_yQ_x)\|^2 \\                &= (P_yQ_z-P_zQ_y)^2+(P_zQ_x-P_xQ_z)^2+(P_xQ_y-P_yQ_x)^2 \\                &= (P_y^2+P_z^2)Q_x^2+(P_x^2+P_z^2)Q_y^2+(P_x^2+P_y^2)Q_z^2- \\                  &\quad 2P_xQ_xP_yQ_y-2P_xQ_xP_zQ_z-2P_yQ_yP_zQ_z\end{aligned}\end{equation}\tag{28}</script><p>在上式右侧加$P_x^2Q_x^2+P_y^2Q_y^2+P_z^2Q_z^2$，再减去它，得：</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}\|P\times Q\|^2 &= (P_x^2+P_y^2+P_z^2)(Q_x^2+Q_y^2+Q_z^2)-(P_xQ_x+P_yQ_y+P_zQ_z)^2 \\                              &= \|P\|^2\|Q\|^2-(P\cdot Q)^2\end{aligned}\end{equation}\tag{29}</script><p>将式$(12)P\cdot Q=|P||Q|\cos\alpha$代入式$(29)$中，替换内积$P\cdot Q$得：</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}\|P\times Q\|^2 &= \|P\|^2\|Q\|^2-\|P\|^2\|Q\|^2\cos^2\alpha  \\                              &= \|P\|^2\|Q\|^2(1-\cos^2\alpha) \\                              &= \|P\|^2\|Q\|^2\sin^2\alpha\end{aligned}\end{equation}\tag{30}</script><p>等式两边开平方，则得$|P\times Q|=|P||Q|\sin\alpha$。</p><p><strong>证毕</strong></p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%90%91%E9%87%8F/4.png" width="30%" div align="c"></p><p>定理2中计算出的两个向量外积$P\times Q$的大小等于平行四边形的面积，该平行四边形的两个邻边分别是两个向量$P$和$Q$，继而可以得出，由三个顶点$V_1$，$V_2$和$V_3$组成的任意三角形的面积$A$可由以下公式得到：</p><script type="math/tex; mode=display">A=\frac{1}{2}\|(V_2-V_1)\times(V_3-V_1)\| \tag{31}</script><h2 id="定理3"><a href="#定理3" class="headerlink" title="定理3"></a>定理3</h2><p>给定任意$2$个标量$a$和$b$以及任意$3$个三维向量$P$、$Q$和$R$，向量外积具有以下性质：</p><ol><li><p>$Q\times P=-(P\times Q)$        <strong>外积不满足交换律，要取反。</strong></p></li><li><p>$(aP)\times Q=a(P\times Q)$</p></li><li>$P\times(Q+R)=P\times Q+P\times R$</li><li>$P\times P=0=(0,0,0)$</li><li>$(P\times Q)\cdot R=(R\times P)\cdot Q=(Q\times R)\cdot P$</li></ol><p><strong>证明</strong></p><p>由式$(26)$直接得出。</p><ol><li>$P\times (Q\times P) = (P\times Q\times P)=P^2Q-(P\cdot Q)P$</li></ol><p><strong>证明</strong></p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}P\times (Q\times P) &= P\times [-(P\times Q)] \\                                  &= -[-(P\times Q)\times P] \\                                  &= P\times Q\times P\end{aligned}\end{equation}\tag{34}</script><p>其$x$分量等于：</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}(P\times Q\times P)_x &= ((P_yQ_z-P_zQ_y,P_zQ_x-P_xQ_z,P_xQ_y-P_yQ_x)\times P)_x  \\                                        &= (P_zQ_x-P_xQ_z)P_z-(P_xQ_y-P_yQ_x)P_y  \\                                        &= (P_y^2+P_z^2)Q_x-(P_yQ_y-P_zQ_z)P_x\end{aligned}\end{equation}\tag{35}</script><p>对上式加一个$P_x^2Q_x$，再减去$P_x^2Q_x$，可以得到需要的结果：</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}    (P_y^2+P_z^2)Q_x-(P_yQ_y-P_zQ_z)P_x &=     (P_y^2+P_z^2)Q_x+P_x^2Q_x-(P_yQ_y-P_zQ_z)P_x-P_x^2Q_x \\    &= (P_x^2+P_y^2+P_z^2)Q_x-(P_xQ_x+P_yQ_y-P_zQ_z)P_x \\    &= P^2Q_x-(P\cdot Q)P_x\end{aligned}\end{equation}\tag{36}</script><p>同理，可得到$y$和$z$分量。</p><p><strong>证毕</strong></p><p>向量外积不满足结合律，即任意3个三维向量$P$，$Q$和$R$，$(P\times Q)\times R\neq P\times(Q\times R)$成立。</p><p>例如，令$P=(1,1,0)$、$Q=(0,1,1)$和$R=(1,0,1)$，首先计算$(P\times Q)\times R$，有：</p><script type="math/tex; mode=display">P\times Q = \left|                        \begin{matrix}                        i & j & k \\                        1 & 1 & 0 \\                        0 & 1 & 1                        \end{matrix}                        \right|                    = (1,-1,1)                    \tag{37}</script><script type="math/tex; mode=display">(P\times Q)\times R = \left|                      \begin{matrix}                      i &  j & k \\                      1 & -1 & 1 \\                      1 &  0 & 1                      \end{matrix}                      \right|                    = (-1,0,1)                    \tag{38}</script><p>再计算$P\times (Q\times R)$，有：</p><script type="math/tex; mode=display">Q\times R = \left|            \begin{matrix}            i &  j & k \\            0 &  1 & 1 \\            1 &  0 & 1            \end{matrix}            \right|            = (1,1,-1)            \tag{39}</script><script type="math/tex; mode=display">P\times (Q\times R) = \left|                      \begin{matrix}                      i &  j &  k \\                      1 &  1 &  0 \\                      1 &  1 & -1                      \end{matrix}                      \right|                    = (-1,1,0)                    \tag{40}</script><p>综上可得，$(P\times Q)\times R\neq P\times(Q\times R)$。</p><h1 id="向量空间"><a href="#向量空间" class="headerlink" title="向量空间"></a>向量空间</h1><h2 id="定义1"><a href="#定义1" class="headerlink" title="定义1"></a>定义1</h2><p>向量空间是一个集合$V$，该集合的元素都是向量。</p><p>包含全部$n$元组形式向量的向量空间表示为$\R^n$。</p><p>若定义了加法和标量乘法，则以下性质成立：</p><ol><li>集合$V$对加法运算封闭，即集合$V$中的任意向量$P$和$Q$，它们的和$P+Q$也是集合$V$的向量。</li><li>集合$V$对标量乘法运算封闭，即对于任意实数$a$和集合$V$中的任意向量$P$，它们的积$aP$也是集合$V$的向量。</li><li>集合$V$中存在零向量，对于集合$V$中的任意向量$P$，$P+0=0+P=P$成立。</li><li>集合$V$中任意向量$P$，在集合$V$中存在向量$Q$，使$P+Q=0$成立。</li><li>集合$V$中向量加法满足结合律，即对于集合$V$中的任意向量$P$、$Q$和$R$，$(P+Q)+R=P+(Q+R)$成立。</li><li>标量乘法满足结合律，即对于任意实数$a$和$b$，以及集合$V$中的任意向量$P$，$(ab)P=a(bP)$成立。</li><li>标量与向量和的乘法满足分配率，即对于任意实数$a$，以及集合$V$中的任意向量$P$和$Q$，$a(P+Q)=aP+aQ$成立。</li><li>标量和与向量的乘法满足分配率，即对于任意实数$a$和$b$，以及集合$V$中的任意向量$P$，$(a+b)P=aP+bP$成立。</li></ol><p>若向量空间的所有向量都可以由其子集的向量线性组合产生，则该子集称为<strong>向量空间的基</strong>。</p><h2 id="定义2"><a href="#定义2" class="headerlink" title="定义2"></a>定义2</h2><p>对于含有$n$个向量的集合$(e_1,e_2,…,e_n)$，如果不存在补全为$0$的数$a_1,a_2,…,a_n$，使得下式成立，则向量集合线性无关，反之，则向量集合线性相关。</p><script type="math/tex; mode=display">a_1e_1+a_2e_2+...+a_ne_n=0  \tag{41}</script><h2 id="定义3"><a href="#定义3" class="headerlink" title="定义3"></a>定义3</h2><p>一个$n$维向量空间可以由$n$个线性无关向量的集合生成，生成向量空间的向量集合称为向量空间的基。</p><p><strong>正式定义</strong></p><p>向量空间$V$的基$\beta$是$n$个线性无关向量的集合，$\beta=(e_1,e_2,…,e_n)$，对于向量空间$V$中的任意向量$P$，存在一组实数$a_1,a_2,…,a_n$，使下式成立：</p><script type="math/tex; mode=display">P=a_1e_1+a_2e_2+...+a_ne_n \tag{42}</script><p>一个$n$维向量空间的每个基中有且仅有$n$个向量。例如，在三维向量空间$\R^3$中不可能存在由4个线性无关的向量组成的集合，而且仅有两个线性无关的向量也不足以生成整个三维向量空间。</p><p>向量空间$\R^n$有无穷多个基。</p><h2 id="定义4"><a href="#定义4" class="headerlink" title="定义4"></a>定义4</h2><p>在向量空间的基$\beta$中，如果任意两个向量$e_i$和$e_j$，$i\neq j$，且$e_i\cdot e_j=0$（两个向量线性无关），则基$\beta$称为向量空间的正交基。</p><h2 id="定理1-2"><a href="#定理1-2" class="headerlink" title="定理1"></a>定理1</h2><p>给定任意两个向量$e_1$和$e_2$，如果$e_1\cdot e_2=0$，则$e_1$和$e_2$两个向量线性无关。</p><p><strong>证明</strong></p><p>反证法。</p><p>假设任意两个向量$e_1$和$e_2$非线性无关，即$e_1$和$e_2$线性相关，则存在标量$a_1$和$a_2$，使$a_1e_1+a_2e_2=0$。</p><p>由于$a_1$和$a_2$不全为$0$，假设$a_2$不为$0$，则$e_2=-(a_1/a_2)e_1$。</p><p>而$e_1\cdot e_2=-(a_1/a_2)e_1^2\neq 0$，与已知条件$e_1\cdot e_2=0$矛盾。</p><p><strong>证毕</strong></p><p>如果在向量空间$V$中，找到<strong>$n$个正交向量</strong>，那么这些正交向量的集合组成<strong>向量空间的基</strong>。</p><h2 id="定义5"><a href="#定义5" class="headerlink" title="定义5"></a>定义5</h2><p>对于向量空间的正交基，如果其中每个向量的长度均为$1$，则称为<strong>规范正交基</strong>。</p><p>为了方便表示，引入克罗内克符号函数，如下式所示：</p><script type="math/tex; mode=display">\delta_{ij}\equiv \left \{                                     \begin{matrix}                                    1，如果i=j \\                                    0，如果i\neq j                                    \end{matrix}                                    \right.                                    \tag{43}</script><p>在向量空间的基$\beta=(e_1,e_2,…,e_n)$中，如果任意两个向量$e_i$和$e_j$，$e_i \cdot e_j = \delta_{ij}$，则基$\beta$称为向量空间的<strong>规范正交基</strong>。</p><p>显然，向量集合$(i,j,k)$和$[(\frac{\sqrt{2}}{2},\frac{\sqrt{2}}{2},0),(-\frac{\sqrt{2}}{2},\frac{\sqrt{2}}{2},0),(0,0,1)]$是三维向量空间$\R^3$的规范正交基。</p><h2 id="Gram-Schmidt正交化算法"><a href="#Gram-Schmidt正交化算法" class="headerlink" title="Gram-Schmidt正交化算法"></a>Gram-Schmidt正交化算法</h2><p><strong>作用</strong>：在向量空间$\R^n$中，将$n$个线性无关向量组成的集合变换成正交基的方法。</p><p><strong>基本思想</strong>：将集合中的每个向量减去该向量在其前面的所有向量上的投影，剩余向量必定与其前面的所有向量正交。</p><p><strong>具体算法</strong>：</p><p>给定$n$个线性无关向量组成的集合$\beta=(e_1,e_2,…,e_n)$，该算法可计算出向量集合$\beta’=(e_1’,e_2’,…,e_n’)$，当$i\neq j$时，$e_i’\cdot e_j’=0$。</p><ol><li>令$e_1’=e1$。</li><li>$i=2$。</li><li>从向量$e_i$中减去$e_i$在向量$e_1’,e_2’,…,e_{i-1}’$上的投影，结果保存到$e_i’$中，即：</li></ol><script type="math/tex; mode=display">e_i'=e_i-\sum_{k=1}^{i-1}\frac{e_i\cdot e_k'}{e_k'^2}e_k' \tag{44}</script><ol><li>如果$i&lt;n$，则$i+1$，转到步骤$3$。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数学之美 </category>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 向量 </tag>
            
            <tag> 数学wa </tag>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵</title>
      <link href="/2020/05/19/%E7%9F%A9%E9%98%B5/"/>
      <url>/2020/05/19/%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍了矩阵的基本性质、线性方程组</p><a id="more"></a><h1 id="矩阵性质"><a href="#矩阵性质" class="headerlink" title="矩阵性质"></a>矩阵性质</h1><h2 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h2><p>一个$n\times m$矩阵$M$是由$n$行$m$列数字组成的数组，$M_{ij}$表示矩阵$M$第$i$行第$j$列元素。</p><script type="math/tex; mode=display">M = \left [        \begin{matrix}        M_{00} & M_{01} & M_{02} & M_{03} \\        M_{10} & M_{11} & M_{12} & M_{13} \\        M_{20} & M_{21} & M_{22} & M_{23} \\        M_{30} & M_{31} & M_{32} & M_{33} \\      \end{matrix}        \right]        \tag{1}</script><h2 id="方阵"><a href="#方阵" class="headerlink" title="方阵"></a>方阵</h2><p>如果$n=m$，则称矩阵$M$为<strong>方阵</strong>。</p><h2 id="对角矩阵"><a href="#对角矩阵" class="headerlink" title="对角矩阵"></a>对角矩阵</h2><p>只有主对角元素(矩阵中下标$i=j$的元素)均不为零的方阵称为<strong>对角矩阵</strong>。</p><h2 id="转置矩阵"><a href="#转置矩阵" class="headerlink" title="转置矩阵"></a>转置矩阵</h2><p>一个$n\times m$矩阵$M$的转置矩阵表示为$M^T$，是一个$m\times n$矩阵，其中的$(i,j)$元素等于$M_{ji}$，即$M_{ij}^T=M{ji}$。</p><p>式$(1)$所示的矩阵$M$的转置矩阵可表示为：</p><script type="math/tex; mode=display">M^T = \left [      \begin{matrix}      M_{00} & M_{10} & M_{20} & M_{30} \\      M_{01} & M_{11} & M_{21} & M_{31} \\      M_{02} & M_{12} & M_{22} & M_{32} \\      M_{03} & M_{13} & M_{23} & M_{33} \\      \end{matrix}      \right]      \tag{2}</script><h2 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h2><h3 id="标量与矩阵积"><a href="#标量与矩阵积" class="headerlink" title="标量与矩阵积"></a>标量与矩阵积</h3><p>给定标量$a$和矩阵$M$，它们的乘积$aM$的计算公式如下：</p><script type="math/tex; mode=display">aM=Ma=M = \left [          \begin{matrix}          aM_{00} & aM_{01} & ... & aM_{0m} \\          aM_{10} & aM_{11} & ... & aM_{1m} \\            ...   &   ...   & ... &   ...   \\          aM_{n0} & aM_{n1} & ... & aM_{nm} \\          \end{matrix}          \right]          \tag{3}</script><h3 id="矩阵加法"><a href="#矩阵加法" class="headerlink" title="矩阵加法"></a>矩阵加法</h3><p>给定两个$n\times m$矩阵$F$和$G$，则它们的和$F+G$计算公式如下：</p><script type="math/tex; mode=display">F+G = \left [      \begin{matrix}      F_{00}+G_{00} & F_{01}+G_{01} & ... & F_{0m}+G_{0m} \\      F_{10}+G_{10} & F_{11}+G_{11} & ... & F_{1m}+G_{1m} \\       ...   &  ...   & ... &  ...   \\      F_{n0}+G_{n0} & F_{n1}+G_{n1} & ... & F_{nm}+G_{nm} \\      \end{matrix}      \right]      \tag{4}</script><h3 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h3><p>当矩阵$F$的列数等于矩阵$G$的行数时，这两个矩阵可以相乘，即如果矩阵$F$是$n\times m$矩阵，矩阵$G$是$m\times p$矩阵，则这两个矩阵的乘积$FG$是一个$n\times p$矩阵，其中的$(i,j)$元素等于：</p><script type="math/tex; mode=display">(FG)_{ij}=\sum_{k=1}^mF_{ik}G{kj} \tag{5}</script><p>矩阵$FG$的$(i,j)$元素可以看成<strong>矩阵$F$的第$i$行和矩阵$G$的第$j$列对应向量的内积</strong>。</p><h2 id="单位矩阵"><a href="#单位矩阵" class="headerlink" title="单位矩阵"></a>单位矩阵</h2><p>单位矩阵是一个$n\times n$矩阵，可表示为$I_n$，对于任意$n\times n$矩阵$M$，$MI_n=I_nM=M$。</p><p>单位矩阵可表示为如下形式：</p><script type="math/tex; mode=display">I_n=\left[        \begin{matrix}        1 & 0 & ... & 0 \\        0 & 1 & ... & 0 \\        ... & ... & ... & ... \\        0 & 0 & ... & 1        \end{matrix}        \right]        \tag{6}</script><p>单位矩阵$I_n$的下标$n$经常省略，简单表示为$I$，这是因为单位矩阵的阶数可由相关矩阵得出。</p><h2 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h2><p>给定两个标量$a$和$b$，任意3个$n\times n$矩阵$F$、$G$和$H$，以下矩阵性质成立：</p><ol><li>$F+G=G+F$</li><li>$(F+G)+H=F+(G+H)$</li><li>$a(bF)=(ab)F$</li><li>$a(F+G)=aF+aG$</li><li>$(a+b)F=aF+bF$</li></ol><h2 id="定理2"><a href="#定理2" class="headerlink" title="定理2"></a>定理2</h2><p>给定任意标量$a$，任意一个$n\times m$矩阵$F$、一个$m\times p$矩阵$G$和一个$p\times q$矩阵$H$，以下性质成立：</p><ol><li>$(aF)G=a(FG)$</li></ol><p><strong>证明</strong></p><p>根据式$(5)(FG)_{ij}=\sum_{k=1}^mF_{ik}G{kj}$给出的矩阵乘法的定义，矩阵$(aF)G$的$(i,j)$元素可表示为：</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}\left [(aF)G \right ]_{ij} &= \sum_{k=1}^m(aF)_{ik}G_{kj} \\                                                      &= \sum_{k=1}^ma(F_{ik}G_{kj}) \\                                                      &= a\sum_{k=1}^mF_{ik}G_{kj} \\                                                      &= a(FG)_{ij}\end{aligned}\end{equation}\tag{7}</script><ol><li>$(FG)H=F(GH)$</li></ol><p><strong>证明</strong></p><p>根据式$(5)(FG)_{ij}=\sum_{k=1}^mF_{ik}G{kj}$给出的乘法定义，矩阵$(FG)H$的$(i,j)$元素可表示为：</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}\left [(FG)H \right ]_{ij} &= \sum_{k=1}^p(FG)_{ik}H_{kj} \\                                                      &= \sum_{k=1}^p(\sum_{l=1}^mF_{il}G_{lk})H_{kj} \\                                                      &= \sum_{l=1}^mF_{il}(\sum_{k=1}^pG_{lk}H_{kj}) \\                                                      &= \sum_{l=1}^mF_{il}(GH)_{lj}  \\                                                      &= \left [F(GH) \right ]_{ij}\end{aligned}\end{equation}\tag{8}</script><ol><li>$(FG)^T=G^TF^T$</li></ol><p><strong>证明</strong></p><p>根据式$(5)(FG)_{ij}=\sum_{k=1}^mF_{ik}G{kj}$给出的乘法定义，结合转置矩阵的定义，矩阵$(FG)^T$的$(i,j)$元素可表示为：</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}        (FG)_{ij}^T &= (FG)_{ji} \\                                &= \sum_{k=1}^mF_{jk}G_{ki}    \\                                &= \sum_{k=1}^mF_{kj}^TG_{ik}^T    \\                                &= (G^TF^T)_{ij}\end{aligned}\end{equation}\tag{9}</script><h1 id="线性方程组"><a href="#线性方程组" class="headerlink" title="线性方程组"></a>线性方程组</h1><p>线性方程组可以一个紧凑和方便的形式表示，例如：</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}            3x+2y-3z &= -13  \\            4x-3y+6z &= 7  \\            x-z &= -5\end{aligned}\end{equation}\tag{10}</script><p>可以转化为：</p><script type="math/tex; mode=display">\left [\begin{matrix}        3 & 2  & -3 \\        4 & -3 &  6 \\        1 & 0  & -1\end{matrix}\right ]\left [\begin{matrix}        x \\        y \\        z\end{matrix}\right ]=\left [\begin{matrix}        -13 \\        7 \\        -5\end{matrix}\right ]\tag{11}</script><p>其中未知数向量$(x,y,z)$前面的矩阵称为<strong>系数矩阵</strong>，等号右边的列向量称为<strong>常数矩阵</strong>。</p><p>常数向量不为零向量的线性方程组为<strong>非齐次线性方程组</strong>，常数向量为零向量的线性方程组为<strong>齐次线性方程组</strong>。</p><p><strong>通过对系数矩阵和常数向量组成的矩阵进行初等行变换，可以计算出线性方程组的解</strong>。</p><h2 id="初等行变换"><a href="#初等行变换" class="headerlink" title="初等行变换"></a>初等行变换</h2><p>初等行变换是指对矩阵执行的以下三个操作之一：</p><ol><li>交换矩阵的任意两行。</li><li>用一个非零的标量乘以任意一行。</li><li>将任意一行的数倍加到另外一行。</li></ol><p>式$(11)$中的矩阵组成的增广矩阵如下：</p><script type="math/tex; mode=display">\left [\begin{array}{c:c}\begin{matrix}3&2&-3\\4&-3&6\\1&0&-1\end{matrix}&\begin{matrix}-13\\7\\-5\end{matrix}\end{array}\right ]\tag{12}</script><p>对线性方程组的增广矩阵进行初等行变换求方程组的解更简单，不会改变该线性方程组的解，其目的是使系数矩阵变成阶梯形矩阵。</p><h2 id="阶梯形矩阵-简约矩阵"><a href="#阶梯形矩阵-简约矩阵" class="headerlink" title="阶梯形矩阵(简约矩阵)"></a>阶梯形矩阵(简约矩阵)</h2><p>一个矩阵当且满足以下条件时，才可称为阶梯形矩阵：</p><ol><li>对所有的非零行，左边第一个元素也称为首元，为1；</li><li>所有非零行都位于零行的前面，即，所有零行位于矩阵的底部；</li><li>如果一行的首元位于第$j$列，则其他行的第$j$列不存在非零元素；</li><li>任意两个非零行$i_1$和$i_2$，若$i_2&gt;i_1$，则分别包含这两行的首元的$j_1$和$j_2$列一定满足$j_2&gt;j_1$。</li></ol><p>从定义可以看出，在阶梯形矩阵中，每行的首元根据行所在位置从上到下逐渐向右移动，从而包含某一行首元的列，在首元所在位置的元素为1，而其他元素为$0$。</p><ol><li>以下矩阵为阶梯形矩阵：</li></ol><script type="math/tex; mode=display">\left [\begin{matrix}    1 & 0 & -3 & 0 \\    0 & 1 &  2 & 0 \\    0 & 0 &  0 & 1 \\    0 & 0 &  0 & 0\end{matrix}\right]\tag{13}</script><ol><li>以下矩阵不是阶梯形矩阵：</li></ol><script type="math/tex; mode=display">\left [\begin{matrix}    1 & 0 &  0 & 3 \\    0 & 0 &  1 & 0 \\    0 & 2 &  0 & 0 \\    0 & 0 &  0 & 1\end{matrix}\right]\tag{14}</script><p>​        因为第三行的首元没在第二行首元的右边，第四列含有第四行的首元，而其他元素不为$0$。</p><p>利用初等行变换对线性方程组的增广矩阵进行变换，使其系数矩阵变为阶梯形矩阵的步骤：</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>该算法将线性方程组对应的$n\times(n+1)$增广矩阵$M$，变换成阶梯形矩阵。在每一步中，$M$为矩阵的当前状态而不是原始状态。</p><ol><li>令行号$i=1$；</li><li>令列号$j=1$，从第$1$列到第$n$列开始循环；</li><li>找到第$k$行，$k\geq i$，使$M_{kj}$的绝对值最大，如果不存在$M_{kj}\neq 0$的行，则跳到步骤$8$；</li><li>如果$k\neq i$，则交换第$k$行和第$i$行；</li><li>对第$i$行每个元素乘以$\frac{1}{M_{ij}}$，使矩阵$M$的$(i,j)$元素为$1$；</li><li>对于每行$r$，$1\leq r \leq n$且$r\neq i$，将第$i$行的$-M_{rj}$倍加到第$r$行，该步骤将第$j$列中位于第$i$行上面和下面的全部元素变成$0$；</li><li>$i=i+1$；</li><li>如果$j&lt;n$，$j=j+1$，跳过步骤$3$。</li></ol><p>其中步骤$3$和$4$被称为<strong>主元选择</strong>，除了可以去除矩阵主对角线上的$0$元素外，主元选择还可以保证初等变换的数值稳定性的基础。</p><h3 id="例1-非齐次线性方程组"><a href="#例1-非齐次线性方程组" class="headerlink" title="例1 非齐次线性方程组"></a>例1 非齐次线性方程组</h3><script type="math/tex; mode=display">\left [\begin{matrix}        3 & 2  & -3 \\        4 & -3 &  6 \\        1 & 0  & -1\end{matrix}\right ]\left [\begin{matrix}        x \\        y \\        z\end{matrix}\right ]=\left [\begin{matrix}        -13 \\        7 \\        -5\end{matrix}\right ]\tag{15}</script><p><strong>解：</strong>首先构造增广矩阵，</p><script type="math/tex; mode=display">\left [\begin{array}{c:c}\begin{matrix}3&2&-3\\4&-3&6\\1&0&-1\end{matrix}&\begin{matrix}-13\\7\\-5\end{matrix}\end{array}\right ]\tag{16}</script><p>应用主元选择，即算法中的步骤$3$和$4$，使第$1$列的最大元素变换到第$1$行，为了使第$1$行的首元为$1$，用该行乘以$\frac{1}{4}$，如下：</p><script type="math/tex; mode=display">\left [\begin{array}{c:c}\begin{matrix}1 & -\frac{3}{4} & \frac{3}{2} \\3&2&-3\\1&0&-1\end{matrix}&\begin{matrix}\frac{7}{4} \\-13\\-5\end{matrix}\end{array}\right ]\tag{17}</script><p>执行算法步骤$6$，使第$1$的其他元素为$0$：</p><script type="math/tex; mode=display">\left [\begin{array}{c:c}\begin{matrix}1 & -\frac{3}{4} & \frac{3}{2} \\0 & \frac{17}{4} & -\frac{15}{2}\\0 & \frac{3}{4}  & -\frac{5}{2}\end{matrix}&\begin{matrix}\frac{7}{4} \\-\frac{73}{4} \\-\frac{27}{4} \\\end{matrix}\end{array}\right ]\tag{18}</script><p>对第$2$行乘以$\frac{4}{17}$，使其首元为$1$：</p><script type="math/tex; mode=display">\left [\begin{array}{c:c}\begin{matrix}1 & -\frac{3}{4} & \frac{3}{2} \\0 & 1 & -\frac{30}{17}\\0 & \frac{3}{4}  & -\frac{5}{2}\end{matrix}&\begin{matrix}\frac{7}{4} \\-\frac{73}{17} \\-\frac{27}{4} \\\end{matrix}\end{array}\right ]\tag{19}</script><p>执行算法步骤$6$，使第$2$列的其他元素为$0$：</p><script type="math/tex; mode=display">\left [\begin{array}{c:c}\begin{matrix}1 & 0 & \frac{3}{17} \\0 & 1 & -\frac{30}{17}\\0 & 0  & -\frac{20}{17}\end{matrix}&\begin{matrix}-\frac{25}{17} \\-\frac{73}{17} \\-\frac{60}{17} \\\end{matrix}\end{array}\right ]\tag{20}</script><p>对第$3$行乘以$-\frac{17}{20}$，使其首元为$1$：</p><script type="math/tex; mode=display">\left [\begin{array}{c:c}\begin{matrix}1 & 0 & \frac{3}{17} \\0 & 1 & -\frac{30}{17}\\0 & 0  & 1\end{matrix}&\begin{matrix}-\frac{25}{17} \\-\frac{73}{17} \\3 \\\end{matrix}\end{array}\right ]\tag{21}</script><p>执行算法步骤$6$，使第$3$列的其他元素为$0$：</p><script type="math/tex; mode=display">\left [\begin{array}{c:c}\begin{matrix}1 & 0 & 0 \\0 & 1 & 0 \\0 & 0 & 1\end{matrix}&\begin{matrix}-2 \\1 \\3 \\\end{matrix}\end{array}\right ]\tag{22}</script><p>简约化的增广矩阵对应的线性方程组如下：</p><script type="math/tex; mode=display">\left [\begin{matrix}        1 & 0 & 0 \\        0 & 1 & 0 \\        0 & 0 & 1\end{matrix}\right ]\left [\begin{matrix}        x \\        y \\        z\end{matrix}\right ]=\left [\begin{matrix}        -2 \\         1 \\         3\end{matrix}\right ]\tag{23}</script><p>从上式可以直接得出原线性方程组的解：</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}       x &= -2 \\       y &= 1 \\       z &= 3\end{aligned}\end{equation}\tag{24}</script><p>上述例子中，系数矩阵的阶梯形矩阵为单位矩阵，这种情况下，相应的<strong>线性方程组有唯一解</strong>。</p><p>当阶梯形矩阵有一行或多行为$0$时，对应的线性方程组<strong>无解</strong>或<strong>有无穷多个解</strong>。</p><p>在常数向量中，当与系数矩阵中的$0$行对应元素不等于$0$时，则<strong>线性方程组无解</strong>。</p><p>在常数向量中，当与系数矩阵中的$0$行对应元素等于$0$时，则<strong>线性方程组有无穷多个解</strong>，且线性方程组一定可以表示成包含任意常数的形式。</p><p><strong>任意常数的数量等于阶梯形矩阵中$0$行的数量</strong>，与阶梯形矩阵中不含首元的列对应变量的解可以为任意常数。</p><h3 id="例2-齐次线性方程组"><a href="#例2-齐次线性方程组" class="headerlink" title="例2 齐次线性方程组"></a>例2 齐次线性方程组</h3><script type="math/tex; mode=display">\begin{equation}\begin{aligned}    2x+y+3z &= 0 \\    y-z &= 0 \\    x+3y-z &= 0\end{aligned}\end{equation}\tag{25}</script><p><strong>解：</strong>首先构造其增广矩阵</p><script type="math/tex; mode=display">\left [\begin{array}{c:c}\begin{matrix}2&1&3\\0&1&-1\\1&3&-1\end{matrix}&\begin{matrix}0\\0\\0\end{matrix}\end{array}\right ]\tag{26}</script><p>根据算法计算其阶梯形矩阵如下：</p><script type="math/tex; mode=display">\left [\begin{array}{c:c}\begin{matrix}1&0&2\\0&1&-1\\0&0&0\end{matrix}&\begin{matrix}0\\0\\0\end{matrix}\end{array}\right ]\tag{27}</script><p>该矩阵中存在$0$行，第$3$列中不包含首元，该列对应的变量$z$可为任意数值，令$z=a$，则前面两行对应方程如下：</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}    x+2a &= 0 \\    y-a &= 0 \end{aligned}\end{equation}\tag{28}</script><p>该线性方程组的解为：</p><script type="math/tex; mode=display">\left [\begin{matrix}        x \\        y \\        z\end{matrix}\right ]= a\left [\begin{matrix}        -2 \\         1 \\         1\end{matrix}\right ]\tag{29}</script><p>齐次线性方程组至少有一个$0$向量解，仅当阶梯形系数矩阵存在至少一个$0$行时，齐次线性方程组存在<strong>非平凡解(非零解)</strong>。</p><h1 id="逆矩阵"><a href="#逆矩阵" class="headerlink" title="逆矩阵"></a>逆矩阵</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>对任意$n\times n$矩阵$M$，如果存在一个矩阵$M^{-1}$，使得$MM^{-1}=M^{-1}M=I$，则称举证$M$可逆，矩阵$M^{-1}$称为矩阵$M$的逆矩阵。</p><p>并不是所有矩阵都有逆矩阵，没有逆矩阵的矩阵称为<strong>奇异矩阵</strong>。</p><h2 id="定理1-1"><a href="#定理1-1" class="headerlink" title="定理1"></a>定理1</h2><p>包含$0$行或$0$列的举证不可逆。</p><p><strong>证明</strong></p><p>假设$n\times n$矩阵$F$的$r$行的全部元素为$0$，对于$n\times n$矩阵$G$，其乘积$FG$的$(r,r)$元素为$\sum_{k=1}^{n}F_{rk}G_{kr}$，由于全部$F_{rk}$等于$0$，$FG$的$(r,r)$元素为$0$，与要使矩阵$F$可逆，$FG$的$(r,r)$元素必须为$1$矛盾，所以矩阵$F$不可逆。同理，可以证明包含$0$列的矩阵也不可逆。</p><p><strong>证毕</strong></p><p>推广：在一个矩阵中，若某一行/列可以表示成其他行/列的线性组合，则该矩阵是奇异矩阵。</p><h2 id="定理2-1"><a href="#定理2-1" class="headerlink" title="定理2"></a>定理2</h2><p>当且仅当$M^{T}$矩阵可逆，矩阵$M$可逆。</p><p><strong>证明</strong></p><p>若矩阵$M$可逆，则存在逆矩阵$M^{-1}$，可得</p><script type="math/tex; mode=display">M^T(M^{-1})^T=(M^{-1}M)^T=I^T=I \tag{30}</script><p>和</p><script type="math/tex; mode=display">(M^{-1})^TM^T=(MM^{-1})^T=I^T=I \tag{31}</script><p>因此，$(M^{-1})^T$是$M^T$的逆矩阵。</p><p>同理，若矩阵$M^T$可逆，则存在逆矩阵$(M^{T})^{-1}$，可得</p><script type="math/tex; mode=display">M\left[(M^T)^{-1}\right]^T=\left[(M^T)^{-1}M^T\right]^T=I^T=I \tag{32}</script><p>和</p><script type="math/tex; mode=display">\left[(M^T)^{-1}\right]^TM=\left[M^T(M^T)^{-1}\right]^T=I^T=I \tag{33}</script><p>因此，$\left[(M^T)^{-1}\right]^T$是$M$的逆矩阵。</p><p><strong>证毕</strong></p><h2 id="定理3"><a href="#定理3" class="headerlink" title="定理3"></a>定理3</h2><p>如果$n\times n$矩阵$F$和$G$是可逆矩阵，则它们的积$FG$也可逆，且$(FG)^{-1}=G^{-1}F^{-1}$。</p><p><strong>证明</strong></p><script type="math/tex; mode=display">G^{-1}F^{-1}(FG)=G^{-1}(F^{-1}F)G=G^{-1}G=I \tag{34}</script><p><strong>证毕</strong></p><h2 id="Gauss-Jordan消去法-求逆矩阵"><a href="#Gauss-Jordan消去法-求逆矩阵" class="headerlink" title="Gauss-Jordan消去法(求逆矩阵)"></a>Gauss-Jordan消去法(求逆矩阵)</h2><p>为了计算$n\times n$矩阵$M$的逆矩阵，首先在矩阵$M$的的右边扩展一个同阶的单位矩阵，从而得到一个$n\times 2n$的矩阵$\widetilde{M}$，如下所示：</p><script type="math/tex; mode=display">\widetilde{M}=\left [\begin{array}{c:c}\begin{matrix}M_{00} & M_{01} & ... & M_{0n} \\M_{10} & M_{11} & ... & M_{1n} \\... & ... & ... & ... \\M_{n0} & M_{n1} & ... & M_{nn} \\\end{matrix}&\begin{matrix}1 & 0 & ... & 0 \\0 & 1 & ... & 0 \\... & ... & ... & ... \\0 & 0 & ... & 1 \\\end{matrix}\end{array}\right ]\tag{35}</script><p>对矩阵$\widetilde{M}$进行初等行变换，直到其左边$n\times n$矩阵变成单位矩阵$I_n$，这时矩阵$\widetilde{M}$右边的$n\times n$矩阵就是矩阵$M$的逆矩阵。</p><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><ol><li>构造增广矩阵$\widetilde{M}$，在本算法中，每一步中的$\widetilde{M}$为矩阵的当前状态而不是原始状态；</li><li>令列号$j=1$，从第$1$列到第$n$列开始循环；</li><li>找到第$i$行，$i\geq j$，使$\widetilde{M_{ij}}$的绝对值最大，如果不存在$\widetilde{M_{ij}}\neq 0$的行，则矩阵$M$不可逆；</li><li>如果$i\neq j$，则交换第$i$行和第$j$行，这里的主元选择操作，除了可以去除矩阵对角线上$0$元素外，还可以保证初等变换的数值稳定性；</li><li>给第$j$行的每个元素乘以$\frac{1}{\widetilde{M_{ij}}}$，使矩阵$\widetilde{M_{ij}}$为$1$；</li><li>对行$r$，$1\leq r\leq n$且$r\neq j$，将第$j$行的$-\widetilde{M_{rj}}$倍加到第$r$行，该步骤将第$j$列中位于第$j$行上面和下面的全部元素变成$0$；</li><li>如果$j&lt;n$，$j=j+1$，跳到步骤$3$。</li></ol><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>计算以下$3\times 3$矩阵$M$的逆矩阵。</p><script type="math/tex; mode=display">M=\left [    \begin{matrix}    2 & 3 & 8 \\    6 & 0 & -3 \\    -1 & 3 & 2    \end{matrix}  \right]  \tag{36}</script><p>​    <strong>解：</strong>将单位矩阵增广到矩阵$M$得：</p><script type="math/tex; mode=display">\widetilde{M}=\left [\begin{array}{c:c}\begin{matrix}2 & 3 & 8 \\6 & 0 & -3 \\-1 & 3 & 2 \\\end{matrix}&\begin{matrix}1 & 0 &  0 \\0 & 1 &  0 \\0 & 0 &  1 \\\end{matrix}\end{array}\right ]\tag{37}</script><p>令$j=1$，对矩阵$\widetilde{M}$执行算法中的步骤$3-6$。</p><ol><li>交换第$1$行和第$2$行，给第$1$行乘以$\frac{1}{6}$</li></ol><script type="math/tex; mode=display">\left [\begin{array}{c:c}\begin{matrix}1 & 0 & -\frac{1}{2} \\2 & 3 & 8 \\-1 & 3 & 2 \\\end{matrix}&\begin{matrix}0 & \frac{1}{6} &  0 \\1 & 0 &  0 \\0 & 0 &  1 \\\end{matrix}\end{array}\right ]\tag{38}</script><ol><li>第$1$行乘以$-2$加到第$2$行，第$1$行加到第$2$行</li></ol><script type="math/tex; mode=display">\left [\begin{array}{c:c}\begin{matrix}1 & 0 & -\frac{1}{2} \\0 & 3 & 9 \\0 & 3 & \frac{3}{2} \\\end{matrix}&\begin{matrix}0 & \frac{1}{6} &  0 \\1 & -\frac{1}{3} &  0 \\0 & \frac{1}{6} &  1 \\\end{matrix}\end{array}\right ]\tag{39}</script><p>令$j=2$，对矩阵$\widetilde{M}$执行算法中的步骤$3-6$。</p><ol><li>第$2$行乘以$\frac{1}{3}$</li></ol><script type="math/tex; mode=display">\left [\begin{array}{c:c}\begin{matrix}1 & 0 & -\frac{1}{2} \\0 & 1 & 3 \\0 & 3 & \frac{3}{2} \\\end{matrix}&\begin{matrix}0 & \frac{1}{6} &  0 \\ \frac{1}{3} & -\frac{1}{9} &  0 \\0 & \frac{1}{6} &  1 \\\end{matrix}\end{array}\right ]\tag{40}</script><ol><li>第$2$行乘以$-3$加到第$3$行</li></ol><script type="math/tex; mode=display">\left [\begin{array}{c:c}\begin{matrix}1 & 0 & -\frac{1}{2} \\0 & 1 & 3 \\0 & 0 & -\frac{15}{2} \\\end{matrix}&\begin{matrix}0 & \frac{1}{6} &  0 \\ \frac{1}{3} & -\frac{1}{9} &  0 \\-1 & \frac{1}{2} &  1 \\\end{matrix}\end{array}\right ]\tag{41}</script><p>令$j=3$，对矩阵$\widetilde{M}$执行算法中的步骤$3-6$。</p><ol><li>第$3$行乘以$-\frac{2}{15}$</li></ol><script type="math/tex; mode=display">\left [\begin{array}{c:c}\begin{matrix}1 & 0 & -\frac{1}{2} \\0 & 1 & 3 \\0 & 0 & 1 \\\end{matrix}&\begin{matrix}0 & \frac{1}{6} &  0 \\ \frac{1}{3} & -\frac{1}{9} &  0 \\ \frac{2}{15} & -\frac{1}{15} &  -\frac{2}{15} \\\end{matrix}\end{array}\right ]\tag{42}</script><ol><li>第$3$行乘以$\frac{1}{2}$加到第$1$行</li></ol><script type="math/tex; mode=display">\left [\begin{array}{c:c}\begin{matrix}1 & 0 & 0 \\0 & 1 & 3 \\0 & 0 & 1 \\\end{matrix}&\begin{matrix} \frac{1}{15} & \frac{2}{15} &  -\frac{1}{15} \\ \frac{1}{3} & -\frac{1}{9} &  0 \\ \frac{2}{15} & -\frac{1}{15} &  -\frac{2}{15} \\\end{matrix}\end{array}\right ]\tag{43}</script><ol><li>第$3$行乘以$-3$加到第$2$行</li></ol><script type="math/tex; mode=display">\left [\begin{array}{c:c}\begin{matrix}1 & 0 & 0 \\0 & 1 & 0 \\0 & 0 & 1 \\\end{matrix}&\begin{matrix} \frac{1}{15} & \frac{2}{15} &  -\frac{1}{15} \\ -\frac{1}{15} & \frac{4}{15} & \frac{2}{5} \\ \frac{2}{15} & -\frac{1}{15} &  -\frac{2}{15} \\\end{matrix}\end{array}\right ]\tag{44}</script><p>最后，右边的$3\times 3$矩阵等于$M$的逆矩阵：</p><script type="math/tex; mode=display">M^{-1}=\frac{1}{45}             \left[             \begin{matrix}             3 & 6 & -3 \\       -3 & 4 & 18 \\       6 & -3 & -6       \end{matrix}             \right]             \tag{45}</script><h2 id="定理4"><a href="#定理4" class="headerlink" title="定理4"></a>定理4</h2><p>令矩阵$M’$是$n\times n$矩阵$M$经过初等行变换得到的$n\times n$矩阵，则$M’=EM$，其中$E$是单位矩阵经过相同的初等行变换得到的$n\times n$矩阵。</p><p><strong>证明</strong></p><ol><li>若单位矩阵的$r$行和$s$行交换后，得矩阵$E$，则$E$的元素可按下式计算：</li></ol><script type="math/tex; mode=display">E_{ij}=\left\{              \begin{equation}             \begin{aligned}             & \delta_{ij},如果i\neq r,且i\neq s \\             & \delta_{sj},如果i = r \\             & \delta_{rj},如果i = s \\             \end{aligned}             \end{equation}             \right.             \tag{46}</script><p>其中$\delta_{ij}$是克罗内克函数，定义如下：</p><script type="math/tex; mode=display">\delta_{ij}\equiv \left \{                                     \begin{matrix}                                    1，如果i=j \\                                    0，如果i\neq j                                    \end{matrix}                                    \right.                                    \tag{47}</script><p>则乘积矩阵$EM$的元素可表示为：</p><script type="math/tex; mode=display">(EM)_{ij}=\sum_{k=1}^{n}E_{ik}M_{kj}=\left\{              \begin{equation}             \begin{aligned}             & M_{ij},如果i\neq r,且i\neq s \\             & M_{sj},如果i = r \\             & M_{rj},如果i = s \\             \end{aligned}             \end{equation}             \right.             \tag{48}</script><p>结果，矩阵$M$的$r$行和$s$行进行了交换。</p><ol><li>若单位矩阵的$r$行乘以标量$a$后，得矩阵$E$，则$E$的元素可按下式计算：</li></ol><script type="math/tex; mode=display">E_{ij}=\left\{              \begin{equation}             \begin{aligned}             & \delta_{ij},如果i\neq r \\             & a\delta_{ij},如果i = r \\             \end{aligned}             \end{equation}             \right.             \tag{49}</script><p>则乘积矩阵$EM$的元素可表示为：</p><script type="math/tex; mode=display">(EM)_{ij}=\sum_{k=1}^{n}E_{ik}M_{kj}=\left\{              \begin{equation}             \begin{aligned}             & M_{ij},如果i\neq r \\             & aM_{rj},如果i = r \\             \end{aligned}             \end{equation}             \right.             \tag{50}</script><p>得到矩阵$M$的$r$行乘以标量$a$的结果。</p><ol><li>若单位矩阵的$r$行乘以标量$a$，再加到$s$行后，得矩阵$E$，则$E$的元素可按下式计算：</li></ol><script type="math/tex; mode=display">E_{ij}=\left\{              \begin{equation}             \begin{aligned}             & \delta_{ij},如果i\neq s \\             & \delta_{ij}+a\delta_{rj},如果i = s \\             \end{aligned}             \end{equation}             \right.             \tag{51}</script><p>则乘积矩阵$EM$的元素可表示为</p><script type="math/tex; mode=display">(EM)_{ij}=\sum_{k=1}^{n}E_{ik}M_{kj}=\left\{              \begin{equation}             \begin{aligned}             & M_{ij},如果i\neq s \\             & M_{ij}+aM_{rj},如果i = s \\             \end{aligned}             \end{equation}             \right.             \tag{52}</script><p>得到矩阵$M$的$r$行乘以标量$a$，再加到$s$行的结果。</p><p><strong>证毕</strong></p><p>单位矩阵经过和初等行变换得到的$n\times n$矩阵$E$被称为初等矩阵。如果将矩阵$M$变成相应的单位矩阵，需要$k$个初等行变换，则：</p><script type="math/tex; mode=display">I=E_kE_{k-1}E_{k-2}...E_0M \tag{53}</script><p>其中，$E_0$，$E_2$，…，$E_k$是与单位矩阵的$k$个初等行变换对应初等矩阵，它们的乘积$E_kE_{k-1}…E_0$等于矩阵$M$的逆矩阵。</p><p>如果矩阵$M$是奇异矩阵，则不存在初等矩阵$E_0,E_1,…,E_k$使得上式$(53)$成立，这是因为奇异矩阵的行向量是线性相关的。</p><h2 id="定理5"><a href="#定理5" class="headerlink" title="定理5"></a>定理5</h2><p>当且仅当$n\times n$矩阵$M$的行向量形成线性无关的向量集合时，矩阵$M$可逆。</p><p><strong>证明</strong></p><p>矩阵$M$的行向量为$R_1^T,R_2^T,…,R_n^T$，分两部分证明。</p><ol><li><p>用反证法证明，若矩阵$M$可逆，$M$的行向量形成线性无关的向量集合。即证明若$M$的行向量形成线性相关的向量集合，则矩阵$M$是奇异矩阵。</p><p> 假设$M$的行向量线性相关，那么存在一行$r$，可以用其他$k$行的线性组合表示如下式所示：</p><script type="math/tex; mode=display"> R_r^T=a_1R_{s_1}^T+a_2R_{s_2}^T+...+a_kR_{s_k}^T \tag{54}</script><p> 其中，$a_i$为标量，$s_i$是矩阵$M$中除了行$r$以外的全部$k$行索引。令$n\times n$矩阵$E_i$为将第$s_i$乘以$a_i$后加到行$r$的初等变换对应的初等矩阵，可得：</p><script type="math/tex; mode=display"> M=E_kE_{k-1}E_{k-2}...E_0M' \tag{55}</script><p> 此时，在矩阵$M’$中，除了第$r$行元素均为$0$外，其他元素均等于矩阵$M$中相应元素，由<strong>定理1</strong>可得，矩阵$M’$是奇异矩阵，而矩阵$M$也是奇异矩阵。</p></li><li><p>假设矩阵$M$的行向量形成线性无关的向量集合，已知对矩阵进行的初等行变换不会改变矩阵的行向量之间线性无关的特性。利用Gauss-Jordan消去算法计算$M$的逆矩阵，如果算法步骤$3$失败，则此时从$R_j^T$到行$R_n^T$至少有一个非$0$元素的列数量少于行的数量，所以矩阵的第$j$到$n$行形成线性相关向量集合，与假设矛盾，因此算法步骤$3$不可能失败，矩阵$M$一定可逆。</p></li></ol><p><strong>证毕</strong></p><p>所有奇异矩阵都可以写成一个初等矩阵和一个含有0行的矩阵的乘积。</p>]]></content>
      
      
      <categories>
          
          <category> 数学之美 </category>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 线性代数 </tag>
            
            <tag> 矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenMP并行编程指南</title>
      <link href="/2020/04/20/OpenMP%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/"/>
      <url>/2020/04/20/OpenMP%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p>OpenMP主要用于C/C++的CPU并行计算。</p><a id="more"></a><h3 id="并行计算"><a href="#并行计算" class="headerlink" title="并行计算"></a>并行计算</h3><p>对于CPU密集型的程序来说，可以使用OpenMP加快程序的计算速度。</p><p>OpenMP是跨平台的，大部分现代的C/C++编译器都支持OpenMP。</p><p>程序员可以简单地通过编译器指令<code>pragma omp</code>去控制程序的行为。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp <span class="hljs-meta-string">&lt;directive&gt; [clause[[,] clause] ...]</span></span><br></code></pre></td></tr></table></figure><p>最常见的指令应该是<code>parallel</code>指令，紧接在<code>parallel</code>指令后面的那个代码块将会并行执行：</p><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp parallel&#123;</span><br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Hello World!"</span>&lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序会启用N个线程去执行<code>parallel</code>指令后面的那个代码块（N为CPU的核心数），执行完这个代码块后，程序又会变回单线程。</p><p>编译时只需提供<code>-fopenmp</code>参数，就可以让编译器启用OpenMP。</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ g++ -std=c++11 -fopenmp -o main main.cpp<br>$ ./main<br>Hello, World!<br>Hello, World!<br></code></pre></td></tr></table></figure><p>OpenMP还提供<code>parallel for</code>指令，它的作用是<strong>将for循环分为N个线程去执行</strong>。</p><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdint&gt;</span></span><br><span class="hljs-keyword">using</span> Int = <span class="hljs-keyword">uint64_t</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;<br>    <span class="hljs-keyword">constexpr</span> Int size = <span class="hljs-number">10</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Int&gt; squares(size, <span class="hljs-number">0</span>);<br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp parallel for</span><br>    <span class="hljs-keyword">for</span> (Int i = <span class="hljs-number">0</span>; i &lt; size; ++i)<br>    &#123;<br>        squares[i] = i * i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该代码等同于：</p><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;omp.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdint&gt;</span></span><br><span class="hljs-keyword">using</span> Int = <span class="hljs-keyword">uint64_t</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;<br>    <span class="hljs-keyword">constexpr</span> Int size = <span class="hljs-number">10</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Int&gt; squares(size, <span class="hljs-number">0</span>);<br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp parallel</span><br>    &#123;<br>        Int thread_id = omp_get_thread_num();     <span class="hljs-comment">// 线程 ID, 范围从 0 到 N - 1</span><br>        Int thread_nums = omp_get_num_threads();  <span class="hljs-comment">// 线程的数量</span><br>        Int first = thread_id * size / thread_nums;<br>        Int last = (thread_id + <span class="hljs-number">1</span>) * size / thread_nums;<br>        <span class="hljs-keyword">for</span> (Int i = first; i &lt; last; ++i)<br>        &#123;<br>            squares[i] = i * i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>unity学习</title>
      <link href="/2020/03/22/unity%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/03/22/unity%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
          <category> unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
            <tag> unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LearnOpenGL</title>
      <link href="/2020/02/27/LearnOpenGL/"/>
      <url>/2020/02/27/LearnOpenGL/</url>
      
        <content type="html"><![CDATA[<p>本文主要总结了我在《LearnOpenGL》中学习的过程</p><a id="more"></a><h1 id="文档说明"><a href="#文档说明" class="headerlink" title="文档说明"></a>文档说明</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>LearnOpenGL被分解成许多大的主题。每个<strong>主题</strong>包括一些<strong>小节</strong>，每个小节中会对不同的概念进行详细的解释。</p><p>本文采用了<strong>方框</strong>和<strong>代码</strong>。</p><h3 id="方框"><a href="#方框" class="headerlink" title="方框"></a>方框</h3><table><tr><td bgcolor="Chartreuse">绿色方框是一些注释或者对于OpenGL或讨论主题有用的特性/提示</td></tr></table><table><tr><td bgcolor="LightCoral">红色方框是一些警告或者一些你需要特别注意的特性</td></tr></table><table><tr><td bgcolor="LightSkyBlue">蓝色方框是帮助读者理解附加的一些信息</td></tr></table><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>代码会放在代码框中</p><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 这个方框是代码</span><br></code></pre></td></tr></table></figure><p>这样只提供了代码片段，当需要的时候会提供<strong>链接</strong>到当前工程的源代码中。</p><h3 id="颜色标记"><a href="#颜色标记" class="headerlink" title="颜色标记"></a>颜色标记</h3><p>有一些词语会以不同的颜色显示出来，用来表示这些词语有不同的意义</p><ul><li><font color="Green">定义</font>：绿色的字是定义，即一个重要的概念或名称，这些词语常能看到。</li><li><font color="Red">程序逻辑</font>：红色的字是函数的名称或者是类名。</li><li><font color="blue">变量</font>：蓝色的字是变量，包括所有的OpenGL常量。</li></ul><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>OpenGL是一个<strong>图形API（Application Programming Interface, 应用程序编程接口）</strong>，包含了一系列可以操作图形、图像的函数，由<a href="https://www.khronos.org/" target="_blank" rel="noopener">khronos</a>组织制定并维护的规范(Specification)。</p><p>OpenGL规范严格规定了<strong>每个函数该如何执行，以及它的输出值</strong>。内部函数具体如何实现(Implement)的，由OpenGL库的开发者自行决定，因此具体的OpenGL库允许使用不同的实现，只要其功能和结果与规范相匹配即可。</p><p>实际的OpenGL库的开发者通常是显卡的生产商。购买的显卡所支持的OpenGL版本都为这个系列的显卡专门开发的。当你使用Apple系统的时候，OpenGL库是由Apple自身维护的。在Linux下，有显卡生产商提供的OpenGL库，也有一些爱好者改编的版本。这也意味着<strong>任何时候OpenGL库表现的行为与规范规定的不一致时，基本都是库的开发者留下的bug</strong>。</p><table><tr><td bgcolor="Chartreuse">由于OpenGL的大多数实现都是由显卡厂商编写的，当产生一个bug时通常可以通过升级显卡驱动来解决。这些驱动会包括你的显卡能支持的最新版本的OpenGL，这也是为什么总是建议你偶尔更新一下显卡驱动</td></tr></table><p>所有版本的OpenGL规范文档都被公开寄存在Khronos那里。例如：<a href="https://www.opengl.org/registry/doc/glspec33.core.20100311.withchanges.pdf" target="_blank" rel="noopener">OpenGL3.3</a></p><ol><li>c++语言（如果对c++不是很熟悉，可以<a href="www.learncpp.com">learncpp</a>上学习）。</li><li>数学知识（线性代数、几何、三角学）。</li></ol><h2 id="核心模式与立即渲染模式"><a href="#核心模式与立即渲染模式" class="headerlink" title="核心模式与立即渲染模式"></a>核心模式与立即渲染模式</h2><p>早期的OpenGL使用<font color="green">立即渲染模式</font>(Immediate mode, 也就是<font color="green">固定渲染模式</font>)，这个模式下绘制图形很方便，容易使用和理解，但是效率太低。因此从OpenGL3.2开始，规范文档开始废弃立即渲染模式，并鼓励开发者在OpenGL的<font color="green">核心模式</font>(Core-profile)下进行开发，这个分支的规范完全移除了旧的特性，迫使我们使用现代的函数(具有更高的灵活性和效率，然而也更难于学习)。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p><strong>OpenGL的一大特性就是对扩展(Extension)的支持</strong>。当一个显卡公司提出一个新特性或者渲染上的大优化，通常会以<font color="green">扩展</font>的方式在驱动中实现。</p><p>如果一个程序在支持这个扩展的显卡上运行，开发者可以使用这个扩展提供的一些更先进更有效的图形功能。通过这种方式，开发者不必等待一个新的OpenGL规范面世，就可以使用这些新的渲染特性，只需要检查一下显卡是否支持此扩展。</p><p>使用扩展的代码如下：</p><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(GL_ARB_extension_name)&#123;<br>    <span class="hljs-comment">// 使用硬件支持的全新的现代特性</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-comment">// 不支持此扩展: 用旧的方法做</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><p>OpenGL自身是一个巨大的状态机(State Machine)：一系列的变量描述OpenGL此刻应当如何运行。</p><p>OpenGL的状态通常被称为OpenGL<font color="green">上下文</font>(Context)。</p><p>我们通常使用如下途径去更改OpenGL状态：<code>设置选项-操作缓冲</code>，最后使用当前OpenGL上下文来渲染。</p><p>假设当我们想告诉OpenGL去画线段而不是三角形，我们通过<strong>改变一些上下文变量来改变OpenGL状态</strong>，从而告诉OpenGL如何去绘图。一旦我们改变了OpenGL的状态为绘制线段，下一个绘制命令就会画出线段而不是三角形。</p><p>当使用OpenGL的时候，我们会遇到一些<font color="green">状态设置函数</font>(State-changing Function)，这类函数将会改变上下文。以及<font color="green">状态使用函数</font>(State-using Function)，这类函数会根据当前OpenGL的状态执行一些操作。</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>OpenGL的库是用C语言写的，同时也支持多种语言的派生，但其内核仍是一个C库。</p><p>由于C的一些语言结构不易被翻译到其他高级语言，因此OpenGL开发的时候引入了一些抽象层，<strong>对象</strong>就是其中一个。</p><p>在OpenGL中一个<font color="green">对象</font>是指一些选项的集合，它代表OpenGL状态的一个子集。比如，我们可以用一个对象来代表绘图窗口的设置，之后我们就可以设置它的大小、支持的颜色位数等等。可以把对象看做一个C风格的结构体(Struct)：</p><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">object_name</span>&#123;</span><br>    <span class="hljs-keyword">float</span> option1;<br>    <span class="hljs-keyword">int</span> option2;<br>    <span class="hljs-keyword">char</span>[] name;<br>&#125;;<br></code></pre></td></tr></table></figure><p>当我们使用一个对象时，通常看起来像如下一样(把OpenGL上下文看作一个大的结构体)：</p><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// OpenGL的状态</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">OpenGL_Contex</span>&#123;</span><br>    ...<br>    object* object_Window_Target;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>OpenGL常见工作流：</p><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 创建对象</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> objectId = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 用一个id保存它的引用(实际数据被存储到后台)</span><br>glGenObject(<span class="hljs-number">1</span>, &amp;objectId);<br><br><span class="hljs-comment">// 绑定对象至上下文的目标位置(例子中窗口对象目标的位置被定义成GL_WINDOW_TARGET)</span><br>glBindObject(GL_WINDOW_TARGET, ObjectId);<br><br><span class="hljs-comment">// 设置当前绑定到 GL_WINDOW_TARGET 的对象的一些选项</span><br>glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_WIDTH, <span class="hljs-number">800</span>);<br>glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_HEIGHT, <span class="hljs-number">600</span>);<br><br><span class="hljs-comment">// 将上下文对象id设回默认0，解绑这个对象</span><br>glBindObject(GL_WINDOW_TARGET, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>使用对象的好处是在程序中可以定义多个对象，每个对象可以做不同的设置。在执行一个使用OpenGL状态的操作的时候，只需要绑定含有需要的设置的对象即可。</p><p>比如说我们有一些作为3D模型数据（一栋房子或一个人物）的容器对象，在我们想绘制其中任何一个模型的时候，只需绑定一个包含对应模型数据的对象就可以了（当然，我们需要先创建并设置对象的选项）。拥有数个这样的对象允许我们指定多个模型，在想画其中任何一个的时候，直接将对应的对象绑定上去，便不需要再重复设置选项了。</p><h1 id="创建窗口"><a href="#创建窗口" class="headerlink" title="创建窗口"></a>创建窗口</h1>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICthroughVR: Illuminating Cataracts through Virtual Reality</title>
      <link href="/2019/12/21/ICthroughVR-Illuminating-Cataracts-through-Virtual-Reality/"/>
      <url>/2019/12/21/ICthroughVR-Illuminating-Cataracts-through-Virtual-Reality/</url>
      
        <content type="html"><![CDATA[<p><strong>ICthroughVR: Illuminating(照亮) Cataracts(白内障) through Virtual Reality</strong></p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/ICthroughVR%3A%20Illuminating%20Cataracts%20through%20Virtual%20Reality/Figure%201.png"></p><p>Vision impairments, such as cataracts, affect the way many people interact with their environment, yet are rarely considered by <strong>architects and lighting designers</strong> because of a lack of design tools.</p><p>we present a method to <strong>simulate vision impairments</strong>, in particular cataracts, graphically in virtual reality (VR), using eye tracking for gaze-dependent(注视) effects. </p><p>We also conduct(进行) a VR user study to <strong>investigate the effects of lighting on visual perception(感知) for users with cataracts</strong>.</p><p>In contrast to existing approaches, <strong>which mostly provide only simplified simulations and are primarily targeted at educational or demonstrative(示范) purposes</strong>, we account for the user’s vision and the hardware constraints(限制) of the VR headset.</p><p>This makes it possible to calibrate(矫正) our cataract simulation to the same level of degraded(降低) vision for all participants. </p><p>Our study results show that we are able to calibrate(矫正) the vision of all our participants to a similar level of impairment, that maximum recognition distances for escape route signs with simulated cataracts are significantly smaller than without, and that luminaires(灯具) visible in the field of view are perceived as especially disturbing due to the glare effects they create.</p><p>In addition, the results show that our realistic simulation increases the understanding of how people with cataracts see and could therefore also be informative for health care personnel or relatives of cataract patients.</p><a id="more"></a><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Vision impairments affect 1.3 billion people worldwide, according to the <em>World Health Organization</em> (WHO), with cataracts being one of the leading causes.</p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
          <category> 虚拟现实 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟现实 </tag>
            
            <tag> 医疗康复 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>彻底理解红黑树</title>
      <link href="/2019/09/20/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
      <url>/2019/09/20/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p><strong>当在10亿数据中只需要进行10几次比较就能查找到目标时，不禁感叹编程之魅力！人类之伟大呀！ —— 学红黑树有感。</strong></p><p>红黑树是一种比较难的数据结构，要完全搞懂非常耗时耗力，红黑树怎么自平衡？什么时候需要左旋或右旋？插入和删除破坏了树的平衡后怎么处理？等等问题。</p><p>本文将通过图文的方式讲解红黑树的知识点，并且不会涉及到任何代码，相信我，在懂得红黑树实现原理前，看代码会一头雾水的，当原理懂了，代码也就按部就班写而已，没任何难度。</p><p>阅读本文需要具备知识点：</p><ul><li>二叉查找树</li><li>完美平衡二叉树</li></ul><a id="more"></a><p>红黑树也是二叉查找树，我们知道，二叉查找树这一数据结构并不难，而红黑树之所以难是难在它是自平衡的二叉查找树，在进行插入和删除等可能会破坏树的平衡的操作时，需要重新自处理达到平衡状态。</p><h2 id="红黑树的定义和性质"><a href="#红黑树的定义和性质" class="headerlink" title="红黑树的定义和性质"></a>红黑树的定义和性质</h2><p>红黑树是一种含有红黑结点并能自平衡的二叉查找树。它必须满足下面性质：</p><ul><li>性质1：每个结点要么是黑色的，要么是红色的。</li><li>性质2：根结点是黑色的。</li><li>性质3：每个叶子结点（NIL）是黑色的。</li><li>性质4：每个红色结点的两个子结点一定都是黑色的。</li><li><strong>性质5：任意一结点到其每个叶子结点的路径都包含数量相同的黑结点。</strong></li></ul><p>从性质5可以推出：</p><ul><li>性质5.1：如果一个结点存在黑子结点，那么该结点肯定有两个子结点。</li></ul><p>下图就是一颗简单的红黑树。其中Nil为叶子结点，并且它是黑色的。(值得提醒注意的是，在Java中，叶子结点是为null的结点。)</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%80%E6%A3%B5%E7%AE%80%E5%8D%95%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91.png" width="70%"></p><p>红黑树并不是一个<strong>完美</strong>平衡二叉查找树，从上图可以看到，根结点P的左子树显然比右子树高，但左子树和右子树的黑结点的层数是相等的，也即任意一个结点到到每个叶子结点的路径都包含数量相同的黑结点(性质5)。所以我们叫红黑树这种平衡为<strong>黑色完美平衡</strong>。</p><p>介绍到此，为了后面讲解不至于混淆，我们还需要来约定下红黑树一些结点的叫法，如下图所示。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BB%93%E7%82%B9%E5%8F%AB%E6%B3%95%E7%BA%A6%E5%AE%9A.png" width="70%"></p><p>我们把正在处理(遍历)的结点叫做当前结点，如上图中的D，它的父亲叫做父结点，它的父亲的另外一个子结点叫做兄弟结点，父亲的父亲叫做祖父结点。</p><p>红黑树自平衡靠三种操作：左旋、右旋和变色。</p><ul><li><strong>左旋</strong>：以某个结点作为支点(旋转结点P)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。如下图所示。</li></ul><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E6%97%8B.png" width="70%"></p><ul><li><strong>右旋</strong>：以某个结点作为支点(旋转结点P)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。如下图所示。</li></ul><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8F%B3%E6%97%8B.png" width="70%"></p><ul><li><strong>变色</strong>：结点的颜色由红变黑或由黑变红。</li></ul><p>我们先忽略颜色，可以看到旋转操作不会影响旋转结点的父结点，父结点以上的结构还是保持不变的。<br><strong>左旋</strong>只影响旋转结点和其<strong>右子树</strong>的结构，把右子树的结点往左子树挪了。<br><strong>右旋</strong>只影响旋转结点和其<strong>左子树</strong>的结构，把左子树的结点往右子树挪了。</p><p>所以旋转操作是<strong>局部</strong>的。另外可以看出旋转能保持红黑树平衡的一些端详了：当一边子树的结点少了，那么向另外一边子树“借”一些结点；当一边子树的结点多了，那么向另外一边子树“租”一些结点。</p><p>但要保持红黑树的性质，结点不能乱挪，还得靠变色了。怎么变？具体情景又不同变法，后面会具体讲到，现在只需要记住<strong>红黑树总是通过旋转和变色达到自平衡</strong>。</p><blockquote><p><strong>思考题1：黑结点可以同时包含一个红子结点和一个黑子结点吗？</strong></p><p>答：可以。如下图的F结点：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%80%9D%E8%80%83%E9%A2%981.png"></p></blockquote><h2 id="红黑树查找"><a href="#红黑树查找" class="headerlink" title="红黑树查找"></a>红黑树查找</h2><p>因为红黑树是一颗二叉平衡树，并且查找不会破坏树的平衡，所以查找跟二叉平衡树的查找无异：</p><ol><li>从根结点开始查找，把根结点设置为当前结点；</li><li>若当前结点为空，返回null；</li><li>若当前结点不为空，用当前结点的key跟查找key作比较；</li><li>若当前结点key等于查找key，那么该key就是查找目标，返回当前结点；</li><li>若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤2；</li><li>若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤2；</li></ol><p>流程图：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%9F%A5%E6%89%BE.png" width="80%"></p><p>非常简单，但简单不代表它效率不好。正由于红黑树总保持黑色完美平衡，所以它的查找最坏时间复杂度为$O(2logN)$，也即整颗树刚好红黑相隔的时候。能有这么好的查找效率得益于红黑树自平衡的特性，而这背后的付出，红黑树的插入操作功不可没～</p><h2 id="红黑树插入"><a href="#红黑树插入" class="headerlink" title="红黑树插入"></a>红黑树插入</h2><p>插入操作包括两部分工作：一查找插入的位置；二插入后自平衡。查找插入的父结点很简单，跟查找操作区别不大：</p><ol><li>从根结点开始查找；</li><li>若根结点为空，那么插入结点作为根结点，结束。</li><li>若根结点不为空，那么把根结点作为当前结点；</li><li>若当前结点为null，返回当前结点的父结点，结束。</li><li>若当前结点key等于查找key，那么该key所在结点就是插入结点，更新结点的值，结束。</li><li>若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤4；</li><li>若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤4；</li></ol><p>流程图：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A5.png" width="80%"></p><p>ok，插入位置已经找到，把插入结点放到正确的位置就可以啦，但插入结点是应该是什么颜色呢？答案是<strong>红色</strong>。理由很简单，红色在父结点（如果存在）为黑色结点时，红黑树的黑色平衡没被破坏，不需要做自平衡操作。但如果插入结点是黑色，那么插入位置所在的子树黑色结点总是多1，必须做自平衡。</p><p>所有插入情景如下：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A5%E6%83%85%E6%99%AF.png"></p><p>一共有8种插入情景，但情景1、2和3的处理很简单，而情景4.2和情景4.3只是方向反转而已，懂得了一种情景就能推出另外一种情景，所以总体来看，并不复杂，后续我们将一个一个情景来看，把它彻底搞懂。</p><p>根据二叉树的性质，<strong>除了情景2，所有插入操作都是在叶子结点进行的</strong>。这点应该不难理解，因为查找插入位置时，我们就是在找子结点为空的父结点的。</p><p>在开始每个情景的讲解前，我们还是先来约定下，如下图所示。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8F%92%E5%85%A5%E7%BB%93%E7%82%B9%E7%9A%84%E5%8F%AB%E6%B3%95%E7%BA%A6%E5%AE%9A.png" width="80%"></p><p>图中的字母并不代表结点Key的大小。I表示插入结点，P表示插入结点的父结点，S表示插入结点的叔叔结点，PP表示插入结点的祖父结点。</p><p>接下来，我们一个一个分析每个插入情景以及处理。</p><h3 id="插入情景1：红黑树为空树"><a href="#插入情景1：红黑树为空树" class="headerlink" title="插入情景1：红黑树为空树"></a>插入情景1：红黑树为空树</h3><p>最简单的一种情景，直接把插入结点作为根结点就行，但注意，<strong>根据红黑树性质2：根节点是黑色</strong>。还需要把插入结点设为<strong>黑色</strong>。</p><p><strong>处理：把插入结点作为根结点，并把结点设置为黑色</strong>。</p><h3 id="插入情景2：插入结点的Key已存在"><a href="#插入情景2：插入结点的Key已存在" class="headerlink" title="插入情景2：插入结点的Key已存在"></a>插入情景2：插入结点的Key已存在</h3><p>插入结点的Key已存在，既然红黑树总保持平衡，在插入前红黑树已经是平衡的，那么把插入结点设置为将要替代结点的颜色，再把结点的值更新就完成插入。</p><p><strong>处理：</strong></p><ul><li><strong>把I设为当前结点的颜色</strong></li><li><strong>更新当前结点的值为插入结点的值</strong></li></ul><h3 id="插入情景3：插入结点的父结点为黑结点"><a href="#插入情景3：插入结点的父结点为黑结点" class="headerlink" title="插入情景3：插入结点的父结点为黑结点"></a>插入情景3：插入结点的父结点为黑结点</h3><p>由于插入的结点是红色的，当插入结点的父结点为黑色时，并不会影响红黑树的平衡，直接插入即可，无需做自平衡。</p><p><strong>处理：直接插入</strong>。</p><h3 id="插入情景4：插入结点的父结点为红结点"><a href="#插入情景4：插入结点的父结点为红结点" class="headerlink" title="插入情景4：插入结点的父结点为红结点"></a>插入情景4：插入结点的父结点为红结点</h3><p>再次回想下红黑树的性质2：根结点是黑色。<strong>如果插入的父结点为红结点，那么该父结点不可能为根结点，所以插入结点总是存在祖父结点</strong>。这点很重要，因为后续的旋转操作肯定需要祖父结点的参与。</p><p>情景4又分为很多子情景，下面将进入重点部分，各位看官请留神了。</p><h4 id="插入情景4-1：叔叔结点存在并且为红结点"><a href="#插入情景4-1：叔叔结点存在并且为红结点" class="headerlink" title="插入情景4.1：叔叔结点存在并且为红结点"></a>插入情景4.1：叔叔结点存在并且为红结点</h4><p>从红黑树性质4可以，祖父结点肯定为黑结点，因为不可以同时存在两个相连的红结点。那么此时该插入子树的红黑层数的情况是：黑红红。显然最简单的处理方式是把其改为：红黑红。</p><p><strong>处理：</strong></p><ul><li><strong>将P和S设置为黑色</strong></li><li><strong>将PP设置为红色</strong></li><li><strong>把PP设置为当前插入结点</strong></li></ul><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.1.1.png" width="80%"></p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.1.2.png" width="80%"></p><p>可以看到，我们把PP结点设为红色了，如果PP的父结点是黑色，那么无需再做任何处理；但如果PP的父结点是红色，根据性质4，此时红黑树已不平衡了，所以还需要把PP当作新的插入结点，继续做插入操作自平衡处理，直到平衡为止。</p><p>试想下PP刚好为根结点时，那么根据性质2，我们必须把PP重新设为黑色，那么树的红黑结构变为：黑黑红。换句话说，从根结点到叶子结点的路径中，黑色结点增加了。<strong>这也是唯一一种会增加红黑树黑色结点层数的插入情景</strong>。</p><p>我们还可以总结出另外一个经验：<strong>红黑树的生长是自底向上的</strong>。这点不同于普通的二叉查找树，普通的二叉查找树的生长是自顶向下的。</p><h4 id="插入情景4-2：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的左子结点"><a href="#插入情景4-2：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的左子结点" class="headerlink" title="插入情景4.2：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的左子结点"></a>插入情景4.2：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的左子结点</h4><p>单纯从插入前来看，也即不算情景4.1自底向上处理时的情况，叔叔结点非红即为叶子结点(Nil)。因为如果叔叔结点为黑结点，而父结点为红结点，那么叔叔结点所在的子树的黑色结点就比父结点所在子树的多了，这不满足红黑树的性质5。后续情景同样如此，不再多做说明了。</p><p>前文说了，需要旋转操作时，肯定一边子树的结点多了或少了，需要租或借给另一边。插入显然是多的情况，那么把多的结点租给另一边子树就可以了。</p><h5 id="插入情景4-2-1：插入结点是其父结点的左子节点"><a href="#插入情景4-2-1：插入结点是其父结点的左子节点" class="headerlink" title="插入情景4.2.1：插入结点是其父结点的左子节点"></a>插入情景4.2.1：插入结点是其父结点的左子节点</h5><p><strong>处理：</strong></p><ul><li><strong>将P设为黑色</strong></li><li><strong>将PP设为红色</strong></li><li><strong>对PP进行右旋</strong></li></ul><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.2.1.png" width="80%"></p><p>由上图可得，左边两个红结点，右边不存在，那么一边一个刚刚好，并且因为为红色，肯定不会破坏树的平衡。</p><p>咦，可以把PP设为红色，I和P设为黑色吗？答案是可以！看过《算法：第4版》的同学可能知道，书中讲解的就是把PP设为红色，I和P设为黑色。但把PP设为红色，显然又会出现情景4.1的情况，需要自底向上处理，做多了无谓的操作，既然能自己消化就不要麻烦祖辈们啦～</p><h5 id="插入情景4-2-2：插入结点是其父结点的右子结点"><a href="#插入情景4-2-2：插入结点是其父结点的右子结点" class="headerlink" title="插入情景4.2.2：插入结点是其父结点的右子结点"></a>插入情景4.2.2：插入结点是其父结点的右子结点</h5><p>这种情景显然可以转换为情景4.2.1，如下图所示，不做过多说明了。</p><p><strong>处理：</strong></p><ul><li><strong>对P进行左旋</strong></li><li><strong>把P设置为插入结点，得到情景4.2.1</strong></li><li><strong>进行情景4.2.1的处理</strong></li></ul><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.2.2.png" width="80%"></p><h4 id="插入情景4-3：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的右子结点"><a href="#插入情景4-3：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的右子结点" class="headerlink" title="插入情景4.3：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的右子结点"></a>插入情景4.3：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的右子结点</h4><p>该情景对应情景4.2，只是方向反转，不做过多说明了，直接看图。</p><h5 id="插入情景4-3-1：插入结点是其父结点的右子结点"><a href="#插入情景4-3-1：插入结点是其父结点的右子结点" class="headerlink" title="插入情景4.3.1：插入结点是其父结点的右子结点"></a>插入情景4.3.1：插入结点是其父结点的右子结点</h5><p><strong>处理：</strong></p><ul><li><strong>将P设为黑色</strong></li><li><strong>将PP设为红色</strong></li><li><strong>对PP进行左旋</strong></li></ul><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.3.1.png" width="80%"></p><h5 id="插入情景4-3-2：插入结点是其父结点的右子结点"><a href="#插入情景4-3-2：插入结点是其父结点的右子结点" class="headerlink" title="插入情景4.3.2：插入结点是其父结点的右子结点"></a>插入情景4.3.2：插入结点是其父结点的右子结点</h5><p><strong>处理：</strong></p><ul><li><strong>对P进行右旋</strong></li><li><strong>把P设置为插入结点，得到情景4.3.1</strong></li><li><strong>进行情景4.3.1的处理</strong></li></ul><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.3.2.png" width="80%"></p><p>好了，讲完插入的所有情景了。可能又同学会想：上面的情景举例的都是第一次插入而不包含自底向上处理的情况，那么上面所说的情景都适合自底向上的情况吗？答案是肯定的。理由很简单，但每棵子树都能自平衡，那么整棵树最终总是平衡的。</p><blockquote><p>好吧，在出个习题，请大家拿出笔和纸画下试试（请务必动手画下，加深印象）：</p><p><strong>习题1：请画出下图的插入自平衡处理过程。</strong></p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B9%A0%E9%A2%981.png" width="80%"></p><p>答：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B9%A0%E9%A2%981%E8%A7%A3%E7%AD%94.png" width="80%"></p></blockquote><h2 id="红黑树删除"><a href="#红黑树删除" class="headerlink" title="红黑树删除"></a>红黑树删除</h2><p>红黑树插入已经够复杂了，但删除更复杂，也是红黑树最复杂的操作了。但稳住，胜利的曙光就在前面了！</p><p>红黑树的删除操作也包括两部分工作：一查找目标结点；而删除后自平衡。查找目标结点显然可以复用查找操作，当不存在目标结点时，忽略本次操作；当存在目标结点时，删除后就得做自平衡处理了。删除了结点后我们还需要找结点来替代删除结点的位置，不然子树跟父辈结点断开了，除非删除结点刚好没子结点，那么就不需要替代。</p><p>二叉树删除结点找替代结点有3种情情景：</p><ul><li>情景1：若删除结点无子结点，直接删除</li><li>情景2：若删除结点只有一个子结点，用子结点替换删除结点</li><li>情景3：若删除结点有两个子结点，用后继结点（大于删除结点的最小结点）替换删除结点</li></ul><p>补充说明下，<strong>情景3的后继结点是大于删除结点的最小结点</strong>，也是<strong>删除结点的右子树的最左结点</strong>。那么可以拿前继结点（删除结点的左子树最右结点）替代吗？可以的。但习惯上大多都是拿后继结点来替代，后文的讲解也是用后继结点来替代。</p><p>另外告诉大家一种找前继和后继结点的直观的方法（不知为何没人提过，大家都知道？）：<strong>把二叉树所有结点投射在X轴上，所有结点都是从左到右排好序的，所有目标结点的前后结点就是对应前继和后继结点</strong>。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8A%95%E5%B0%84x%E8%BD%B4%E5%90%8E%E6%9C%89%E5%BA%8F.png" width="80%"></p><p>接下来，讲一个重要的思路：<strong>删除结点被替代后，在不考虑结点的键值的情况下，对于树来说，可以认为删除的是替代结点！</strong></p><p>话很苍白，我们看下图。在不看键值对的情况下，图中的红黑树最终结果是删除了Q所在位置的结点！这种思路非常重要，大大简化了后文讲解红黑树删除的情景！</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9%E6%8D%A2%E4%BD%8D%E6%80%9D%E8%B7%AF.png" width="80%"></p><p>基于此，上面所说的3种二叉树的删除情景可以相互转换并且最终都是转换为情景1！</p><ul><li>情景2：删除结点用其唯一的子结点替换，子结点替换为删除结点后，可以认为删除的是子结点，若子结点又有两个子结点，那么相当于转换为情景3，一直自顶向下转换，总是能转换为情景1。（对于红黑树来说，根据性质5.1，只存在一个子结点的结点肯定在树末了）</li><li>情景3：删除结点用后继结点（肯定不存在左结点），如果后继结点有右子结点，那么相当于转换为情景2，否则转为为情景1。</li></ul><p>二叉树删除结点情景关系图如图所示。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E6%99%AF%E8%BD%AC%E6%8D%A2.png" width="80%"></p><p>综上所述，<strong>删除操作删除的结点可以看作删除替代结点，而替代结点最后总是在树末。</strong>有了这结论，我们讨论的删除红黑树的情景就少了很多，因为我们只考虑删除树末结点的情景了。</p><p>同样的，我们也是先来总体看下删除操作的所有情景，如下图所示。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E6%99%AF.png"></p><p>即使简化了还是有9种情景！但跟插入操作一样，存在左右对称的情景，只是方向变了，没有本质区别。</p><p>同样的，我们还是来约定下，如图所示。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E7%BB%93%E7%82%B9%E7%9A%84%E5%8F%AB%E6%B3%95%E7%BA%A6%E5%AE%9A.png" width="80%"></p><p>图中的字母并不代表结点Key的大小。R表示替代结点，P表示替代结点的父结点，S表示替代结点的兄弟结点，SL表示兄弟结点的左子结点，SR表示兄弟结点的右子结点。灰色结点表示它可以是红色也可以是黑色。</p><p>值得特别提醒的是，<strong>R是即将被替换到删除结点的位置的替代结点，在删除前，它还在原来所在位置参与树的子平衡，平衡后再替换到删除结点的位置，才算删除完成。</strong></p><p>万事具备，我们进入最后的也是最难的讲解。</p><h4 id="删除情景1：替换结点是红色结点"><a href="#删除情景1：替换结点是红色结点" class="headerlink" title="删除情景1：替换结点是红色结点"></a>删除情景1：替换结点是红色结点</h4><p>我们把替换结点换到了删除结点的位置时，由于替换结点时红色，删除也了不会影响红黑树的平衡，只要把替换结点的颜色设为删除的结点的颜色即可重新平衡。</p><p><strong>处理：颜色变为删除结点的颜色</strong></p><h4 id="删除情景2：替换结点是黑结点"><a href="#删除情景2：替换结点是黑结点" class="headerlink" title="删除情景2：替换结点是黑结点"></a>删除情景2：替换结点是黑结点</h4><p>当替换结点是黑色时，我们就不得不进行自平衡处理了。我们必须还得考虑替换结点是其父结点的左子结点还是右子结点，来做不同的旋转操作，使树重新平衡。</p><h5 id="删除情景2-1：替换结点是其父结点的左子结点"><a href="#删除情景2-1：替换结点是其父结点的左子结点" class="headerlink" title="删除情景2.1：替换结点是其父结点的左子结点"></a>删除情景2.1：替换结点是其父结点的左子结点</h5><p><strong>删除情景2.1.1：替换结点的兄弟结点是红结点</strong><br>若兄弟结点是红结点，那么根据性质4，兄弟结点的父结点和子结点肯定为黑色，不会有其他子情景，我们按图21处理，得到删除情景2.1.2.3（后续讲解，这里先记住，此时R仍然是替代结点，它的新的兄弟结点SL和兄弟结点的子结点都是黑色）。</p><p><strong>处理：</strong></p><ul><li><strong>将S设为黑色</strong></li><li><strong>将P设为红色</strong></li><li><strong>对P进行左旋，得到情景2.1.2.3</strong></li><li><strong>进行情景2.1.2.3的处理</strong></li></ul><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%88%A0%E9%99%A4%E6%83%85%E6%99%AF2.1.1.png" width="80%"></p><p><strong>删除情景2.1.2：替换结点的兄弟结点是黑结点</strong></p><p>当兄弟结点为黑时，其父结点和子结点的具体颜色也无法确定（如果也不考虑自底向上的情况，子结点非红即为叶子结点Nil，Nil结点为黑结点），此时又得考虑多种子情景。</p><p><strong>删除情景2.1.2.1：替换结点的兄弟结点的右子结点是红结点，左子结点任意颜色</strong><br>即将删除的左子树的一个黑色结点，显然左子树的黑色结点少1了，然而右子树又又红色结点，那么我们直接向右子树“借”个红结点来补充黑结点就好啦，此时肯定需要用旋转处理了。如下图所示。</p><p><strong>处理：</strong></p><ul><li><strong>将S的颜色设为P的颜色</strong></li><li><strong>将P设为黑色</strong></li><li><strong>将SR设为黑色</strong></li><li><strong>对P进行左旋</strong></li></ul><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%88%A0%E9%99%A4%E6%83%85%E6%99%AF2.1.2.1.png" width="80%"></p><p>平衡后的图怎么不满足红黑树的性质？前文提醒过，R是即将替换的，它还参与树的自平衡，平衡后再替换到删除结点的位置，所以R最终可以看作是删除的。另外上图是考虑到第一次替换和自底向上处理的情况，如果只考虑第一次替换的情况，根据红黑树性质，SL肯定是红色或为Nil，所以最终结果树是平衡的。如果是自底向上处理的情况，同样，每棵子树都保持平衡状态，最终整棵树肯定是平衡的。后续的情景同理，不做过多说明了。</p><p><strong>删除情景2.1.2.2：替换结点的兄弟结点的右子结点为黑结点，左子结点为红结点</strong><br>兄弟结点所在的子树有红结点，我们总是可以向兄弟子树借个红结点过来，显然该情景可以转换为情景2.1.2.1。如下图所示。</p><p><strong>处理：</strong></p><ul><li><strong>将S设为红色</strong></li><li><p><strong>将SL设为黑色</strong></p></li><li><p><strong>对S进行右旋，得到情景2.1.2.1</strong></p></li><li><strong>进行情景2.1.2.1的处理</strong></li></ul><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%88%A0%E9%99%A4%E6%83%85%E6%99%AF2.1.2.2.png" width="80%"></p><p><strong>删除情景2.1.2.3：替换结点的兄弟结点的子结点都为黑结点</strong><br>好了，此次兄弟子树都没红结点“借”了，兄弟帮忙不了，找父母呗，这种情景我们把兄弟结点设为红色，再把父结点当作替代结点，自底向上处理，去找父结点的兄弟结点去“借”。但为什么需要把兄弟结点设为红色呢？显然是为了在P所在的子树中保证平衡（R即将删除，少了一个黑色结点，子树也需要少一个），后续的平衡工作交给父辈们考虑了，还是那句，当每棵子树都保持平衡时，最终整棵总是平衡的。</p><p><strong>处理：</strong></p><ul><li><strong>将S设为红色</strong></li><li><strong>把P作为新的替换结点</strong></li><li><strong>重新进行删除结点情景处理</strong></li></ul><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%83%85%E6%99%AF2.1.2.3.png" width="80%"></p><h5 id="删除情景2-2：替换结点是其父结点的右子结点"><a href="#删除情景2-2：替换结点是其父结点的右子结点" class="headerlink" title="删除情景2.2：替换结点是其父结点的右子结点"></a>删除情景2.2：替换结点是其父结点的右子结点</h5><p>好啦，右边的操作也是方向相反，不做过多说明了，相信理解了删除情景2.1后，肯定可以理解2.2。</p><p><strong>删除情景2.2.1：替换结点的兄弟结点是红结点</strong><br>处理：</p><ul><li><strong>将S设为黑色</strong></li><li><strong>将P设为红色</strong></li><li><strong>对P进行右旋，得到情景2.2.2.3</strong></li><li><strong>进行情景2.2.2.3的处理</strong></li></ul><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%88%A0%E9%99%A4%E6%83%85%E6%99%AF2.2.1.png" width="80%"></p><p><strong>删除情景2.2.2：替换结点的兄弟结点是黑结点</strong><br><strong>删除情景2.2.2.1：替换结点的兄弟结点的左子结点是红结点，右子结点任意颜色</strong><br><strong>处理：</strong></p><ul><li><strong>将S的颜色设为P的颜色</strong></li><li><strong>将P设为黑色</strong></li><li><strong>将SL设为黑色</strong></li><li><strong>对P进行右旋</strong></li></ul><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%88%A0%E9%99%A4%E6%83%85%E6%99%AF2.2.2.1.png" width="80%"></p><p><strong>删除情景2.2.2.2：替换结点的兄弟结点的左子结点为黑结点，右子结点为红结点</strong><br><strong>处理：</strong></p><ul><li><strong>将S设为红色</strong></li><li><strong>将SR设为黑色</strong></li><li><strong>对S进行左旋，得到情景2.2.2.1</strong></li><li><strong>进行情景2.2.2.1的处理</strong></li></ul><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%88%A0%E9%99%A4%E6%83%85%E6%99%AF2.2.2.2.png" width="80%"></p><p><strong>删除情景2.2.2.3：替换结点的兄弟结点的子结点都为黑结点</strong><br><strong>处理：</strong></p><ul><li><strong>将S设为红色</strong></li><li><strong>把P作为新的替换结点</strong></li><li><strong>重新进行删除结点情景处理</strong></li></ul><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%88%A0%E9%99%A4%E6%83%85%E6%99%AF2.2.2.3.png" width="80%"></p><p>综上，红黑树删除后自平衡的处理可以总结为：</p><ol><li>自己能搞定的自消化（情景1）</li><li>自己不能搞定的叫兄弟帮忙（除了情景1、情景2.1.2.3和情景2.2.2.3）</li><li>兄弟都帮忙不了的，通过父母，找远方亲戚（情景2.1.2.3和情景2.2.2.3）</li></ol><p>哈哈，是不是跟现实中很像，当我们有困难时，首先先自己解决，自己无力了总兄弟姐妹帮忙，如果连兄弟姐妹都帮不上，再去找远方的亲戚了。这里记忆应该会好记点～</p><blockquote><p>最后再做个习题加深理解（请不熟悉的同学务必动手画下）：</p><p>习题2：请画出下图的删除自平衡处理过程。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B9%A0%E9%A2%982.png" width="80%"></p><p>答：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B9%A0%E9%A2%982%E8%A7%A3%E7%AD%94.png"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红黑树 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性代数公式</title>
      <link href="/2019/09/10/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%85%AC%E5%BC%8F/"/>
      <url>/2019/09/10/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%85%AC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<ul><li>矩阵的秩</li></ul><a id="more"></a><h2 id="矩阵的秩"><a href="#矩阵的秩" class="headerlink" title="矩阵的秩"></a>矩阵的秩</h2><p>设$A$是$m\times n$矩阵，$B$是满足有关矩阵运算要求的矩阵，则</p><ol><li>$0\le r(a)\le \min\{m,n\}$</li><li><p>$r(kA)=r(A),(k\ne 0)$</p></li><li><p>设$A$是$m\times n$矩阵，$P,Q$分别是$m$阶、$n$阶可逆矩阵，则$r(A)=r(PA)=r(AQ)=r(PAQ)$</p></li><li><p>$r(AB)\le \min\{r(A),r(B)\}$，注：若$r(AB)\le r(A)$，$B$为$n$阶矩阵，则$r(B)&lt;n$</p></li><li>$r(A+B)\le r(A)+r(B)$</li><li><p>$r\left(\begin{bmatrix}A &amp;O\\O&amp;B\end{bmatrix}\right)=r(A)+r(B)$</p></li><li><p>$r(A)+r(B)\le r\left(\begin{bmatrix}A &amp;O\\C&amp;B\end{bmatrix}\right)\le r(A)+r(B)+r(C)$</p></li><li>$r(AB)\ge r(A)+r(B)-n$，注：当$AB=0$时，$r(A)+r(B)\le n$，$n$是$A$的列数（或$B$的行数）</li><li>$r(A)=r(A^T)=r(AA^T)=r(A^TA)$</li><li>$r(A^*)=\begin{cases}<br>\ n,r(A)=n \\<br>\ 1,r(A)=n-1,其中A为n阶方阵 \\<br>\ 0,r(A)&lt;n-1<br>\end{cases}$</li><li>若$A$是$n$阶方阵，$A^2=A$，则$r(A)+r(E-A)=n$</li><li>若$A$是$n$阶方阵，$A^2=E$，则$r(A+E)=r(A-E)=n$</li><li>$Ax=0$，基础解系所含向量的个数$S=n-r(A)$</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数学之美 </category>
          
          <category> 数学公式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 高数 </tag>
            
            <tag> 数学公式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高数公式</title>
      <link href="/2019/09/09/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/"/>
      <url>/2019/09/09/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<ul><li>不定积分的基本积分公式</li><li>定积分的性质</li><li>常见泰勒展开式</li><li>和差化积公式</li><li>积化和差公式</li><li>微分中值定理</li></ul><a id="more"></a><h2 id="不定积分的基本积分公式"><a href="#不定积分的基本积分公式" class="headerlink" title="不定积分的基本积分公式"></a>不定积分的基本积分公式</h2><p>$\int x^\alpha dx=\frac{1}{1+\alpha}x^{1+\alpha}+C,(\alpha \ne -1)$</p><p>$\int \frac{1}{x} dx=\ln|x|+C$</p><p>$\int a^x dx=\frac{a^x}{\ln a}+C,\int e^x dx=e^x+C$</p><p>$\int\cos xdx=\sin x+C$</p><p>$\int\sin xdx=-\cos x+C$</p><p>$\int \sec^2xdx=\int\frac{1}{\cos^2x}dx=\tan{x}+C$</p><p>$\int \csc^2xdx=\int\frac{1}{\sin^2x}dx=-\cot{x}+C$</p><p>$\int\sec xdx=\ln|\sec x+\tan x|+C$</p><p>$\int\csc xdx=\ln|\csc x-\cot x|+C$</p><p>$\int\frac{1}{a^2+x^2}dx=\frac{1}{a}\arctan\frac{x}{a}+C,\int\frac{1}{1+x^2}dx=\arctan x+C$</p><p>$\int\frac{1}{\sqrt{a^2-x^2}}dx=\arcsin\frac{x}{a}+C,(a&gt;0),\int\frac{1}{\sqrt{1-x^2}}dx=\arcsin x+C,(a&gt;0)$</p><p>$\int\frac{1}{a^2-x^2}dx=\frac{1}{2a}\ln|\frac{a+x}{a-x}|+C$</p><p>$\int\frac{1}{\sqrt{x^2\pm a^2}}dx=\ln|x+\sqrt{x^2\pm a^2}|+C$</p><h2 id="定积分性质"><a href="#定积分性质" class="headerlink" title="定积分性质"></a>定积分性质</h2><p>设$f(x)$，$g(x)$在区间$[a,b]$上可积，则</p><ol><li><p>$\int_{a}^bkf(x)dx=k\int_{a}^bf(x)dx$</p></li><li><p>$\int_a^b[f(x)\pm g(x)]dx=\int_a^bf(x)dx\pm \int_a^bg(x)dx$</p></li><li>$\int_a^b1\cdot dx=\int_a^bdx=b-a$</li><li><p>若$f(x)$在由$a, b,c$构成的最大的区间上可积，则$\int_a^bf(x)dx=\int_a^cf(x)dx+\int_c^bf(x)dx$</p></li><li><p>若在区间$[a,b]$上$f(x)\le g(x)$，则$\int_a^bf(x)dx\le\int_a^bg(x)dx$</p></li><li><p><strong>定积分的估值定理：</strong>如果$f(x)$在q㢟$[a,b]$上的最大值与最小值分别为$M,m$，则$m(b-a)\le\int_a^bf(x)dx\le M(b-a)$</p></li><li><p><strong>积分中值定理：</strong>如果$f(x)$在区间$[a,b]$上连续，则$[a,b]$上至少存在一点$\xi$，使$\int_a^bf(x)dx=f(\xi)(b-a)$，称$\frac{1}{b-a}\int_a^bf(x)dx$为函数$y=f(x)$在区间$[a,b]$上的平均值</p></li></ol><h2 id="常见泰勒展开式"><a href="#常见泰勒展开式" class="headerlink" title="常见泰勒展开式"></a>常见泰勒展开式</h2><p>$e^x=\sum\limits_{n=0}^{\infty}\frac{x^n}{n!}=1+x+\frac{x^2}{2!}+…+\frac{x^n}{n!}+…,-\infty&lt;x&lt;+\infty$</p><p>$\frac{1}{1+x}=\sum\limits_{n=0}^{\infty}(-1)^nx^n=1-x+x^2-x^3+…+(-1)^nx^n+…,-1&lt;x&lt;1$</p><p>$\frac{1}{1-x}=\sum\limits_{n=0}^{\infty}x^n=1+x+x^2+x^3+…+x^n+…,-1&lt;x&lt;1$</p><p>$\ln(1+x)=\sum\limits_{n=1}^{\infty}(-1)^{n-1}\frac{x^n}{n}=x-\frac{x^2}{2}+\frac{x^3}{3}-\frac{x^4}{4}+…+(-1)^{n-1}\frac{x^n}{n}+…,-1\le{x}\le{1}$</p><p>$\sin{x}=\sum\limits_{n=0}^{\infty}(-1)^n\frac{x^{2n+1}}{(2n+1)!}=x-\frac{x^3}{3!}+\frac{x^5}{5!}-\frac{x^7}{7!}+…+(-1)^n\frac{x^{2n+1}}{(2n+1)!}+…,-\infty&lt;x&lt;+\infty$</p><p>$\cos{x}=\sum\limits_{n=0}^{\infty}(-1)^n\frac{x^{2n}}{(2n)!}=1-\frac{x^2}{2!}+\frac{x^4}{4!}-\frac{x^6}{6!}+…+(-1)^n\frac{x^{2n}}{(2n)!}+…,-\infty&lt;x&lt;+\infty$</p><p>$(1+x)^{\alpha}=1+\alpha{x}+\frac{\alpha(\alpha-1)}{2!}x^2+…+\frac{\alpha(\alpha-1)…(\alpha-n+1)}{n!}x^n+…,$$\begin{cases}<br> \ x\in(-1,1),\alpha\le-1\\<br> \ x\in(-1,1],-1&lt;\alpha<0\\ \ x\in[-1,1],\alpha>0<br>\end{cases}$</0\\></p><p>$\tan{x}=x+\frac{1}{3}x^3+o(x^3)$</p><p>$\arcsin{x}=x+\frac{1}{6}x^3+o(x^3)$</p><p>$\arctan{x}=x-\frac{1}{3}x^3+o(x^3)$</p><h2 id="和差化积公式"><a href="#和差化积公式" class="headerlink" title="和差化积公式"></a>和差化积公式</h2><p>$\sin\alpha+\sin\beta=2\sin\frac{\alpha+\beta}{2}\cos\frac{\alpha-\beta}{2}$</p><p>$\sin\alpha-\sin\beta=2\sin\frac{\alpha-\beta}{2}\cos\frac{\alpha+\beta}{2}$</p><p>$\cos\alpha+\cos\beta=2\cos\frac{\alpha+\beta}{2}\cos\frac{\alpha-\beta}{2}$</p><p>$\cos\alpha-\cos\beta=-2\sin\frac{\alpha+\beta}{2}\sin\frac{\alpha-\beta}{2}$</p><h2 id="积化和差公式"><a href="#积化和差公式" class="headerlink" title="积化和差公式"></a>积化和差公式</h2><p>$\sin\alpha\sin\beta=\frac{1}{2}[\cos(\alpha-\beta)-\cos(\alpha+\beta)]$</p><p>$\cos\alpha\cos\beta=\frac{1}{2}[\cos(\alpha+\beta)+\cos(\alpha-\beta)]$</p><p>$\sin\alpha\cos\beta=\frac{1}{2}[\sin(\alpha+\beta)+\sin(\alpha-\beta)]$</p><p>$\cos\alpha\sin\beta=\frac{1}{2}[\sin(\alpha+\beta)-\sin(\alpha-\beta)]$</p><h2 id="微分中值定理"><a href="#微分中值定理" class="headerlink" title="微分中值定理"></a>微分中值定理</h2><h3 id="罗尔定理"><a href="#罗尔定理" class="headerlink" title="罗尔定理"></a>罗尔定理</h3><p>设$f(x)$在闭区间$[a,b]$上连续，在开区间$(a,b)$内可导，若$f(a)=f(b)$，则至少存在一点$\xi\in(a,b)$，使得$f’(\xi)=0$。</p><h3 id="拉格朗日中值定理"><a href="#拉格朗日中值定理" class="headerlink" title="拉格朗日中值定理"></a>拉格朗日中值定理</h3><p>设$f(x)$在闭区间$[a,b]$上连续，在开区间$(a,b)$内可导，则至少存在一点$\xi\in(a,b)$，使得$f(b)-f(a)=f’(\xi)(b-a)$。</p><h3 id="柯西中值定理"><a href="#柯西中值定理" class="headerlink" title="柯西中值定理"></a>柯西中值定理</h3><p>设$f(x)$，$g(x)$在闭区间$[a,b]$上连续，在开区间$(a,b)$内可导，且$g’(x)\ne 0$，$x\in(a,b)$，则至少存在一点$\xi\in(a,b)$，使得$\frac{f(b)-f(a)}{g(b)-g(a)}=\frac{f’(\xi)}{g’(\xi)}$。</p><h3 id="泰勒定理"><a href="#泰勒定理" class="headerlink" title="泰勒定理"></a>泰勒定理</h3><h4 id="带拉格朗日余项的泰勒定理"><a href="#带拉格朗日余项的泰勒定理" class="headerlink" title="带拉格朗日余项的泰勒定理"></a>带拉格朗日余项的泰勒定理</h4><p>设$f(x)$在点$x_0$的某一领域内有直到$n+1$阶的导数，则对该领域内的任意点$x$，都有</p><script type="math/tex; mode=display">f(x)=f(x_0)+\frac{f'(x_0)}{1!}(x-x_0)+\frac{f''(x_0)}{2!}(x-x_0)^2+...+\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n+\frac{f^{(n+1)}(\xi)}{(n+1)!}(x-x_0)^{n+1} \nonumber</script><p>其中，$\xi$ 介于$x$，$x_0$之间。</p><h4 id="带皮亚诺余项的泰勒定理"><a href="#带皮亚诺余项的泰勒定理" class="headerlink" title="带皮亚诺余项的泰勒定理"></a>带皮亚诺余项的泰勒定理</h4><p>设$f(x)$在点$x_0$的某一领域内有直到 $n$ 阶的导数，则对该领域内的任意点$x$，都有</p><script type="math/tex; mode=display">f(x)=f(x_0)+\frac{f'(x_0)}{1!}(x-x_0)+\frac{f''(x_0)}{2!}(x-x_0)^2+...+\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n+o(x-x_0)^{n} \nonumber</script><h4 id="几个常用函数的带皮亚诺余项的麦克劳林展开式"><a href="#几个常用函数的带皮亚诺余项的麦克劳林展开式" class="headerlink" title="几个常用函数的带皮亚诺余项的麦克劳林展开式"></a>几个常用函数的带皮亚诺余项的麦克劳林展开式</h4><p>$e^x=1+x+\frac{x^2}{2!}+…+\frac{x^n}{n!}+o(x^n)$</p><p>$\sin{x}=x-\frac{x^3}{3!}+\frac{x^5}{5!}-\frac{x^7}{7!}+…+(-1)^n\frac{x^{2n+1}}{(2n+1)!}+o(x^{2n+1})$</p><p>$\cos{x}=1-\frac{x^2}{2!}+\frac{x^4}{4!}-\frac{x^6}{6!}+…+(-1)^n\frac{x^{2n}}{(2n)!}+o(x^{2n})$</p><p>$\ln(1+x)=x-\frac{x^2}{2}+\frac{x^3}{3}-\frac{x^4}{4}+…+(-1)^{n-1}\frac{x^n}{n}+o(x^n)$</p><p>$(1+x)^{\alpha}=1+\alpha{x}+\frac{\alpha(\alpha-1)}{2!}x^2+…+\frac{\alpha(\alpha-1)…(\alpha-n+1)}{n!}x^n+o(x^n)$</p>]]></content>
      
      
      <categories>
          
          <category> 数学之美 </category>
          
          <category> 数学公式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 高数 </tag>
            
            <tag> 数学公式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卷积神经网络（CNN）模型结构可视化工具</title>
      <link href="/2019/09/01/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88CNN%EF%BC%89%E6%A8%A1%E5%9E%8B%E7%BB%93%E6%9E%84%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7/"/>
      <url>/2019/09/01/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88CNN%EF%BC%89%E6%A8%A1%E5%9E%8B%E7%BB%93%E6%9E%84%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>深度学习中，CNN模型可视化有助于我们学习、分析网络模型。目前接触到的可视化有：特征图可视化、网络模型结构可视化。本文为大家介绍的就是网络模型结构可视化的两款小工具。</p><h2 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h2><p>本文主要介绍Netscope和ConvNetDraw。</p><a id="more"></a><h2 id="Netscope"><a href="#Netscope" class="headerlink" title="Netscope"></a>Netscope</h2><p>Netscope是一个在线编辑，用于可视化卷积神经网络模型结构的小工具。目前，支持Caffe的prototxt文件可视化。</p><p>支持自定义网络结构，可视化输出结构，只要按照prototxt的格式写即可。</p><p>可视化效果：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B7%A5%E5%85%B7/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E7%BB%93%E6%9E%84%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7/trick-8-1.png" width="50%"></p><p>体验地址：<a href="https://cuijiahua.com/netscope/quickstart.html" target="_blank" rel="noopener">https://cuijiahua.com/netscope/quickstart.html</a></p><h2 id="ConvNetDraw"><a href="#ConvNetDraw" class="headerlink" title="ConvNetDraw"></a>ConvNetDraw</h2><p>ConvNetDraw也是一个用于可视化卷积神经网络模型结构的小工具。与Netscope不同的是，ConvNetDraw是使用可视化命令进行可视化的，而且命令很简单比如：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B7%A5%E5%85%B7/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E7%BB%93%E6%9E%84%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7/trick-8-2.png" width="50%"></p><p>可视化效果：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B7%A5%E5%85%B7/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E7%BB%93%E6%9E%84%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7/trick-8-3.png" width="50%"></p><p>体验地址：<a href="https://cuijiahua.com/convdraw/" target="_blank" rel="noopener">https://cuijiahua.com/convdraw/</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>两个工具都有些bug，对于前端可视化卷积神经网络感兴趣的朋友，可以去他们的Github开源项目看看，帮助完善就更赞了。</p><p>Netscope开源项目地址：<a href="https://cuijiahua.com/wp-content/themes/begin/inc/go.php?url=https://github.com/ethereon/netscope" target="_blank" rel="noopener">https://github.com/ethereon/netscope</a></p><p>ConvNetDraw开源项目地址：<a href="https://cuijiahua.com/wp-content/themes/begin/inc/go.php?url=https://github.com/cbovar/ConvNetDraw" target="_blank" rel="noopener">https://github.com/cbovar/ConvNetDraw</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机工具 </category>
          
          <category> 网络模型结构可视化工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CNN </tag>
            
            <tag> 模型结构 </tag>
            
            <tag> 可视化工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How a Kalman filter works, in pictures</title>
      <link href="/2019/08/30/How-a-Kalman-filter-works-in-pictures/"/>
      <url>/2019/08/30/How-a-Kalman-filter-works-in-pictures/</url>
      
        <content type="html"><![CDATA[<p>I have to tell you about the Kalman filter, because what it does is pretty damn amazing.</p><p>Surprisingly few software engineers and scientists seem to know about it, and that makes me sad because it is such a general and powerful tool for <strong>combining information</strong> in the presence of uncertainty. At times its ability to extract accurate information seems almost magical— and if it sounds like I’m talking this up too much, then take a look at <a href="https://www.bzarg.com/p/improving-imu-attitude-estimates-with-velocity-data" target="_blank" rel="noopener">this previously posted video</a> where I demonstrate a Kalman filter figuring out the <em>orientation</em> of a free-floating body by looking at its <em>velocity</em>. Totally neat!</p><a id="more"></a><h2 id="What-is-it"><a href="#What-is-it" class="headerlink" title="What is it?"></a>What is it?</h2><p>You can use a Kalman filter in any place where you have <strong>uncertain information</strong> about some dynamic system, and you can make an <strong>educated guess</strong> about what the system is going to do next. Even if messy reality comes along and interferes with the clean motion you guessed about, the Kalman filter will often do a very good job of figuring out what actually happened. And it can take advantage of correlations between crazy phenomena that you maybe wouldn’t have thought to exploit!</p><p>Kalman filters are ideal for systems which are <strong>continuously changing</strong>. They have the advantage that they are light on memory (they don’t need to keep any history other than the previous state), and they are very fast, making them well suited for real time problems and embedded systems.</p><p>The math for implementing the Kalman filter appears pretty scary and opaque in most places you find on Google. That’s a bad state of affairs, because the Kalman filter is actually super simple and easy to understand if you look at it in the right way. Thus it makes a great article topic, and I will attempt to illuminate it with lots of clear, pretty pictures and colors. The prerequisites are simple; all you need is a basic understanding of probability and matrices.</p><p>I’ll start with a loose example of the kind of thing a Kalman filter can solve, but if you want to get right to the shiny pictures and math, feel free to <a href="http://www.bzarg.com/p/how-a-kalman-filter-works-in-pictures/#mathybits" target="_blank" rel="noopener">jump ahead</a>.</p><h2 id="What-can-we-do-with-a-Kalman-filter"><a href="#What-can-we-do-with-a-Kalman-filter" class="headerlink" title="What can we do with a Kalman filter?"></a>What can we do with a Kalman filter?</h2><p>Let’s make a toy example: You’ve built a little robot that can wander around in the woods, and the robot needs to know exactly where it is so that it can navigate.</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/robot_forest.png" width="30%"></p><p>We’ll say our robot has a state $\vec{x_k}$ , which is just a position and a velocity :</p><script type="math/tex; mode=display">\nonumber\vec{x_k} = (\vec{p}, \vec{v})</script><p>Note that the state is just a list of numbers about the underlying configuration of your system; it could be anything. In our example it’s position and velocity, but it could be data about the amount of fluid in a tank, the temperature of a car engine, the position of a user’s finger on a touchpad, or any number of things you need to keep track of.</p><p>Our robot also has a GPS sensor, which is accurate to about 10 meters, which is good, but it needs to know its location more precisely than 10 meters. There are lots of gullies and cliffs in these woods, and if the robot is wrong by more than a few feet, it could fall off a cliff. So GPS by itself is not good enough.</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/robot_ohnoes.png" width="30%"></p><p>We might also know something about how the robot moves: It knows the commands sent to the wheel motors, and its knows that if it’s headed in one direction and nothing interferes, at the next instant it will likely be further along that same direction. But of course it doesn’t know everything about its motion: It might be buffeted by the wind, the wheels might slip a little bit, or roll over bumpy terrain; so the amount the wheels have turned might not exactly represent how far the robot has actually traveled, and the prediction won’t be perfect.</p><p>The GPS <strong>sensor</strong> tells us something about the state, but only indirectly, and with some uncertainty or inaccuracy. Our <strong>prediction</strong> tells us something about how the robot is moving, but only indirectly, and with some uncertainty or inaccuracy.</p><p>But if we use all the information available to us, can we get a better answer than <strong>either estimate would give us by itself</strong>? Of course the answer is yes, and that’s what a Kalman filter is for.</p><h2 id="How-a-Kalman-filter-sees-your-problem"><a href="#How-a-Kalman-filter-sees-your-problem" class="headerlink" title="How a Kalman filter sees your problem"></a>How a Kalman filter sees your problem</h2><p>Let’s look at the landscape we’re trying to interpret. We’ll continue with a simple state having only position and velocity.</p><script type="math/tex; mode=display">\nonumber\vec{x} = \begin{bmatrix}p\\v\end{bmatrix}</script><p>We don’t know what the <em>actual</em> position and velocity are; there are a whole range of possible combinations of position and velocity that might be true, but some of them are more likely than others:</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/gauss_0.png" width="30%"></p><p>The Kalman filter assumes that both variables (postion and velocity, in our case) are random and <em>Gaussian distributed.</em> Each variable has a <strong>mean</strong> value $\mu$), which is the center of the random distribution (and its most likely state), and a <strong>variance </strong>$\sigma^2$, which is the uncertainty:</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/gauss_1.png" width="30%"></p><p>In the above picture, position and velocity are <strong>uncorrelated</strong>, which means that the state of one variable tells you nothing about what the other might be.</p><p>The example below shows something more interesting: Position and velocity are <strong>correlated</strong>. The likelihood of observing a particular position depends on what velocity you have:</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/gauss_3.png" width="30%"></p><p>This kind of situation might arise if, for example, we are estimating a new position based on an old one. If our velocity was high, we probably moved farther, so our position will be more distant. If we’re moving slowly, we didn’t get as far.</p><p>This kind of relationship is really important to keep track of, because it gives us <strong>more information:</strong> One measurement tells us something about what the others could be. And that’s the goal of the Kalman filter, we want to squeeze as much information from our uncertain measurements as we possibly can!</p><p>This correlation is captured by something called a <a href="https://en.wikipedia.org/wiki/Covariance_matrix" target="_blank" rel="noopener">covariance matrix</a>. In short, each element of the matrix $\Sigma_{ij}$ is the degree of correlation between the <em>ith</em> state variable and the <em>jth</em> state variable. (You might be able to guess that the covariance matrix is <a href="https://en.wikipedia.org/wiki/Symmetric_matrix" target="_blank" rel="noopener">symmetric</a>, which means that it doesn’t matter if you swap <em>i</em> and <em>j</em>). Covariance matrices are oftimg en labelled “$\mathbf{\Sigma}$”, so we call their elements “$\Sigma_{ij}$”.</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/gauss_2.png" width="30%"></p><h2 id="Describing-the-problem-with-matrices"><a href="#Describing-the-problem-with-matrices" class="headerlink" title="Describing the problem with matrices"></a>Describing the problem with matrices</h2><p>We’re modeling our knowledge about the state as a Gaussian blob, so we need two pieces of information at time (k): We’ll call our best estimate $\mathbf{\hat{x}_k}$ (the mean, elsewhere named $\mu$, and its covariance matrix $\mathbf{P_k}$. </p><script type="math/tex; mode=display">\begin{equation} \label{eq:statevars}\begin{aligned}\mathbf{\hat{x}}_k &= \begin{bmatrix}\text{position}\\\text{velocity}\end{bmatrix}\\\mathbf{P}_k &=\begin{bmatrix}\Sigma_{pp} & \Sigma_{pv} \\\Sigma_{vp} & \Sigma_{vv} \\\end{bmatrix}\end{aligned}\end{equation}</script><p>(Of course we are using only position and velocity here, but it’s useful to remember that the state can contain any number of variables, and represent anything you want).</p><p>Next, we need some way to look at the <strong>current state</strong> (at time <strong>k-1</strong>) and <strong>predict the next state</strong> at time <strong>k</strong>. Remember, we don’t know which state is the “real” one, but our prediction function doesn’t care. It just works on <em>all of them</em>, and gives us a new distribution:</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/gauss_7.jpg" width="30%"></p><p>We can represent this prediction step with a matrix, $\mathbf{F_k}$:</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/gauss_8.jpg" width="30%"></p><p>It takes <em>every point</em> in our original estimate and moves it to a new predicted location, which is where the system would move if that original estimate was the right one.</p><p>Let’s apply this. How would we use a matrix to predict the position and velocity at the next moment in the future? We’ll use a really basic kinematic formula:</p><script type="math/tex; mode=display">\nonumber\begin{split}\color{deeppink}{p_k} &= \color{royalblue}{p_{k-1}} + \Delta t &\color{royalblue}{v_{k-1}} \\\color{deeppink}{v_k} &= &\color{royalblue}{v_{k-1}}\end{split}</script><p>In other words : </p><script type="math/tex; mode=display">\begin{align}\color{deeppink}{\mathbf{\hat{x}}_k} &= \begin{bmatrix}1 & \Delta t \\0 & 1\end{bmatrix} \color{royalblue}{\mathbf{\hat{x}}_{k-1}} \\&= \mathbf{F}_k \color{royalblue}{\mathbf{\hat{x}}_{k-1}} \label{statevars}\end{align}</script><p>We now have a <strong>prediction matrix</strong> which gives us our next state, but we still don’t know how to update the covariance matrix.</p><p>This is where we need another formula. If we multiply every point in a distribution by a matrix $\color{firebrick}{\mathbf{A}}$, then what happens to its covariance matrix $\Sigma$ ?</p><p>Well, it’s easy. I’ll just give you the identity:</p><script type="math/tex; mode=display">\begin{equation}\begin{split}Cov(x) &= \Sigma\\Cov(\color{firebrick}{\mathbf{A}}x) &= \color{firebrick}{\mathbf{A}} \Sigma \color{firebrick}{\mathbf{A}}^T\end{split} \label{covident}\end{equation}</script><p>So combining $\eqref{covident}$ with equation $\eqref{statevars}$:</p><script type="math/tex; mode=display">\begin{equation}\begin{split}\color{deeppink}{\mathbf{\hat{x}}_k} &= \mathbf{F}_k \color{royalblue}{\mathbf{\hat{x}}_{k-1}} \\\color{deeppink}{\mathbf{P}_k} &= \mathbf{F_k} \color{royalblue}{\mathbf{P}_{k-1}} \mathbf{F}_k^T\end{split}\end{equation}</script><h2 id="External-influence"><a href="#External-influence" class="headerlink" title="External influence"></a>External influence</h2><p>We haven’t captured everything, though. There might be some changes that <strong>aren’t related to the state</strong> itself— the outside world could be affecting the system.</p><p>For example, if the state models the motion of a train, the train operator might push on the throttle, causing the train to accelerate. Similarly, in our robot example, the navigation software might issue a command to turn the wheels or stop. If we know this additional information about what’s going on in the world, we could stuff it into a vector called $\color{darkorange}{\vec{\mathbf{u}_k}}$, do something with it, and add it to our prediction as a correction.</p><p>Let’s say we know the expected acceleration $\color{darkorange}{a}$ due to the throttle setting or control commands. From basic kinematics we get :</p><script type="math/tex; mode=display">\nonumber\begin{split}\color{deeppink}{p_k} &= \color{royalblue}{p_{k-1}} + {\Delta t} &\color{royalblue}{v_{k-1}} + &\frac{1}{2} \color{darkorange}{a} {\Delta t}^2 \\\color{deeppink}{v_k} &= &\color{royalblue}{v_{k-1}} + & \color{darkorange}{a} {\Delta t}\end{split}</script><p>In matrix form: </p><script type="math/tex; mode=display">\begin{equation}\begin{split}\color{deeppink}{\mathbf{\hat{x}}_k} &= \mathbf{F}_k \color{royalblue}{\mathbf{\hat{x}}_{k-1}} + \begin{bmatrix}\frac{\Delta t^2}{2} \\\Delta t\end{bmatrix} \color{darkorange}{a} \\&= \mathbf{F}_k \color{royalblue}{\mathbf{\hat{x}}_{k-1}} + \mathbf{B}_k \color{darkorange}{\vec{\mathbf{u}_k}}\end{split}\end{equation}</script><p>$\mathbf{B}_k$ is called the <strong>control matrix</strong> and $\color{darkorange}{\vec{\mathbf{u}_k}}$ the <strong>control vector.</strong></p><p>(For very simple systems with no external influence, you could omit these).</p><p>Let’s add one more detail. What happens if our prediction is not a 100% accurate model of what’s actually going on?</p><h2 id="External-uncertainty"><a href="#External-uncertainty" class="headerlink" title="External uncertainty"></a>External uncertainty</h2><p>Everything is fine if the state evolves based on its own properties. Everything is <em>still</em> fine if the state evolves based on external forces, so long as we know what those external forces are.</p><p>But what about forces that we <em>don’t</em> know about? If we’re tracking a quadcopter, for example, it could be buffeted around by wind. If we’re tracking a wheeled robot, the wheels could slip, or bumps on the ground could slow it down. We can’t keep track of these things, and if any of this happens, our prediction could be off because we didn’t account for those extra forces.</p><p>We can model the uncertainty associated with the “world” (i.e. things we aren’t keeping track of) by adding some new uncertainty after every prediction step:</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/gauss_9.jpg" width="30%"></p><p>Every state in our original estimate could have moved to a <em>range</em> of states. Because we like Gaussian blobs so much, we’ll say that each point in $\color{royalblue}{\mathbf{\hat{x}}_{k-1}}$ is moved to somewhere inside a Gaussian blob with covariance $\color{mediumaquamarine}{\mathbf{Q}_k}$. Another way to say this is that we are treating the untracked influences as <strong>noise</strong> with covariance $\color{mediumaquamarine}{\mathbf{Q}_k}$.</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/gauss_10a.jpg" width="30%"></p><p>This produces a new Gaussian blob, with a different covariance (but the same mean):</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/gauss_10b.jpg" width="30%"></p><p>We get the expanded covariance by simply <strong>adding</strong> ${\color{mediumaquamarine}{\mathbf{Q}_k}}$, giving our complete expression for the <strong>prediction step</strong>: </p><script type="math/tex; mode=display">\begin{equation}\begin{split}\color{deeppink}{\mathbf{\hat{x}}_k} &= \mathbf{F}_k \color{royalblue}{\mathbf{\hat{x}}_{k-1}} + \mathbf{B}_k \color{darkorange}{\vec{\mathbf{u}_k}} \\\color{deeppink}{\mathbf{P}_k} &= \mathbf{F_k} \color{royalblue}{\mathbf{P}_{k-1}} \mathbf{F}_k^T + \color{mediumaquamarine}{\mathbf{Q}_k}\end{split}\label{kalpredictfull}\end{equation}</script><p>In other words, the <strong>new best estimate</strong> is a <strong>prediction</strong> made from <strong>previous best estimate</strong>, plus a <strong>correction</strong> for <strong>known external influences</strong>.</p><p>And the <strong>new uncertainty</strong> is <strong>predicted</strong> from the <strong>old uncertainty</strong>, with some <strong>additional uncertainty from the environment</strong>.</p><p>All right, so that’s easy enough. We have a fuzzy estimate of where our system might be, given by $\color{deeppink}{\mathbf{\hat{x}}_k}$ and $\color{deeppink}{\mathbf{P}_k}$. What happens when we get some data from our sensors?</p><h2 id="Refining-the-estimate-with-measurements"><a href="#Refining-the-estimate-with-measurements" class="headerlink" title="Refining the estimate with measurements"></a>Refining the estimate with measurements</h2><p>We might have several sensors which give us information about the state of our system. For the time being it doesn’t matter what they measure; perhaps one reads position and the other reads velocity. Each sensor tells us something <strong>indirect</strong> about the state— in other words, the sensors operate on a state and produce a set of <strong>readings</strong>.</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/gauss_12.jpg" width="30%"></p><p>Notice that the units and scale of the reading might not be the same as the units and scale of the state we’re keeping track of. You might be able to guess where this is going: We’ll model the sensors with a matrix, $\mathbf{H}_k$.</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/gauss_13.jpg" width="30%"></p><p>We can figure out the distribution of sensor readings we’d expect to see in the usual way:</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}\vec{\mu}_{\text{expected}} &= \mathbf{H}_k \color{deeppink}{\mathbf{\hat{x}}_k} \\\mathbf{\Sigma}_{\text{expected}} &= \mathbf{H}_k \color{deeppink}{\mathbf{P}_k} \mathbf{H}_k^T\end{aligned}\end{equation}</script><p>One thing that Kalman filters are great for is dealing with <em>sensor noise</em>. In other words, our sensors are at least somewhat unreliable, and every state in our original estimate might result in a <em>range</em> of sensor readings.</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/gauss_14.jpg" width="30%"></p><p>From each reading we observe, we might guess that our system was in a particular state. But because there is uncertainty, <strong>some states are more likely than others</strong> to have have produced the reading we saw:</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/gauss_11.jpg" width="30%"></p><p>We’ll call the <strong>covariance</strong> of this uncertainty (i.e. of the sensor noise) $\color{mediumaquamarine}{\mathbf{R}_k}$. The distribution has a <strong>mean</strong> equal to the reading we observed, which we’ll call $\color{yellowgreen}{\vec{\mathbf{z}_k}}$.</p><p>So now we have two Gaussian blobs: One surrounding the mean of our transformed prediction, and one surrounding the actual sensor reading we got.</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/gauss_4.jpg" width="30%"></p><p>We must try to reconcile our guess about the readings we’d see based on the <strong>predicted state</strong> (<strong>pink</strong>) with a <em>different</em> guess based on our <strong>sensor readings</strong> (<strong>green</strong>) that we actually observed.</p><p>So what’s our new most likely state? For any possible reading $(z_1,z_2)$, we have two associated probabilities: (1) The probability that our sensor reading $\color{yellowgreen}{\vec{\mathbf{z}_k}}$ is a (mis-)measurement of $(z_1,z_2)$, and (2) the probability that our previous estimate thinks $(z_1,z_2)$ is the reading we should see.</p><p>If we have two probabilities and we want to know the chance that <em>both</em> are true, we just multiply them together. So, we take the two Gaussian blobs and multiply them:</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/gauss_6a.png" width="30%"></p><p>What we’re left with is the <strong>overlap</strong>, the region where <em>both</em> blobs are bright/likely. And it’s a lot more precise than either of our previous estimates. The mean of this distribution is the configuration for which <strong>both estimates are most likely</strong>, and is therefore the <strong>best guess</strong>of the true configuration given all the information we have.</p><p>Hmm. This looks like another Gaussian blob.</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/gauss_6.png" width="30%"></p><p>As it turns out, when you multiply two Gaussian blobs with separate means and covariance matrices, you get a <em>new</em> Gaussian blob with its <strong>own</strong> mean and covariance matrix! Maybe you can see where this is going: There’s got to be a formula to get those new parameters from the old ones!</p><h2 id="Combining-Gaussians"><a href="#Combining-Gaussians" class="headerlink" title="Combining Gaussians"></a>Combining Gaussians</h2><p>Let’s find that formula. It’s easiest to look at this first in <strong>one dimension</strong>. A 1D Gaussian bell curve with variance $\sigma^2$ and mean (\mu) is defined as: </p><script type="math/tex; mode=display">\begin{equation} \label{gaussformula}\mathcal{N}(x, \mu,\sigma) = \frac{1}{ \sigma \sqrt{ 2\pi } } e^{ -\frac{ (x – \mu)^2 }{ 2\sigma^2 } }\end{equation}</script><p>We want to know what happens when you multiply two Gaussian curves together. The blue curve below represents the (unnormalized) intersection of the two Gaussian populations:</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/gauss_joint.png" width="30%"></p><script type="math/tex; mode=display">\begin{equation} \label{gaussequiv}\mathcal{N}(x, \color{fuchsia}{\mu_0}, \color{deeppink}{\sigma_0}) \cdot \mathcal{N}(x, \color{yellowgreen}{\mu_1}, \color{mediumaquamarine}{\sigma_1}) \stackrel{?}{=} \mathcal{N}(x, \color{royalblue}{\mu’}, \color{mediumblue}{\sigma’})\end{equation}</script><p>You can substitute equation $\eqref{gaussformula}$ into equation $\eqref{gaussequiv}$ and do some algebra (being careful to renormalize, so that the total probability is 1) to obtain: </p><script type="math/tex; mode=display">\begin{equation} \label{fusionformula}\begin{aligned}\color{royalblue}{\mu’} &= \mu_0 + \frac{\sigma_0^2 (\mu_1 – \mu_0)} {\sigma_0^2 + \sigma_1^2}\\\color{mediumblue}{\sigma’}^2 &= \sigma_0^2 – \frac{\sigma_0^4} {\sigma_0^2 + \sigma_1^2}\end{aligned}\end{equation}</script><p>We can simplify by factoring out a little piece and calling it $\color{purple}{\mathbf{k}}$: </p><script type="math/tex; mode=display">\begin{equation} \label{gainformula}\color{purple}{\mathbf{k}} = \frac{\sigma_0^2}{\sigma_0^2 + \sigma_1^2}\end{equation}</script><script type="math/tex; mode=display">\begin{equation}\begin{split}\color{royalblue}{\mu’} &= \mu_0 + &\color{purple}{\mathbf{k}} (\mu_1 – \mu_0)\\\color{mediumblue}{\sigma’}^2 &= \sigma_0^2 – &\color{purple}{\mathbf{k}} \sigma_0^2\end{split} \label{update}\end{equation}</script><p>Take note of how you can take your previous estimate and <strong>add something</strong> to make a new estimate. And look at how simple that formula is!</p><p>But what about a matrix version? Well, let’s just re-write equations $\eqref{gainformula}$ and $\eqref{update}$ in matrix form. If $\Sigma$ is the covariance matrix of a Gaussian blob, and $\vec{\mu}$ its mean along each axis, then: </p><script type="math/tex; mode=display">\begin{equation} \label{matrixgain}\color{purple}{\mathbf{K}} = \Sigma_0 (\Sigma_0 + \Sigma_1)^{-1}\end{equation}</script><script type="math/tex; mode=display">\begin{equation}\begin{split}\color{royalblue}{\vec{\mu}’} &= \vec{\mu_0} + &\color{purple}{\mathbf{K}} (\vec{\mu_1} – \vec{\mu_0})\\\color{mediumblue}{\Sigma’} &= \Sigma_0 – &\color{purple}{\mathbf{K}} \Sigma_0\end{split} \label{matrixupdate}\end{equation}</script><p>$\color{purple}{\mathbf{K}}$ is a matrix called the <strong>Kalman gain</strong>, and we’ll use it in just a moment.</p><p>Easy! We’re almost finished!</p><h2 id="Putting-it-all-together"><a href="#Putting-it-all-together" class="headerlink" title="Putting it all together"></a>Putting it all together</h2><p>We have two distributions: The predicted measurement with $(\color{fuchsia}{\mu_0}, \color{deeppink}{\Sigma_0}) = (\color{fuchsia}{\mathbf{H}_k \mathbf{\hat{x}}_k}, \color{deeppink}{\mathbf{H}_k \mathbf{P}_k \mathbf{H}_k^T}) $, and the observed measurement with $(\color{yellowgreen}{\mu_1}, \color{mediumaquamarine}{\Sigma_1}) = (\color{yellowgreen}{\vec{\mathbf{z}_k}}, \color{mediumaquamarine}{\mathbf{R}_k})$. We can just plug these into equation $\eqref{matrixupdate}$ to find their overlap:</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}\mathbf{H}_k \color{royalblue}{\mathbf{\hat{x}}_k’} &= \color{fuchsia}{\mathbf{H}_k \mathbf{\hat{x}}_k} & + & \color{purple}{\mathbf{K}} ( \color{yellowgreen}{\vec{\mathbf{z}_k}} – \color{fuchsia}{\mathbf{H}_k \mathbf{\hat{x}}_k} ) \\\mathbf{H}_k \color{royalblue}{\mathbf{P}_k’} \mathbf{H}_k^T &= \color{deeppink}{\mathbf{H}_k \mathbf{P}_k \mathbf{H}_k^T} & – & \color{purple}{\mathbf{K}} \color{deeppink}{\mathbf{H}_k \mathbf{P}_k \mathbf{H}_k^T}\end{aligned} \label {kalunsimplified}\end{equation}</script><p> And from $\eqref{matrixgain}$, the Kalman gain is:</p><script type="math/tex; mode=display">\begin{equation} \label{eq:kalgainunsimplified}\color{purple}{\mathbf{K}} = \color{deeppink}{\mathbf{H}_k \mathbf{P}_k \mathbf{H}_k^T} ( \color{deeppink}{\mathbf{H}_k \mathbf{P}_k \mathbf{H}_k^T} + \color{mediumaquamarine}{\mathbf{R}_k})^{-1}\end{equation}</script><p> We can knock an $\mathbf{H}_k$ off the front of every term in $\eqref{kalunsimplified}$ and $\eqref{eq:kalgainunsimplified}$ (note that one is hiding inside $\color{purple}{\mathbf{K}}$ ), and an $\mathbf{H}_k^T$ off the end of all terms in the equation for $\color{royalblue}{\mathbf{P}_k’}$. </p><script type="math/tex; mode=display">\begin{equation}\begin{split}\color{royalblue}{\mathbf{\hat{x}}_k’} &= \color{fuchsia}{\mathbf{\hat{x}}_k} & + & \color{purple}{\mathbf{K}’} ( \color{yellowgreen}{\vec{\mathbf{z}_k}} – \color{fuchsia}{\mathbf{H}_k \mathbf{\hat{x}}_k} ) \\\color{royalblue}{\mathbf{P}_k’} &= \color{deeppink}{\mathbf{P}_k} & – & \color{purple}{\mathbf{K}’} \color{deeppink}{\mathbf{H}_k \mathbf{P}_k}\end{split}\label{kalupdatefull}\end{equation}</script><script type="math/tex; mode=display">\begin{equation}\color{purple}{\mathbf{K}’} = \color{deeppink}{\mathbf{P}_k \mathbf{H}_k^T} ( \color{deeppink}{\mathbf{H}_k \mathbf{P}_k \mathbf{H}_k^T} + \color{mediumaquamarine}{\mathbf{R}_k})^{-1}\label{kalgainfull}\end{equation}</script><p> …giving us the complete equations for the <strong>update step.</strong></p><p>And that’s it! $\color{royalblue}{\mathbf{\hat{x}}_k’}$ is our new best estimate, and we can go on and feed it (along with  $\color{royalblue}{\mathbf{P}_k’} $ ) back into another round of <strong>predict</strong> or <strong>update</strong> as many times as we like.</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/kalflow.png" width="80%"></p><h2 id="Wrapping-up"><a href="#Wrapping-up" class="headerlink" title="Wrapping up"></a>Wrapping up</h2><p>Of all the math above, all you need to implement are equations $\eqref{kalpredictfull}, \eqref{kalupdatefull}$, and $\eqref{kalgainfull}$. (Or if you forget those, you could re-derive everything from equations $\eqref{covident}$ and $\eqref{matrixupdate}$.)</p><p>This will allow you to model any linear system accurately. For nonlinear systems, we use the <strong>extended Kalman filter</strong>, which works by simply linearizing the predictions and measurements about their mean. (I may do a second write-up on the EKF in the future).</p><p>If I’ve done my job well, hopefully someone else out there will realize how cool these things are and come up with an unexpected new place to put them into action.</p><p>Some credit and referral should be given to <a href="http://www.cl.cam.ac.uk/~rmf25/papers/Understanding the Basis of the Kalman Filter.pdf" target="_blank" rel="noopener">this fine document</a>, which uses a similar approach involving overlapping Gaussians. More in-depth derivations can be found there, for the curious.</p>]]></content>
      
      
      <categories>
          
          <category> 常见模型 </category>
          
          <category> 卡尔曼滤波 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 卡尔曼滤波 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-101-对称二叉树</title>
      <link href="/2019/08/28/leetcode-101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/08/28/leetcode-101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p><p>示例1：</p><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">    <span class="hljs-number">1</span><br>   / \<br>  <span class="hljs-number">2</span>   <span class="hljs-number">2</span><br> / \ / \<br><span class="hljs-number">3</span>  <span class="hljs-number">4</span> <span class="hljs-number">4</span>  <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>但是下面这个 <code>[1,2,2,null,3,null,3]</code>则不是镜像对称的:</p><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">  <span class="hljs-number">1</span><br> / \<br><span class="hljs-number">2</span>   <span class="hljs-number">2</span><br> \   \<br> <span class="hljs-number">3</span>    <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><a id="more"></a><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol><li><strong>递归</strong></li><li><strong>迭代</strong></li></ol><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>数组完成排序后，我们可以放置两个指针 $i$ 和 $j$，其中 $i$ 是慢指针，而 $j$ 是快指针。只要 $nums[i] = nums[j]$，我们就增加 $j$ 以跳过重复项。</p><p>当我们遇到 $nums[j] \neq nums[i]$ 时，跳过重复项的运行已经结束，因此我们必须把它（$nums[j]$）的值复制到 $nums[i + 1]$。然后递增 $i$，接着我们将再次重复相同的过程，直到 $j$ 到达数组的末尾为止。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.size()==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=i+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(j&lt;nums.size())&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]==nums[j])&#123;<br>                j++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                i++;<br>                nums[i]=nums[j];<br>                j++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：$O(n)$，假设数组的长度是 $n$，那么 $i$ 和 $j$ 分别最多遍历 $n$ 步。</li><li>空间复杂度：$O(1)$。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法与数据结构 </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 对称 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反向传播算法</title>
      <link href="/2019/08/26/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95/"/>
      <url>/2019/08/26/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>卷积神经网络是一种特殊的前馈神经网络，通常也是一种深度神经网络。</p><p>深度学习是在克服反向传播算法对深度神经网络的训练困难过程中逐步发展和建立起来的。而深度神经网络的基本学习训练方法是反向传播算法。</p><p>作为一种有监督学习的算法，反向传播算法在本质上是一种具有递归结构的梯度下降算法，往往需要给定足够多的训练样本，才能获得满意的效果。</p><p>下面先给出任意前馈神经网络的<strong>通用反向传播算法</strong>，再讨论深层神经网络的<strong>逐层反向传播算法</strong>。</p><a id="more"></a><h2 id="通用反向传播算法"><a href="#通用反向传播算法" class="headerlink" title="通用反向传播算法"></a>通用反向传播算法</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>设前馈神经网络共有$N$个节点$\{u_1,u_2,…,u_N\}$，只有从编号较小的神经元才能连接到编号较大的神经元，没有反馈连接。</p><p>下图给出了前馈神经网络的一种可能的连接结构，共包含10个节点，其中两个为输入。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%89%8D%E9%A6%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" width="50%"></p><p>一般地，用$x_{n,l}$表示第$n$个节点对第$l$个输入样本的输出，其中$1\le{n}\le{N}$且$1\le{l}\le{L}$。</p><p>如果$u_n$是输入节点，那么它对第$l$个输入样本的输入为$net_{n,l}=x_{n,l}$；否则，$u_n$是隐含节点或输出节点，相应的输入为$net_{n,l}=\sum_{k}w_{k\to{n}}x_{k,l}$，输出为$x_{n,l}=f_n(net_{n,l})$。</p><p>其中，$w_{k\to{n}}(k&lt;n)$表示从第$k$个节点到第$n$个节点的有向连接$k\to{n}$的权值，$f_n$表示第$n$个节点的激活函数，比如sigmoid函数。</p><p>此外，若令$x_{0,l}=1$，则可用$w_{0\to{n}}$表示非输入节点$u_n$的偏置值。</p><p>最后，用OUT表示所有输出神经元的集合，且对任意$n\in{OUT}$，用$y_{n,l}$表示$x_{n,l}$的期望值，用$e_{n,l}$表示编号为$n$的输出神经元对第$l$个输入样本产生的输出误差。</p><p>因此，关于样本$l$的输出误差可以表示为：</p><script type="math/tex; mode=display">E_l=\sum\limits_{n\in{OUT}}e_{n,l}</script><p>总的输出误差为：</p><script type="math/tex; mode=display">E=\sum\limits^L_{l=1}E_l=\sum\limits^L_{l=1}\sum\limits_{n\in{OUT}}e_{n,l}</script><p>如果定义第$n$个神经网络关于第$l$个样本的反传误差信号（backpropagated error signal）或灵敏度（sensitivity）如下：</p><script type="math/tex; mode=display">\delta_{n,l}=\frac{\partial{E}}{\partial{net_{n,l}}}=\frac{\partial{E_l}}{\partial{net_{n,l}}}</script><p> 那么用链式法则可以得到：</p><script type="math/tex; mode=display">\forall{n}\in{OUT}，\frac{\partial{E}}{\partial{w_{k\to{n}}}}=\sum\limits^{L}_{l=1}\frac{\partial{E_l}}{\partial{net_{n,l}}}\frac{\partial{net_{n,l}}}{\partial{w_{k\to{n}}}}=\sum\limits^{L}_{l=1}\frac{\partial{E_l}}{\partial{x_{n,l}}}f'_{n}(net_{n,l})\frac{\partial{net_{n,l}}}{\partial{w_{k\to{n}}}}\\=\sum\limits^{L}_{l=1}\delta_{n,l}\frac{\partial{net_{n,l}}}{\partial{w_{k\to{n}}}}=\sum\limits^{L}_{n=1}\delta_{n,l}x_{k,l}</script><script type="math/tex; mode=display">\forall{k}\notin{OUT}，\frac{\partial{E}}{\partial{w_{j\to{k}}}}=\sum\limits^{L}_{l=1}\frac{\partial{E_l}}{\partial{net_{k,l}}}\frac{\partial{net_{k,l}}}{\partial{w_{j\to{k}}}}=\sum\limits^{L}_{l=1}(\sum\limits_{k\to{n}}\frac{\partial{E_l}}{\partial{net_{n,l}}}\frac{\partial{net_{n,l}}}{\partial{net_{k,l}}})\frac{\partial{net_{k,l}}}{\partial{w_{j\to{k}}}}\\=\sum\limits^{L}_{l=1}(\sum\limits_{k\to{n}}w_{k\to{n}}\delta_{n,l})f'_{k}(net_{k,l})\frac{\partial{net_{k,l}}}{\partial{w_{j\to{k}}}}=\sum\limits^{L}_{l=1}\delta_{k,l}\frac{\partial{net_{k,l}}}{\partial{w_{j\to{k}}}}=\sum\limits^{L}_{n=1}\delta_{k,l}x_{j,l}</script><p>如果对输出节点选择平方误差$e_{n,l}=\frac{1}{2}(x_{n,l}-y_{n,l})^2$，那么</p><script type="math/tex; mode=display">\forall{n}\in{OUT}，\delta_{n,l}=\frac{\partial{e_{n,l}}}{\partial{net_{n,l}}}=(x_{n,l}-y_{n,l})f'_{n}(net_{n,l})</script><script type="math/tex; mode=display">\forall{n}\notin{OUT}，\delta_{k,l}=(\sum\limits_{k\to{n}}w_{k\to{n}}\delta_{n,l})f'_{k}(net_{k,l})</script><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><strong>输入：</strong>训练集$\{(\pmb{x}^l,\pmb{y}^l), 1\le{l}\le{L}\}$，学习率$\eta$，前馈网络结构，迭代次数epoch</p><p><strong>输出：</strong>所有前馈连接权值$w_{k\to{n}}$</p><ol><li><p>选择学习率$\eta&gt;0$，迭代次数epoch，随机初始化$w_{k\to{n}}$</p></li><li><p><strong>for</strong> $i = 1$ to epoch <strong>do</strong></p></li><li>$\quad$<strong>for</strong> $l = 1$ to $L$ <strong>do</strong></li><li>$\qquad$如果$n$是输出节点，则计算其反传误差信号$\delta_{n,l}=(x_{n,l}-y_{n,l})f’_{n}(net_{n,l})$</li><li>$\qquad$否则递归计算其反传误差信号$\delta_{n,l}=\Big (\sum\limits_{k\to{n}}w_{k\to{n}}\delta_{n,l}\Big)f’_{k}(net_{k,l})$</li><li>$\quad$<strong>end for</strong></li><li><p>$\quad$计算关于连接权的偏导$\Delta{w_{k\to{n}}}=\frac{\partial{E}}{\partial{w_{k\to{n}}}}=\sum\limits^{L}_{l=1}\delta_{n,l}x_{k,l}$</p></li><li><p>$\quad$如果所有这些偏导产生的总梯度足够小，则停止</p></li><li>$\quad$否则，更新连接权值$w_{k\to{n}}=w_{k\to{n}}-\eta\Delta{w_{k\to{n}}}$</li><li><strong>end for</strong></li></ol><p><strong>注意：</strong>epoch表示迭代次数，在实际应用中可能需要几十次、几百次，甚至成千上万次迭代，才能获得令人满意的学习训练效果。</p><h2 id="逐层反向传播算法"><a href="#逐层反向传播算法" class="headerlink" title="逐层反向传播算法"></a>逐层反向传播算法</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>对于多层感知器来说，可以设计出更加简洁实用的<strong>逐层反向传播算法</strong>。</p><p>多层感知器由一个输出层、若干隐含层和一个输出层组成，如下图所示：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E5%99%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png" width="50%"></p><p>设输入层的维数为$m$，输入向量表示为$x=(x_1,x_2,…,x_m)^T\in{\pmb{R}}$。第$k$个隐含层包含$n_k$个神经元$(k=1,2,…,R)$，相应的隐含层向量表示为$\pmb{h}_k=(h_{k,1},h_{k,2},…,h_{k,n_k})^T\in{\pmb{R}}^{n_k}$。输出层包含$c$个神经元，输出向量表示为$\pmb{o}=(o_1,o_2,…,o_c)^T\in{\pmb{R}^c}$。输入层与第$1$个隐含层之间的权值矩阵用$\pmb{W}^1=(w^1_{ij})_{n_1\times{m}}$表示，第$k-1$个隐含层与第$k$个隐含层之间的权值矩阵用$\pmb{W}^k=(w^k_{ij})_{n_k\times n_{k-1}}(1&lt;k\le R)$表示，第$R$个隐含层与输出层之间的权值矩阵用$\pmb{W}^{R+1}=(w^{R+1}_{ij})_{c\times{n_R}}$表示。那么，这个多层感知器的各层神经元激活输出可以计算如下：</p><script type="math/tex; mode=display">\begin{cases} \pmb{h}_1=\sigma_{\pmb{h}_1}(\pmb{W}^1\pmb{x}+\pmb{b}^1) \\ \pmb{h}_k=\sigma_{\pmb{h}_k}(\pmb{W}^k\pmb{h}_{k-1}+\pmb{b}^k),2\le{k}\le{R} \\ \pmb{o}=\sigma_{\pmb{o}}(\pmb{W}^{R+1}\pmb{h}_{R}+\pmb{b}^{R+1}) \end{cases}</script><p>其中，$\pmb{b}^1$、$\pmb{b}^k$和$\pmb{b}^{R+1}$是各层的偏置，$\sigma_{\pmb{h}_1}$、$\sigma_{\pmb{h}_k}$和$\sigma_{\pmb{o}}$是各层的逐元向量函数，一般都取为逐元sigmoid函数。</p><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p><strong>输入：</strong>训练集$\{(\pmb{x}^l,\pmb{y}^l), 1\le{l}\le{L}\}$，学习率$\eta$，分层网络结构，隐含层数$\pmb{R}$、迭代次数epoch</p><p><strong>输出：</strong>所有权值和偏置$(\pmb{W}^k,\pmb{b}^k)(1\le{k}\le{R})$</p><ol><li>随机初始化$\pmb{W}^k\approx{0}$，$\pmb{b}^k\approx0$，$k=1$，…，$R$</li><li>令$\pmb{h}_0^l=\pmb{x}^l$</li><li><strong>for</strong> $i = 1$ to epoch <strong>do</strong></li><li>$\quad$<strong>for</strong> $l = 1$ to $L$ <strong>do</strong></li><li>$\qquad$计算$\pmb{u}_k^l=\pmb{W}^k\pmb{h}_{k-1}^l+\pmb{b}^k$，$\pmb{h}^l_k=\sigma(\pmb{u}^l_k)$，$1\le{k}\le{R+1}$</li><li>$\qquad$计算$\pmb{\delta}_{R+1}^l=(\pmb{o}^l-\pmb{y}^l)$，$\sigma’{\pmb{u}_{R+1}^l}$</li><li>$\qquad$计算$\delta_k^l=[(\pmb{W}^{k+1})^T\delta^l_{k+1}]$，$\sigma’{\pmb{u}_{k}^l}$，$1\le{k}\le{R}$</li><li>$\quad$<strong>end for</strong></li><li>$\quad$计算$\frac{\partial{E}}{\partial{\pmb{W}^k}}=\sum\limits^{L}_{l=1}\pmb{\delta}^l_k(\pmb{h}^l_{k-1})^T$，$\frac{\partial{E}}{\partial{\pmb{b}^k}}=\sum\limits^{L}_{l=1}\pmb{\delta}^l_k$，$1\le{k}\le {R+1}$</li><li>$\quad$如果所有这些偏导产生的总梯度足够小，则停止</li><li>$\quad$否则，更新权值和偏置：$\pmb{W}^k\gets\pmb{W}^k-\eta\frac{\partial \pmb{L}_N}{\partial\pmb{W}^k}$，$\pmb{b}^k\gets\pmb{b}^k-\eta\frac{\partial \pmb{L}_N}{\partial \pmb{b}^k}$，$1\le k\le R+1$</li><li><strong>end for</strong></li></ol><p><strong>注意：</strong>epoch表示迭代次数，在实际应用中可能需要几十次、几百次，甚至成千上万次迭代，才能获得令人满意的学习训练效果。</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>为了对多层感知器中的权值和偏置进行学习，需要给定一组训练样本。</p><p>假定共有$L$个训练样本$(\pmb{x}^l,\pmb{y}^l)(1\le l\le L)$，输入是$\pmb{x}^l=(\pmb{x}^l_1,\pmb{x}^l_2,…,\pmb{x}^l_m)^T$，期望输出是$\pmb{y}^l=(y^l_1,y^l_2,…,y^l_c)^T$，实际输出是$\pmb{o}^l=(o^l_1,o^l_2,…,o^l_c)^T$。</p><p>优化函数选取平方误差：</p><script type="math/tex; mode=display">E=\frac{1}{2}\sum\limits^L_{l=1}\|\pmb{o}^l-\pmb{y}^l \|^2=\frac{1}{2}\sum\limits^L_{l=1}\sum\limits^c_{j=1}(o^l-y^l )^2</script><p>令$\pmb{h}^l_0=\pmb{x}^l$，$\pmb{u}_k^l=\pmb{W}^k\pmb{h}^l_{k-1}+\pmb{b}^k$，$\pmb{h}^l_k=\sigma(\pmb{u}^l_k)(1\le k \le R+1)$，$\pmb{o}^l=\pmb{h}^l_{R+1}=\sigma(\pmb{u}^l_{R+1})$</p><p>如果定义网络各层关于第$l$个样本的反传误差信号或灵敏度为：$\pmb{\delta}_k^l=\frac{\partial \pmb{E}}{\partial \pmb{u}^l_k}$</p><p>那么这些反传误差信号可以递归计算如下：</p><script type="math/tex; mode=display">\pmb{\delta}^l_{R+1}=\frac{\partial \pmb{E}}{\partial\pmb{u}^l_{R+1}}=\frac{\partial \pmb{E}}{\partial\pmb{o}^l}\frac{\partial\pmb{o}^l}{\partial\pmb{u}^l_{R+1}}=(\pmb{o}^l-\pmb{y}^l)\circ\sigma'(\pmb{u}^l_{R+1})=(\pmb{o}^l-\pmb{y}^l)\circ\pmb{o}^l\circ(1-\pmb{o}^l)</script><script type="math/tex; mode=display">\delta_k^l=\frac{\partial \pmb E}{\partial \pmb u^l_k}=\frac{\partial \pmb E}{\partial \pmb{u}^l_{k+1}}\frac{\partial \pmb{u}^l_{k+1}}{\partial \pmb u^l_k}=[(\pmb{W}^{k+1})^T\delta^l_{k+1}]\circ\sigma'(\pmb{u}^l_k),1\le k \le R</script><p>如果采用<strong>受限玻尔兹曼</strong>对多层感知器的权值和偏置进行预训练代理随机初始化，还可以进一步提高逐层反向传播算法的学习训练效果。</p><p>此外，学习训练过程优化的目标函数不一定是平方误差，还可以是其他函数，比如交叉熵：</p><script type="math/tex; mode=display">E=-\sum\limits^L_{l=1}\sum\limits^c_{j=1}(y^l_j\times log(o^l_j)+(1-y^l_j)\times log(1-o^l_j))</script><p>这时，相应的逐层反向传播算法只需把$\pmb{\delta}^l_{R+1}$的计算公式修改为：</p><script type="math/tex; mode=display">\pmb{\delta}^l_{R+1}=\pmb{o}^l-\pmb{y}^l</script><p>多层感知器在训练完之后，常常再被用softmax函数转换成伪概率输出。</p><p>虽然很多文献和代码都把这种softmax函数转换称为软最大输出，但从理论上严格地说，软最大输出应该是把输出层的计算定义为：</p><script type="math/tex; mode=display">\pmb{o}=softmax(\pmb{W}^{R+1}\pmb{h}_R+\pmb{b}^{R+1})</script><p>如果保持其他部分不变，但采用式$(14)$计算网络的输出，那么在采用平方误差$(9)$作为目标函数时，$\pmb{\delta}^l_{R+1}$的计算公式应改为：</p><script type="math/tex; mode=display">\pmb{\delta}^l_{R+1}=\frac{\partial \pmb{E}}{\partial\pmb{u}^l_{R+1}}=\frac{\partial \pmb{E}}{\partial\pmb{o}^l}\frac{\partial\pmb{o}^l}{\partial\pmb{u}^l_{R+1}}=[diag(\pmb{o}^l)-\pmb{o}^l(\pmb{o}^l)^T](\pmb{o}^l-\pmb{y}^l)</script><p>而在采用交叉熵作为目标函数时，$\pmb{\delta}^l_{R+1}$的计算公式应改为：</p><script type="math/tex; mode=display">\pmb{\delta}^l_{R+1}=\left(\begin{array}{cccc}     1 &  \frac{o^l_1}{o^l_2-1} & ... & \frac{o^l_1}{o^l_c-1} \\     \frac{o^l_2}{o^l_1-1} & 1  & ... & \frac{o^l_2}{o^l_c-1}\\     ... & ... & ... &...\\      \frac{o^l_c}{o^l_1-1} & \frac{o^l_c}{o^l_2-1} & ...& 1\end{array}\right)(\pmb{o}^l-\pmb{y}^l)\\=(diag(\pmb{1}./(\pmb{1}-\pmb{o}^l))-(\pmb{o}^l)^T(\pmb{1}./(\pmb{1}-\pmb{o}^l)))(\pmb{o}^l-\pmb{y}^l)</script><p>其中，$<code>\pmb{1}&quot;$表示一个分量全是1的向量，$</code>./“$表示向量的对应分量相除。</p><p>如果每个样本的期望输出$\pmb{y}^l$仅有一个分量，为$\pmb{y}^l_{jl}=1$，那么还可以选用退化交叉熵作为目标函数，即：</p><script type="math/tex; mode=display">E=-\sum\limits^{L}_{l=1}log(\pmb{o}^l_{jl})</script><p>同时，$\pmb{\delta}^l_{R+1}$的计算公式修正为：</p><script type="math/tex; mode=display">\pmb{\delta}^l_{R+1}=\pmb{o}^l-\pmb{y}^l</script>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
          <category> 深度学习 </category>
          
          <category> 预备知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反向传播 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>梯度下降算法</title>
      <link href="/2019/08/25/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E7%AE%97%E6%B3%95/"/>
      <url>/2019/08/25/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>梯度下降算法，又称为最速下降算法，是在无约束条件下计算连续可微函数极小值的基本方法。</p><p>这种方法的核心思想是用负梯度方向作为下降方向，在1874年由法国科学家Cauchy提出。</p><a id="more"></a><h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>设$f(\pmb{x})$在$\pmb{x_k}$附近连续可微，令$\pmb{x}=\pmb{x}_k+\alpha{\pmb{d}}$，其中$\pmb{d}$为单位方向( $|\pmb{d}|=1$ )。</p><p>如果$\pmb{g}_k=\bigtriangledown{f(\pmb{x}_k)}\ne0$，则由Taylor展开式得：</p><script type="math/tex; mode=display">f(\pmb{x})=f(\pmb{x}_k)+(\bigtriangledown{f(\pmb{x}_k)})^{T}(\pmb{x}-\pmb{x}_k)+o(\|\pmb{x}-\pmb{x}_k\|)</script><p>或改写为：</p><script type="math/tex; mode=display">f(\pmb{x}_k+\alpha{\pmb{d}})=f(\pmb{x}_k)+\alpha{\pmb{g}_k}^T\pmb{d}+o(\alpha),\alpha>0</script><p>设$\theta$为$d$与$-g_k$之间的夹角，则有：</p><script type="math/tex; mode=display">\pmb{g}_k^T\pmb{d}=-\pmb{g}_k\cos{\theta}</script><p>不难看出，当$\theta=0$时，$\cos{\theta}=1$，$\pmb{g}_k^T\pmb{d}$取最小值，从而$f(\pmb{x})$下降最快，此时$\pmb{d}=-\pmb{g}_k$。</p><p>因此，负梯度方向$-\pmb{g}_k$就是函数$f(\pmb{x})$在$\pmb{x}_k$附近下降最快的方向。</p><p>梯度下降算法一般都是线性收敛的，速度通常较慢。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p><strong>输入：</strong>$f(\pmb{x})$的表达式</p><p><strong>输出：</strong>极小值点$\pmb{x}^*$</p><ol><li>选初始点$\pmb{x}_0$，收敛误差$\epsilon&gt;0$，迭代次数为$N$，令$k=0$</li><li>若$|\pmb{g}_k|\le{\epsilon}$，则$\pmb{x}^*=\pmb{x}_k$，停止迭代；否则计算$\pmb{d}_k=-\pmb{g}_k$</li><li>选择和计算步长因子$\alpha_k$</li><li>计算$\pmb{x}_{k+1}=\pmb{x}_k+\alpha_k\pmb{d}_k$</li><li>令$k=k+1$，若$k\ge{N}$，则$\pmb{x}^*=\pmb{x}_k$，停止迭代；否则转步到2</li></ol><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>如果$f(\pmb{x})=\frac{1}{2}\pmb{x}^T\pmb{Gx}$，其中$\pmb{G}$是$n\times{n}$对称正定矩阵，最大和最小特征值分别是$\lambda_1$和$\lambda_n$，那么梯度下降算法的收敛速度至少是线性的，且产生的点列${\pmb{x}_k}$对所有k满足</p><script type="math/tex; mode=display">\frac{f(\pmb{x}_{k+1})-f(\pmb{x}^*)}{f(\pmb{x}_{k})-f(\pmb{x}^*)}\le\frac{(\lambda_1-\lambda_n)^2}{(\lambda_1+\lambda_n)^2}</script><script type="math/tex; mode=display">\frac{\|\pmb{x}_{k+1}-\pmb{x}^*\|}{\|\pmb{x}_{k}-\pmb{x}^*\|}\le\sqrt{\frac{\lambda_n}{\lambda_1}}\frac{(\lambda_1-\lambda_n)^2}{(\lambda_1+\lambda_n)^2}</script><p>其中，$\pmb{x}^*$是问题的唯一极小值点。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
          <category> 深度学习 </category>
          
          <category> 预备知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 梯度下降 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>激活函数</title>
      <link href="/2019/08/24/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"/>
      <url>/2019/08/24/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>一些常见的激活函数</p><a id="more"></a><p><strong>恒等函数：</strong>$f(x)=x$</p><p><strong>sigmoid函数：</strong>$\sigma(x)=sigm(x)=\frac{1}{1+e^{-x}}$ ，<strong>导数：</strong> $\sigma’(x)=(sigm(x))’=\sigma(x)(1-\sigma(x))=-\frac{e^{-x}}{(1+e^{-x})^{2}}$</p><p><strong>双曲正切函数tanh：</strong>$\tanh(x)=\frac{e^x-x^{-x}}{e^x+e^{-x}}$ ，<strong>导数：</strong>$(\tanh(x))’=1-(\tanh(x))^{2}=\frac{(e^x+x^{-x})^2-(e^x-e^{-x})^2}{(e^x+e^{-x})^2}$</p><p><strong>硬限幅函数：</strong>$\begin{equation}<br>\text{hardlim}(x)=\left\{\begin{array}{lr}1,x\ge{0} \\ 0,x&lt;0\end{array}\right.<br>\end{equation}$</p><p><strong>斜面函数：</strong>$\begin{equation}<br>\text{ramp}(x)=\left\{\begin{array}{lr}1,x\ge{1} \\ x,-1&lt;x&lt;1 \\ -1,x\le{-1}\end{array}\right.<br>\end{equation}$</p><p><strong>修正线性单元ReLU：</strong>$\text{ReLU}(x)=max(0,x)$ ， <strong>导数：</strong>$\begin{equation}<br>(\text{ReLU}(x))’=\left\{\begin{array}{lr}1,x\ge{0} \\ 0,x&lt;0\end{array}\right.<br>\end{equation}$</p><p><strong>渗漏修正线性单元LReLU：</strong>$\begin{equation}<br>\text{LReLU}(x)=\left\{\begin{array}{lr}1,x\ge{0} \\ax,x&lt;0\end{array}\right.<br>\end{equation}$ ，其中，$a\in{(0,1)}$是一个固定值。</p><p>如果按照某个均匀分布取随机值，则称为RReLU ( Ramdomized LReLU )。</p><p><strong>参数修正线性单元PReLU：</strong>$\begin{equation}<br>\text{PReLU}(x)=\left\{\begin{array}{lr}1,x\ge{0} \\ax,x&lt;0\end{array}\right.<br>\end{equation}$ ，其中，$a\le{1}$是一个可调参数，具体值需要通过学习得到。</p><p><strong>指数线性单元ELU：</strong>$\begin{equation}<br>\text{ELU}(x)=\left\{\begin{array}{lr}1,x\ge{0} \\a(e^{x}-1),x&lt;0\end{array}\right.<br>\end{equation}$  ，其中，$a\ge{0}$ 是一个可调参数。</p><p><strong>软加函数softplus：</strong>$f(x)=\ln(1+e^{x})$</p><p><strong>最大输出函数maxout：</strong>$maxout(x)=max(x_{1},x_{2},…,x_{n})$</p><p><strong>软最大输出函数softmax：</strong>$softmax(x_{1},x_{2},…,x_{n})=\frac{e^{x_i}}{\sum{_{i=1}^{n}}e^{x_i}}$</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
          <category> 深度学习 </category>
          
          <category> 预备知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 激活函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-26-删除排序数组中的重复项</title>
      <link href="/2019/08/24/leetcode-26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
      <url>/2019/08/24/leetcode-26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><p>示例1：</p><blockquote><p>给定数组 nums = [1,1,2], </p><p>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </p><p>你不需要考虑数组中超出新长度后面的元素。</p></blockquote><p>示例2：</p><blockquote><p>给定 nums = [0,0,1,1,1,2,2,3,3,4],</p><p>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</p><p>你不需要考虑数组中超出新长度后面的元素。</p></blockquote><p>说明：</p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><blockquote><p>// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝<br>int len = removeDuplicates(nums);</p><p>// 在函数里修改输入数组对于调用者是可见的。<br>// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。<br>for (int i = 0; i &lt; len; i++) {<br>   print(nums[i]);<br>}</p></blockquote><a id="more"></a><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>双指针法</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>数组完成排序后，我们可以放置两个指针 $i$ 和 $j$，其中 $i$ 是慢指针，而 $j$ 是快指针。只要 $nums[i] = nums[j]$，我们就增加 $j$ 以跳过重复项。</p><p>当我们遇到 $nums[j] \neq nums[i]$ 时，跳过重复项的运行已经结束，因此我们必须把它（$nums[j]$）的值复制到 $nums[i + 1]$。然后递增 $i$，接着我们将再次重复相同的过程，直到 $j$ 到达数组的末尾为止。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.size()==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=i+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(j&lt;nums.size())&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]==nums[j])&#123;<br>                j++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                i++;<br>                nums[i]=nums[j];<br>                j++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：$O(n)$，假设数组的长度是 $n$，那么 $i$ 和 $j$ 分别最多遍历 $n$ 步。</li><li>空间复杂度：$O(1)$。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法与数据结构 </tag>
            
            <tag> 删除重复 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-7-整数反转</title>
      <link href="/2019/08/23/leetcode-7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
      <url>/2019/08/23/leetcode-7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<p>给出一个32位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p><p>示例1：</p><blockquote><p>输入：123</p><p>输出：321</p></blockquote><p>示例2：</p><blockquote><p>输入：-123</p><p>输出：-321</p></blockquote><p>示例3：</p><blockquote><p>输入：120</p><p>输出：21</p></blockquote><p>注意：</p><p>假设我们的环境只能存储得下32位的有符号整数，则其数值范围为$[-2^{31}, 2^{31}-1]$。请根据这个假设，如果反转后整数溢出那么就返回0</p><a id="more"></a><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>弹出和推入数字 &amp; 溢出前进行检查</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我们可以一次构建反转整数的一位数字。在这样做的时候，我们可以预先检查向原整数附加另一位数字是否会导致溢出。</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>反转整数的方法可以与反转字符串进行类比。</p><p>我们想重复“弹出” $x$ 的最后一位数字，并将它“推入”到 $\text{rev}$ 的后面。最后，$\text{rev}$ 将与 $x$ 相反。</p><p>要在没有辅助堆栈 / 数组的帮助下 “弹出” 和 “推入” 数字，我们可以使用数学方法。</p><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//pop operation:</span><br>pop = x % <span class="hljs-number">10</span>;<br>x /= <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">//push operation:</span><br>temp = rev * <span class="hljs-number">10</span> + pop;<br>rev = temp;<br></code></pre></td></tr></table></figure><p>但是，这种方法很危险，因为当 $\text{temp} = \text{rev} \cdot 10 + \text{pop}$ 时会导致溢出。</p><p>幸运的是，事先检查这个语句是否会导致溢出很容易。</p><p>为了便于解释，我们假设 $\text{rev}$ 是正数。</p><ol><li>如果 $temp = \text{rev} \cdot 10 + \text{pop}$ 导致溢出，那么一定有$ \text{rev} \geq \frac{INTMAX}{10}$ 。</li><li>如果 $\text{rev} &gt; \frac{INTMAX}{10}$ ，那么 $temp = \text{rev} \cdot 10 + \text{pop}$ 一定会溢出。</li><li>如果 $\text{rev} == \frac{INTMAX}{10}$ ，那么只要 $\text{pop} &gt; 7$ ，$temp = \text{rev} \cdot 10 + \text{pop}$ 就会溢出。</li></ol><p>当 $\text{rev}$ 为负时可以应用类似的逻辑。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> rev = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">do</span>&#123;<br>            <span class="hljs-keyword">int</span> pop = x % <span class="hljs-number">10</span>;<br>            x /= <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">if</span> (rev &gt; INT_MAX/<span class="hljs-number">10</span> || (rev == INT_MAX / <span class="hljs-number">10</span> &amp;&amp; pop &gt; <span class="hljs-number">7</span>)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (rev &lt; INT_MIN/<span class="hljs-number">10</span> || (rev == INT_MIN / <span class="hljs-number">10</span> &amp;&amp; pop &lt; <span class="hljs-number">-8</span>)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            rev = rev * <span class="hljs-number">10</span> + pop;<br>        &#125;<span class="hljs-keyword">while</span> (x) ;<br>        <span class="hljs-keyword">return</span> rev;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：$O(\log(x))$，$x$ 中大约有 $\log_{10}(x)$ 位数字。</li><li>空间复杂度：$O(1)$。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法与数据结构 </tag>
            
            <tag> 溢出边界 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程挑战任务：车道检测</title>
      <link href="/2019/08/16/Python-OpenCV%E6%95%99%E7%A8%8B%E6%8C%91%E6%88%98%E4%BB%BB%E5%8A%A1%EF%BC%9A%E8%BD%A6%E9%81%93%E6%A3%80%E6%B5%8B/"/>
      <url>/2019/08/16/Python-OpenCV%E6%95%99%E7%A8%8B%E6%8C%91%E6%88%98%E4%BB%BB%E5%8A%A1%EF%BC%9A%E8%BD%A6%E9%81%93%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<p>挑战任务：实际公路的车道线检测。</p><a id="more"></a><h2 id="挑战内容"><a href="#挑战内容" class="headerlink" title="挑战内容"></a>挑战内容</h2><ol><li>在所提供的公路图片上检测出车道线并标记</li></ol><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_lane_detection_result_sample.jpg"></p><ol><li>在所提供的公路视频上检测出车道线并标记</li></ol><p>本次挑战内容来自Udacity自动驾驶纳米学位课程，素材中车道保持不变，车道线清晰明确，易于检测，是车道检测的基础版本，网上也有很多针对复杂场景的高级实现，感兴趣的童鞋可以自行了解。</p><h2 id="挑战解答"><a href="#挑战解答" class="headerlink" title="挑战解答"></a>挑战解答</h2><h3 id="挑战方案"><a href="#挑战方案" class="headerlink" title="挑战方案"></a>挑战方案</h3><p>要检测出当前车道，就是要检测出左右两条车道直线。</p><p>由于无人车一直保持在当前车道，那么无人车上的相机拍摄的视频中，车道线的位置应该基本固定在某一个范围内：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_lane_detection_roi_sample.jpg"></p><p>如果我们手动把这部分ROI区域抠出来，就会排除掉大部分干扰。接下来检测直线肯定是用霍夫变换，但ROI区域内的边缘直线信息还是很多，考虑到只有左右两条车道线，一条斜率为正，一条为负，可将所有的线分为两组，每组再通过均值或最小二乘法拟合的方式确定唯一一条线就可以完成检测。</p><p>总体步骤如下：</p><ol><li>灰度化</li><li>高斯模糊</li><li>Canny边缘检测</li><li>不规则ROI区域截取</li><li>霍夫直线检测</li><li>车道计算</li></ol><p>对于视频来说，只要一幅图能检查出来，合成下就可以了，问题不大。</p><h3 id="图像预处理"><a href="#图像预处理" class="headerlink" title="图像预处理"></a>图像预处理</h3><p>灰度化和滤波操作是大部分图像处理的必要步骤。灰度化不必多说，因为不是基于色彩信息识别的任务，所以没有必要用彩色图，<strong>可以大大减少计算量</strong>。而滤波会削弱图像噪点，排除干扰信息。另外，根据前面学习的知识，边缘提取是基于图像梯度的，<strong>梯度对噪声很敏感，所以平滑滤波操作必不可少</strong>。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_lane_detection_gray_blur_result.jpg"></p><p>这次的代码我们分模块来写，规范一点。其中<code>process_an_image()</code>是主要的图像处理流程：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 高斯滤波核大小</span><br>blur_ksize = <span class="hljs-number">5</span><br><span class="hljs-comment"># Canny边缘检测高低阈值</span><br>canny_lth = <span class="hljs-number">50</span><br>canny_hth = <span class="hljs-number">150</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process_an_image</span><span class="hljs-params">(img)</span>:</span><br>    <span class="hljs-comment"># 1. 灰度化、滤波和Canny</span><br>    gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)<br>    blur_gray = cv2.GaussianBlur(gray, (blur_ksize, blur_ksize), <span class="hljs-number">1</span>)<br>    edges = cv2.Canny(blur_gray, canny_lth, canny_hth)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:<br>    img = cv2.imread(<span class="hljs-string">'test_pictures/lane.jpg'</span>)<br>    result = process_an_image(img)<br>    cv2.imshow(<span class="hljs-string">"lane"</span>, np.hstack((img, result)))<br>    cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_lane_detection_canny_result.jpg"></p><h3 id="ROI截取"><a href="#ROI截取" class="headerlink" title="ROI截取"></a>ROI截取</h3><p>按照前面描述的方案，只需保留边缘图中红线部分区域用于后续的霍夫直线检测，其余都是无用的信息：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_lane_detection_canny_roi_reserve.jpg"></p><p>如何实现呢？还记得图像混合中的这张图吗？</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_understand_mask.jpg"></p><p>我们可以创建一个梯形的mask掩膜，然后与边缘检测结果图混合运算，掩膜中白色的部分保留，黑色的部分舍弃。梯形的四个坐标需要手动标记：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_lane_detection_mask_sample.jpg"></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process_an_image</span><span class="hljs-params">(img)</span>:</span><br>    <span class="hljs-comment"># 1. 灰度化、滤波和Canny</span><br>gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)<br>    blur_gray = cv2.GaussianBlur(gray, (blur_ksize, blur_ksize), <span class="hljs-number">1</span>)<br>    edges = cv2.Canny(blur_gray, canny_lth, canny_hth)<br>    <span class="hljs-comment"># 2. 标记四个坐标点用于ROI截取</span><br>    rows, cols = edges.shape<br>    points = np.array([[(<span class="hljs-number">0</span>, rows), (<span class="hljs-number">460</span>, <span class="hljs-number">325</span>), (<span class="hljs-number">520</span>, <span class="hljs-number">325</span>), (cols, rows)]])<br>    <span class="hljs-comment"># [[[0 540], [460 325], [520 325], [960 540]]]</span><br>    roi_edges = roi_mask(edges, points)<br>    <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">roi_mask</span><span class="hljs-params">(img, corner_points)</span>:</span><br>    <span class="hljs-comment"># 创建掩膜</span><br>    mask = np.zeros_like(img)<br>    cv2.fillPoly(mask, corner_points, <span class="hljs-number">255</span>)<br><br>    masked_img = cv2.bitwise_and(img, mask)<br>    <span class="hljs-keyword">return</span> masked_img<br></code></pre></td></tr></table></figure><p>这样，结果图”roi_edges”应该是：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_lane_detection_masked_roi_edges.jpg"></p><h3 id="霍夫直线提取"><a href="#霍夫直线提取" class="headerlink" title="霍夫直线提取"></a>霍夫直线提取</h3><p>为了方便后续计算直线的斜率，我们使用统计概率霍夫直线变换（因为它能直接得到直线的起点和终点坐标）。霍夫变换的参数比较多，可以放在代码开头，便于修改：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 霍夫变换参数</span><br>rho = <span class="hljs-number">1</span><br>theta = np.pi / <span class="hljs-number">180</span><br>threshold = <span class="hljs-number">15</span><br>min_line_len = <span class="hljs-number">40</span><br>max_line_gap = <span class="hljs-number">20</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process_an_image</span><span class="hljs-params">(img)</span>:</span><br>    <span class="hljs-comment"># 1. 灰度化、滤波和Canny</span><br>gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)<br>    blur_gray = cv2.GaussianBlur(gray, (blur_ksize, blur_ksize), <span class="hljs-number">1</span>)<br>    edges = cv2.Canny(blur_gray, canny_lth, canny_hth)<br>    <br>    <span class="hljs-comment"># 2. 标记四个坐标点用于ROI截取</span><br>    rows, cols = edges.shape<br>    points = np.array([[(<span class="hljs-number">0</span>, rows), (<span class="hljs-number">460</span>, <span class="hljs-number">325</span>), (<span class="hljs-number">520</span>, <span class="hljs-number">325</span>), (cols, rows)]])<br>    <span class="hljs-comment"># [[[0 540], [460 325], [520 325], [960 540]]]</span><br>    roi_edges = roi_mask(edges, points)<br>    <br>    <span class="hljs-comment"># 3. 霍夫直线提取</span><br>    drawing, lines = hough_lines(roi_edges, rho, theta, threshold, min_line_len, max_line_gap)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hough_lines</span><span class="hljs-params">(img, rho, theta, threshold, min_line_len, max_line_gap)</span>:</span><br>    <span class="hljs-comment"># 统计概率霍夫直线变换</span><br>    lines = cv2.HoughLinesP(img, rho, theta, threshold, minLineLength=min_line_len, maxLineGap=max_line_gap)<br><br>    <span class="hljs-comment"># 新建一副空白画布</span><br>    drawing = np.zeros((img.shape[<span class="hljs-number">0</span>], img.shape[<span class="hljs-number">1</span>], <span class="hljs-number">3</span>), dtype=np.uint8)<br>    <span class="hljs-comment"># draw_lines(drawing, lines)     # 画出直线检测结果</span><br><br>    <span class="hljs-keyword">return</span> drawing, lines<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draw_lines</span><span class="hljs-params">(img, lines, color=[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>], thickness=<span class="hljs-number">1</span>)</span>:</span><br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines:<br>        <span class="hljs-keyword">for</span> x1, y1, x2, y2 <span class="hljs-keyword">in</span> line:<br>            cv2.line(img, (x1, y1), (x2, y2), color, thickness)<br></code></pre></td></tr></table></figure><p><code>draw_lines()</code>是用来画直线检测的结果，后面我们会接着处理直线，所以这里注释掉了，可以取消注释看下效果：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_lane_detection_hough_lines_direct_result.jpg"></p><p>对本例的这张测试图来说，如果打印出直线的条数<code>print(len(lines))</code>，应该是有16条。</p><h3 id="车道计算"><a href="#车道计算" class="headerlink" title="车道计算"></a>车道计算</h3><p>这部分应该算是本次挑战任务的核心内容了：前面通过霍夫变换得到了多条直线的起点和终点，我们的目的是通过某种算法只得到左右两条车道线。</p><p><strong>第一步、根据斜率正负划分某条线是左车道还是右车道。</strong></p><script type="math/tex; mode=display">斜率=\frac{y_2-y_1}{x_2-x_1}(\le0:左，>0:右)</script><blockquote><p>经验之谈：再次强调，斜率计算是在图像坐标系下，所以斜率正负/左右跟平面坐标有区别。</p></blockquote><p><strong>第二步、迭代计算各直线斜率与斜率均值的差，排除掉差值过大的异常数据。</strong></p><p>注意这里迭代的含义，意思是第一次计算完斜率均值并排除掉异常值后，再在剩余的斜率中取均值，继续排除……这样迭代下去。</p><p><strong>第三步、最小二乘法拟合左右车道线。</strong></p><p>经过第二步的筛选，就只剩下可能的左右车道线了，这样只需从多条直线中拟合出一条就行。拟合方法有很多种，最常用的便是最小二乘法，它通过最小化误差的平方和来寻找数据的最佳匹配函数。</p><p>具体来说，假设目前可能的左车道线有6条，也就是12个坐标点，包括12个x和12个y，我们的目的是拟合出这样一条直线：</p><script type="math/tex; mode=display">f(x_i)=ax_i+b</script><p>使得误差平方和最小：</p><script type="math/tex; mode=display">E=\sum[f(x_i)-y_i]^2</script><p>Python中可以直接使用<code>np.polyfit()</code>进行最小二乘法拟合。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process_an_image</span><span class="hljs-params">(img)</span>:</span><br>    <span class="hljs-comment"># 1. 灰度化、滤波和Canny</span><br><br>    <span class="hljs-comment"># 2. 标记四个坐标点用于ROI截取</span><br><br>    <span class="hljs-comment"># 3. 霍夫直线提取</span><br><br>    <span class="hljs-comment"># 4. 车道拟合计算</span><br>    draw_lanes(drawing, lines)<br><br>    <span class="hljs-comment"># 5. 最终将结果合在原图上</span><br>    result = cv2.addWeighted(img, <span class="hljs-number">0.9</span>, drawing, <span class="hljs-number">0.2</span>, <span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">return</span> result<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draw_lanes</span><span class="hljs-params">(img, lines, color=[<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], thickness=<span class="hljs-number">8</span>)</span>:</span><br>    <span class="hljs-comment"># a. 划分左右车道</span><br>    left_lines, right_lines = [], []<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines:<br>        <span class="hljs-keyword">for</span> x1, y1, x2, y2 <span class="hljs-keyword">in</span> line:<br>            k = (y2 - y1) / (x2 - x1)<br>            <span class="hljs-keyword">if</span> k &lt; <span class="hljs-number">0</span>:<br>                left_lines.append(line)<br>            <span class="hljs-keyword">else</span>:<br>                right_lines.append(line)<br><br>    <span class="hljs-keyword">if</span> (len(left_lines) &lt;= <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> len(right_lines) &lt;= <span class="hljs-number">0</span>):<br>        <span class="hljs-keyword">return</span><br><br>    <span class="hljs-comment"># b. 清理异常数据</span><br>    clean_lines(left_lines, <span class="hljs-number">0.1</span>)<br>    clean_lines(right_lines, <span class="hljs-number">0.1</span>)<br><br>    <span class="hljs-comment"># c. 得到左右车道线点的集合，拟合直线</span><br>    left_points = [(x1, y1) <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> left_lines <span class="hljs-keyword">for</span> x1, y1, x2, y2 <span class="hljs-keyword">in</span> line]<br>    left_points = left_points + [(x2, y2) <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> left_lines <span class="hljs-keyword">for</span> x1, y1, x2, y2 <span class="hljs-keyword">in</span> line]<br>    right_points = [(x1, y1) <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> right_lines <span class="hljs-keyword">for</span> x1, y1, x2, y2 <span class="hljs-keyword">in</span> line]<br>    right_points = right_points + [(x2, y2) <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> right_lines <span class="hljs-keyword">for</span> x1, y1, x2, y2 <span class="hljs-keyword">in</span> line]<br><br>    left_results = least_squares_fit(left_points, <span class="hljs-number">325</span>, img.shape[<span class="hljs-number">0</span>])<br>    right_results = least_squares_fit(right_points, <span class="hljs-number">325</span>, img.shape[<span class="hljs-number">0</span>])<br><br>    <span class="hljs-comment"># 注意这里点的顺序</span><br>    vtxs = np.array([[left_results[<span class="hljs-number">1</span>], left_results[<span class="hljs-number">0</span>], right_results[<span class="hljs-number">0</span>], right_results[<span class="hljs-number">1</span>]]])<br>    <span class="hljs-comment"># d. 填充车道区域</span><br>    cv2.fillPoly(img, vtxs, (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>))<br><br>    <span class="hljs-comment"># 或者只画车道线</span><br>    <span class="hljs-comment"># cv2.line(img, left_results[0], left_results[1], (0, 255, 0), thickness)</span><br>    <span class="hljs-comment"># cv2.line(img, right_results[0], right_results[1], (0, 255, 0), thickness)</span><br>    <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">clean_lines</span><span class="hljs-params">(lines, threshold)</span>:</span><br>    <span class="hljs-comment"># 迭代计算斜率均值，排除掉与差值差异较大的数据</span><br>    slope = [(y2 - y1) / (x2 - x1) <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines <span class="hljs-keyword">for</span> x1, y1, x2, y2 <span class="hljs-keyword">in</span> line]<br>    <span class="hljs-keyword">while</span> len(lines) &gt; <span class="hljs-number">0</span>:<br>        mean = np.mean(slope)<br>        diff = [abs(s - mean) <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> slope]<br>        idx = np.argmax(diff)<br>        <span class="hljs-keyword">if</span> diff[idx] &gt; threshold:<br>            slope.pop(idx)<br>            lines.pop(idx)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">break</span><br>            <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">least_squares_fit</span><span class="hljs-params">(point_list, ymin, ymax)</span>:</span><br>    <span class="hljs-comment"># 最小二乘法拟合</span><br>    x = [p[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> point_list]<br>    y = [p[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> point_list]<br><br>    <span class="hljs-comment"># polyfit第三个参数为拟合多项式的阶数，所以1代表线性</span><br>    fit = np.polyfit(y, x, <span class="hljs-number">1</span>)<br>    fit_fn = np.poly1d(fit)  <span class="hljs-comment"># 获取拟合的结果</span><br><br>    xmin = int(fit_fn(ymin))<br>    xmax = int(fit_fn(ymax))<br><br>    <span class="hljs-keyword">return</span> [(xmin, ymin), (xmax, ymax)]<br></code></pre></td></tr></table></figure><p>这段代码比较多，请每个步骤单独来看。最后得到的是左右两条车道线的起点和终点坐标，可以选择画出车道线，这里我直接填充了整个区域：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_lane_detection_result_sample.jpg"></p><h3 id="视频处理"><a href="#视频处理" class="headerlink" title="视频处理"></a>视频处理</h3><p>搞定了一张图，视频也就没什么问题了，关键就是视频帧的提取和合成，为此，我们要用到Python的视频编辑包<a href="https://pypi.org/project/moviepy/#files" target="_blank" rel="noopener">moviepy</a>：</p><p>另外还需要ffmpeg，首次运行moviepy时会自动下载，也可<a href="https://github.com/imageio/imageio-binaries/tree/master/ffmpeg" target="_blank" rel="noopener">手动</a>下载。</p><p>只需在开头导入moviepy，然后将主函数改掉就可以了，其余代码不需要更改：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 开头导入moviepy</span><br><span class="hljs-keyword">from</span> moviepy.editor <span class="hljs-keyword">import</span> VideoFileClip<br><br><span class="hljs-comment"># 主函数更改为：</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:<br>    output = <span class="hljs-string">'test_videos/output.mp4'</span><br>    clip = VideoFileClip(<span class="hljs-string">"test_videos/cv2_white_lane.mp4"</span>)<br>    out_clip = clip.fl_image(process_an_image)<br>    out_clip.write_videofile(output, audio=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><p>本文实现了车道检测的基础版本，如果你感兴趣的话，可以自行搜索或参考引用部分了解更多。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="http://pic.ex2tron.top/cv2_lane_detection_material.zip" target="_blank" rel="noopener">图片和视频素材</a></li><li><a href="https://zhuanlan.zhihu.com/p/25354571" target="_blank" rel="noopener">从零开始学习无人驾驶技术 — 车道检测</a></li><li><a href="https://blog.csdn.net/u010665216/article/details/80152458" target="_blank" rel="noopener">无人驾驶之高级车道线检测</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 车道检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>目标检测背景</title>
      <link href="/2019/08/16/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E8%83%8C%E6%99%AF/"/>
      <url>/2019/08/16/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E8%83%8C%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<p><strong>图像分类，检测及分割是计算机视觉领域的三大任务。</strong></p><p>图像分类模型是将图像划分为单个类别，通常对应于图像中最突出的物体。但在现实世界的很多图片通常包含不只一个物体，此时如果使用图像分类模型为图像分配一个单一标签其实是非常粗糙的，并不准确。</p><p>对于这样的情况，就需要目标检测模型，目标检测模型可以识别一张图片的多个物体，并可以定位出不同物体（给出边界框）。</p><p>目标检测在很多场景有用，如无人驾驶和安防系统。</p><p>以下是图像分类，目标检测与实例分割的对比。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB%EF%BC%8C%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%88%86%E5%89%B2%E7%9A%84%E5%AF%B9%E6%AF%94.png"></p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>目前主流的目标检测算法主要是基于深度学习模型，其可以分成两大类：</p><ul><li><p>two-stage检测算法</p><p>  two-stage检测算法将检测问题划分为两个阶段，首先产生候选区域（region proposals），然后对候选区域分类（一般还需要对位置精修），这类算法的典型代表是基于region proposal的R-CNN系算法，如R-CNN、Fast R-CNN、Faster R-CNN等。</p></li><li><p>one-stage检测算法</p><p>  one-stage检测不需要region proposal阶段，直接产生物体的类别概率和位置坐标值，比较典型的算法如YOLO和SSD。</p></li></ul><p>目标检测模型的主要性能指标是检测<strong>准确度</strong>和<strong>速度</strong>。</p><p>一般情况下，two-stage算法在准确度上有优势，而one-stage算法在速度上有优势。</p><p>在这篇长文中，我们将对最新的目标检测算法做一个综述。在介绍目标检测算法之前，先简单介绍目标检测领域常用的数据集以及性能指标。</p><h2 id="数据集合性能指标"><a href="#数据集合性能指标" class="headerlink" title="数据集合性能指标"></a>数据集合性能指标</h2><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p>PASCAL VOC（<a href="http://host.robots.ox.ac.uk/pascal/VOC/" target="_blank" rel="noopener">The PASCAL Visual Object Classification</a>）是目标检测，分类，分割等领域。从2005到2012年，共举办了8个不同的挑战赛。PASCAL VOC包含约10,000张带有边界框的图片用于训练和验证。但是，PASCAL VOC数据集仅包含20个类别，因此其被看成目标检测问题的一个基准数据集。</p><p><a href="http://www.image-net.org/" target="_blank" rel="noopener">ImageNet</a>在2013年放出了包含边界框的目标检测数据集。训练数据集包含500,000张图片，属于200类物体。由于数据集太大，训练所需计算量很大，因而很少使用。同时，由于类别数也比较多，目标检测的难度也相当大。</p><p>MS COCO（<a href="http://cocodataset.org/#home" target="_blank" rel="noopener">Common Objects in COntext</a>）数据集。这个数据集用于多种竞赛：图像标题生成，目标检测，关键点检测和物体分割。对于目标检测任务，COCO共包含80个类别，每年大赛的训练和验证数据集包含超过120,000个图片，超过40,000个测试图片。测试集最近被划分为两类，一类是test-dev数据集用于研究者，一类是test-challenge数据集用于竞赛者。测试集的标签数据没有公开，以避免在测试集上过拟合。</p><h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><p>目标检测问题同时是一个回归和分类问题。</p><p>首先，为了评估定位精度，需要计算IoU（Intersection over Union，介于0到1之间），其表示预测框与真实框（ground-truth box）之间的重叠程度。IoU越高，预测框的位置越准确。因而，在评估预测框时，通常会设置一个IoU阈值（如0.5），只有当预测框与正式框的IoU值大于这个阈值的时候，该预测框才被认定为真阳性（True Positive，TP），反之就是假阳性（False Positive，FP）。</p><p>对于二分类，AP（Average Precision）是一个重要的指标，这是信息检索中的一个概念，基于precision-recall曲线计算出来，可以参考<a href="https://en.wikipedia.org/w/index.php?title=Information_retrieval&amp;oldid=793358396#Average_precision" target="_blank" rel="noopener">这里</a>。对于目标检测，首先要单独计算各个类别的AP值，这是评估检测效果的重要指标。取各个类别的AP的平均值，就得到一个综合指标mAP（Mean Average Precision），mAP指标可以避免某些类别比较极端化而弱化其他类别的性能这个问题。</p><p>对于目标检测，mAP一般在某个固定的IoU上计算，但是不同的IoU值会改变TP和FP的比例，从而造成mAP的差异。COCO数据集提供了<a href="https://github.com/cocodataset/cocoapi" target="_blank" rel="noopener">官方的评估指标</a>，它的AP是计算一系列IoU下（0.5 : 0.05 : 0.9, 见<a href="http://cocodataset.org/#detection-eval" target="_blank" rel="noopener">说明</a>）AP的平均值，这样可以消除IoU导致的AP波动。其实对于PASCAL VOC数据集也是这样，Facebook的Detectron上的有比较清晰的<a href="https://github.com/facebookresearch/Detectron/blob/05d04d3a024f0991339de45872d02f2f50669b3d/lib/datasets/voc_eval.py#L54" target="_blank" rel="noopener">实现</a>。</p><p>除了检测准确度，目标检测算法的另外一个重要性能指标是速度，只有速度快，才能实现实时检测，这对一些应用场景极其重要。评估速度的常用指标是每秒帧率（Frame Per Second，FPS），即每秒内可以处理的图片数量。当然要对比FPS，你需要在同一硬件上进行。另外也可以使用处理一张图片所需时间来评估检测速度，时间越短，速度越快。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> 目标检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 目标检测 </tag>
            
            <tag> 背景 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YOLO原理与实现</title>
      <link href="/2019/08/16/YOLO%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/08/16/YOLO%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍了YOLO算法</p><p>其全称是：You Only Look Once: Unified, Real-Time Object Detection</p><p>该名称基本上把Yolo算法的特点都概括全了：</p><ul><li>You Only Look Once：只需要一次CNN运算</li><li>Unified：一个统一的框架，提供end-to-end的预测</li><li>Real-Time：Yolo算法速度快</li></ul><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> 基本模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 基本模型 </tag>
            
            <tag> YOLO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程17：霍夫变换</title>
      <link href="/2019/08/15/Python-OpenCV%E6%95%99%E7%A8%8B17%EF%BC%9A%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2/"/>
      <url>/2019/08/15/Python-OpenCV%E6%95%99%E7%A8%8B17%EF%BC%9A%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>学习使用霍夫变换识别出图像中的直线和圆等几何形状。</p><p>目标：</p><ul><li>理解霍夫变换的实现</li><li>分别使用霍夫线变换和圆变换检测图像中的直线和圆</li><li>OpenCV函数：<ul><li><code>cv2.HoughLines()</code>：霍夫直线变换（整条直线）</li><li><code>cv2.HoughLinesP()</code>：统计概率霍夫直线变换</li><li><code>cv2.HoughCircles()</code>：霍夫圆变换</li></ul></li></ul><a id="more"></a><h2 id="霍夫变换"><a href="#霍夫变换" class="headerlink" title="霍夫变换"></a>霍夫变换</h2><p>霍夫变换常用来在图像中提取直线和圆等几何形状，我来做个简易的解释：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_understand_hough_transform.jpg"></p><p>学过几何的都知道，直线可以分别用直角坐标系和极坐标系来表示：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_line_expression_in_coordinate.jpg"></p><p>那么经过某个点(x0,y0)的所有直线都可以用这个式子来表示：</p><script type="math/tex; mode=display">r_\theta=x_0\cdot\cos{\theta}+y_0\cdot\sin{\theta}</script><p>也就是说每一个(r,θ)都表示一条经过(x0,y0)直线，那么同一条直线上的点必然会有同样的(r,θ)。如果将某个点所有的(r,θ)绘制成下面的曲线，那么同一条直线上的点的(r,θ)曲线会相交于一点：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_curve_of_r_theta.jpg"></p><p>OpenCV中首先计算(r,θ) 累加数，累加数超过一定值后就认为在同一直线上。</p><h2 id="霍夫直线变换"><a href="#霍夫直线变换" class="headerlink" title="霍夫直线变换"></a>霍夫直线变换</h2><p>OpenCV中用<code>cv2.HoughLines()</code>在二值图上实现霍夫变换，函数返回的是一组直线的(r,θ)数据：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 1.加载图片，转为二值图</span><br>img = cv2.imread(<span class="hljs-string">'shapes.jpg'</span>)<br>drawing = np.zeros(img.shape[:], dtype=np.uint8)<br>gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br>edges = cv2.Canny(gray, <span class="hljs-number">50</span>, <span class="hljs-number">150</span>)<br><br><span class="hljs-comment"># 2.霍夫直线变换</span><br>lines = cv2.HoughLines(edges, <span class="hljs-number">0.8</span>, np.pi / <span class="hljs-number">180</span>, <span class="hljs-number">90</span>)<br></code></pre></td></tr></table></figure><p>函数中：</p><ul><li>参数1：要检测的二值图（一般是阈值分割或边缘检测后的图）</li><li>参数2：距离r的精度，值越大，考虑越多的线</li><li>参数3：角度θ的精度，值越小，考虑越多的线</li><li>参数4：累加数阈值，值越小，考虑越多的线</li></ul><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 3.将检测的线画出来（注意是极坐标噢）</span><br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines:<br>    rho, theta = line[<span class="hljs-number">0</span>]<br>    a = np.cos(theta)<br>    b = np.sin(theta)<br>    x0 = a * rho<br>    y0 = b * rho<br>    x1 = int(x0 + <span class="hljs-number">1000</span> * (-b))<br>    y1 = int(y0 + <span class="hljs-number">1000</span> * (a))<br>    x2 = int(x0 - <span class="hljs-number">1000</span> * (-b))<br>    y2 = int(y0 - <span class="hljs-number">1000</span> * (a))<br>    <br>    cv2.line(drawing, (x1, y1), (x2, y2), (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>))<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_hough_line_function.jpg"></p><h2 id="统计概率霍夫直线变换"><a href="#统计概率霍夫直线变换" class="headerlink" title="统计概率霍夫直线变换"></a>统计概率霍夫直线变换</h2><p>前面的方法又称为标准霍夫变换，它会计算图像中的每一个点，计算量比较大，另外它得到的是整一条线（r和θ），并不知道原图中直线的端点。所以提出了统计概率霍夫直线变换(Probabilistic Hough Transform)，是一种改进的霍夫变换：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">drawing = np.zeros(img.shape[:], dtype=np.uint8)<br><span class="hljs-comment"># 统计概率霍夫线变换</span><br>lines = cv2.HoughLinesP(edges, <span class="hljs-number">0.8</span>, np.pi / <span class="hljs-number">180</span>, <span class="hljs-number">90</span>,<br>                        minLineLength=<span class="hljs-number">50</span>, maxLineGap=<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><p>前面几个参数跟之前的一样，有两个可选参数：</p><ul><li><code>minLineLength</code>：最短长度阈值，比这个长度短的线会被排除</li><li><code>maxLineGap</code>：同一直线两点之间的最大距离</li></ul><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将检测的线画出来</span><br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines:<br>    x1, y1, x2, y2 = line[<span class="hljs-number">0</span>]<br>    cv2.line(drawing, (x1, y1), (x2, y2), (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>), <span class="hljs-number">1</span>, lineType=cv2.LINE_AA)<br></code></pre></td></tr></table></figure><p><code>cv2.LINE_AA</code>在之前绘图功能中讲解过，表示抗锯齿线型。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_hough_lines_p_function.jpg"></p><h2 id="霍夫圆变换"><a href="#霍夫圆变换" class="headerlink" title="霍夫圆变换"></a>霍夫圆变换</h2><p>霍夫圆变换跟直线变换类似，只不过线是用(r,θ)表示，圆是用(x_center,y_center,r)来表示，从二维变成了三维，数据量变大了很多；所以一般使用霍夫梯度法减少计算量，对该算法感兴趣的同学可参考：<a href="https://en.wikipedia.org/wiki/Circle_Hough_Transform" target="_blank" rel="noopener">Circle Hough Transform</a></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">drawing = np.zeros(img.shape[:], dtype=np.uint8)<br><span class="hljs-comment"># 霍夫圆变换</span><br>circles = cv2.HoughCircles(edges, cv2.HOUGH_GRADIENT, <span class="hljs-number">1</span>, <span class="hljs-number">20</span>, param2=<span class="hljs-number">30</span>)<br>circles = np.int0(np.around(circles))<br></code></pre></td></tr></table></figure><p>其中，</p><ul><li>参数2：变换方法，一般使用霍夫梯度法，详情：<a href="https://docs.opencv.org/3.3.1/d7/dbd/group__imgproc.html#ga073687a5b96ac7a3ab5802eb5510fe65" target="_blank" rel="noopener">HoughModes</a></li><li>参数3 dp=1：表示霍夫梯度法中累加器图像的分辨率与原图一致</li><li>参数4：两个不同圆圆心的最短距离</li><li>参数5：param2跟霍夫直线变换中的累加数阈值一样</li></ul><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将检测的圆画出来</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> circles[<span class="hljs-number">0</span>, :]:<br>    cv2.circle(drawing, (i[<span class="hljs-number">0</span>], i[<span class="hljs-number">1</span>]), i[<span class="hljs-number">2</span>], (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>), <span class="hljs-number">2</span>)  <span class="hljs-comment"># 画出外圆</span><br>    cv2.circle(drawing, (i[<span class="hljs-number">0</span>], i[<span class="hljs-number">1</span>]), <span class="hljs-number">2</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">3</span>)  <span class="hljs-comment"># 画出圆心</span><br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_hough_circles_function.jpg"></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_houghlines/py_houghlines.html" target="_blank" rel="noopener">Hough Line Transform</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_houghcircles/py_houghcircles.html" target="_blank" rel="noopener">Hough Circle Transform</a></li><li><a href="https://en.wikipedia.org/wiki/Hough_transform" target="_blank" rel="noopener">Hough transform</a></li><li><a href="https://blog.csdn.net/YuYunTan/article/details/80141392" target="_blank" rel="noopener">经典霍夫变换（Hough Transform）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 霍夫变换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程16：模板匹配</title>
      <link href="/2019/08/15/Python-OpenCV%E6%95%99%E7%A8%8B16%EF%BC%9A%E6%A8%A1%E6%9D%BF%E5%8C%B9%E9%85%8D/"/>
      <url>/2019/08/15/Python-OpenCV%E6%95%99%E7%A8%8B16%EF%BC%9A%E6%A8%A1%E6%9D%BF%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<p>学习使用模板匹配在图像中寻找物体。</p><p>目标：</p><ul><li>使用模板匹配在图像中寻找物体，在大图中找小图</li><li>OpenCV函数<ul><li><code>cv2.matchTemplate()</code>：进行模板匹配</li><li><code>cv2.minMaxLoc()</code>：得到最大匹配值的坐标，以这个点为左上角角点。</li></ul></li></ul><a id="more"></a><h2 id="模板匹配"><a href="#模板匹配" class="headerlink" title="模板匹配"></a>模板匹配</h2><p><a href="https://baike.baidu.com/item/模板匹配" target="_blank" rel="noopener">模板匹配</a>就是用来在大图中找小图，也就是说在一副图像中寻找另外一张模板图像的位置：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_understand_template_matching.jpg"></p><p>用<code>cv2.matchTemplate()</code>实现模板匹配。首先我们来读入图片和模板：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><br>img = cv2.imread(<span class="hljs-string">'lena.jpg'</span>, <span class="hljs-number">0</span>)<br>template = cv2.imread(<span class="hljs-string">'face.jpg'</span>, <span class="hljs-number">0</span>)<br>h, w = template.shape[:<span class="hljs-number">2</span>]  <span class="hljs-comment"># rows-&gt;h, cols-&gt;w</span><br></code></pre></td></tr></table></figure><p>匹配函数返回的是一副灰度图，最白的地方表示最大的匹配。</p><p>使用<code>cv2.minMaxLoc()</code>函数可以得到最大匹配值的坐标，以这个点为左上角角点。</p><p>模板的宽和高画矩形就是匹配的位置了：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 相关系数匹配方法：cv2.TM_CCOEFF</span><br>res = cv2.matchTemplate(img, template, cv2.TM_CCOEFF)<br>min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)<br><br>left_top = max_loc  <span class="hljs-comment"># 左上角</span><br>right_bottom = (left_top[<span class="hljs-number">0</span>] + w, left_top[<span class="hljs-number">1</span>] + h)  <span class="hljs-comment"># 右下角</span><br>cv2.rectangle(img, left_top, right_bottom, <span class="hljs-number">255</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment"># 画出矩形位置</span><br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_ccoeff_matching_template.jpg"></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>模板匹配的原理其实很简单，就是不断地在原图中移动模板图像去比较，有6种不同的比较方法，详情可参考：<a href="https://docs.opencv.org/3.3.1/df/dfb/group__imgproc__object.html#ga3a7850640f1fe1f58fe91a2d7583695d" target="_blank" rel="noopener">TemplateMatchModes</a></p><ul><li>平方差匹配CV_TM_SQDIFF：用两者的平方差来匹配，最好的匹配值为0</li><li>归一化平方差匹配CV_TM_SQDIFF_NORMED</li><li>相关匹配CV_TM_CCORR：用两者的乘积匹配，数值越大表明匹配程度越好</li><li>归一化相关匹配CV_TM_CCORR_NORMED</li><li>相关系数匹配CV_TM_CCOEFF：用两者的相关系数匹配，1表示完美的匹配，-1表示最差的匹配</li><li>归一化相关系数匹配CV_TM_CCOEFF_NORMED</li></ul><p>归一化的意思就是将值统一到0~1，这些方法的对比代码可到源码处查看。</p><p>模板匹配也是应用卷积来实现的：假设原图大小为W×H，模板图大小为w×h，那么生成图大小是(W-w+1)×(H-h+1)，生成图中的每个像素值表示原图与模板的匹配程度。</p><h2 id="匹配多个物体"><a href="#匹配多个物体" class="headerlink" title="匹配多个物体"></a>匹配多个物体</h2><p>前面我们是找最大匹配的点，所以只能匹配一次。我们可以设定一个匹配阈值来匹配多次：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1.读入原图和模板</span><br>img_rgb = cv2.imread(<span class="hljs-string">'mario.jpg'</span>)<br>img_gray = cv2.cvtColor(img_rgb, cv2.COLOR_BGR2GRAY)<br>template = cv2.imread(<span class="hljs-string">'mario_coin.jpg'</span>, <span class="hljs-number">0</span>)<br>h, w = template.shape[:<span class="hljs-number">2</span>]<br><br><span class="hljs-comment"># 2.标准相关模板匹配</span><br>res = cv2.matchTemplate(img_gray, template, cv2.TM_CCOEFF_NORMED)<br>threshold = <span class="hljs-number">0.8</span> <br><br><span class="hljs-comment"># 3.这边是Python/Numpy的知识，后面解释</span><br>loc = np.where(res &gt;= threshold)  <span class="hljs-comment"># 匹配程度大于%80的坐标y,x</span><br><span class="hljs-keyword">for</span> pt <span class="hljs-keyword">in</span> zip(*loc[::<span class="hljs-number">-1</span>]):  <span class="hljs-comment"># *号表示可选参数</span><br>    right_bottom = (pt[<span class="hljs-number">0</span>] + w, pt[<span class="hljs-number">1</span>] + h)<br>    cv2.rectangle(img_rgb, pt, right_bottom, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_template_matching_multi.jpg"></p><p>第3步有几个Python/Numpy的重要知识，来大致看下：</p><ul><li><a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.where.html" target="_blank" rel="noopener">np.where()</a>在这里返回res中值大于0.8的所有坐标，如：</li></ul><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">x = np.arange(<span class="hljs-number">9.</span>).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)<br>print(np.where(x &gt; <span class="hljs-number">5</span>))<br><span class="hljs-comment"># 结果(先y坐标，再x坐标)：(array([2, 2, 2]), array([0, 1, 2]))</span><br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_np_where_function.jpg"></p><ul><li><a href="https://docs.python.org/3/library/functions.html#zip" target="_blank" rel="noopener">zip()</a>函数，功能强大到难以解释，举个简单例子就知道了：</li></ul><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">x = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>y = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br>print(list(zip(x, y)))  <span class="hljs-comment"># [(1, 4), (2, 5), (3, 6)]</span><br></code></pre></td></tr></table></figure><p>这样大家就能理解前面代码的用法了吧：因为loc是先y坐标再x坐标，所以用loc[::-1]翻转一下，然后再用zip函数拼接在一起。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_template_matching/py_template_matching.html" target="_blank" rel="noopener">Template Matching</a></li><li><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/histograms/template_matching/template_matching.html#template-matching" target="_blank" rel="noopener">模板匹配</a></li><li><a href="https://docs.opencv.org/3.3.1/df/dfb/group__imgproc__object.html#ga3a7850640f1fe1f58fe91a2d7583695d" target="_blank" rel="noopener">TemplateMatchModes</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 模板匹配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程15：直方图</title>
      <link href="/2019/08/15/Python-OpenCV%E6%95%99%E7%A8%8B15%EF%BC%9A%E7%9B%B4%E6%96%B9%E5%9B%BE/"/>
      <url>/2019/08/15/Python-OpenCV%E6%95%99%E7%A8%8B15%EF%BC%9A%E7%9B%B4%E6%96%B9%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>学习计算并绘制直方图，直方图均衡化等。</p><p>目标：</p><ul><li>计算并绘制直方图</li><li>（自适应）直方图均衡化</li><li>OpenCV函数：<ul><li><code>cv2.calcHist()</code>：计算直方图</li><li><code>cv2.equalizeHist()</code>：均衡化直方图</li></ul></li></ul><p>均衡化用来使图像的直方图分布更加均匀，提升亮度和对比度。</p><a id="more"></a><h2 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h2><p>直方图是一种分析图像的手段，简单来说就是图像中每个像素值的个数统计，比如说一副灰度图中像素值为0的有多少个，1的有多少个……直方图是一种分析图片的手段：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_understand_histogram.jpg"></p><p>在计算直方图之前，有几个术语先来了解一下：</p><ul><li>dims：要计算的通道数，对于灰度图dims=1，普通彩色图dims=3</li><li>range：要计算的像素值范围，一般为[0,256)</li><li>bins：子区段数目，如果我们统计0~255每个像素值，bins=256；如果划分区间，比如0~15, 16~31…240~255这样16个区间，bins=16</li></ul><h2 id="计算直方图"><a href="#计算直方图" class="headerlink" title="计算直方图"></a>计算直方图</h2><p>OpenCV和Numpy中都提供了计算直方图的函数，我们对比下它们的性能。</p><h3 id="OpenCV中直方图计算"><a href="#OpenCV中直方图计算" class="headerlink" title="OpenCV中直方图计算"></a>OpenCV中直方图计算</h3><p>使用<code>cv2.calcHist(images, channels, mask, histSize, ranges)</code>计算，其中：</p><ul><li>参数1：要计算的原图，以方括号的传入，如：[img]</li><li>参数2：类似前面提到的dims，灰度图写[0]就行，彩色图B/G/R分别传入[0]/[1]/[2]</li><li>参数3：要计算的区域，计算整幅图的话，写None</li><li>参数4：前面提到的bins</li><li>参数5：前面提到的range</li></ul><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>img = cv2.imread(<span class="hljs-string">'hist.jpg'</span>, <span class="hljs-number">0</span>)<br>hist = cv2.calcHist([img], [<span class="hljs-number">0</span>], <span class="hljs-literal">None</span>, [<span class="hljs-number">256</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">256</span>])  <span class="hljs-comment"># 性能：0.025288 s</span><br></code></pre></td></tr></table></figure><h3 id="Numpy中直方图计算"><a href="#Numpy中直方图计算" class="headerlink" title="Numpy中直方图计算"></a>Numpy中直方图计算</h3><p>也可用Numpy的函数计算，其中<a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ravel.html" target="_blank" rel="noopener">ravel()</a>函数将二维矩阵展平变成一维数组，之前有提到过：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">hist, bins = np.histogram(img.ravel(), <span class="hljs-number">256</span>, [<span class="hljs-number">0</span>, <span class="hljs-number">256</span>])  <span class="hljs-comment"># 性能：0.020628 s</span><br></code></pre></td></tr></table></figure><blockquote><p>经验之谈：Numpy中还有一种更高效的方式：（还记得怎么评估性能吗：<a href="[http://huris.xyz/2019/08/13/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%871%EF%BC%9A%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/](http://huris.xyz/2019/08/13/Python-OpenCV教程番外篇1：代码性能优化/">番外篇：代码性能优化</a>)）</p></blockquote><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">hist = np.bincount(img.ravel(), minlength=<span class="hljs-number">256</span>)  <span class="hljs-comment"># 性能：0.003163 s</span><br></code></pre></td></tr></table></figure><h2 id="绘制直方图"><a href="#绘制直方图" class="headerlink" title="绘制直方图"></a>绘制直方图</h2><p>其实Matplotlib自带了一个计算并绘制直方图的功能，不需要用到上面的函数：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.hist(img.ravel(), <span class="hljs-number">256</span>, [<span class="hljs-number">0</span>, <span class="hljs-number">256</span>])<br>plt.show()<br></code></pre></td></tr></table></figure><p>当然，也可以用前面计算出来的结果绘制：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.plot(hist)<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_calc_draw_histogram.jpg"></p><p>从直方图上可以看到图片的大部分区域集中在150偏白的附近，这其实并不是很好的效果，下面我们来看看如何改善它。</p><blockquote><p>使用OpenCV的画线功能也可以画直方图，不过太麻烦了，有兴趣的可以看下官方示例：<a href="https://github.com/opencv/opencv/blob/master/samples/python/hist.py" target="_blank" rel="noopener">hist.py</a>。</p></blockquote><h2 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h2><p>一副效果好的图像通常在直方图上的分布比较均匀，直方图均衡化就是用来改善图像的全局亮度和对比度。其实从观感上就可以发现，前面那幅图对比度不高，偏灰白。对均衡化算法感兴趣的同学可参考：<a href="https://zh.wikipedia.org/wiki/直方图均衡化" target="_blank" rel="noopener">维基百科：直方图均衡化</a></p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_understand_histogram_equalization.jpg"></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">equ = cv2.equalizeHist(img)<br></code></pre></td></tr></table></figure><p>OpenCV中用<code>cv2.equalizeHist()</code>实现均衡化。我们把两张图片并排显示，对比一下：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">cv2.imshow(<span class="hljs-string">'equalization'</span>, np.hstack((img, equ)))  <span class="hljs-comment"># 并排显示</span><br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_before_after_equalization.jpg"></p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_before_after_equalization_histogram.jpg"></p><p>可以看到均衡化后图片的亮度和对比度效果明显好于原图。</p><h2 id="自适应均衡化"><a href="#自适应均衡化" class="headerlink" title="自适应均衡化"></a>自适应均衡化</h2><p>不难看出来，直方图均衡化是应用于整幅图片的，会有什么问题呢？看下图：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_understand_adaptive_histogram.jpg"></p><p>很明显，因为全局调整亮度和对比度的原因，脸部太亮，大部分细节都丢失了。</p><p>自适应均衡化就是用来解决这一问题的：它在每一个小区域内（默认8×8）进行直方图均衡化。</p><p>当然，如果有噪点的话，噪点会被放大，需要对小区域内的对比度进行了限制，所以这个算法全称叫：<strong>对比度受限的自适应直方图均衡化</strong>CLAHE(<a href="https://en.wikipedia.org/wiki/Adaptive_histogram_equalization" target="_blank" rel="noopener">Contrast Limited Adaptive Histogram Equalization</a>)。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 自适应均衡化，参数可选</span><br>clahe = cv2.createCLAHE(clipLimit=<span class="hljs-number">2.0</span>, tileGridSize=(<span class="hljs-number">8</span>, <span class="hljs-number">8</span>))<br>cl1 = clahe.apply(img)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_adaptive_histogram.jpg"></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p><code>cv2.calcHist()</code>函数中的参数3是指要计算的区域(mask：目标区域白色，其余黑色)，编写一个只计算图片左上角200×200区域直方图的程序。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_histogram_mask.jpg"></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>img = cv2.imread(<span class="hljs-string">'hist.jpg'</span>, <span class="hljs-number">0</span>)<br><span class="hljs-comment"># 只计算左上角200*200的区域</span><br>mask = np.zeros(img.shape, dtype=np.uint8)<br>mask[:<span class="hljs-number">200</span>, :<span class="hljs-number">200</span>] = <span class="hljs-number">255</span><br><br>hist_mask = cv2.calcHist([img], [<span class="hljs-number">0</span>], mask, [<span class="hljs-number">256</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">256</span>])<br><br>plt.plot(hist_mask)<br>plt.show()<br></code></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_histograms/py_histogram_begins/py_histogram_begins.html#histograms-getting-started" target="_blank" rel="noopener">Histograms - 1 : Find, Plot, Analyze !!!</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_histograms/py_histogram_equalization/py_histogram_equalization.html#histogram-equalization" target="_blank" rel="noopener">Histograms - 2: Histogram Equalization</a></li><li><a href="https://zh.wikipedia.org/wiki/直方图均衡化" target="_blank" rel="noopener">维基百科：直方图均衡化</a></li><li><a href="https://en.wikipedia.org/wiki/Adaptive_histogram_equalization" target="_blank" rel="noopener">维基百科：自适应直方图均衡化</a></li><li><a href="http://www.cambridgeincolour.com/tutorials/histograms1.htm" target="_blank" rel="noopener">Cambridge in Color website</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 直方图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程14：轮廓特征</title>
      <link href="/2019/08/15/Python-OpenCV%E6%95%99%E7%A8%8B14%EF%BC%9A%E8%BD%AE%E5%BB%93%E7%89%B9%E5%BE%81/"/>
      <url>/2019/08/15/Python-OpenCV%E6%95%99%E7%A8%8B14%EF%BC%9A%E8%BD%AE%E5%BB%93%E7%89%B9%E5%BE%81/</url>
      
        <content type="html"><![CDATA[<p>学习计算轮廓特征，如面积、周长、最小外接矩形等。</p><p>目标：</p><ul><li>计算物体的周长、面积、质心、最小外接矩形等</li><li>OpenCV函数：<ul><li><code>cv2.contourArea()</code>：面积</li><li><code>cv2.arcLength()</code>：周长</li><li><code>cv2.boundingRect()</code>：外接矩</li><li><code>cv2.minAreaRect()</code>：最小外接矩</li><li><code>cv2.minEnclosingCircle()</code>：最小外接圆</li><li><code>cv2.matchShapes()</code>：进行形状匹配</li></ul></li></ul><a id="more"></a><h2 id="轮廓特征"><a href="#轮廓特征" class="headerlink" title="轮廓特征"></a>轮廓特征</h2><p>在计算轮廓特征之前，我们先用上一节的代码把轮廓找到：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_31_handwriting_sample.jpg"></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>img = cv2.imread(<span class="hljs-string">'handwriting.jpg'</span>, <span class="hljs-number">0</span>)<br>_, thresh = cv2.threshold(img, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)<br>image, contours, hierarchy = cv2.findContours(thresh, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 以数字3的轮廓为例</span><br>cnt = contours[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>为了便于绘制，我们创建出两幅彩色图，并把轮廓画在第一幅图上：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">img_color1 = cv2.cvtColor(image, cv2.COLOR_GRAY2BGR)<br>img_color2 = np.copy(img_color1)<br>cv2.drawContours(img_color1, [cnt], <span class="hljs-number">0</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h3 id="轮廓面积"><a href="#轮廓面积" class="headerlink" title="轮廓面积"></a>轮廓面积</h3><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">area = cv2.contourArea(cnt)  <span class="hljs-comment"># 4386.5</span><br></code></pre></td></tr></table></figure><p>注意轮廓特征计算的结果并不等同于像素点的个数，而是根据几何方法算出来的，所以有小数。</p><blockquote><p>如果统计二值图中像素点个数，应尽量避免循环，<strong>可以使用<code>cv2.countNonZero()</code></strong>，更加高效。</p></blockquote><h3 id="轮廓周长"><a href="#轮廓周长" class="headerlink" title="轮廓周长"></a>轮廓周长</h3><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">perimeter = cv2.arcLength(cnt, <span class="hljs-literal">True</span>)  <span class="hljs-comment"># 585.7</span><br></code></pre></td></tr></table></figure><p>参数2表示轮廓是否封闭，显然我们的轮廓是封闭的，所以是True。</p><h3 id="图像矩"><a href="#图像矩" class="headerlink" title="图像矩"></a>图像矩</h3><p>矩可以理解为图像的各类几何特征，详情请参考：[<a href="http://en.wikipedia.org/wiki/Image_moment" target="_blank" rel="noopener">Image Moments</a>]</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">M = cv2.moments(cnt)<br></code></pre></td></tr></table></figure><p>M中包含了很多轮廓的特征信息，比如M[‘m00’]表示轮廓面积，与前面<code>cv2.contourArea()</code>计算结果是一样的。</p><p>质心也可以用它来算：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">cx, cy = M[<span class="hljs-string">'m10'</span>] / M[<span class="hljs-string">'m00'</span>], M[<span class="hljs-string">'m01'</span>] / M[<span class="hljs-string">'m00'</span>]  <span class="hljs-comment"># (205, 281)</span><br></code></pre></td></tr></table></figure><h3 id="外接矩形"><a href="#外接矩形" class="headerlink" title="外接矩形"></a>外接矩形</h3><p>形状的外接矩形有两种，如下图，绿色的叫外接矩形，表示不考虑旋转并且能包含整个轮廓的矩形。蓝色的叫最小外接矩，考虑了旋转：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_min_rect_rect_bounding.jpg"></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">x, y, w, h = cv2.boundingRect(cnt)  <span class="hljs-comment"># 外接矩形</span><br>cv2.rectangle(img_color1, (x, y), (x + w, y + h), (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>), <span class="hljs-number">2</span>)<br><br>rect = cv2.minAreaRect(cnt)  <span class="hljs-comment"># 最小外接矩形</span><br>box = np.int0(cv2.boxPoints(rect))  <span class="hljs-comment"># 矩形的四个角点取整</span><br>cv2.drawContours(img_color1, [box], <span class="hljs-number">0</span>, (<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>其中<code>np.int0(x)</code>是把x取整的操作，比如377.93就会变成377，也可以用<code>x.astype(np.int)</code>。</p><h3 id="最小外接圆"><a href="#最小外接圆" class="headerlink" title="最小外接圆"></a>最小外接圆</h3><p>外接圆跟外接矩形一样，找到一个能包围物体的最小圆：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">`(x, y), radius = cv2.minEnclosingCircle(cnt)(x, y, radius) = np.int0((x, y, radius))  <span class="hljs-comment"># 圆心和半径取整cv2.circle(img_color2, (x, y), radius, (0, 0, 255), 2)`</span><br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_min_enclosing_circle.jpg"></p><h3 id="拟合椭圆"><a href="#拟合椭圆" class="headerlink" title="拟合椭圆"></a>拟合椭圆</h3><p>我们可以用得到的轮廓拟合出一个椭圆：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ellipse = cv2.fitEllipse(cnt)<br>cv2.ellipse(img_color2, ellipse, (<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>), <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_fitting_ellipse.jpg"></p><h3 id="形状匹配"><a href="#形状匹配" class="headerlink" title="形状匹配"></a>形状匹配</h3><p><code>cv2.matchShapes()</code>可以检测两个形状之间的相似度，返回<strong>值越小，越相似</strong>。先读入下面这张图片：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_match_shape_shapes.jpg"></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">img = cv2.imread(<span class="hljs-string">'shapes.jpg'</span>, <span class="hljs-number">0</span>)<br>_, thresh = cv2.threshold(img, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)<br>contours, hierarchy = cv2.findContours(thresh, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>)<br>img_color = cv2.cvtColor(thresh, cv2.COLOR_GRAY2BGR)  <span class="hljs-comment"># 用于绘制的彩色图</span><br></code></pre></td></tr></table></figure><p>图中有3条轮廓，我们用A/B/C表示：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">cnt_a, cnt_b, cnt_c = contours[<span class="hljs-number">0</span>], contours[<span class="hljs-number">1</span>], contours[<span class="hljs-number">2</span>]<br>print(cv2.matchShapes(cnt_b, cnt_b, <span class="hljs-number">1</span>, <span class="hljs-number">0.0</span>))  <span class="hljs-comment"># 0.0</span><br>print(cv2.matchShapes(cnt_b, cnt_c, <span class="hljs-number">1</span>, <span class="hljs-number">0.0</span>))  <span class="hljs-comment"># 2.17e-05</span><br>print(cv2.matchShapes(cnt_b, cnt_a, <span class="hljs-number">1</span>, <span class="hljs-number">0.0</span>))  <span class="hljs-comment"># 0.418</span><br></code></pre></td></tr></table></figure><p>可以看到BC相似程度比AB高很多，并且图形的旋转或缩放并没有影响。其中，参数3是匹配方法，详情可参考：<a href="https://docs.opencv.org/4.0.0/d3/dc0/group__imgproc__shape.html#gaf2b97a230b51856d09a2d934b78c015f" target="_blank" rel="noopener">ShapeMatchModes</a>，参数4是OpenCV的预留参数，暂时没有实现，可以不用理会。</p><p>形状匹配是通过图像的Hu矩来实现的(<code>cv2.HuMoments()</code>)，大家如果感兴趣，可以参考：<a href="http://en.wikipedia.org/wiki/Image_moment#Rotation_invariant_moments" target="_blank" rel="noopener">Hu-Moments</a></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol><li>前面我们是对图片中的数字3进行轮廓特征计算的，大家换成数字1看看。</li></ol><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 载入手写数字图片</span><br>img = cv2.imread(<span class="hljs-string">'handwriting.jpg'</span>, <span class="hljs-number">0</span>)<br>_, thresh = cv2.threshold(img, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)<br>contours, hierarchy = cv2.findContours(thresh, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 创建出两幅彩色图用于绘制</span><br>img_color1 = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)<br>img_color2 = np.copy(img_color1)<br><br><span class="hljs-comment"># 计算数字1的轮廓特征</span><br>cnt = contours[<span class="hljs-number">1</span>]<br>cv2.drawContours(img_color1, [cnt], <span class="hljs-number">0</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 1.轮廓面积</span><br>area = cv2.contourArea(cnt)  <span class="hljs-comment"># 6289.5</span><br>print(area)<br><br><br><span class="hljs-comment"># 2.轮廓周长</span><br>perimeter = cv2.arcLength(cnt, <span class="hljs-literal">True</span>)  <span class="hljs-comment"># 527.4041</span><br>print(perimeter)<br><br><br><span class="hljs-comment"># 3.图像矩</span><br>M = cv2.moments(cnt)<br>print(M)<br>print(M[<span class="hljs-string">'m00'</span>])  <span class="hljs-comment"># 同前面的面积：6289.5</span><br>cx, cy = M[<span class="hljs-string">'m10'</span>] / M[<span class="hljs-string">'m00'</span>], M[<span class="hljs-string">'m01'</span>] / M[<span class="hljs-string">'m00'</span>]  <span class="hljs-comment"># 质心</span><br>print(cx, cy)<br><br><span class="hljs-comment"># 4.图像外接矩形和最小外接矩形</span><br>x, y, w, h = cv2.boundingRect(cnt)  <span class="hljs-comment"># 外接矩形</span><br>cv2.rectangle(img_color1, (x, y), (x + w, y + h), (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>), <span class="hljs-number">2</span>)<br><br>rect = cv2.minAreaRect(cnt)  <span class="hljs-comment"># 最小外接矩形</span><br>box = np.int0(cv2.boxPoints(rect))  <span class="hljs-comment"># 矩形的四个角点并取整</span><br>cv2.drawContours(img_color1, [box], <span class="hljs-number">0</span>, (<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">2</span>)<br><br>cv2.imshow(<span class="hljs-string">'contours'</span>, img_color1)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br><br><br><span class="hljs-comment"># 5.最小外接圆</span><br>(x, y), radius = cv2.minEnclosingCircle(cnt)<br>(x, y, radius) = map(int, (x, y, radius))  <span class="hljs-comment"># 这也是取整的一种方式噢</span><br>cv2.circle(img_color2, (x, y), radius, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">2</span>)<br><br><br><span class="hljs-comment"># 6.拟合椭圆</span><br>ellipse = cv2.fitEllipse(cnt)<br>cv2.ellipse(img_color2, ellipse, (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>), <span class="hljs-number">2</span>)<br><br>cv2.imshow(<span class="hljs-string">'contours2'</span>, img_color2)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><ol><li>用形状匹配比较两个字母或数字（这相当于很简单的一个<a href="https://baike.baidu.com/item/光学字符识别/4162921?fr=aladdin&amp;fromid=25995&amp;fromtitle=OCR" target="_blank" rel="noopener">OCR</a>噢）。</li></ol><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br><span class="hljs-comment"># 载入原图</span><br>img = cv2.imread(<span class="hljs-string">'abc.jpg'</span>, <span class="hljs-number">0</span>)<br>_, thresh = cv2.threshold(img, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)<br>contours, hierarchy = cv2.findContours(thresh, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>)<br><span class="hljs-comment"># 找到ABC的轮廓</span><br>b, c, a = contours[<span class="hljs-number">0</span>], contours[<span class="hljs-number">3</span>], contours[<span class="hljs-number">4</span>]<br><br><span class="hljs-comment"># 载入标准模板图</span><br>img_a = cv2.imread(<span class="hljs-string">'template_a.jpg'</span>, <span class="hljs-number">0</span>)<br>_, th = cv2.threshold(img_a, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)<br>contours, hierarchy = cv2.findContours(th, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>)<br><span class="hljs-comment"># 字母A的轮廓</span><br>template_a = contours[<span class="hljs-number">0</span>]<br><br>print(cv2.matchShapes(a, template_a, <span class="hljs-number">1</span>, <span class="hljs-number">0.0</span>))  <span class="hljs-comment"># 0.02557(最相似)</span><br>print(cv2.matchShapes(b, template_a, <span class="hljs-number">1</span>, <span class="hljs-number">0.0</span>))  <span class="hljs-comment"># 0.80585</span><br>print(cv2.matchShapes(c, template_a, <span class="hljs-number">1</span>, <span class="hljs-number">0.0</span>))  <span class="hljs-comment"># 3.26050</span><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><ul><li><a href="https://docs.opencv.org/4.0.0/d3/dc0/group__imgproc__shape.html#ga2c759ed9f497d4a618048a2f56dc97f1" target="_blank" rel="noopener">cv2.contourArea()</a></li><li><a href="https://docs.opencv.org/4.0.0/d3/dc0/group__imgproc__shape.html#ga8d26483c636be6b35c3ec6335798a47c" target="_blank" rel="noopener">cv2.arcLength()</a></li><li><a href="https://docs.opencv.org/4.0.0/d3/dc0/group__imgproc__shape.html#ga556a180f43cab22649c23ada36a8a139" target="_blank" rel="noopener">cv2.moments()</a></li><li><a href="https://docs.opencv.org/4.0.0/d3/dc0/group__imgproc__shape.html#ga103fcbda2f540f3ef1c042d6a9b35ac7" target="_blank" rel="noopener">cv2.boundingRect()</a></li><li><a href="https://docs.opencv.org/4.0.0/d3/dc0/group__imgproc__shape.html#ga3d476a3417130ae5154aea421ca7ead9" target="_blank" rel="noopener">cv2.minAreaRect()</a></li><li><a href="https://docs.opencv.org/4.0.0/d3/dc0/group__imgproc__shape.html#ga8ce13c24081bbc7151e9326f412190f1" target="_blank" rel="noopener">cv2.minEnclosingCircle()</a></li><li><a href="https://docs.opencv.org/4.0.0/d3/dc0/group__imgproc__shape.html#gaf259efaad93098103d6c27b9e4900ffa" target="_blank" rel="noopener">cv2.fitEllipse()</a></li><li><a href="https://docs.opencv.org/4.0.0/d3/dc0/group__imgproc__shape.html#gaadc90cb16e2362c9bd6e7363e6e4c317" target="_blank" rel="noopener">cv2.matchShapes()</a></li><li><a href="https://docs.opencv.org/4.0.0/d3/dc0/group__imgproc__shape.html#gaf2b97a230b51856d09a2d934b78c015f" target="_blank" rel="noopener">cv2.ShapeMatchModes</a></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contour_features/py_contour_features.html" target="_blank" rel="noopener">Contour Features</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contours_more_functions/py_contours_more_functions.html" target="_blank" rel="noopener">Contours : More Functions</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 轮廓 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程番外篇11：凸包及更多轮廓特征</title>
      <link href="/2019/08/15/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%8711%EF%BC%9A%E5%87%B8%E5%8C%85%E5%8F%8A%E6%9B%B4%E5%A4%9A%E8%BD%AE%E5%BB%93%E7%89%B9%E5%BE%81/"/>
      <url>/2019/08/15/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%8711%EF%BC%9A%E5%87%B8%E5%8C%85%E5%8F%8A%E6%9B%B4%E5%A4%9A%E8%BD%AE%E5%BB%93%E7%89%B9%E5%BE%81/</url>
      
        <content type="html"><![CDATA[<p>计算凸包及更多轮廓特征。</p><a id="more"></a><h2 id="多边形逼近"><a href="#多边形逼近" class="headerlink" title="多边形逼近"></a>多边形逼近</h2><p>前面我们学习过最小外接矩和最小外接圆，那么可以用一个最小的多边形包围物体吗？当然可以：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 多边形逼近</span><br><span class="hljs-comment"># 1.先找到轮廓</span><br>img = cv2.imread(<span class="hljs-string">'unregular.jpg'</span>, <span class="hljs-number">0</span>)<br>_, thresh = cv2.threshold(img, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)<br>contours, hierarchy = cv2.findContours(thresh, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>)<br>cnt = contours[<span class="hljs-number">0</span>]<br><br><span class="hljs-comment"># 2.进行多边形逼近，得到多边形的角点</span><br>approx = cv2.approxPolyDP(cnt, <span class="hljs-number">3</span>, <span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 3.画出多边形</span><br>image = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)<br>cv2.polylines(image, [approx], <span class="hljs-literal">True</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>), <span class="hljs-number">2</span>)<br>print(len(approx))  <span class="hljs-comment"># 角点的个数</span><br>cv2.imshow(<span class="hljs-string">'approxPloyDP'</span>, image)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>其中<code>cv2.approxPolyDP()</code>的参数2(epsilon)是一个距离值，表示多边形的轮廓接近实际轮廓的程度，值越小，越精确；参数3表示是否闭合。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_understand_approxpoly.jpg"></p><h2 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h2><p><a href="https://baike.baidu.com/item/凸包/179150?fr=aladdin" target="_blank" rel="noopener">凸包</a>跟多边形逼近很像，只不过它是物体最外层的”凸”多边形：集合A内连接任意两个点的直线都在A的内部，则称集合A是凸形的。</p><p>如下图，红色的部分为手掌的凸包，双箭头部分表示凸缺陷(Convexity Defects)，凸缺陷常用来进行手势识别等：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_understand_convex.jpg"></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 凸包</span><br><span class="hljs-comment"># 1.先找到轮廓</span><br>img = cv2.imread(<span class="hljs-string">'convex.jpg'</span>, <span class="hljs-number">0</span>)<br>_, thresh = cv2.threshold(img, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)<br>contours, hierarchy = cv2.findContours(thresh, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>)<br>cnt = contours[<span class="hljs-number">0</span>]<br><br><span class="hljs-comment"># 2.寻找凸包，得到凸包的角点</span><br>hull = cv2.convexHull(cnt)<br><br><span class="hljs-comment"># 3.绘制凸包</span><br>image = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)<br>cv2.polylines(image, [hull], <span class="hljs-literal">True</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>), <span class="hljs-number">2</span>)<br>cv2.imshow(<span class="hljs-string">'convex hull'</span>, image)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_convex_hull.jpg"></p><p>其中函数<code>cv2.convexHull()</code>有个可选参数returnPoints，默认是True，代表返回角点的x/y坐标；如果为False的话，表示返回轮廓中是凸包角点的索引，比如说：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">print(hull[<span class="hljs-number">0</span>])  <span class="hljs-comment"># [[362 184]]（坐标）</span><br>hull2 = cv2.convexHull(cnt, returnPoints=<span class="hljs-literal">False</span>)<br>print(hull2[<span class="hljs-number">0</span>])  <span class="hljs-comment"># [510]（cnt中的索引）</span><br>print(cnt[<span class="hljs-number">510</span>])  <span class="hljs-comment"># [[362 184]]</span><br></code></pre></td></tr></table></figure><p>当使用<code>cv2.convexityDefects()</code>计算凸包缺陷时，returnPoints需为False，详情可参考：<a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contours_more_functions/py_contours_more_functions.html#contours-more-functions" target="_blank" rel="noopener">Convexity Defects</a></p><p>另外可以用下面的语句来判断轮廓是否是凸形的：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">print(cv2.isContourConvex(hull))  <span class="hljs-comment"># True</span><br></code></pre></td></tr></table></figure><h2 id="点到轮廓的"><a href="#点到轮廓的" class="headerlink" title="点到轮廓的"></a>点到轮廓的</h2><p><code>cv2.pointPolygonTest()</code>函数计算点到轮廓的最短距离（也就是垂线），又称多边形测试：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">dist = cv2.pointPolygonTest(cnt, (<span class="hljs-number">100</span>, <span class="hljs-number">100</span>), <span class="hljs-literal">True</span>)  <span class="hljs-comment"># -3.53</span><br></code></pre></td></tr></table></figure><p>其中参数3为True时表示计算距离值：点在轮廓外面值为负，点在轮廓上值为0，点在轮廓里面值为正；参数3为False时，只返回-1/0/1表示点相对轮廓的位置，不计算距离。</p><p>更多轮廓特征，如当量直径、平均强度等，我目前也没用到过，以后用到再写吧，感兴趣的可以参看：<a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contour_properties/py_contour_properties.html" target="_blank" rel="noopener">Contour Properties</a>、<a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contours_hierarchy/py_contours_hierarchy.html" target="_blank" rel="noopener">Contours Hierarchy</a></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contours_more_functions/py_contours_more_functions.html#contours-more-functions" target="_blank" rel="noopener">Convexity Defects</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contour_properties/py_contour_properties.html" target="_blank" rel="noopener">Contour Properties</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contours_hierarchy/py_contours_hierarchy.html" target="_blank" rel="noopener">Contours Hierarchy</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程番外篇10：轮廓层级</title>
      <link href="/2019/08/15/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%8710%EF%BC%9A%E8%BD%AE%E5%BB%93%E5%B1%82%E7%BA%A7/"/>
      <url>/2019/08/15/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%8710%EF%BC%9A%E8%BD%AE%E5%BB%93%E5%B1%82%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<p>了解轮廓间的层级关系。</p><p>前面我们使用<code>cv2.findContours()</code>寻找轮廓时，参数3表示轮廓的寻找方式(RetrievalModes)，当时我们传入的是cv2.RETR_TREE，它表示什么意思呢？另外，函数返回值hierarchy有什么用途呢？</p><p>下面我们就来研究下这两个问题。</p><a id="more"></a><h2 id="理解轮廓层级"><a href="#理解轮廓层级" class="headerlink" title="理解轮廓层级"></a>理解轮廓层级</h2><p>很多情况下，图像中的形状之间是有关联的，比如说下图：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_understand_hierarchy.jpg"></p><p>图中总共有8条轮廓，2和2a分别表示外层和里层的轮廓，3和3a也是一样。从图中看得出来：</p><ul><li>轮廓0/1/2是最外层的轮廓，我们可以说它们处于同一轮廓等级：0级</li><li>轮廓2a是轮廓2的子轮廓，反过来说2是2a的父轮廓，轮廓2a算一个等级：1级</li><li>同样3是2a的子轮廓，轮廓3处于一个等级：2级</li><li>类似的，3a是3的子轮廓，等等…………</li></ul><p>这里面OpenCV关注的就是两个概念：同一轮廓等级和轮廓间的子属关系。</p><h2 id="OpenCV中轮廓等级的表示"><a href="#OpenCV中轮廓等级的表示" class="headerlink" title="OpenCV中轮廓等级的表示"></a>OpenCV中轮廓等级的表示</h2><p>如果我们打印出<code>cv2.findContours()</code>函数的返回值hierarchy，会发现它是一个包含4个值的数组：<strong>[Next, Previous, First Child, Parent]</strong></p><ul><li><em>Next：与当前轮廓处于同一层级的下一条轮廓</em></li></ul><p>举例来说，前面图中跟0处于同一层级的下一条轮廓是1，所以Next=1；同理，对轮廓1来说，Next=2；那么对于轮廓2呢？没有与它同一层级的下一条轮廓了，此时Next=-1。</p><ul><li><em>Previous：与当前轮廓处于同一层级的上一条轮廓</em></li></ul><p>跟前面一样，对于轮廓1来说，Previous=0；对于轮廓2，Previous=1；对于轮廓1，没有上一条轮廓了，所以Previous=-1。</p><ul><li><em>First Child：当前轮廓的第一条子轮廓</em></li></ul><p>比如对于轮廓2，第一条子轮廓就是轮廓2a，所以First Child=2a；对轮廓3a，First Child=4。</p><ul><li><em>Parent：当前轮廓的父轮廓</em></li></ul><p>比如2a的父轮廓是2，Parent=2；轮廓2没有父轮廓，所以Parent=-1。</p><p>下面我们通过代码验证一下：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br><span class="hljs-comment"># 1.读入图片</span><br>img = cv2.imread(<span class="hljs-string">'hierarchy.jpg'</span>)<br>img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br>_, thresh = cv2.threshold(img_gray, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)<br><br><span class="hljs-comment"># 2.寻找轮廓</span><br>contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, <span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 3.绘制轮廓</span><br>print(len(contours),hierarchy)  <span class="hljs-comment"># 8条</span><br>cv2.drawContours(img, contours, <span class="hljs-number">-1</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><blockquote><p>经验之谈：OpenCV中找到的轮廓序号跟前面讲的不同噢，如下图：</p></blockquote><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_hierarchy_RETR_TREE.jpg"></p><p>现在既然我们了解了层级的概念，那么类似cv2.RETR_TREE的轮廓寻找方式又是啥意思呢？</p><h2 id="轮廓寻找方式"><a href="#轮廓寻找方式" class="headerlink" title="轮廓寻找方式"></a>轮廓寻找方式</h2><p>OpenCV中有四种轮廓寻找方式<a href="https://docs.opencv.org/3.3.1/d3/dc0/group__imgproc__shape.html#ga819779b9857cc2f8601e6526a3a5bc71" target="_blank" rel="noopener">RetrievalModes</a>，下面分别来看下：</p><h3 id="RETR-LIST"><a href="#RETR-LIST" class="headerlink" title="RETR_LIST"></a>RETR_LIST</h3><p>这是最简单的一种寻找方式，它不建立轮廓间的子属关系，也就是所有轮廓都属于同一层级。</p><p>这样，hierarchy中的后两个值[First Child, Parent]都为-1。</p><p>比如同样的图，我们使用cv2.RETR_LIST来寻找轮廓：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">_, hierarchy = cv2.findContours(thresh, cv2.RETR_LIST, <span class="hljs-number">2</span>)<br>print(hierarchy)<br><span class="hljs-comment"># 结果如下</span><br>[[[ <span class="hljs-number">1</span> <span class="hljs-number">-1</span> <span class="hljs-number">-1</span> <span class="hljs-number">-1</span>]<br>  [ <span class="hljs-number">2</span>  <span class="hljs-number">0</span> <span class="hljs-number">-1</span> <span class="hljs-number">-1</span>]<br>  [ <span class="hljs-number">3</span>  <span class="hljs-number">1</span> <span class="hljs-number">-1</span> <span class="hljs-number">-1</span>]<br>  [ <span class="hljs-number">4</span>  <span class="hljs-number">2</span> <span class="hljs-number">-1</span> <span class="hljs-number">-1</span>]<br>  [ <span class="hljs-number">5</span>  <span class="hljs-number">3</span> <span class="hljs-number">-1</span> <span class="hljs-number">-1</span>]<br>  [ <span class="hljs-number">6</span>  <span class="hljs-number">4</span> <span class="hljs-number">-1</span> <span class="hljs-number">-1</span>]<br>  [ <span class="hljs-number">7</span>  <span class="hljs-number">5</span> <span class="hljs-number">-1</span> <span class="hljs-number">-1</span>]<br>  [<span class="hljs-number">-1</span>  <span class="hljs-number">6</span> <span class="hljs-number">-1</span> <span class="hljs-number">-1</span>]]]<br></code></pre></td></tr></table></figure><p>因为没有从属关系，所以轮廓0的下一条是1，1的下一条是2……</p><blockquote><p>经验之谈：如果你不需要轮廓层级信息的话，cv2.RETR_LIST更推荐使用，因为性能更好。</p></blockquote><h3 id="RETR-TREE"><a href="#RETR-TREE" class="headerlink" title="RETR_TREE"></a>RETR_TREE</h3><blockquote><p>注意：使用这个参数找到的轮廓序号与之前不同。</p></blockquote><p>图中括号里面1代表外层轮廓，2代表里层轮廓。比如说对于轮廓2，Next就是4，Previous是1，它有里层的轮廓3，所以First Child=3，但因为只有两个层级，它本身就是外层轮廓，所以Parent=-1。大家可以针对其他的轮廓自己验证一下。</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>如下图，找到3个圆环的内环，然后填充成(180,215,215)这种颜色：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_hierarchy_fill_holes.jpg"></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 1.读入圆环</span><br>img = cv2.imread(<span class="hljs-string">'circle_ring.jpg'</span>)<br>img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br>_, thresh = cv2.threshold(<br>    img_gray, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)<br><br><span class="hljs-comment"># 2.使用cv2.RETR_CCOMP寻找轮廓</span><br>contours, hierarchy = cv2.findContours(thresh, cv2.RETR_CCOMP, <span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 3.找到内层轮廓并填充</span><br><span class="hljs-comment"># hierarchy的形状为(1,6,4)，使用np.squeeze压缩一维数据，变成(6,4)</span><br>hierarchy = np.squeeze(hierarchy)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(contours)):<br>    <span class="hljs-comment"># 存在父轮廓，说明是里层</span><br>    <span class="hljs-keyword">if</span>(hierarchy[i][<span class="hljs-number">3</span>] != <span class="hljs-number">-1</span>):<br>        cv2.drawContours(img, contours, i, (<span class="hljs-number">180</span>, <span class="hljs-number">215</span>, <span class="hljs-number">215</span>), <span class="hljs-number">-1</span>)<br><br><span class="hljs-comment"># 4.显示结果</span><br>cv2.imshow(<span class="hljs-string">'fill'</span>, img)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contours_hierarchy/py_contours_hierarchy.html#contours-hierarchy" target="_blank" rel="noopener">Contours Hierarchy</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 轮廓层级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程13：轮廓</title>
      <link href="/2019/08/15/Python-OpenCV%E6%95%99%E7%A8%8B13%EF%BC%9A%E8%BD%AE%E5%BB%93/"/>
      <url>/2019/08/15/Python-OpenCV%E6%95%99%E7%A8%8B13%EF%BC%9A%E8%BD%AE%E5%BB%93/</url>
      
        <content type="html"><![CDATA[<p>学习如何寻找并绘制轮廓。</p><p>目标：</p><ul><li>了解轮廓的概念</li><li>寻找并绘制轮廓</li><li>OpenCV函数：<ul><li><code>cv2.findContours()</code>：寻找轮廓</li><li><code>cv2.drawContours()</code>：绘制轮廓</li></ul></li></ul><a id="more"></a><h2 id="轮廓"><a href="#轮廓" class="headerlink" title="轮廓"></a>轮廓</h2><p>轮廓是一系列相连的点组成的曲线，代表了物体的基本外形。</p><p>谈起轮廓不免想到边缘，它们确实很像。简单的说，<strong>轮廓是连续的，边缘并不全都连续</strong>（下图）。其实边缘主要是作为图像的特征使用，比如可以用边缘特征可以区分脸和手，而轮廓主要用来分析物体的形态，比如物体的周长和面积等，可以说边缘包括轮廓。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_understand_contours.jpg"></p><p>寻找轮廓的操作一般用于二值化图，所以通常会使用阈值分割或Canny边缘检测先得到二值图。</p><blockquote><p>经验之谈：<strong>寻找轮廓是针对白色物体的</strong>，一定要保证物体是白色，而背景是黑色，<strong>不然很多人在寻找轮廓时会找到图片最外面的一个框</strong>。</p></blockquote><h2 id="寻找轮廓"><a href="#寻找轮廓" class="headerlink" title="寻找轮廓"></a>寻找轮廓</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><ul><li><a href="https://docs.opencv.org/4.0.0/d3/dc0/group__imgproc__shape.html#gadf1ad6a0b82947fa1fe3c3d497f260e0" target="_blank" rel="noopener">cv2.findContours()</a></li><li><a href="https://docs.opencv.org/4.0.0/d3/dc0/group__imgproc__shape.html#ga819779b9857cc2f8601e6526a3a5bc71" target="_blank" rel="noopener">cv2.RetrievalModes</a></li><li><a href="https://docs.opencv.org/4.0.0/d3/dc0/group__imgproc__shape.html#ga4303f45752694956374734a03c54d5ff" target="_blank" rel="noopener">cv2.ContourApproximationModes</a></li><li><a href="https://docs.opencv.org/4.0.0/d6/d6e/group__imgproc__draw.html#ga746c0625f1781f1ffc9056259103edbc" target="_blank" rel="noopener">cv2.drawContours()</a></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contours_begin/py_contours_begin.html" target="_blank" rel="noopener">Contours : Getting Started</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 轮廓 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程12：腐蚀与膨胀</title>
      <link href="/2019/08/15/Python-OpenCV%E6%95%99%E7%A8%8B12%EF%BC%9A%E8%85%90%E8%9A%80%E4%B8%8E%E8%86%A8%E8%83%80/"/>
      <url>/2019/08/15/Python-OpenCV%E6%95%99%E7%A8%8B12%EF%BC%9A%E8%85%90%E8%9A%80%E4%B8%8E%E8%86%A8%E8%83%80/</url>
      
        <content type="html"><![CDATA[<p>学习常用形态学操作：腐蚀膨胀，开运算和闭运算。</p><p>目标：</p><ul><li>了解形态学操作的概念</li><li>学习膨胀、腐蚀、开运算和闭运算等形态学操作</li><li>OpenCV：<ul><li><code>cv2.erode()</code>：腐蚀函数</li><li><code>cv2.dilate()</code>：膨胀函数</li><li><code>cv2.morphologyEx()</code>：开闭运算函数</li></ul></li></ul><p>形态学操作就是改变物体的形状，如腐蚀使物体”变瘦”，膨胀使物体”变胖”</p><p>先腐蚀后膨胀会分离物体，所以叫开运算，常用来<strong>去除小区域物体</strong>。</p><p>先膨胀后腐蚀会<strong>消除物体内的小洞</strong>，所以叫闭运算。</p><p>开/闭理解了之后很容易记忆噢(⊙o⊙)。</p><a id="more"></a><h2 id="形态学操作"><a href="#形态学操作" class="headerlink" title="形态学操作"></a>形态学操作</h2><p>形态学操作其实就是<strong>改变物体的形状</strong>，比如腐蚀就是”变瘦”，膨胀就是”变胖”，看下图就明白了：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_understand_morphological.jpg"></p><blockquote><p>经验之谈：形态学操作一般作用于二值化图，来连接相邻的元素或分离成独立的元素。<strong>腐蚀和膨胀是针对图片中的白色部分！</strong></p></blockquote><h2 id="腐蚀"><a href="#腐蚀" class="headerlink" title="腐蚀"></a>腐蚀</h2><p>腐蚀的效果是把图片”变瘦”，其原理是在原图的小区域内取局部最小值。因为是二值化图，只有0和255，所以小区域内有一个是0该像素点就为0：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_understand_erosion.jpg"></p><p>这样原图中边缘地方就会变成0，达到了瘦身目的（小胖福利(●ˇ∀ˇ●)）</p><p>OpenCV中用<code>cv2.erode()</code>函数进行腐蚀，只需要指定核的大小就行：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>img = cv2.imread(<span class="hljs-string">'j.bmp'</span>, <span class="hljs-number">0</span>)<br>kernel = np.ones((<span class="hljs-number">5</span>, <span class="hljs-number">5</span>), np.uint8)<br>erosion = cv2.erode(img, kernel)  <span class="hljs-comment"># 腐蚀</span><br></code></pre></td></tr></table></figure><blockquote><p>这个核也叫结构元素，因为形态学操作其实也是应用卷积来实现的。结构元素可以是矩形/椭圆/十字形，可以用<code>cv2.getStructuringElement()</code>来生成不同形状的结构元素，比如：</p></blockquote><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (<span class="hljs-number">5</span>, <span class="hljs-number">5</span>))  <span class="hljs-comment"># 矩形结构</span><br>kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (<span class="hljs-number">5</span>, <span class="hljs-number">5</span>))  <span class="hljs-comment"># 椭圆结构</span><br>kernel = cv2.getStructuringElement(cv2.MORPH_CROSS, (<span class="hljs-number">5</span>, <span class="hljs-number">5</span>))  <span class="hljs-comment"># 十字形结构</span><br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_morphological_struct_element.jpg"></p><h2 id="膨胀"><a href="#膨胀" class="headerlink" title="膨胀"></a>膨胀</h2><p>膨胀与腐蚀相反，取的是局部最大值，效果是把图片“<strong>变胖</strong>”。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">dilation = cv2.dilate(img, kernel)  <span class="hljs-comment"># 膨胀</span><br></code></pre></td></tr></table></figure><h2 id="开闭运算"><a href="#开闭运算" class="headerlink" title="开闭运算"></a>开闭运算</h2><p>先腐蚀后膨胀叫开运算（因为先腐蚀会分开物体，这样容易记住）。</p><p>其作用是：分离物体，消除小区域。</p><p>这类形态学操作用<code>cv2.morphologyEx()</code>函数实现：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (<span class="hljs-number">5</span>, <span class="hljs-number">5</span>))  <span class="hljs-comment"># 定义结构元素</span><br>img = cv2.imread(<span class="hljs-string">'j_noise_out.bmp'</span>, <span class="hljs-number">0</span>)<br>opening = cv2.morphologyEx(img, cv2.MORPH_OPEN, kernel)  <span class="hljs-comment"># 开运算</span><br></code></pre></td></tr></table></figure><p>闭运算则相反：先膨胀后腐蚀（先膨胀会使白色的部分扩张，以至于消除/“闭合”物体里面的小黑洞，所以叫闭运算）</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">img = cv2.imread(<span class="hljs-string">'j_noise_in.bmp'</span>, <span class="hljs-number">0</span>)<br>closing = cv2.morphologyEx(img, cv2.MORPH_CLOSE, kernel)  <span class="hljs-comment"># 闭运算</span><br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_morphological_opening_closing.jpg"></p><blockquote><p>经验之谈：很多人对开闭运算的作用不是很清楚（好吧，其实是比较容易混◑﹏◐），但看上图↑，不用怕：如果我们的目标物体外面有很多无关的小区域，就用开运算去除掉；如果物体内部有很多小黑洞，就用闭运算填充掉。</p></blockquote><p>接下来的3种形态学操作并不常用，大家有兴趣可以看看（因为较短，没有做成番外篇）：</p><h2 id="其他形态学操作"><a href="#其他形态学操作" class="headerlink" title="其他形态学操作"></a>其他形态学操作</h2><h3 id="形态学梯度"><a href="#形态学梯度" class="headerlink" title="形态学梯度"></a>形态学梯度</h3><p>膨胀图减去腐蚀图，<code>dilation - erosion</code>，这样会得到物体的轮廓：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">img = cv2.imread(<span class="hljs-string">'school.bmp'</span>, <span class="hljs-number">0</span>)<br>gradient = cv2.morphologyEx(img, cv2.MORPH_GRADIENT, kernel)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_morphological_gradient.jpg"></p><h3 id="顶帽"><a href="#顶帽" class="headerlink" title="顶帽"></a>顶帽</h3><p>原图减去开运算后的图：<code>src - opening</code></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">tophat = cv2.morphologyEx(img, cv2.MORPH_TOPHAT, kernel)<br></code></pre></td></tr></table></figure><h3 id="黑帽"><a href="#黑帽" class="headerlink" title="黑帽"></a>黑帽</h3><p>闭运算后的图减去原图：<code>closing - src</code></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">blackhat = cv2.morphologyEx(img, cv2.MORPH_BLACKHAT, kernel)<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><ul><li><a href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#gaeb1e0c1033e3f6b891a25d0511362aeb" target="_blank" rel="noopener">cv2.erode()</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#gac342a1bb6eabf6f55c803b09268e36dc" target="_blank" rel="noopener">cv2.getStructuringElement()</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#ga4ff0f3318642c4f469d0e11f242f3b6c" target="_blank" rel="noopener">cv2.dilate()</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#gac2db39b56866583a95a5680313c314ad" target="_blank" rel="noopener">cv2.MorphShapes</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#ga67493776e3ad1a3df63883829375201f" target="_blank" rel="noopener">cv2.morphologyEx()</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#ga7be549266bad7b2e6a04db49827f9f32" target="_blank" rel="noopener">cv2.MorphTypes</a></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="http://homepages.inf.ed.ac.uk/rbf/HIPR2/morops.htm" target="_blank" rel="noopener">Morphological Operations</a></li><li><a href="http://szeliski.org/Book/" target="_blank" rel="noopener">Computer Vision: Algorithms and Applications</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 形态学 </tag>
            
            <tag> 腐蚀 </tag>
            
            <tag> 膨胀 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程11：边缘检测</title>
      <link href="/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B11%EF%BC%9A%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/"/>
      <url>/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B11%EF%BC%9A%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<p>学习使用Canny获取图像的边缘。</p><blockquote><p><a href="https://www.computer.org/cms/Computer.org/Transactions Home Pages/TPAMI/PDFs/top_ten_6.pdf" target="_blank" rel="noopener">Canny J . A Computational Approach To Edge Detection[J\]. IEEE Transactions on Pattern Analysis and Machine Intelligence, 1986, PAMI-8(6):679-698.</a></p></blockquote><p>目标：</p><ul><li>Canny边缘检测的简单概念</li><li>OpenCV函数：<code>cv2.Canny()</code>：进行Canny边缘检测</li></ul><a id="more"></a><h2 id="Canny边缘检测"><a href="#Canny边缘检测" class="headerlink" title="Canny边缘检测"></a>Canny边缘检测</h2><p>Canny边缘检测方法常被誉为边缘检测的最优方法，废话不多说，先看个例子：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># Canny边缘检测</span><br>img = cv2.imread(<span class="hljs-string">'handwriting.jpg'</span>, <span class="hljs-number">0</span>)<br>edges = cv2.Canny(img, <span class="hljs-number">30</span>, <span class="hljs-number">70</span>)<br><br>cv2.imshow(<span class="hljs-string">'canny'</span>, np.hstack((img, edges)))<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_canny_edge_detection.jpg"></p><p><code>cv2.Canny()</code>进行边缘检测，参数2、3表示最低、高阈值，下面来解释下具体原理。</p><blockquote><p>经验之谈：之前我们用低通滤波的方式模糊了图片，那反过来，想得到物体的边缘，就需要用到高通滤波。推荐先阅读：<a href="[http://huris.xyz/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%879%EF%BC%9A%E5%9B%BE%E5%83%8F%E6%A2%AF%E5%BA%A6/](http://huris.xyz/2019/08/14/Python-OpenCV教程番外篇9：图像梯度/">番外篇：图像梯度</a>)。</p></blockquote><p><strong>Canny边缘提取</strong>的具体步骤如下：</p><ol><li>使用5×5高斯滤波消除噪声：</li></ol><p>边缘检测本身属于锐化操作，对噪点比较敏感，所以需要进行平滑处理。</p><p>高斯滤波的具体内容参考前一篇：<a href="[http://huris.xyz/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B10%EF%BC%9A%E5%B9%B3%E6%BB%91%E5%9B%BE%E5%83%8F/](http://huris.xyz/2019/08/14/Python-OpenCV教程10：平滑图像/">平滑图像</a>)</p><script type="math/tex; mode=display">K=\frac{1}{256}\begin{bmatrix}1&4&6&4&1\\4&16&24&16&4\\6&24&36&24&6\\4&16&24&16&4\\1&4&6&4&1\end{bmatrix}</script><ol><li>计算图像梯度的方向</li></ol><p>首先使用<strong>Sobel算子</strong>计算两个方向上的梯度$G_x$和$G_y$，然后算出梯度的方向：</p><script type="math/tex; mode=display">\theta=\arctan(\frac{G_y}{G_x})</script><p>保留这四个方向的梯度：$0^{\circ}/45^{\circ}/90^{\circ}/135^{\circ}$，有什么用呢？我们接着看。</p><ol><li>取局部极大值</li></ol><p>梯度其实已经表示了轮廓，但为了进一步筛选，可以在上面的四个角度方向上再取局部极大值：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_understand_canny_direction.jpg"></p><p>比如，A点在45°方向上大于B/C点，那就保留它，把B/C设置为0。</p><ol><li>滞后阈值</li></ol><p>经过前面三步，就只剩下0和可能的边缘梯度值了，为了最终确定下来，需要设定高低阈值：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_understand_canny_max_min_val.jpg"></p><ul><li>像素点的值大于最高阈值，那肯定是边缘（上图A）</li><li>同理像素值小于最低阈值，那肯定不是边缘</li><li>像素值介于两者之间，如果与高于最高阈值的点连接，也算边缘，所以上图中C算，B不算</li></ul><p>Canny推荐的高低阈值比在2:1到3:1之间。</p><h2 id="先阈值分割后检测"><a href="#先阈值分割后检测" class="headerlink" title="先阈值分割后检测"></a>先阈值分割后检测</h2><p>其实很多情况下，阈值分割后再检测边缘，效果会更好：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 先阈值，后边缘检测</span><br><span class="hljs-comment"># 阈值分割（使用到了番外篇讲到的Otsu自动阈值）</span><br>_, thresh = cv2.threshold(img, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)<br>edges = cv2.Canny(thresh, <span class="hljs-number">30</span>, <span class="hljs-number">70</span>)<br><br>cv2.imshow(<span class="hljs-string">'canny'</span>, np.hstack((img, thresh, edges)))<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>代码中我用了<a href="[http://huris.xyz/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%874%EF%BC%9AOtsu%E9%98%88%E5%80%BC%E6%B3%95/](http://huris.xyz/2019/08/14/Python-OpenCV教程番外篇4：Otsu阈值法/">番外篇：Otsu阈值法</a>)中的自动阈值分割，如果你不太了解，大可以使用传统的方法，不过如果是下面这种图片，推荐用Otsu阈值法。</p><p>另外Python中某个值不用的话，就写个下划线’_’。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_canny_edge_detection_threshold.jpg"></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>如果你不太理解高低阈值的效果，创建两个滑动条来调节它们的值看看：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_trackbar_maxval_minval_canny.gif"></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">track_back</span><span class="hljs-params">(x)</span>:</span><br>    <span class="hljs-keyword">pass</span><br><br><br>img = cv2.imread(<span class="hljs-string">'sudoku.jpg'</span>, <span class="hljs-number">0</span>)<br>cv2.namedWindow(<span class="hljs-string">'window'</span>)<br><br><span class="hljs-comment"># 创建滑动条</span><br>cv2.createTrackbar(<span class="hljs-string">'maxVal'</span>, <span class="hljs-string">'window'</span>, <span class="hljs-number">100</span>, <span class="hljs-number">255</span>, track_back)<br>cv2.createTrackbar(<span class="hljs-string">'minVal'</span>, <span class="hljs-string">'window'</span>, <span class="hljs-number">200</span>, <span class="hljs-number">255</span>, track_back)<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment"># 获取滑动条的值</span><br>    max_val = cv2.getTrackbarPos(<span class="hljs-string">'maxVal'</span>, <span class="hljs-string">'window'</span>)<br>    min_val = cv2.getTrackbarPos(<span class="hljs-string">'minVal'</span>, <span class="hljs-string">'window'</span>)<br><br>    edges = cv2.Canny(img, min_val, max_val)<br>    cv2.imshow(<span class="hljs-string">'window'</span>, edges)<br><br>    <span class="hljs-comment"># 按下ESC键退出</span><br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">30</span>) == <span class="hljs-number">27</span>:<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><ul><li><a href="https://docs.opencv.org/4.0.0/dd/d1a/group__imgproc__feature.html#ga04723e007ed888ddf11d9ba04e2232de" target="_blank" rel="noopener">cv2.Canny()</a></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_canny/py_canny.html" target="_blank" rel="noopener">Canny Edge Detection</a></li><li><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/imgtrans/canny_detector/canny_detector.html" target="_blank" rel="noopener">Canny 边缘检测</a></li><li><a href="https://www.computer.org/cms/Computer.org/Transactions Home Pages/TPAMI/PDFs/top_ten_6.pdf" target="_blank" rel="noopener">Canny J . A Computational Approach To Edge Detection[J\]. IEEE Transactions on Pattern Analysis and Machine Intelligence, 1986, PAMI-8(6):679-698.</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 边缘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程番外篇9：图像梯度</title>
      <link href="/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%879%EF%BC%9A%E5%9B%BE%E5%83%8F%E6%A2%AF%E5%BA%A6/"/>
      <url>/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%879%EF%BC%9A%E5%9B%BE%E5%83%8F%E6%A2%AF%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>了解图像梯度和边缘检测的相关概念。</p><p>还记得前面<a href="http://ex2tron.wang/opencv-python-smoothing-images/" target="_blank" rel="noopener">平滑图像</a>中提到的滤波与模糊的区别吗？我们说低通滤波器是模糊，高通滤波器是锐化，这节我们就来看看高通滤波器。</p><a id="more"></a><h2 id="图像梯度"><a href="#图像梯度" class="headerlink" title="图像梯度"></a>图像梯度</h2><blockquote><p>如果你还记得高数中用一阶导数来求极值的话，就很容易理解了：</p><p>把图片想象成连续函数，因为边缘部分的像素值是与旁边像素明显有区别的，所以对图片局部求极值，就可以得到整幅图片的边缘信息了。不过图片是二维的离散函数，导数就变成了差分，这个差分就称为图像的梯度。</p></blockquote><p>当然，大部分人应该是早忘记高数了(￣▽￣)”，所以看不懂的话，就把上面的解释划掉，我们重新从卷积的角度来看看。</p><h3 id="垂直边缘提取"><a href="#垂直边缘提取" class="headerlink" title="垂直边缘提取"></a>垂直边缘提取</h3><p>滤波是应用卷积来实现的，卷积的关键就是卷积核，我们来考察下面这个卷积核：</p><script type="math/tex; mode=display">k1=\begin{bmatrix}-1&0&1\\-2&0&2\\-1&0&1\end{bmatrix}</script><p>这个核是用来提取图片中的垂直边缘的，怎么做到的呢？看下图：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_understand_sobel_edge_detection.jpg"></p><p>当前列左右两侧的元素进行差分，由于边缘的值明显小于（或大于）周边像素，所以边缘的差分结果会明显不同，这样就提取出了垂直边缘。</p><p>同理，把上面那个矩阵转置一下，就是提取水平边缘。</p><p>这种差分操作就称为图像的梯度计算：</p><script type="math/tex; mode=display">k2=\begin{bmatrix}-1&-2&-1\\0&0&0\\1&2&1\end{bmatrix}</script><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_horizen_vertical_edge_detection.jpg"></p><blockquote><p>还记得滤波函数<code>cv2.filter2D()</code>吗？（<a href="[http://huris.xyz/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%878%EF%BC%9A%E5%8D%B7%E7%A7%AF%E5%9F%BA%E7%A1%80-%E5%9B%BE%E7%89%87%E8%BE%B9%E6%A1%86/](http://huris.xyz/2019/08/14/Python-OpenCV教程番外篇8：卷积基础-图片边框/">番外篇：卷积基础</a>)）我们来手动实现上面的功能：</p></blockquote><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">img = cv2.imread(<span class="hljs-string">'sudoku.jpg'</span>, <span class="hljs-number">0</span>)<br><span class="hljs-comment"># 自己进行垂直边缘提取</span><br>kernel = np.array([[<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],<br>                   [<span class="hljs-number">-2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>],<br>                   [<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]], dtype=np.float32)<br>dst_v = cv2.filter2D(img, <span class="hljs-number">-1</span>, kernel)<span class="hljs-comment"># -1表示与原通道数相同</span><br><span class="hljs-comment"># 自己进行水平边缘提取</span><br>dst_h = cv2.filter2D(img, <span class="hljs-number">-1</span>, kernel.T)  <span class="hljs-comment"># -1表示与原通道数相同</span><br><span class="hljs-comment"># 横向并排对比显示</span><br>cv2.imshow(<span class="hljs-string">'edge'</span>, np.hstack((img, dst_v, dst_h)))<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h3 id="Sobel算子"><a href="#Sobel算子" class="headerlink" title="Sobel算子"></a>Sobel算子</h3><p>上面的这种差分方法就叫<a href="https://baike.baidu.com/item/Sobel算子/11000092?fr=aladdin" target="_blank" rel="noopener">Sobel算子</a>：</p><ol><li>先在<strong>垂直方向</strong>计算梯度$G_x=k_1×src$</li><li>再在<strong>水平方向</strong>计算梯度$G_y=k_2×src$</li><li>最后求出<strong>总梯度</strong>：$G=\sqrt{G_{x}^2+G_{y}^2}$</li></ol><p>我们可以把前面的代码用Sobel算子更简单地实现：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">sobelx = cv2.Sobel(img, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, ksize=<span class="hljs-number">3</span>)  <span class="hljs-comment"># 只计算x方向</span><br>sobely = cv2.Sobel(img, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, ksize=<span class="hljs-number">3</span>)  <span class="hljs-comment"># 只计算y方向</span><br></code></pre></td></tr></table></figure><blockquote><p>经验之谈：很多人疑问，Sobel算子的卷积核这几个值是怎么来的呢？事实上，并没有规定，你可以用你自己的。</p></blockquote><p>比如，最初只利用领域间的原始差值来检测边缘的<a href="https://baike.baidu.com/item/Prewitt算子/8415245?fr=aladdin" target="_blank" rel="noopener">Prewitt算子</a>：</p><script type="math/tex; mode=display">k=\begin{bmatrix}-1&0&1\\-1&0&1\\-1&0&1\end{bmatrix}</script><p>还有比Sobel更好用的<strong>Scharr算子</strong>，大家可以了解下：</p><script type="math/tex; mode=display">k=\begin{bmatrix}-3&0&3\\-10&0&10\\-3&0&3\end{bmatrix}</script><p>这些算法都是一阶边缘检测的代表，网上也有算子之间的对比资料，有兴趣的可参考引用。</p><h3 id="Laplacian算子"><a href="#Laplacian算子" class="headerlink" title="Laplacian算子"></a>Laplacian算子</h3><p>高数中用一阶导数求极值，在这些极值的地方，二阶导数为0，所以也可以通过求二阶导计算梯度：$dst=\frac{\partial^{2}{f}}{\partial{x^2}}+\frac{\partial^{2}{f}}{\partial{y^2}}$</p><p>一维的一阶和二阶差分公式分别为：</p><script type="math/tex; mode=display">\frac{\partial{f}}{\partial{x}}=f(x+1)-f(x)</script><script type="math/tex; mode=display">\frac{\partial^{2}{f}}{\partial{x}^{2}}=f(x+1)+f(x-1)-2f(x)</script><p>提取前面的系数，那么一维的Laplacian滤波核是：</p><script type="math/tex; mode=display">K=\begin{bmatrix}1&2&1\end{bmatrix}</script><p>而对于二维函数f(x,y)，两个方向的二阶差分分别是：</p><script type="math/tex; mode=display">\frac{\partial^{2}{f}}{\partial{x}^{2}}=f(x+1,y)+f(x-1,y)-2f(x,y)</script><script type="math/tex; mode=display">\frac{\partial^{2}{f}}{\partial{y}^{2}}=f(x,y+1)+f(x,y-1)-2f(x,y)</script><p>合在一起就是：</p><script type="math/tex; mode=display">\nabla^{2}f(x,y)=f(x+1,y)+f(x-1,y)+f(x,y+1)+f(x,y-1)-4f(x,y)</script><p>同样提取前面的系数，那么二维的Laplacian滤波核就是：</p><script type="math/tex; mode=display">K=\begin{bmatrix}0&1&0\\1&-4&1\\0&1&0\end{bmatrix}</script><p>这就是Laplacian算子的图像卷积模板，有些资料中在此基础上考虑斜对角情况，将卷积核拓展为：</p><script type="math/tex; mode=display">K=\begin{bmatrix}1&1&1\\1&-8&1\\1&1&1\end{bmatrix}</script><p>OpenCV中直接使用<code>cv2.Laplacian()</code>函数：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">laplacian = cv2.Laplacian(img, <span class="hljs-number">-1</span>)  <span class="hljs-comment"># 使用Laplacian算子</span><br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_laplacian.jpg"></p><p>Laplacian算子是二阶边缘检测的典型代表，一/二阶边缘检测各有优缺点，大家可自行了解。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_gradients/py_gradients.html" target="_blank" rel="noopener">Image Gradients</a></li><li><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/imgtrans/sobel_derivatives/sobel_derivatives.html#sobel-derivatives" target="_blank" rel="noopener">Sobel导数</a></li><li><a href="https://zh.wikipedia.org/wiki/边缘检测" target="_blank" rel="noopener">维基百科：边缘检测</a></li><li><a href="https://www.jianshu.com/p/2334bee37de5" target="_blank" rel="noopener">数字图像 - 边缘检测原理 - Sobel, Laplace, Canny算子</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 梯度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程10：平滑图像</title>
      <link href="/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B10%EF%BC%9A%E5%B9%B3%E6%BB%91%E5%9B%BE%E5%83%8F/"/>
      <url>/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B10%EF%BC%9A%E5%B9%B3%E6%BB%91%E5%9B%BE%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<p>学习模糊/平滑图像，消除噪点。</p><p>目标：</p><ul><li>模糊/平滑图片来消除图片噪声</li><li>OpenCV函数<ul><li><code>cv2.blur()</code>：均值滤波</li><li><code>cv2.GaussianBlur()</code>：高斯滤波</li><li><code>cv2.medianBlur()</code>：中值滤波</li><li><code>cv2.bilateralFilter()</code>：双边滤波</li></ul></li></ul><p>小结：</p><ul><li>在不知道用什么滤波器好的时候，优先高斯滤波<code>cv2.GaussianBlur()</code>，然后均值滤波<code>cv2.blur()</code>。</li><li>斑点和椒盐噪声优先使用中值滤波<code>cv2.medianBlur()</code>。</li><li>要去除噪点的同时尽可能保留更多的边缘信息，使用双边滤波<code>cv2.bilateralFilter()</code>。</li><li>线性滤波方式：均值滤波、方框滤波、高斯滤波（速度相对快）。</li><li>非线性滤波方式：中值滤波、双边滤波（速度相对慢）。</li></ul><a id="more"></a><h2 id="滤波与模糊"><a href="#滤波与模糊" class="headerlink" title="滤波与模糊"></a>滤波与模糊</h2><p>关于滤波和模糊，很多人分不清，我来给大家理理（虽说如此，我后面也会混着用,,ԾㅂԾ,,）：</p><ul><li>它们<strong>都属于卷积</strong>，<strong>不同滤波方法之间只是卷积核不同</strong>（对线性滤波而言）</li><li>低通滤波器是模糊，高通滤波器是锐化</li></ul><p><strong>低通滤波器</strong>就是允许低频信号通过，在图像中边缘和噪点都相当于高频部分，所以低通滤波器用于去除噪点、平滑和模糊图像。</p><p><strong>高通滤波器</strong>则反之，用来增强图像边缘，进行锐化处理。</p><blockquote><p>常见噪声有<a href="https://baike.baidu.com/item/椒盐噪声/3455958?fr=aladdin" target="_blank" rel="noopener">椒盐噪声</a>和<a href="https://baike.baidu.com/item/高斯噪声" target="_blank" rel="noopener">高斯噪声</a>：</p><p><strong>椒盐噪声：</strong>可以理解为斑点，随机出现在图像中的黑点或白点；</p><p><strong>高斯噪声：</strong>可以理解为拍摄图片时由于光照等原因造成的噪声。</p></blockquote><h3 id="均值滤波"><a href="#均值滤波" class="headerlink" title="均值滤波"></a>均值滤波</h3><p>均值滤波是一种最简单的滤波处理，它取的是卷积核区域内元素的均值，用<code>cv2.blur()</code>实现，如3×3的卷积核：</p><script type="math/tex; mode=display">kernel=\frac{1}{9}\begin{bmatrix}1&1&1\\1&1&1\\1&1&1\end{bmatrix}</script><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>img = cv2.imread(<span class="hljs-string">'lena.jpg'</span>)<br><span class="hljs-comment"># 均值滤波</span><br>blur = cv2.blur(img, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>))<br><br><span class="hljs-comment"># 上面的均值滤波也可以用方框滤波实现：normalize=True</span><br><span class="hljs-comment"># blur = cv2.boxFilter(img, -1, (3, 3), normalize=True)</span><br></code></pre></td></tr></table></figure><blockquote><p>所有的滤波函数都有一个可选参数borderType，这个参数就是<a href="[http://huris.xyz/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%878%EF%BC%9A%E5%8D%B7%E7%A7%AF%E5%9F%BA%E7%A1%80-%E5%9B%BE%E7%89%87%E8%BE%B9%E6%A1%86/](http://huris.xyz/2019/08/14/Python-OpenCV教程番外篇8：卷积基础-图片边框/">番外篇：卷积基础(图片边框)</a>)中所说的边框填充方式。</p></blockquote><h3 id="方框滤波"><a href="#方框滤波" class="headerlink" title="方框滤波"></a>方框滤波</h3><p>方框滤波跟均值滤波很像，如3×3的滤波核如下：</p><script type="math/tex; mode=display">kernel=a\begin{bmatrix}1&1&1\\1&1&1\\1&1&1\end{bmatrix}</script><p>用<code>cv2.boxFilter()</code>函数实现，</p><p><strong>当可选参数normalize为True的时候，方框滤波就是均值滤波，上式中的a就等于1/9；</strong></p><p><strong>当normalize为False的时候，a=1，相当于求区域内的像素和。</strong></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 前面的均值滤波也可以用方框滤波实现：normalize=True</span><br>blur = cv2.boxFilter(img, <span class="hljs-number">-1</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), normalize=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><h3 id="高斯滤波"><a href="#高斯滤波" class="headerlink" title="高斯滤波"></a>高斯滤波</h3><p>前面两种滤波方式，卷积核内的每个值都一样，也就是说图像区域中每个像素的权重也就一样。高斯滤波的卷积核权重并不相同：中间像素点权重最高，越远离中心的像素权重越小，来，数学时间( ╯□╰ )，还记得标准正态分布的曲线吗？</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_gaussian_kernel_function_theory.jpg"></p><p>显然这种处理元素间权值的方式更加合理一些。</p><p>图像是2维的，所以我们需要使用<a href="https://en.wikipedia.org/wiki/Gaussian_filter" target="_blank" rel="noopener">2维的高斯函数</a>，比如OpenCV中默认的3×3的高斯卷积核（具体原理和卷积核生成方式请参考文末的番外小篇：</p><script type="math/tex; mode=display">kernel=\begin{bmatrix}0.0625&0.125&0.0625\\0.125&0.25&0.125\\0.0625&0.125&0.0625\end{bmatrix}</script><p>OpenCV中对应函数为<code>cv2.GaussianBlur(src,ksize,sigmaX)</code>：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">img = cv2.imread(<span class="hljs-string">'gaussian_noise.bmp'</span>)<br><span class="hljs-comment"># 均值滤波vs高斯滤波</span><br>blur = cv2.blur(img, (<span class="hljs-number">5</span>, <span class="hljs-number">5</span>))  <span class="hljs-comment"># 均值滤波</span><br>gaussian = cv2.GaussianBlur(img, (<span class="hljs-number">5</span>, <span class="hljs-number">5</span>), <span class="hljs-number">1</span>)  <span class="hljs-comment"># 高斯滤波</span><br></code></pre></td></tr></table></figure><p>参数3 σx值越大，模糊效果越明显。</p><p>高斯滤波相比均值滤波效率要慢，但可以有效消除高斯噪声，能保留更多的图像细节，所以经常被称为最有用的滤波器。</p><p>均值滤波与高斯滤波的对比结果如下（均值滤波丢失的细节更多）：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_gaussian_vs_average.jpg"></p><h3 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h3><p><a href="https://baike.baidu.com/item/中值" target="_blank" rel="noopener">中值</a>又叫中位数，是所有数排序后取中间的值。中值滤波就是用区域内的中值来代替本像素值，所以那种孤立的斑点，如0或255很容易消除掉，<strong>适用于去除椒盐噪声和斑点噪声</strong>。</p><p>中值是一种非线性操作，效率相比前面几种线性滤波要慢。</p><p>比如下面这张斑点噪声图，用中值滤波显然更好：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">img = cv2.imread(<span class="hljs-string">'salt_noise.bmp'</span>, <span class="hljs-number">0</span>)<br><span class="hljs-comment"># 均值滤波vs中值滤波</span><br>blur = cv2.blur(img, (<span class="hljs-number">5</span>, <span class="hljs-number">5</span>))  <span class="hljs-comment"># 均值滤波</span><br>median = cv2.medianBlur(img, <span class="hljs-number">5</span>)  <span class="hljs-comment"># 中值滤波</span><br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_median_vs_average.jpg"></p><h3 id="双边滤波"><a href="#双边滤波" class="headerlink" title="双边滤波"></a>双边滤波</h3><p>模糊操作基本都会损失掉图像细节信息，尤其前面介绍的线性滤波器，图像的边缘信息很难保留下来。</p><p>然而，边缘（edge）信息是图像中很重要的一个特征，所以这才有了<a href="https://baike.baidu.com/item/双边滤波" target="_blank" rel="noopener">双边滤波</a>。</p><p>用<code>cv2.bilateralFilter()</code>函数实现：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">img = cv2.imread(<span class="hljs-string">'lena.jpg'</span>)<br><span class="hljs-comment"># 双边滤波vs高斯滤波</span><br>gau = cv2.GaussianBlur(img, (<span class="hljs-number">5</span>, <span class="hljs-number">5</span>), <span class="hljs-number">0</span>)  <span class="hljs-comment"># 高斯滤波</span><br>blur = cv2.bilateralFilter(img, <span class="hljs-number">9</span>, <span class="hljs-number">75</span>, <span class="hljs-number">75</span>)  <span class="hljs-comment"># 双边滤波</span><br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_bilateral_vs_gaussian.jpg" width="80%"></p><p>可以看到，双边滤波明显保留了更多边缘信息。</p><h2 id="番外小篇：高斯滤波卷积核"><a href="#番外小篇：高斯滤波卷积核" class="headerlink" title="番外小篇：高斯滤波卷积核"></a>番外小篇：高斯滤波卷积核</h2><p>要解释高斯滤波卷积核是如何生成的，需要先复习下概率论的知识（What？？又是数学( ╯□╰ )）</p><p>一维的高斯函数/正态分布$X\sim{N(\mu,\sigma^{2})}$：</p><script type="math/tex; mode=display">G(x)=\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^{2}}{2\sigma^{2}}}</script><p>当$\mu=0$，$\sigma^{2}=1$时，称为标准正态分布$X\sim{N(0,1)}$：</p><script type="math/tex; mode=display">G(x)=\frac{1}{\sqrt{2\pi}}e^{-\frac{x^{2}}{2}}</script><p>二维X/Y相互独立的高斯函数：</p><script type="math/tex; mode=display">G(x,y)=\frac{1}{2\pi\sigma_x\sigma_y}e^{-\frac{(x-\mu_x)^2+(y-\mu_y)^2}{2\sigma_{x}\sigma_{y}}}=G(x)G(y)</script><p>由上可知，<strong>二维高斯函数具有可分离性</strong>。</p><p>所以OpenCV分两步计算二维高斯卷积：先水平再垂直，每个方向上都是一维的卷积。</p><p>OpenCV中这个一维卷积的计算公式类似于上面的一维高斯函数：</p><script type="math/tex; mode=display">G(i)=\alpha*e^{-\frac{(i-\frac{ksize-1}{2})^{2}}{2\sigma^{2}}}</script><p>其中i=0,…,ksize-1，$\alpha$是一个常数，也称为放缩因子，它使得$\sum{G(i)}=1$</p><p>比如我们可以用<code>cv2.getGaussianKernel(ksize,sigma)</code>来生成一维卷积核：</p><ul><li>sigma&lt;=0时，sigma=0.3<em>((ksize-1)</em>0.5 - 1) + 0.8</li><li>sigma&gt;0时，sigma=sigma</li></ul><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">print(cv2.getGaussianKernel(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>))<br><span class="hljs-comment"># 结果：[[0.25][0.5][0.25]]</span><br></code></pre></td></tr></table></figure><p>生成之后，先进行三次的水平卷积：</p><script type="math/tex; mode=display">I\times{\begin{bmatrix}0.25&0.5&0.25\\0.25&0.5&0.25\\0.25&0.5&0.25\end{bmatrix}}</script><p>然后再进行垂直的三次卷积：</p><script type="math/tex; mode=display">I\times{\begin{bmatrix}0.25&0.5&0.25\\0.25&0.5&0.25\\0.25&0.5&0.25\end{bmatrix}}\times{\begin{bmatrix}0.25&0.5&0.25\\0.25&0.5&0.25\\0.25&0.5&0.25\end{bmatrix}}=I\times{\begin{bmatrix}0.0625&0.125&0.0625\\0.125&0.25&0.125\\0.0625&0.125&0.0625\end{bmatrix}}</script><p>这就是OpenCV中高斯卷积核的生成方式。其实，OpenCV源码中对小于7×7的核是直接计算好放在数组里面的，这样计算速度会快一点，感兴趣的可以看下源码：<a href="https://github.com/ex2tron/OpenCV-Python-Tutorial/blob/master/10. 平滑图像/cv2_source_code_getGaussianKernel.cpp" target="_blank" rel="noopener">getGaussianKernel()</a></p><p>上面矩阵也可以写成：</p><script type="math/tex; mode=display">\frac{1}{16}\begin{bmatrix}1&2&1\\2&4&2\\1&2&1\end{bmatrix}</script><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><ul><li><a href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#ga8c45db9afe636703801b0b2e440fce37" target="_blank" rel="noopener">cv2.blur()</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#gad533230ebf2d42509547d514f7d3fbc3" target="_blank" rel="noopener">cv2.boxFilter()</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#gaabe8c836e97159a9193fb0b11ac52cf1" target="_blank" rel="noopener">cv2.GaussianBlur()</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#gac05a120c1ae92a6060dd0db190a61afa" target="_blank" rel="noopener">cv2.getGaussianKernel()</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#ga564869aa33e58769b4469101aac458f9" target="_blank" rel="noopener">cv2.medianBlur()</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#ga9d7064d478c95d60003cf839430737ed" target="_blank" rel="noopener">cv2.bilateralFilter()</a></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_filtering/py_filtering.html" target="_blank" rel="noopener">Smoothing Images</a></li><li><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/gausian_median_blur_bilateral_filter/gausian_median_blur_bilateral_filter.html" target="_blank" rel="noopener">图像平滑处理</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 模糊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程番外篇8：卷积基础(图片边框)</title>
      <link href="/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%878%EF%BC%9A%E5%8D%B7%E7%A7%AF%E5%9F%BA%E7%A1%80-%E5%9B%BE%E7%89%87%E8%BE%B9%E6%A1%86/"/>
      <url>/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%878%EF%BC%9A%E5%8D%B7%E7%A7%AF%E5%9F%BA%E7%A1%80-%E5%9B%BE%E7%89%87%E8%BE%B9%E6%A1%86/</url>
      
        <content type="html"><![CDATA[<p>了解卷积/滤波的基础知识，给图片添加边框。如果你已了解相关理论，请直接跳到部分。</p><p>卷积的概念其实很好理解，下面我就给大家做个最简单的解释，绝对轻松加愉快的辣o(<em>￣▽￣</em>)o</p><a id="more"></a><h2 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h2><p>可以看下面这张图片了解二维卷积：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_understand_convolution.jpg" width="70%"></p><p>卷积就是<strong>循环对图像跟一个核逐个元素相乘再求和得到另外一副图像的操作</strong>，比如结果图中第一个元素5是怎么算的呢？原图中3×3的区域与3×3的核逐个元素相乘再相加：</p><script type="math/tex; mode=display">5=1\times{1}+2\times{0}+1\times{0}+0\times{0}+1\times{0}+3\times{0}+0\times{0}+2\times{2}</script><p>算完之后，整个框再往右移一步继续计算，横向计算完后，再往下移一步继续计算……网上有一副很经典的动态图，方便我们理解卷积：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_understand_cnn.gif" width="70%"></p><h2 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h2><p>不难发现，前面我们用3×3的核对一副6×6的图像进行卷积，得到的是4×4的图，图片缩小了！那怎么办呢？我们可以<strong>把原图扩充一圈，再卷积，这个操作叫填充padding</strong>。</p><blockquote><p>事实上，原图为n×n，卷积核为f×f，最终结果图大小为(n-f+1) × (n-f+1)。</p></blockquote><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_understand_padding.jpg" width="70%"></p><p>那么扩展的这一层应该填充什么值呢？OpenCV中有好几种填充方式，都使用<code>cv2.copyMakeBorder()</code>函数实现，一起来看看。</p><h2 id="添加边框"><a href="#添加边框" class="headerlink" title="添加边框"></a>添加边框</h2><p><code>cv2.copyMakeBorder()</code>用来给图片添加边框，它有下面几个参数：</p><ul><li>src：要处理的原图</li><li>top, bottom, left, right：上下左右要扩展的像素数</li><li><strong>borderType</strong>：边框类型，这个就是需要关注的填充方式，详情请参考：<a href="https://docs.opencv.org/3.3.1/d2/de8/group__core__array.html#ga209f2f4869e304c82d07739337eae7c5" target="_blank" rel="noopener">BorderTypes</a></li></ul><p>其中默认方式和固定值方式最常用，我们详细说明一下：</p><h3 id="固定值填充"><a href="#固定值填充" class="headerlink" title="固定值填充"></a>固定值填充</h3><p>顾名思义，<code>cv2.BORDER_CONSTANT</code>这种方式就是边框都填充成一个固定的值，比如下面的程序都填充0：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>img = cv2.imread(<span class="hljs-string">'6_by_6.bmp'</span>, <span class="hljs-number">0</span>)<br>print(img)<br><span class="hljs-comment"># 结果应该如下：</span><br><span class="hljs-comment"># [[213 166 237 240 196 243]</span><br><span class="hljs-comment">#  [166  81 213 181  34 197]</span><br><span class="hljs-comment">#  [237 217 247 240 196 243]</span><br><span class="hljs-comment">#  [245 200 241 241 199 240]</span><br><span class="hljs-comment">#  [200  38 190 189  35 197]</span><br><span class="hljs-comment">#  [241 185 237 240 189 241]]</span><br><br><span class="hljs-comment"># 固定值边框：zero padding</span><br>cons = cv2.copyMakeBorder(img, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, cv2.BORDER_CONSTANT, value=<span class="hljs-number">0</span>)<br>print(cons)<br><span class="hljs-comment"># 结果应该如下：</span><br><span class="hljs-comment"># [[0   0   0   0   0   0   0   0]</span><br><span class="hljs-comment">#  [0 213 166 237 240 196 243   0]</span><br><span class="hljs-comment">#  [0 166  81 213 181  34 197   0]</span><br><span class="hljs-comment">#  [0 237 217 247 240 196 243   0]</span><br><span class="hljs-comment">#  [0 245 200 241 241 199 240   0]</span><br><span class="hljs-comment">#  [0 200  38 190 189  35 197   0]</span><br><span class="hljs-comment">#  [0 241 185 237 240 189 241   0]</span><br><span class="hljs-comment">#  [0   0   0   0   0   0   0   0]]</span><br></code></pre></td></tr></table></figure><h3 id="默认边框类型"><a href="#默认边框类型" class="headerlink" title="默认边框类型"></a>默认边框类型</h3><p>默认边框<code>cv2.BORDER_DEFAULT</code>其实是取镜像对称的像素填充，比较拗口，一步步解释：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>img = cv2.imread(<span class="hljs-string">'6_by_6.bmp'</span>, <span class="hljs-number">0</span>)<br>print(img)<br><span class="hljs-comment"># 结果应该如下：</span><br><span class="hljs-comment"># [[213 166 237 240 196 243]</span><br><span class="hljs-comment">#  [166  81 213 181  34 197]</span><br><span class="hljs-comment">#  [237 217 247 240 196 243]</span><br><span class="hljs-comment">#  [245 200 241 241 199 240]</span><br><span class="hljs-comment">#  [200  38 190 189  35 197]</span><br><span class="hljs-comment">#  [241 185 237 240 189 241]]</span><br><br><span class="hljs-comment"># 默认边框类型</span><br>default = cv2.copyMakeBorder(img, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, cv2.BORDER_DEFAULT)<br>print(default)<br><span class="hljs-comment"># 结果应该如下：</span><br><span class="hljs-comment"># [[ 81 166  81 213 181  34 197  34]</span><br><span class="hljs-comment">#  [166 213 166 237 240 196 243 196]</span><br><span class="hljs-comment">#  [ 81 166  81 213 181  34 197  34]</span><br><span class="hljs-comment">#  [217 237 217 247 240 196 243 196]</span><br><span class="hljs-comment">#  [200 245 200 241 241 199 240 199]</span><br><span class="hljs-comment">#  [ 38 200  38 190 189  35 197  35]</span><br><span class="hljs-comment">#  [185 241 185 237 240 189 241 189]</span><br><span class="hljs-comment">#  [ 38 200  38 190 189  35 197  35]]</span><br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_up_down_padding_first.jpg"></p><p>同理再进行左右两边的填充，最后把四个顶点补充上就好了：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_right_left_padding_second2.jpg"></p><blockquote><p>经验之谈：一般情况下默认方式更加合理，因为边界的像素值更加接近。具体应视场合而定。</p></blockquote><h2 id="OpenCV进行卷积"><a href="#OpenCV进行卷积" class="headerlink" title="OpenCV进行卷积"></a>OpenCV进行卷积</h2><p>OpenCV中用<code>cv2.filter2D()</code>实现卷积操作，比如我们的核是下面这样（3×3区域像素的和除以10）：</p><script type="math/tex; mode=display">M=\frac{1}{10}\begin{bmatrix}1&1&1\\1&1&1\\1&1&1\end{bmatrix}</script><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">img = cv2.imread(<span class="hljs-string">'lena.jpg'</span>)<br><span class="hljs-comment"># 定义卷积核</span><br>kernel = np.ones((<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), np.float32) / <span class="hljs-number">10</span><br><span class="hljs-comment"># 卷积操作，-1表示通道数与原图相同</span><br>dst = cv2.filter2D(img, <span class="hljs-number">-1</span>, kernel)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_convolution_kernel_3_3.jpg"></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_core/py_basic_ops/py_basic_ops.html" target="_blank" rel="noopener">Basic Operations on Images</a></li><li><a href="http://blog.csdn.net/zouxy09/article/details/49080029" target="_blank" rel="noopener">图像卷积与滤波的一些知识点</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 卷积 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程9：图像混合</title>
      <link href="/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B9%EF%BC%9A%E5%9B%BE%E5%83%8F%E6%B7%B7%E5%90%88/"/>
      <url>/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B9%EF%BC%9A%E5%9B%BE%E5%83%8F%E6%B7%B7%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p>学习图片间的数学运算，图像混合。</p><p>目标：</p><ul><li>学习图片间的数学运算，如相加、按位运算等。</li><li>OpenCV函数：<ul><li><code>cv2.add()</code>：叠加两幅图片。</li><li><code>cv2.addWeighted()</code>：叠加两幅图片，可自定义两幅图片的权重。</li><li><code>cv2.bitwise_and()</code>：执行按位与运算。</li><li><code>cv2.bitwise_not()</code>：执行按位非运算。</li><li><code>cv2.bitwise_or()</code>：执行按位或运算。</li><li><code>cv2.bitwise_xor()</code>：执行按位异或运算。</li></ul></li><li>掩膜就是用来对图片进行全局或局部的遮挡。</li></ul><a id="more"></a><h2 id="图片相加"><a href="#图片相加" class="headerlink" title="图片相加"></a>图片相加</h2><p>要叠加两张图片，可以用<code>cv2.add()</code>函数，相加两幅图片的形状（高度/宽度/通道数）必须相同。</p><p>numpy中可以直接用res = img + img1相加，但这两者的结果并不相同：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">x = np.uint8([<span class="hljs-number">250</span>])<br>y = np.uint8([<span class="hljs-number">10</span>])<br>print(cv2.add(x, y))  <span class="hljs-comment"># 250+10 = 260 =&gt; 255</span><br>print(x + y)  <span class="hljs-comment"># 250+10 = 260 % 256 = 4</span><br></code></pre></td></tr></table></figure><p>如果是二值化图片（只有0和255两种值），两者结果是一样的（用numpy的方式更简便一些）。</p><h2 id="图像混合"><a href="#图像混合" class="headerlink" title="图像混合"></a>图像混合</h2><p>图像混合<code>cv2.addWeighted()</code>也是一种图片相加的操作，只不过两幅图片的权重不一样，γ相当于一个修正值：</p><script type="math/tex; mode=display">dst=\alpha\times{img1}+\beta\times{img2}+\gamma</script><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">img1 = cv2.imread(<span class="hljs-string">'lena_small.jpg'</span>)<br>img2 = cv2.imread(<span class="hljs-string">'opencv-logo-white.png'</span>)<br>res = cv2.addWeighted(img1, <span class="hljs-number">0.6</span>, img2, <span class="hljs-number">0.4</span>, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_image_blending_6_4.jpg" width="80%"></p><blockquote><p>经验之谈：$\alpha$和$\beta$都等于1时，就相当于图片相加。</p></blockquote><h2 id="按位操作"><a href="#按位操作" class="headerlink" title="按位操作"></a>按位操作</h2><p>按位操作包括按位与/或/非/异或操作，有什么用途呢？比如说我们要实现下图的效果：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_bitwise_operations_demo.jpg"></p><p>如果将两幅图片直接相加会改变图片的颜色，如果用图像混合，则会改变图片的透明度，所以我们需要用<strong>按位操作</strong>。</p><p>首先来了解一下<a href="https://baike.baidu.com/item/掩膜/8544392?fr=aladdin" target="_blank" rel="noopener">掩膜</a>（mask）的概念：</p><blockquote><p>掩膜是用一副二值化图片对另外一幅图片进行局部的遮挡</p></blockquote><p>看下图就一目了然了：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_understand_mask.jpg"></p><p>所以我们的思路就是把原图中要放logo的区域抠出来，再把logo放进去就行了：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br><span class="hljs-comment"># 按位操作</span><br>img1 = cv2.imread(<span class="hljs-string">'lena.jpg'</span>)<br>img2 = cv2.imread(<span class="hljs-string">'opencv-logo-white.png'</span>)<br><br><span class="hljs-comment"># 把logo放在左上角，所以我们只关心这一块区域</span><br>rows, cols = img2.shape[:<span class="hljs-number">2</span>]  <span class="hljs-comment"># img2.shape为(172,172,3)</span><br>roi = img1[:rows, :cols]  <span class="hljs-comment"># 获取指定区域</span><br><br><br><span class="hljs-comment"># 创建掩膜</span><br>img2gray = cv2.cvtColor(img2, cv2.COLOR_BGR2GRAY)  <span class="hljs-comment"># 颜色空间转换</span><br><span class="hljs-comment"># 设置阈值, mask为结果</span><br>ret, mask = cv2.threshold(img2gray, <span class="hljs-number">10</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY)<br>mask_inv = cv2.bitwise_not(mask)    <span class="hljs-comment"># 做取反操作</span><br><br><span class="hljs-comment"># 保留除logo外的背景</span><br>img1_bg = cv2.bitwise_and(roi, roi, mask=mask_inv)<br>dst = cv2.add(img1_bg, img2)  <span class="hljs-comment"># 进行融合</span><br>img1[:rows, :cols] = dst  <span class="hljs-comment"># 融合后放在原图上</span><br><br>cv2.imshow(<span class="hljs-string">'result'</span>, img1)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><blockquote><p>经验之谈：掩膜的概念在图像混合/叠加的场景下使用较多，可以多多练习噢！</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><ul><li><a href="https://docs.opencv.org/4.0.0/d2/de8/group__core__array.html#ga10ac1bfb180e2cfda1701d06c24fdbd6" target="_blank" rel="noopener">cv2.add()</a></li><li><a href="https://docs.opencv.org/4.0.0/d2/de8/group__core__array.html#gafafb2513349db3bcff51f54ee5592a19" target="_blank" rel="noopener">cv2.addWeighted()</a></li><li><a href="https://docs.opencv.org/4.0.0/d2/de8/group__core__array.html#ga60b4d04b251ba5eb1392c34425497e14" target="_blank" rel="noopener">cv2.bitwise_and()</a></li><li><a href="https://docs.opencv.org/4.0.0/d2/de8/group__core__array.html#ga0002cf8b418479f4cb49a75442baee2f" target="_blank" rel="noopener">cv2.bitwise_not()</a></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="https://baike.baidu.com/item/掩膜/8544392?fr=aladdin" target="_blank" rel="noopener">掩膜</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_core/py_image_arithmetics/py_image_arithmetics.html" target="_blank" rel="noopener">Arithmetic Operations on Images</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 图像混合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程番外篇7：亮度与对比度</title>
      <link href="/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%877%EF%BC%9A%E4%BA%AE%E5%BA%A6%E4%B8%8E%E5%AF%B9%E6%AF%94%E5%BA%A6/"/>
      <url>/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%877%EF%BC%9A%E4%BA%AE%E5%BA%A6%E4%B8%8E%E5%AF%B9%E6%AF%94%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>学习如何调整图片的亮度和对比度。</p><a id="more"></a><h2 id="亮度与对比度"><a href="#亮度与对比度" class="headerlink" title="亮度与对比度"></a>亮度与对比度</h2><ul><li>亮度调整是将图像像素的强度整体变大/变小。</li><li>对比度调整指的是图像暗处的像素强度变低，亮处的变高，从而拓宽某个区域内的显示精度。</li></ul><p>OpenCV中亮度和对比度应用这个公式来计算：</p><script type="math/tex; mode=display">g(x)=\alpha f(x)+\beta</script><p>其中：$\alpha(&gt;0)$、$\beta$常称为增益与偏置值，分别控制图片的对比度和亮度。</p><blockquote><p>经验之谈：此处对α/β控制对比度和亮度有争议，具体请参考：<a href="http://blog.csdn.net/abc20002929/article/details/40474807" target="_blank" rel="noopener">OpenCV关于对比度和亮度的误解</a>。</p></blockquote><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>img = cv2.imread(<span class="hljs-string">'lena.jpg'</span>)<br><span class="hljs-comment"># numpy默认是取模运算，250+10 = 260%256 = 4</span><br><span class="hljs-comment"># 所以此处需要用np.clip进行范围限定，</span><br><span class="hljs-comment"># a&lt;0 =&gt; a=0, a&gt;255 =&gt; a=255</span><br>res = np.uint8(np.clip((<span class="hljs-number">1.5</span> * img + <span class="hljs-number">10</span>), <span class="hljs-number">0</span>, <span class="hljs-number">255</span>))<br><br><span class="hljs-comment"># 两张图片横向合并（便于对比显示）</span><br>tmp = np.hstack((img, res))<br>cv2.imshow(<span class="hljs-string">'image'</span>, tmp)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>还记得图像混合那一节中numpy对数据溢出的取模处理吗？<code>250+10 = 260 =&gt; 260%256=4</code>，它并不适用于我们的图像处理，所以用<a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.clip.html#numpy.clip" target="_blank" rel="noopener">np.clip()</a>函数将数据限定：<code>a&lt;0 =&gt; a=0, a&gt;255 =&gt; a=255</code>。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_contrast_brightness.jpg"></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>创建两个滑动条分别调整对比度和亮度（对比度范围：0~0.3，亮度：0~100）。提示：因为滑动条没有小数，所以可以设置为0~300，然后乘以0.01。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nothing</span><span class="hljs-params">(x)</span>:</span><br>    <span class="hljs-string">'''<br>    ### 回调函数，暂时无用<br>    '''</span><br>    <span class="hljs-keyword">pass</span><br><br><br>img = cv2.imread(<span class="hljs-string">'lena.jpg'</span>)<br>cv2.namedWindow(<span class="hljs-string">'image'</span>)<br><br><span class="hljs-comment"># 创建两个滑块</span><br>cv2.createTrackbar(<span class="hljs-string">'brightness'</span>, <span class="hljs-string">'image'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, nothing)<br>cv2.createTrackbar(<span class="hljs-string">'contrast'</span>, <span class="hljs-string">'image'</span>, <span class="hljs-number">100</span>, <span class="hljs-number">300</span>, nothing)<br><br>temp = img.copy()<br>rows, cols = img.shape[:<span class="hljs-number">2</span>]<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    cv2.imshow(<span class="hljs-string">'image'</span>, temp)<br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">1</span>) == <span class="hljs-number">27</span>:<br>        <span class="hljs-keyword">break</span><br><br>    <span class="hljs-comment"># 得到两个滑块的值</span><br>    brightness = cv2.getTrackbarPos(<span class="hljs-string">'brightness'</span>, <span class="hljs-string">'image'</span>)<br>    contrast = cv2.getTrackbarPos(<span class="hljs-string">'contrast'</span>, <span class="hljs-string">'image'</span>) * <span class="hljs-number">0.01</span><br>    <span class="hljs-comment"># 进行对比度和亮度调整</span><br>    temp = np.uint8(np.clip(contrast * img + brightness, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>))<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_liangdu_duibidu.png" width="70%"></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.clip.html#numpy.clip" target="_blank" rel="noopener">numpy.clip()</a></li><li><a href="http://blog.csdn.net/abc20002929/article/details/40474807" target="_blank" rel="noopener">OpenCV关于对比度和亮度的误解</a></li><li><a href="http://blog.csdn.net/u013139259/article/details/52145377" target="_blank" rel="noopener">OpenCV改变图像亮度和对比度以及优化</a></li><li><a href="https://docs.opencv.org/3.1.0/d3/d63/classcv_1_1Mat.html#a3f356665bb0ca452e7d7723ccac9a810" target="_blank" rel="noopener">Mat::convertTo</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 亮度 </tag>
            
            <tag> 对比度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程挑战任务：画动态时钟</title>
      <link href="/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E6%8C%91%E6%88%98%E4%BB%BB%E5%8A%A1%EF%BC%9A%E7%94%BB%E5%8A%A8%E6%80%81%E6%97%B6%E9%92%9F/"/>
      <url>/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E6%8C%91%E6%88%98%E4%BB%BB%E5%8A%A1%EF%BC%9A%E7%94%BB%E5%8A%A8%E6%80%81%E6%97%B6%E9%92%9F/</url>
      
        <content type="html"><![CDATA[<p>挑战任务：使用OpenCV绘制一个随系统时间动态变化的时钟，<strong>中间显示当前日期</strong>。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_draw_clock_dynamic_sample.gif" width="50%"></p><a id="more"></a><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>本次挑战任务旨在提升大家的动手实践能力，解决实际问题，所以我们得先有个解题思路和方案。观察下常见的时钟表盘：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_draw_clock_actual_clock_sample.jpg"></p><p>整个表盘其实只有3根表针在动，所以可以先画出静态表盘，然后获取系统当前时间，根据时间实时动态绘制3根表针就解决了。</p><h2 id="绘制表盘"><a href="#绘制表盘" class="headerlink" title="绘制表盘"></a>绘制表盘</h2><p>表盘上只有60条分/秒刻线和12条小时刻线，当然还有表盘的外部轮廓圆，也就是重点在如何画72根线。先把简单的圆画出来：</p><p>前面我们使用OpenCV画直线的时候，需知道直线的起点和终点坐标，那么画72根线就变成了获取72组坐标。</p><p>在平面坐标系下，已知半径和角度的话，A点的坐标可以表示为：</p><script type="math/tex; mode=display">x=r\times{\cos{\alpha}}\\y=r\times{\sin{\alpha}}</script><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_draw_clock_center_shift.jpg"></p><p>先只考虑将坐标系原点移动到左上角，角度依然是平面坐标系中的逆时针计算，那么新坐标是：</p><script type="math/tex; mode=display">x=r+r\times{\cos{\alpha}}\\y=r+r\times{\sin{\alpha}}</script><p>对于60条分/秒刻线，刻线间的夹角是360°/60=6°，对于小时刻线，角度是360°/12=30°，这样就得到了72组起点坐标，那怎么得到终点坐标呢？</p><p>其实同样的原理，用一个同心的小圆来计算得到B点：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_draw_clock_a_b_position.jpg"></p><p>通过A/B两点就可以画出直线：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python">pt1 = []<br><br><span class="hljs-comment"># 画出60条秒和分钟的刻线</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">60</span>):<br>    <span class="hljs-comment"># 最外部圆，计算A点</span><br>    x1 = center_x+(radius-margin)*math.cos(i*<span class="hljs-number">6</span>*np.pi/<span class="hljs-number">180.0</span>)<br>    y1 = center_y+(radius-margin)*math.sin(i*<span class="hljs-number">6</span>*np.pi/<span class="hljs-number">180.0</span>)<br>    pt1.append((int(x1), int(y1)))<br><br>    <span class="hljs-comment"># 同心小圆，计算B点</span><br>    x2 = center_x+(radius<span class="hljs-number">-15</span>)*math.cos(i*<span class="hljs-number">6</span>*np.pi/<span class="hljs-number">180.0</span>)<br>    y2 = center_y+(radius<span class="hljs-number">-15</span>)*math.sin(i*<span class="hljs-number">6</span>*np.pi/<span class="hljs-number">180.0</span>)<br><br>    cv2.line(img, pt1[i], (int(x2), int(y2)), (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), thickness=<span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 4. 画出12条小时的刻线</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">12</span>):<br>    <span class="hljs-comment"># 12条小时刻线应该更长一点</span><br>    x = center_x+(radius<span class="hljs-number">-25</span>)*math.cos(i*<span class="hljs-number">30</span>*np.pi/<span class="hljs-number">180.0</span>)<br>    y = center_y+(radius<span class="hljs-number">-25</span>)*math.sin(i*<span class="hljs-number">30</span>*np.pi/<span class="hljs-number">180.0</span>)<br>    <span class="hljs-comment"># 这里用到了前面的pt1</span><br>    cv2.line(img, pt1[i*<span class="hljs-number">5</span>], (int(x), int(y)), (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), thickness=<span class="hljs-number">5</span>)<br><br><span class="hljs-comment"># 到这里基本的表盘图就已经画出来了</span><br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_draw_clock_blank_clock.jpg"></p><h2 id="角度换算"><a href="#角度换算" class="headerlink" title="角度换算"></a>角度换算</h2><p>接下来算是一个小难点，首先<strong>时钟的起始坐标在正常二维坐标系的90°方向，其次时钟跟图像一样，都是顺时针计算角度的</strong>，所以三者需要统一下：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_draw_clock_different_clock_contrast.jpg"></p><p>因为角度是完全对称的，顺逆时针没有影响，所以平面坐标系完全不用理会，放在这里只是便于大家理解。对于时钟坐标和图像坐标，时钟0的0°对应图像的270°，时钟15的90°对应图像的360°，时钟30的180°对应图像的450°（360°+90°）…</p><p>所以两者之间的关系便是：</p><blockquote><p>计算角度 = 时钟角度+270°</p><p>计算角度 = 计算角度 if 计算角度&lt;=360° else 计算角度-360°</p></blockquote><h2 id="同步时间"><a href="#同步时间" class="headerlink" title="同步时间"></a>同步时间</h2><p>Python中如何获取当前时间和添加日期文字都比较简单，看代码就行，我就不解释了。代码中角度计算我换了一种方式，其实是一样的，看你能不能看懂(●ˇ∀ˇ●)：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment"># 不断拷贝表盘图，才能更新绘制，不然会重叠在一起</span><br>    temp = np.copy(img)<br><br>    <span class="hljs-comment"># 获取系统时间，画出动态的时-分-秒三条刻线</span><br>    now_time = datetime.datetime.now()<br>    hour, minute, second = now_time.hour, now_time.minute, now_time.second<br><br>    <span class="hljs-comment"># 画秒刻线</span><br>    <span class="hljs-comment"># 参见博客，OpenCV中的角度是顺时针计算的，所以需要转换下</span><br>    sec_angle = second * <span class="hljs-number">6</span> + <span class="hljs-number">270</span> <span class="hljs-keyword">if</span> second &lt;= <span class="hljs-number">15</span> <span class="hljs-keyword">else</span> (second - <span class="hljs-number">15</span>) * <span class="hljs-number">6</span><br>    sec_x = center_x + (radius - margin) * math.cos(sec_angle * np.pi / <span class="hljs-number">180.0</span>)<br>    sec_y = center_y + (radius - margin) * math.sin(sec_angle * np.pi / <span class="hljs-number">180.0</span>)<br>    cv2.line(temp, center, (int(sec_x), int(sec_y)), (<span class="hljs-number">203</span>, <span class="hljs-number">222</span>, <span class="hljs-number">166</span>), <span class="hljs-number">2</span>)<br><br>    <span class="hljs-comment"># 画分刻线</span><br>    min_angle = minute * <span class="hljs-number">6</span> + <span class="hljs-number">270</span> <span class="hljs-keyword">if</span> minute &lt;= <span class="hljs-number">15</span> <span class="hljs-keyword">else</span> (minute - <span class="hljs-number">15</span>) * <span class="hljs-number">6</span><br>    min_x = center_x + (radius - <span class="hljs-number">35</span>) * math.cos(min_angle * np.pi / <span class="hljs-number">180.0</span>)<br>    min_y = center_y + (radius - <span class="hljs-number">35</span>) * math.sin(min_angle * np.pi / <span class="hljs-number">180.0</span>)<br>    cv2.line(temp, center, (int(min_x), int(min_y)), (<span class="hljs-number">186</span>, <span class="hljs-number">199</span>, <span class="hljs-number">137</span>), <span class="hljs-number">8</span>)<br><br>    <span class="hljs-comment"># 画时刻线</span><br>    hour_angle = hour * <span class="hljs-number">30</span> + <span class="hljs-number">270</span> <span class="hljs-keyword">if</span> hour &lt;= <span class="hljs-number">3</span> <span class="hljs-keyword">else</span> (hour - <span class="hljs-number">3</span>) * <span class="hljs-number">30</span><br>    hour_x = center_x + (radius - <span class="hljs-number">65</span>) * math.cos(hour_angle * np.pi / <span class="hljs-number">180.0</span>)<br>    hour_y = center_y + (radius - <span class="hljs-number">65</span>) * math.sin(hour_angle * np.pi / <span class="hljs-number">180.0</span>)<br>    cv2.line(temp, center, (int(hour_x), int(hour_y)), (<span class="hljs-number">169</span>, <span class="hljs-number">198</span>, <span class="hljs-number">26</span>), <span class="hljs-number">15</span>)<br><br>    <span class="hljs-comment"># 添加当前日期文字</span><br>    font = cv2.FONT_HERSHEY_SIMPLEX<br>    time_str = now_time.strftime(<span class="hljs-string">"%d/%m/%Y"</span>)<br>    cv2.putText(img, time_str, (<span class="hljs-number">135</span>, <span class="hljs-number">275</span>), font, <span class="hljs-number">1</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">2</span>)<br><br>    cv2.imshow(<span class="hljs-string">'clocking'</span>, temp)<br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">1</span>) == <span class="hljs-number">27</span>:  <span class="hljs-comment"># 按下ESC键退出</span><br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p>本此挑战旨在锻炼一步步解决实际问题的思路（虽然有点数学知识(￣▽￣)”），大家再接再厉噢！</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">import</span> datetime<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>margin = <span class="hljs-number">5</span>  <span class="hljs-comment"># 上下左右边距</span><br>radius = <span class="hljs-number">220</span>  <span class="hljs-comment"># 圆的半径</span><br>center = (center_x, center_y) = (<span class="hljs-number">225</span>, <span class="hljs-number">225</span>)  <span class="hljs-comment"># 圆心</span><br><br><span class="hljs-comment"># 1. 新建一个画板并填充成白色</span><br>img = np.zeros((<span class="hljs-number">450</span>, <span class="hljs-number">450</span>, <span class="hljs-number">3</span>), np.uint8)<br>img[:] = (<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>)<br><br><span class="hljs-comment"># 2. 画出圆盘</span><br>cv2.circle(img, center, radius, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), thickness=<span class="hljs-number">5</span>)<br><br>pt1 = []<br><br><span class="hljs-comment"># 3. 画出60条秒和分钟的刻线</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">60</span>):<br>    <span class="hljs-comment"># 最外部圆，计算A点</span><br>    x1 = center_x + (radius - margin) * math.cos(i * <span class="hljs-number">6</span> * np.pi / <span class="hljs-number">180.0</span>)<br>    y1 = center_y + (radius - margin) * math.sin(i * <span class="hljs-number">6</span> * np.pi / <span class="hljs-number">180.0</span>)<br>    pt1.append((int(x1), int(y1)))<br><br>    <span class="hljs-comment"># 同心小圆，计算B点</span><br>    x2 = center_x + (radius - <span class="hljs-number">15</span>) * math.cos(i * <span class="hljs-number">6</span> * np.pi / <span class="hljs-number">180.0</span>)<br>    y2 = center_y + (radius - <span class="hljs-number">15</span>) * math.sin(i * <span class="hljs-number">6</span> * np.pi / <span class="hljs-number">180.0</span>)<br><br>    cv2.line(img, pt1[i], (int(x2), int(y2)), (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), thickness=<span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 4. 画出12条小时的刻线</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">12</span>):<br>    <span class="hljs-comment"># 12条小时刻线应该更长一点</span><br>    x = center_x + (radius - <span class="hljs-number">25</span>) * math.cos(i * <span class="hljs-number">30</span> * np.pi / <span class="hljs-number">180.0</span>)<br>    y = center_y + (radius - <span class="hljs-number">25</span>) * math.sin(i * <span class="hljs-number">30</span> * np.pi / <span class="hljs-number">180.0</span>)<br>    <span class="hljs-comment"># 这里用到了前面的pt1</span><br>    cv2.line(img, pt1[i * <span class="hljs-number">5</span>], (int(x), int(y)), (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), thickness=<span class="hljs-number">5</span>)<br><br><span class="hljs-comment"># 到这里基本的表盘图就已经画出来了</span><br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment"># 不断拷贝表盘图，才能更新绘制，不然会重叠在一起</span><br>    temp = np.copy(img)<br><br>    <span class="hljs-comment"># 5. 获取系统时间，画出动态的时-分-秒三条刻线</span><br>    now_time = datetime.datetime.now()<br>    hour, minute, second = now_time.hour, now_time.minute, now_time.second<br><br>    <span class="hljs-comment"># 画秒刻线</span><br>    <span class="hljs-comment"># 参见博客，OpenCV中的角度是顺时针计算的，所以需要转换下</span><br>    sec_angle = second * <span class="hljs-number">6</span> + <span class="hljs-number">270</span> <span class="hljs-keyword">if</span> second &lt;= <span class="hljs-number">15</span> <span class="hljs-keyword">else</span> (second - <span class="hljs-number">15</span>) * <span class="hljs-number">6</span><br>    sec_x = center_x + (radius - margin) * math.cos(sec_angle * np.pi / <span class="hljs-number">180.0</span>)<br>    sec_y = center_y + (radius - margin) * math.sin(sec_angle * np.pi / <span class="hljs-number">180.0</span>)<br>    cv2.line(temp, center, (int(sec_x), int(sec_y)), (<span class="hljs-number">203</span>, <span class="hljs-number">222</span>, <span class="hljs-number">166</span>), <span class="hljs-number">2</span>)<br><br>    <span class="hljs-comment"># 画分刻线</span><br>    min_angle = minute * <span class="hljs-number">6</span> + <span class="hljs-number">270</span> <span class="hljs-keyword">if</span> minute &lt;= <span class="hljs-number">15</span> <span class="hljs-keyword">else</span> (minute - <span class="hljs-number">15</span>) * <span class="hljs-number">6</span><br>    min_x = center_x + (radius - <span class="hljs-number">35</span>) * math.cos(min_angle * np.pi / <span class="hljs-number">180.0</span>)<br>    min_y = center_y + (radius - <span class="hljs-number">35</span>) * math.sin(min_angle * np.pi / <span class="hljs-number">180.0</span>)<br>    cv2.line(temp, center, (int(min_x), int(min_y)), (<span class="hljs-number">186</span>, <span class="hljs-number">199</span>, <span class="hljs-number">137</span>), <span class="hljs-number">8</span>)<br><br>    <span class="hljs-comment"># 画时刻线</span><br>    hour_angle = hour * <span class="hljs-number">30</span> + <span class="hljs-number">270</span> <span class="hljs-keyword">if</span> hour &lt;= <span class="hljs-number">3</span> <span class="hljs-keyword">else</span> (hour - <span class="hljs-number">3</span>) * <span class="hljs-number">30</span><br>    hour_x = center_x + (radius - <span class="hljs-number">65</span>) * math.cos(hour_angle * np.pi / <span class="hljs-number">180.0</span>)<br>    hour_y = center_y + (radius - <span class="hljs-number">65</span>) * math.sin(hour_angle * np.pi / <span class="hljs-number">180.0</span>)<br>    cv2.line(temp, center, (int(hour_x), int(hour_y)), (<span class="hljs-number">169</span>, <span class="hljs-number">198</span>, <span class="hljs-number">26</span>), <span class="hljs-number">15</span>)<br><br>    <span class="hljs-comment"># 6. 添加当前日期文字</span><br>    font = cv2.FONT_HERSHEY_SIMPLEX<br>    time_str = now_time.strftime(<span class="hljs-string">"%d/%m/%Y"</span>)<br>    cv2.putText(img, time_str, (<span class="hljs-number">135</span>, <span class="hljs-number">275</span>), font, <span class="hljs-number">1</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">2</span>)<br><br>    cv2.imshow(<span class="hljs-string">'clocking'</span>, temp)<br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">1</span>) == <span class="hljs-number">27</span>:  <span class="hljs-comment"># 按下ESC键退出</span><br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 绘图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程番外篇6：鼠标绘图</title>
      <link href="/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%876%EF%BC%9A%E9%BC%A0%E6%A0%87%E7%BB%98%E5%9B%BE/"/>
      <url>/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%876%EF%BC%9A%E9%BC%A0%E6%A0%87%E7%BB%98%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>学习如何用鼠标实时绘图。</p><p>目标：</p><ul><li>捕获鼠标事件</li><li>OpenCV函数：<code>cv2.setMouseCallback()</code></li><li>要用鼠标绘图，需要用<code>cv2.setMouseCallback()</code>定义回调函数，然后在回调函数中根据不同的event事件，执行不同的功能。</li></ul><a id="more"></a><h2 id="确定鼠标位置"><a href="#确定鼠标位置" class="headerlink" title="确定鼠标位置"></a>确定鼠标位置</h2><p>OpenCV中，我们需要创建一个鼠标的回调函数来获取鼠标当前的位置、当前的事件如左键按下/左键释放或是右键单击等等，然后执行相应的功能。</p><p>使用<code>cv2.setMouseCallback()</code>来创建鼠标的回调函数，比如我们在左键单击的时候，打印出当前鼠标的位置：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mouse_event</span><span class="hljs-params">(event, x, y, flags, param)</span>:</span><br>    <span class="hljs-string">'''<br>    ### 鼠标的回调函数<br>    '''</span><br>    <span class="hljs-comment"># 通过event判断具体是什么事件，这里是左键按下</span><br>    <span class="hljs-keyword">if</span> event == cv2.EVENT_LBUTTONDOWN:<br>        print((x, y))<br><br>img = np.zeros((<span class="hljs-number">512</span>, <span class="hljs-number">512</span>, <span class="hljs-number">3</span>), np.uint8)<br>cv2.namedWindow(<span class="hljs-string">'image'</span>)<br><span class="hljs-comment"># 定义鼠标的回调函数</span><br>cv2.setMouseCallback(<span class="hljs-string">'image'</span>, mouse_event)<br><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">True</span>):<br>    cv2.imshow(<span class="hljs-string">'image'</span>, img)<br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">20</span>) == ord(<span class="hljs-string">'q'</span>):<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p>上面的代码先定义鼠标的回调函数<code>mouse_event()</code>，然后在回调函数中判断是否是左键单击事件 <code>EVENT_LBUTTONDOWN</code>，是的话就打印出坐标。需要注意的是，<strong>回调函数的参数格式是固定的</strong>，不要随意更改。</p><p>那除了左键单击之外，还有哪些事件呢？可以用下面的代码打印出来：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 获取所有的事件</span><br>events = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> dir(cv2) <span class="hljs-keyword">if</span> <span class="hljs-string">'EVENT'</span> <span class="hljs-keyword">in</span> i]<br>print(events)<br><br>**************************************************************<br><br>运行结果：<br>[<span class="hljs-string">'EVENT_FLAG_ALTKEY'</span>, <span class="hljs-string">'EVENT_FLAG_CTRLKEY'</span>, <span class="hljs-string">'EVENT_FLAG_LBUTTON'</span>, <span class="hljs-string">'EVENT_FLAG_MBUTTON'</span>, <span class="hljs-string">'EVENT_FLAG_RBUTTON'</span>, <span class="hljs-string">'EVENT_FLAG_SHIFTKEY'</span>, <span class="hljs-string">'EVENT_LBUTTONDBLCLK'</span>, <span class="hljs-string">'EVENT_LBUTTONDOWN'</span>, <span class="hljs-string">'EVENT_LBUTTONUP'</span>, <span class="hljs-string">'EVENT_MBUTTONDBLCLK'</span>, <span class="hljs-string">'EVENT_MBUTTONDOWN'</span>, <span class="hljs-string">'EVENT_MBUTTONUP'</span>, <span class="hljs-string">'EVENT_MOUSEHWHEEL'</span>, <span class="hljs-string">'EVENT_MOUSEMOVE'</span>, <span class="hljs-string">'EVENT_MOUSEWHEEL'</span>, <span class="hljs-string">'EVENT_RBUTTONDBLCLK'</span>, <span class="hljs-string">'EVENT_RBUTTONDOWN'</span>, <span class="hljs-string">'EVENT_RBUTTONUP'</span>]<br></code></pre></td></tr></table></figure><h2 id="综合实例"><a href="#综合实例" class="headerlink" title="综合实例"></a>综合实例</h2><p>现在我们来实现一个综合的例子，这个实例会帮助你理解图像交互的一些思想：</p><p>在图像上用鼠标画图，可以画圆或矩形，按m键在两种模式下切换。左键按下时开始画图，移动到哪儿画到哪儿，左键释放时结束画图。听上去很复杂，是吗？一步步来看：</p><ul><li>用鼠标画图：需要定义鼠标的回调函数mouse_event</li><li>画圆或矩形：需要定义一个画图的模式mode</li><li>左键单击、移动、释放：需要捕获三个不同的事件</li><li>开始画图，结束画图：需要定义一个画图的标记位drawing</li></ul><p>好，开始coding吧：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>drawing = <span class="hljs-literal">False</span>  <span class="hljs-comment"># 是否开始画图</span><br>mode = <span class="hljs-literal">True</span>  <span class="hljs-comment"># True：画矩形，False：画圆</span><br>start = (<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mouse_event</span><span class="hljs-params">(event, x, y, flags, param)</span>:</span><br>    <span class="hljs-keyword">global</span> start, drawing, mode<br><br>    <span class="hljs-comment"># 左键按下：开始画图</span><br>    <span class="hljs-keyword">if</span> event == cv2.EVENT_LBUTTONDOWN:<br>        drawing = <span class="hljs-literal">True</span><br>        start = (x, y)<br>    <span class="hljs-comment"># 鼠标移动，画图</span><br>    <span class="hljs-keyword">elif</span> event == cv2.EVENT_MOUSEMOVE:<br>        <span class="hljs-keyword">if</span> drawing:<br>            <span class="hljs-keyword">if</span> mode:<br>                cv2.rectangle(img, start, (x, y), (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>), <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">else</span>:<br>                cv2.circle(img, (x, y), <span class="hljs-number">5</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">-1</span>)<br>    <span class="hljs-comment"># 左键释放：结束画图</span><br>    <span class="hljs-keyword">elif</span> event == cv2.EVENT_LBUTTONUP:<br>        drawing = <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">if</span> mode:<br>            cv2.rectangle(img, start, (x, y), (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>), <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">else</span>:<br>            cv2.circle(img, (x, y), <span class="hljs-number">5</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">-1</span>)<br><br><br>img = np.zeros((<span class="hljs-number">512</span>, <span class="hljs-number">512</span>, <span class="hljs-number">3</span>), np.uint8)<br>cv2.namedWindow(<span class="hljs-string">'image'</span>)<br>cv2.setMouseCallback(<span class="hljs-string">'image'</span>, mouse_event)<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    cv2.imshow(<span class="hljs-string">'image'</span>, img)<br>    <span class="hljs-comment"># 按下m切换模式</span><br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">1</span>) == ord(<span class="hljs-string">'m'</span>):<br>        mode = <span class="hljs-keyword">not</span> mode<br>    <span class="hljs-comment"># 按下ESC退出</span><br>    <span class="hljs-keyword">elif</span> cv2.waitKey(<span class="hljs-number">1</span>) == <span class="hljs-number">27</span>:<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p>效果应该如下图所示：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_mouse_drawing_rectangle_circle.jpg"></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="练习1"><a href="#练习1" class="headerlink" title="练习1"></a>练习1</h3><p>实现用鼠标画矩形，跟实例差不多，但只实时画一个，类似于下面动画：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_live_draw_rectangle.gif"></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>start, end = (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>drawing = <span class="hljs-literal">False</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mouse_event</span><span class="hljs-params">(event, x, y, flags, param)</span>:</span><br>    <span class="hljs-keyword">global</span> start, drawing, end, temp<br><br>    <span class="hljs-comment"># 鼠标按下，开始画图：记录下起点</span><br>    <span class="hljs-keyword">if</span> event == cv2.EVENT_LBUTTONDOWN:<br>        drawing = <span class="hljs-literal">True</span><br>        start = (x, y)<br>    <span class="hljs-comment"># 实时移动的位置作为矩形终点（右下角点）</span><br>    <span class="hljs-keyword">elif</span> event == cv2.EVENT_MOUSEMOVE:<br>        <span class="hljs-keyword">if</span> drawing:<br>            end = (x, y)<br>    <span class="hljs-comment"># 鼠标释放后，停止绘图</span><br>    <span class="hljs-keyword">elif</span> event == cv2.EVENT_LBUTTONUP:<br>        drawing = <span class="hljs-literal">False</span><br>        cv2.rectangle(img, start, (x, y), (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>), <span class="hljs-number">2</span>)<br>        start = end = (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br><br><br>img = np.zeros((<span class="hljs-number">512</span>, <span class="hljs-number">512</span>, <span class="hljs-number">3</span>), np.uint8)<br>cv2.namedWindow(<span class="hljs-string">'image'</span>)<br>cv2.setMouseCallback(<span class="hljs-string">'image'</span>, mouse_event)<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment"># 下面这句话很关键，拷贝出原图，这样才可以实时画一个矩形</span><br>    temp = np.copy(img)<br>    <span class="hljs-keyword">if</span> drawing <span class="hljs-keyword">and</span> end != (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>):<br>        cv2.rectangle(temp, start, end, (<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">2</span>)<br><br>    cv2.imshow(<span class="hljs-string">'image'</span>, temp)<br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">20</span>) == <span class="hljs-number">27</span>:<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h3 id="练习2"><a href="#练习2" class="headerlink" title="练习2"></a>练习2</h3><p>做一个在白色面板上绘图的简单程序，可用滑动条调整颜色和笔刷大小。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nothing</span><span class="hljs-params">(x)</span>:</span><br>    <span class="hljs-string">'''<br>    ### 回调函数，x表示滑块的位置，本例暂不使用<br>    '''</span><br>    <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mouse_event</span><span class="hljs-params">(event, x, y, flags, param)</span>:</span><br>    <span class="hljs-string">'''<br>    ### 鼠标回调函数<br>    '''</span><br>    <span class="hljs-keyword">global</span> brush_size, brush_color, drawing<br><br>    <span class="hljs-keyword">if</span> event == cv2.EVENT_LBUTTONDOWN:<br>        drawing = <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">elif</span> event == cv2.EVENT_MOUSEMOVE:<br>        <span class="hljs-keyword">if</span> drawing:<br>            cv2.circle(img, (x, y), brush_size, brush_color, <span class="hljs-number">-1</span>)<br>    <span class="hljs-keyword">elif</span> event == cv2.EVENT_LBUTTONUP:<br>        drawing = <span class="hljs-literal">False</span><br>        cv2.circle(img, (x, y), brush_size, brush_color, <span class="hljs-number">-1</span>)<br><br><br>img = np.zeros((<span class="hljs-number">300</span>, <span class="hljs-number">512</span>, <span class="hljs-number">3</span>), np.uint8)<br>img[:] = (<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>)  <span class="hljs-comment"># 定义画板为白色</span><br>cv2.namedWindow(<span class="hljs-string">'painting'</span>)<br><br><span class="hljs-comment"># 定义默认的笔刷尺寸和颜色</span><br>brush_size, brush_color = <span class="hljs-number">8</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>drawing = <span class="hljs-literal">False</span><br><br><span class="hljs-comment"># 创建rgb三个滑动条</span><br>cv2.createTrackbar(<span class="hljs-string">'r'</span>, <span class="hljs-string">'painting'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, nothing)<br>cv2.createTrackbar(<span class="hljs-string">'g'</span>, <span class="hljs-string">'painting'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, nothing)<br>cv2.createTrackbar(<span class="hljs-string">'b'</span>, <span class="hljs-string">'painting'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, nothing)<br><span class="hljs-comment"># 创建笔刷大小滑动条</span><br>cv2.createTrackbar(<span class="hljs-string">'brush size'</span>, <span class="hljs-string">'painting'</span>, <span class="hljs-number">8</span>, <span class="hljs-number">15</span>, nothing)<br><span class="hljs-comment"># 定义鼠标回调函数</span><br>cv2.setMouseCallback(<span class="hljs-string">'painting'</span>, mouse_event)<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    cv2.imshow(<span class="hljs-string">'painting'</span>, img)<br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">1</span>) == <span class="hljs-number">27</span>:<br>        <span class="hljs-keyword">break</span><br><br>    r = cv2.getTrackbarPos(<span class="hljs-string">'r'</span>, <span class="hljs-string">'painting'</span>)<br>    g = cv2.getTrackbarPos(<span class="hljs-string">'g'</span>, <span class="hljs-string">'painting'</span>)<br>    b = cv2.getTrackbarPos(<span class="hljs-string">'b'</span>, <span class="hljs-string">'painting'</span>)<br>    brush_color = (b, g, r)<br>    brush_size = cv2.getTrackbarPos(<span class="hljs-string">'brush size'</span>, <span class="hljs-string">'painting'</span>)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_paint_ex2.png" width="70%"></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_mouse_handling/py_mouse_handling.html" target="_blank" rel="noopener">Mouse as a Paint-Brush</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 绘图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程8：绘图功能</title>
      <link href="/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B8%EF%BC%9A%E7%BB%98%E5%9B%BE%E5%8A%9F%E8%83%BD/"/>
      <url>/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B8%EF%BC%9A%E7%BB%98%E5%9B%BE%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>学习画线、圆和矩形等多种几何形状，给图片添加文字。</p><p>目标：</p><ul><li>绘制各种几何形状、添加文字</li><li>OpenCV函数<ul><li><code>cv2.line()</code>：直线</li><li><code>cv2.circle()</code>：圆</li><li><code>cv2.rectangle()</code>：矩形</li><li><code>cv2.ellipse()</code>：椭圆</li><li><code>cv2.polylines()</code>：多边形</li><li><code>cv2.putText()</code>：添加文字</li></ul></li></ul><p>画多条直线时，<code>cv2.polylines()</code>要比<code>cv2.line()</code>高效很多。</p><p><strong>所有绘图函数均会直接影响原图片，这点要注意。</strong></p><a id="more"></a><h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><p>绘制形状的函数有一些共同的参数，提前说明一下：</p><ul><li>img：要绘制形状的图片</li><li>color：绘制的颜色<ul><li>彩色图就传入BGR的一组值，如蓝色就是(255,0,0)</li><li>灰度图，传入一个灰度值就行</li></ul></li><li>thickness：线宽，默认为1；<strong>对于矩形/圆之类的封闭形状而言，传入-1表示填充形状</strong></li></ul><p>需要导入的模块和显示图片的通用代码：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>cv2.imshow(<span class="hljs-string">'img'</span>, img)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_drawing_functions.jpg"></p><p>上图就是本教程绘制的最终效果，下面一步步来看：</p><h3 id="画线"><a href="#画线" class="headerlink" title="画线"></a>画线</h3><p>画直线只需指定起点和终点的坐标就行：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 画一条线宽为5的蓝色直线</span><br><span class="hljs-comment"># 参数1：图片，参数2：起点，参数3：终点，参数4：BGR颜色，参数5：线宽</span><br>cv2.line(img, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">512</span>, <span class="hljs-number">512</span>), (<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><h3 id="画矩形"><a href="#画矩形" class="headerlink" title="画矩形"></a>画矩形</h3><p>画矩形需要知道左上角和右下角的坐标：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 画一个绿色边框的矩形</span><br><span class="hljs-comment"># 参数1：图片，参数2：左上角坐标，参数3：右下角坐标，参数4：BGR颜色，参数5：线宽（负数为填充）</span><br>cv2.rectangle(img, (<span class="hljs-number">384</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">510</span>, <span class="hljs-number">128</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>), <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><h3 id="画圆"><a href="#画圆" class="headerlink" title="画圆"></a>画圆</h3><p>画圆需要指定圆心和半径，注意下面的例子中线宽=-1代表填充：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 画一个填充红色的圆</span><br><span class="hljs-comment"># 参数1：图片，参数2：圆心坐标，参数3：半径，参数4：BGR颜色，参数5：线宽（负数为填充）</span><br>cv2.circle(img, (<span class="hljs-number">447</span>, <span class="hljs-number">63</span>), <span class="hljs-number">63</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">-1</span>)<br></code></pre></td></tr></table></figure><h3 id="画椭圆"><a href="#画椭圆" class="headerlink" title="画椭圆"></a>画椭圆</h3><p>画椭圆需要的参数比较多，请对照后面的代码理解这几个参数：</p><ul><li>参数2：椭圆中心(x,y)</li><li>参数3：x/y轴的长度</li><li>参数4：angle—椭圆的旋转角度（顺时针计算）</li><li>参数5：startAngle—椭圆的起始角度</li><li>参数6：endAngle—椭圆的结束角度</li></ul><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在图中心画一个填充的半圆</span><br><span class="hljs-comment"># 参数1：图片，参数2：椭圆中心，参数3：x/y轴长度，参数4：旋转角度</span><br><span class="hljs-comment"># 参数5：椭圆起始角度，参数6：椭圆结束角度，参数7：BGR颜色，参数8：线宽（负数为填充）</span><br>cv2.ellipse(img, (<span class="hljs-number">256</span>, <span class="hljs-number">256</span>), (<span class="hljs-number">100</span>, <span class="hljs-number">50</span>), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">180</span>, (<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">-1</span>)<br></code></pre></td></tr></table></figure><h3 id="画多边形"><a href="#画多边形" class="headerlink" title="画多边形"></a>画多边形</h3><p>画多边形需要指定一系列多边形的顶点坐标，相当于从第一个点到第二个点画直线，再从第二个点到第三个点画直线….</p><p>OpenCV中需要先将多边形的顶点坐标需要变成顶点数×1×2维的矩阵，再来绘制：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 画一个闭合的四边形</span><br><span class="hljs-comment"># 定义四个顶点坐标</span><br>pts = np.array([[<span class="hljs-number">10</span>, <span class="hljs-number">5</span>],  [<span class="hljs-number">50</span>, <span class="hljs-number">10</span>], [<span class="hljs-number">70</span>, <span class="hljs-number">20</span>], [<span class="hljs-number">20</span>, <span class="hljs-number">30</span>]], np.int32)<br><span class="hljs-comment"># 顶点个数：4，矩阵变成顶点数*1*2维（注意numpy中-1的用法）</span><br>pts = pts.reshape((<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br><span class="hljs-comment"># 参数1：图片，参数2：顶点集合，参数3：是否闭合，参数4：BGR颜色</span><br>cv2.polylines(img, [pts], <span class="hljs-literal">True</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>))<br></code></pre></td></tr></table></figure><p><code>cv2.polylines()</code>的参数3如果是False的话，多边形就不闭合，即<strong>最后一个点与第一个点不连</strong>。</p><blockquote><p>经验之谈：如果需要绘制多条直线，使用cv2.polylines()要比cv2.line()高效很多，例如：</p></blockquote><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用cv2.polylines()画多条直线</span><br>line1 = np.array([[<span class="hljs-number">100</span>, <span class="hljs-number">20</span>],  [<span class="hljs-number">300</span>, <span class="hljs-number">20</span>]], np.int32).reshape((<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br>line2 = np.array([[<span class="hljs-number">100</span>, <span class="hljs-number">60</span>],  [<span class="hljs-number">300</span>, <span class="hljs-number">60</span>]], np.int32).reshape((<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br>line3 = np.array([[<span class="hljs-number">100</span>, <span class="hljs-number">100</span>],  [<span class="hljs-number">300</span>, <span class="hljs-number">100</span>]], np.int32).reshape((<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br>cv2.polylines(img, [line1, line2, line3], <span class="hljs-literal">True</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>))<br></code></pre></td></tr></table></figure><h3 id="添加文字"><a href="#添加文字" class="headerlink" title="添加文字"></a>添加文字</h3><p>使用<code>cv2.putText()</code>添加文字，它的参数也比较多，同样请对照后面的代码理解这几个参数：</p><ul><li>参数2：要添加的文本</li><li>参数3：文字的起始坐标（左下角为起点）</li><li>参数4：字体</li><li>参数5：文字大小（缩放比例）</li></ul><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 添加文字</span><br>font = cv2.FONT_HERSHEY_SIMPLEX<br><span class="hljs-comment"># 参数1：图片，参数2：添加的文本内容，参数3：文字起始坐标，参数4：字体类型</span><br><span class="hljs-comment"># 参数5：字体大小，参数6：字体颜色，参数7：线宽，参数8：线型</span><br>cv2.putText(img, <span class="hljs-string">'ex2tron'</span>, (<span class="hljs-number">10</span>, <span class="hljs-number">500</span>), font,<br>            <span class="hljs-number">4</span>, (<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>), <span class="hljs-number">2</span>, lineType=cv2.LINE_AA)<br></code></pre></td></tr></table></figure><p>字体可参考：<a href="https://docs.opencv.org/4.0.0/d6/d6e/group__imgproc__draw.html#ga0f9314ea6e35f99bb23f29567fc16e11" target="_blank" rel="noopener">HersheyFonts</a>。另外，这里有个线型lineType参数，LINE_AA表示抗锯齿线型，具体可见<a href="https://docs.opencv.org/3.3.1/d0/de1/group__core.html#gaf076ef45de481ac96e0ab3dc2c29a777" target="_blank" rel="noopener">LineTypes</a>。</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>能用已学的绘图功能画出OpenCV的logo。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>img = np.zeros((<span class="hljs-number">200</span>, <span class="hljs-number">200</span>, <span class="hljs-number">3</span>), np.uint8)<br><br><span class="hljs-comment"># 画OpenCV的logo，其实很简单</span><br><span class="hljs-comment"># 1.先画一个0°到300°的圆</span><br><span class="hljs-comment"># 2.再在中心画一个跟背景颜色一样的小圆</span><br><span class="hljs-comment"># 3.重复前两部，并且旋转一定的角度即可</span><br><br><span class="hljs-comment"># 画绿色的部分</span><br>cv2.ellipse(img, (<span class="hljs-number">43</span>, <span class="hljs-number">125</span>), (<span class="hljs-number">45</span>, <span class="hljs-number">45</span>), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">300</span>,<br>            (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>), <span class="hljs-number">-1</span>, lineType=cv2.LINE_AA)<br>cv2.circle(img, (<span class="hljs-number">43</span>, <span class="hljs-number">125</span>), <span class="hljs-number">15</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">-1</span>, lineType=cv2.LINE_AA)<br><br><span class="hljs-comment"># 画红色的部分</span><br>cv2.ellipse(img, (<span class="hljs-number">90</span>, <span class="hljs-number">40</span>), (<span class="hljs-number">45</span>, <span class="hljs-number">45</span>), <span class="hljs-number">120</span>, <span class="hljs-number">0</span>, <span class="hljs-number">300</span>,<br>            (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">-1</span>, lineType=cv2.LINE_AA)<br>cv2.circle(img, (<span class="hljs-number">90</span>, <span class="hljs-number">40</span>), <span class="hljs-number">15</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">-1</span>, lineType=cv2.LINE_AA)<br><br><span class="hljs-comment"># 画蓝色的部分</span><br>cv2.ellipse(img, (<span class="hljs-number">137</span>, <span class="hljs-number">125</span>), (<span class="hljs-number">45</span>, <span class="hljs-number">45</span>), <span class="hljs-number">-60</span>, <span class="hljs-number">0</span>, <span class="hljs-number">300</span>,<br>            (<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">-1</span>, lineType=cv2.LINE_AA)<br>cv2.circle(img, (<span class="hljs-number">137</span>, <span class="hljs-number">125</span>), <span class="hljs-number">15</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">-1</span>, lineType=cv2.LINE_AA)<br><br>cv2.imshow(<span class="hljs-string">'img'</span>, img)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_draw_opencv_logo.jpg"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><ul><li><a href="https://docs.opencv.org/4.0.0/d6/d6e/group__imgproc__draw.html#ga7078a9fae8c7e7d13d24dac2520ae4a2" target="_blank" rel="noopener">cv2.line()</a></li><li><a href="https://docs.opencv.org/4.0.0/d6/d6e/group__imgproc__draw.html#gaf10604b069374903dbd0f0488cb43670" target="_blank" rel="noopener">cv2.circle()</a></li><li><a href="https://docs.opencv.org/4.0.0/d6/d6e/group__imgproc__draw.html#ga07d2f74cadcf8e305e810ce8eed13bc9" target="_blank" rel="noopener">cv2.rectangle()</a></li><li><a href="https://docs.opencv.org/4.0.0/d6/d6e/group__imgproc__draw.html#ga28b2267d35786f5f890ca167236cbc69" target="_blank" rel="noopener">cv2.ellipse()</a></li><li><a href="https://docs.opencv.org/4.0.0/d6/d6e/group__imgproc__draw.html#ga5126f47f883d730f633d74f07456c576" target="_blank" rel="noopener">cv2.putText()</a></li><li><a href="https://docs.opencv.org/4.0.0/d6/d6e/group__imgproc__draw.html#ga1ea127ffbbb7e0bfc4fd6fd2eb64263c" target="_blank" rel="noopener">cv2.polylines()</a></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="https://docs.opencv.org/3.3.1/d0/de1/group__core.html#gaf076ef45de481ac96e0ab3dc2c29a777" target="_blank" rel="noopener">LineTypes</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_drawing_functions/py_drawing_functions.html" target="_blank" rel="noopener">Drawing Functions in OpenCV</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 绘图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-OpenCV教程番外篇5：仿射变换与透视变换</title>
      <link href="/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%875%EF%BC%9A%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2%E4%B8%8E%E9%80%8F%E8%A7%86%E5%8F%98%E6%8D%A2/"/>
      <url>/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%875%EF%BC%9A%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2%E4%B8%8E%E9%80%8F%E8%A7%86%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>常见的2D图像变换从原理上讲主要包括基于2×3矩阵的<a href="https://baike.baidu.com/item/仿射变换" target="_blank" rel="noopener">仿射变换</a>和基于3×3矩阵<a href="https://baike.baidu.com/item/透视变换" target="_blank" rel="noopener">透视变换</a>。</p><a id="more"></a><h2 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h2><p>基本的图像变换就是二维坐标的变换：从一种二维坐标(x,y)到另一种二维坐标(u,v)的线性变换：</p><script type="math/tex; mode=display">u=a_1x+b_1y+c_1\\v=a_2x+b_2y+c_2</script><p>如果写成矩阵的形式，就是：</p><script type="math/tex; mode=display">\begin{bmatrix}u\\v\end{bmatrix}=\begin{bmatrix}a_1 & b_1\\a_2 & b_2\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}+\begin{bmatrix}c_1\\c_2\end{bmatrix}</script><p>作如下定义：</p><script type="math/tex; mode=display">R=\begin{bmatrix}a_1&b_1\\a_2&b_2\end{bmatrix},t=\begin{bmatrix}c_1\\c_2\end{bmatrix},T=\begin{bmatrix}R&t\end{bmatrix}</script><p>矩阵T(2×3)就称为<strong>仿射变换的变换矩阵</strong>，R为<strong>线性变换矩阵</strong>，t为<strong>平移矩阵</strong>。</p><p>简单来说，<strong>仿射变换就是线性变换+平移</strong>。变换后直线依然是直线，平行线依然是平行线，直线间的相对位置关系不变，因此<strong>非共线的三个对应点便可确定唯一的一个仿射变换</strong>，<em>线性变换4个自由度+平移2个自由度</em>→<strong>仿射变换自由度为6</strong>。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_warp_affine_image_sample_introduction2.jpg"></p><p>来看下OpenCV中如何实现仿射变换：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>img = cv2.imread(<span class="hljs-string">'drawing.jpg'</span>)<br>rows, cols = img.shape[:<span class="hljs-number">2</span>]<br><br><span class="hljs-comment"># 仿射变换</span><br><br><span class="hljs-comment"># 变换前的三个点</span><br>pts1 = np.float32([[<span class="hljs-number">50</span>, <span class="hljs-number">65</span>], [<span class="hljs-number">150</span>, <span class="hljs-number">65</span>], [<span class="hljs-number">210</span>, <span class="hljs-number">210</span>]])<br><span class="hljs-comment"># 变换后的三个点</span><br>pts2 = np.float32([[<span class="hljs-number">50</span>, <span class="hljs-number">100</span>], [<span class="hljs-number">150</span>, <span class="hljs-number">65</span>], [<span class="hljs-number">100</span>, <span class="hljs-number">250</span>]])<br><br><span class="hljs-comment"># 生成变换矩阵，维数：2*3</span><br>M = cv2.getAffineTransform(pts1, pts2)<br>dst = cv2.warpAffine(img, M, (cols, rows))<br><br>plt.subplot(<span class="hljs-number">121</span>), plt.imshow(img), plt.title(<span class="hljs-string">'input'</span>)<br>plt.subplot(<span class="hljs-number">122</span>), plt.imshow(dst), plt.title(<span class="hljs-string">'output'</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_affine_transformation_drawing.jpg"></p><p>其实平移、旋转、缩放和翻转等变换就是对应了不同的仿射变换矩阵，下面分别来看下。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_image_transformation_sample.jpg"></p><h3 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h3><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_warp_affine_shift_sample.jpg"></p><p>平移就是x和y方向上的直接移动，可以上下/左右移动，自由度为2，变换矩阵可以表示为：</p><script type="math/tex; mode=display">\begin{bmatrix}u\\v\end{bmatrix}=\begin{bmatrix}1&0\\0&1\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}+\begin{bmatrix}t_x\\t_y\end{bmatrix}</script><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_warp_affine_rotation_sample.jpg"></p><p>旋转是坐标轴方向饶原点旋转一定的角度$\theta$，自由度为1，不包含平移，如顺时针旋转可以表示为：</p><script type="math/tex; mode=display">\begin{bmatrix}u\\v\end{bmatrix}=\begin{bmatrix}\cos{\theta}&-\sin{\theta}\\\sin{\theta}&\cos{\theta}\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}+\begin{bmatrix}0\\0\end{bmatrix}</script><blockquote><p>思考：如果不是绕原点，而是可变点，自由度是多少呢？（请看下文刚体变换）</p></blockquote><h3 id="翻转"><a href="#翻转" class="headerlink" title="翻转"></a>翻转</h3><p>翻转是x或y某个方向或全部方向上取反，自由度为2，比如这里以垂直翻转为例：</p><script type="math/tex; mode=display">\begin{bmatrix}u\\v\end{bmatrix}=\begin{bmatrix}1&0\\0&-1\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}+\begin{bmatrix}0\\0\end{bmatrix}</script><h3 id="刚体变换"><a href="#刚体变换" class="headerlink" title="刚体变换"></a>刚体变换</h3><p>旋转+平移也称刚体变换（Rigid Transform），就是说如果<strong>图像变换前后两点间的距离仍然保持不变</strong>，那么这种变化就称为刚体变换。刚体变换包括了平移、旋转和翻转，自由度为3。变换矩阵可以表示为：</p><script type="math/tex; mode=display">\begin{bmatrix}u\\v\end{bmatrix}=\begin{bmatrix}\cos{\theta}&-\sin{\theta}\\\sin{\theta}&\cos{\theta}\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}+\begin{bmatrix}t_x\\t_y\end{bmatrix}</script><p>由于只是旋转和平移，刚体变换保持了直线间的长度不变，所以也称欧式变换（变化前后保持欧氏距离）。</p><h3 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h3><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_warp_affine_scale_sampel.jpg"></p><p>缩放是x和y方向的尺度（倍数）变换，在有些资料上非等比例的缩放也称为拉伸/挤压，等比例缩放自由度为1，非等比例缩放自由度为2，矩阵可以表示为：</p><script type="math/tex; mode=display">\begin{bmatrix}u\\v\end{bmatrix}=\begin{bmatrix}s_x&0\\0&s_y\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}+\begin{bmatrix}0\\0\end{bmatrix}</script><h3 id="相似变换"><a href="#相似变换" class="headerlink" title="相似变换"></a>相似变换</h3><p>相似变换又称缩放旋转，相似变换包含了旋转、等比例缩放和平移等变换，自由度为4。在OpenCV中，旋转就是用相似变换实现的：</p><p>若<strong>缩放比例为scale</strong>，<strong>旋转角度为$\theta$</strong>，<strong>旋转中心是$(center_x,center_y)$</strong>，则仿射变换可以表示为：</p><script type="math/tex; mode=display">\begin{bmatrix}u\\v\end{bmatrix}=\begin{bmatrix}\alpha&\beta\\-\beta&\alpha\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}+\begin{bmatrix}(1-\alpha)center_x-\beta center_y\\\beta center_x+(1-\alpha)center_y\end{bmatrix}</script><p>其中：</p><script type="math/tex; mode=display">\alpha=scale\cdot{\cos\theta},\beta=scale\cdot\sin{\theta}</script><p><strong>相似变换相比刚体变换加了缩放，所以并不会保持欧氏距离不变，但直线间的夹角依然不变。</strong></p><blockquote><p>经验之谈：OpenCV中默认按照逆时针旋转噢~</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_transformation_matrix_dof_summary.jpg" width="70%"></p><div class="table-container"><table><thead><tr><th style="text-align:center">变换</th><th style="text-align:center">矩阵</th><th style="text-align:center">自由度</th><th style="text-align:center">保持性质</th></tr></thead><tbody><tr><td style="text-align:center">平移</td><td style="text-align:center">[I, t]（2×3）</td><td style="text-align:center">2</td><td style="text-align:center">方向/长度/夹角/平行性/直线性</td></tr><tr><td style="text-align:center">刚体</td><td style="text-align:center">[R, t]（2×3）</td><td style="text-align:center">3</td><td style="text-align:center">长度/夹角/平行性/直线性</td></tr><tr><td style="text-align:center">相似</td><td style="text-align:center">[sR, t]（2×3）</td><td style="text-align:center">4</td><td style="text-align:center">夹角/平行性/直线性</td></tr><tr><td style="text-align:center">仿射</td><td style="text-align:center">[T]（2×3）</td><td style="text-align:center">6</td><td style="text-align:center">平行性/直线性</td></tr><tr><td style="text-align:center">透视</td><td style="text-align:center">[T]（3×3）</td><td style="text-align:center">8</td><td style="text-align:center">直线性</td></tr></tbody></table></div><h3 id="透视变换"><a href="#透视变换" class="headerlink" title="透视变换"></a>透视变换</h3><p>前面仿射变换后依然是平行四边形，并不能做到任意的变换。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_warp_perspective_image_sample4.jpg"></p><p><a href="https://baike.baidu.com/item/透视变换" target="_blank" rel="noopener">透视变换</a>（Perspective Transformation）是将二维的图片投影到一个三维视平面上，然后再转换到二维坐标下，所以也称为投影映射（Projective Mapping）。简单来说就是二维→三维→二维的一个过程。</p><script type="math/tex; mode=display">X=a_1x+b_1y+c_1\\Y=a_2x+b_2y+c_2\\Z=a_3x+b_3y+c_3</script><p>可以写成齐次矩阵的形式：</p><script type="math/tex; mode=display">\begin{bmatrix}X\\Y\\Z\end{bmatrix}=\begin{bmatrix}a_1&b_1&c_1\\a_2&b_2&c_2\\a_3&b_3&c_3\end{bmatrix}\begin{bmatrix}x\\y\\1\end{bmatrix}</script><p>其中，$\begin{bmatrix}a_1&amp;b_1\\a_2&amp;b_2\end{bmatrix}$表示线性变换，$\begin{bmatrix}a_3&amp;b_3\end{bmatrix}$产生透视变换，其余表示平移变换，因此<strong>仿射变换是透视变换的子集</strong>。接下来再通过除以Z轴转换成二维坐标：</p><script type="math/tex; mode=display">x'=\frac{X}{Z}=\frac{a_1x+b_1y+c_1}{a_3x+b_3y+c_3}\\y'=\frac{Y}{Z}=\frac{a_2x+b_2y+c_2}{a_3x+b_3y+c_3}</script><p>透视变换相比仿射变换更加灵活，变换后会产生一个新的四边形，但不一定是平行四边形，所以需要<strong>非共线的四个点才能唯一确定</strong>，原图中的直线变换后依然是直线。</p><p>因为四边形包括了所有的平行四边形，所以透视变换包括了所有的仿射变换。</p><p>OpenCV中首先根据变换前后的四个点用<code>cv2.getPerspectiveTransform()</code>生成3×3的变换矩阵，然后再用<code>cv2.warpPerspective()</code>进行透视变换。实战演练一下：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_perspective_transformations_inm.jpg"></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># 透视变换</span><br>img = cv2.imread(<span class="hljs-string">'card.jpg'</span>)<br><br><span class="hljs-comment"># 原图中卡片的四个角点</span><br>pts1 = np.float32([[<span class="hljs-number">148</span>, <span class="hljs-number">80</span>], [<span class="hljs-number">437</span>, <span class="hljs-number">114</span>], [<span class="hljs-number">94</span>, <span class="hljs-number">247</span>], [<span class="hljs-number">423</span>, <span class="hljs-number">288</span>]])<br><span class="hljs-comment"># 变换后分别在左上、右上、左下、右下四个点</span><br>pts2 = np.float32([[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">320</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">178</span>], [<span class="hljs-number">320</span>, <span class="hljs-number">178</span>]])<br><br><span class="hljs-comment"># 生成透视变换矩阵</span><br>M = cv2.getPerspectiveTransform(pts1, pts2)<br><span class="hljs-comment"># 进行透视变换，参数3是目标图像大小</span><br>dst = cv2.warpPerspective(img, M, (<span class="hljs-number">320</span>, <span class="hljs-number">178</span>))<br><br><span class="hljs-comment"># matplotlib默认以RGB通道显示，所以需要用[:, :, ::-1]翻转一下</span><br>plt.subplot(<span class="hljs-number">121</span>), plt.imshow(img[:, :, ::<span class="hljs-number">-1</span>]), plt.title(<span class="hljs-string">'input'</span>)<br>plt.subplot(<span class="hljs-number">122</span>), plt.imshow(dst[:, :, ::<span class="hljs-number">-1</span>]), plt.title(<span class="hljs-string">'output'</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p>当然，<strong>我们后面学习了特征提取之后，就可以自动识别角点了。</strong>透视变换是一项很酷的功能。比如我们经常会用手机去拍身份证和文件，无论你怎么拍，貌似都拍不正或者有边框。如果你使用过手机上面一些扫描类软件，比如”<a href="https://baike.baidu.com/item/扫描全能王" target="_blank" rel="noopener">扫描全能王</a>“，”<a href="https://baike.baidu.com/item/Office Lens" target="_blank" rel="noopener">Office Lens</a>“，它们能很好地矫正图片，这些软件就是应用透视变换实现的。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="http://pic.ex2tron.top/Computer Vision：Algorithms and Applications.pdf" target="_blank" rel="noopener">计算机视觉：算法与应用</a></li><li><a href="https://zh.wikipedia.org/wiki/仿射变换" target="_blank" rel="noopener">维基百科：仿射变换</a></li><li><a href="https://www.zhihu.com/question/20666664" target="_blank" rel="noopener">如何通俗地讲解「仿射变换」这个概念？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 几何变换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程7：图像几何变换</title>
      <link href="/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B7%EF%BC%9A%E5%9B%BE%E5%83%8F%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2/"/>
      <url>/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B7%EF%BC%9A%E5%9B%BE%E5%83%8F%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>学习如何旋转、平移、缩放和翻转图片。</p><p>目标：</p><ul><li>实现旋转、平移、缩放和翻转图片</li><li>OpenCV函数：<ul><li><code>cv2.resize()</code>：缩放图片，可以按指定大小缩放，也可以按比例缩放。</li><li><code>cv2.flip()</code>：翻转图片，可以指定水平、垂直、水平垂直翻转三种方式。</li><li><code>cv2.warpAffine()</code>：仿射变换，可以实现平移和旋转。</li></ul></li></ul><blockquote><p>图像的几何变换从原理上看主要包括两种：基于2×3矩阵的仿射变换（平移、缩放、旋转和翻转等）、基于3×3矩阵的透视变换，感兴趣的小伙伴可参考<a href="[http://huris.xyz/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%875%EF%BC%9A%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2%E4%B8%8E%E9%80%8F%E8%A7%86%E5%8F%98%E6%8D%A2/](http://huris.xyz/2019/08/14/Python-OpenCV教程番外篇5：仿射变换与透视变换/">番外篇：仿射变换与透视变换</a>)。</p></blockquote><a id="more"></a><h2 id="缩放图片"><a href="#缩放图片" class="headerlink" title="缩放图片"></a>缩放图片</h2><p>缩放就是调整图片的大小，使用<code>cv2.resize()</code>函数实现缩放。可以按照比例缩放，也可以按照指定的大小缩放：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br>img = cv2.imread(<span class="hljs-string">'drawing.jpg'</span>)<br><br><span class="hljs-comment"># 1.按照指定的宽度、高度缩放图片</span><br>res = cv2.resize(img, (<span class="hljs-number">132</span>, <span class="hljs-number">150</span>))<br><br><span class="hljs-comment"># 按照比例缩放，如x,y轴均放大一倍</span><br>res2 = cv2.resize(img, <span class="hljs-literal">None</span>, fx=<span class="hljs-number">2</span>, fy=<span class="hljs-number">2</span>, interpolation=cv2.INTER_LINEAR)<br><br>cv2.imshow(<span class="hljs-string">'shrink'</span>, res), cv2.imshow(<span class="hljs-string">'zoom'</span>, res2)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>我们也可以指定缩放方法<code>interpolation</code>，更专业点叫插值方法，默认是<code>INTER_LINEAR</code>，全部可以参考：<a href="https://docs.opencv.org/4.0.0/da/d54/group__imgproc__transform.html#ga5bb5a1fea74ea38e1a5445ca803ff121" target="_blank" rel="noopener">InterpolationFlags</a></p><h2 id="翻转图片"><a href="#翻转图片" class="headerlink" title="翻转图片"></a>翻转图片</h2><p>镜像翻转图片，可以用<code>cv2.flip()</code>函数：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">dst = cv2.flip(img, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>其中，参数2 = 0：垂直翻转(沿x轴)，参数2 &gt; 0: 水平翻转(沿y轴)，参数2 &lt; 0: 水平垂直翻转。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_flip_image_sample.jpg"></p><h2 id="平移图片"><a href="#平移图片" class="headerlink" title="平移图片"></a>平移图片</h2><p>要平移图片，我们需要定义下面这样一个矩阵，$t_x$，$t_y$是向$x$和$y$方向平移的距离：</p><script type="math/tex; mode=display">M=\begin{bmatrix} 0 & -1 & t_x \\ 1 & 0 & t_y\end{bmatrix}</script><p>平移是用仿射变换函数<code>cv2.warpAffine()</code>实现的：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>img = cv2.imread(<span class="hljs-string">'drawing.jpg'</span>)<br><br><span class="hljs-comment"># 平移图片</span><br>rows, cols = img.shape[:<span class="hljs-number">2</span>]<br><span class="hljs-comment"># 定义平移矩阵，需要是numpy的float32类型</span><br><span class="hljs-comment"># x轴平移100，y轴平移50</span><br>M = np.float32([[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">50</span>]])<br>dst = cv2.warpAffine(img, M, (cols, rows))<br><br>cv2.imshow(<span class="hljs-string">'shift'</span>, dst)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_translation_100_50.jpg"></p><h2 id="旋转图片"><a href="#旋转图片" class="headerlink" title="旋转图片"></a>旋转图片</h2><p>旋转同平移一样，也是用仿射变换实现的，因此也需要定义一个变换矩阵。OpenCV直接提供了 <code>cv2.getRotationMatrix2D()</code>函数来生成这个矩阵，该函数有三个参数：</p><ul><li>参数1：图片的旋转中心</li><li>参数2：旋转角度(正：逆时针，负：顺时针)</li><li>参数3：缩放比例，0.5表示缩小一半</li></ul><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 45°顺时针旋转图片并缩小一半</span><br>M = cv2.getRotationMatrix2D((cols / <span class="hljs-number">2</span>, rows / <span class="hljs-number">2</span>), <span class="hljs-number">-45</span>, <span class="hljs-number">0.5</span>)<br>dst = cv2.warpAffine(img, M, (cols, rows))<br><br>cv2.imshow(<span class="hljs-string">'rotation'</span>, dst)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_rotation_45_degree.jpg"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><ul><li><a href="https://docs.opencv.org/4.0.0/da/d54/group__imgproc__transform.html#ga47a974309e9102f5f08231edc7e7529d" target="_blank" rel="noopener">cv2.resize()</a></li><li><a href="https://docs.opencv.org/4.0.0/d2/de8/group__core__array.html#gaca7be533e3dac7feb70fc60635adf441" target="_blank" rel="noopener">cv2.filp()</a></li><li><a href="https://docs.opencv.org/4.0.0/da/d54/group__imgproc__transform.html#ga0203d9ee5fcd28d40dbc4a1ea4451983" target="_blank" rel="noopener">cv2.warpAffine()</a></li><li><a href="https://docs.opencv.org/4.0.0/da/d54/group__imgproc__transform.html#gafbbc470ce83812914a70abfb604f4326" target="_blank" rel="noopener">cv2.getRotationMatrix2D()</a></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_geometric_transformations/py_geometric_transformations.html" target="_blank" rel="noopener">Geometric Transformations of Images</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 几何变换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程番外篇4：Otsu阈值法</title>
      <link href="/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%874%EF%BC%9AOtsu%E9%98%88%E5%80%BC%E6%B3%95/"/>
      <url>/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%874%EF%BC%9AOtsu%E9%98%88%E5%80%BC%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>大部分图像处理任务都需要先进行二值化操作，阈值的选取很关键，Otsu阈值法会自动计算阈值。</p><p><a href="https://baike.baidu.com/item/otsu/16252828" target="_blank" rel="noopener">Otsu阈值法</a>（日本人大津展之提出的，也可称大津算法）非常适用于双峰图片，啥意思呢？</p><a id="more"></a><h2 id="双峰图片"><a href="#双峰图片" class="headerlink" title="双峰图片"></a>双峰图片</h2><p>双峰图片就是指图片的灰度直方图上有两个峰值，直方图就是每个值（0~255）的像素点个数统计，后面会详细介绍。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_bimodal_image_two_peaks.jpg"></p><p>Otsu算法假设这副图片由前景色和背景色组成，通过统计学方法（最大类间方差）选取一个阈值，将前景和背景尽可能分开，我们先来看下代码，然后详细说明下算法原理。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>下面这段代码对比了使用固定阈值和Otsu阈值后的不同结果：</p><p>另外，对含噪点的图像，先进行滤波操作效果会更好。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><br>img = cv2.imread(<span class="hljs-string">'noisy.jpg'</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 固定阈值法</span><br>ret1, th1 = cv2.threshold(img, <span class="hljs-number">100</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY)<br><br><span class="hljs-comment"># Otsu阈值法</span><br>ret2, th2 = cv2.threshold(img, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)<br><br><span class="hljs-comment"># 先进行高斯滤波，再使用Otsu阈值法</span><br>blur = cv2.GaussianBlur(img, (<span class="hljs-number">5</span>, <span class="hljs-number">5</span>), <span class="hljs-number">0</span>)<br>ret3, th3 = cv2.threshold(blur, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)<br></code></pre></td></tr></table></figure><p>下面我们用Matplotlib把原图、直方图和阈值图都显示出来：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python">images = [img, <span class="hljs-number">0</span>, th1,<br>          img, <span class="hljs-number">0</span>, th2,<br>          blur, <span class="hljs-number">0</span>, th3]<br><br>titles = [<span class="hljs-string">'Original'</span>, <span class="hljs-string">'Histogram'</span>, <span class="hljs-string">'Global(v=100)'</span>,<br>          <span class="hljs-string">'Original'</span>, <span class="hljs-string">'Histogram'</span>, <span class="hljs-string">"Otsu's"</span>,<br>          <span class="hljs-string">'Gaussian filtered Image'</span>, <span class="hljs-string">'Histogram'</span>, <span class="hljs-string">"Otsu's"</span>]<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):<br>    <span class="hljs-comment"># 绘制原图</span><br>    plt.subplot(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, i * <span class="hljs-number">3</span> + <span class="hljs-number">1</span>)<br>    plt.imshow(images[i * <span class="hljs-number">3</span>], <span class="hljs-string">'gray'</span>)<br>    plt.title(titles[i * <span class="hljs-number">3</span>], fontsize=<span class="hljs-number">8</span>)<br>    plt.xticks([]), plt.yticks([])<br><br>    <span class="hljs-comment"># 绘制直方图plt.hist，ravel函数将数组降成一维</span><br>    plt.subplot(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, i * <span class="hljs-number">3</span> + <span class="hljs-number">2</span>)<br>    plt.hist(images[i * <span class="hljs-number">3</span>].ravel(), <span class="hljs-number">256</span>)<br>    plt.title(titles[i * <span class="hljs-number">3</span> + <span class="hljs-number">1</span>], fontsize=<span class="hljs-number">8</span>)<br>    plt.xticks([]), plt.yticks([])<br><br>    <span class="hljs-comment"># 绘制阈值图</span><br>    plt.subplot(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, i * <span class="hljs-number">3</span> + <span class="hljs-number">3</span>)<br>    plt.imshow(images[i * <span class="hljs-number">3</span> + <span class="hljs-number">2</span>], <span class="hljs-string">'gray'</span>)<br>    plt.title(titles[i * <span class="hljs-number">3</span> + <span class="hljs-number">2</span>], fontsize=<span class="hljs-number">8</span>)<br>    plt.xticks([]), plt.yticks([])<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_otsu_vs_simple_thresholding.jpg"></p><p>可以看到，Otsu阈值明显优于固定阈值，省去了不断尝试阈值判断效果好坏的过程。其中，绘制直方图时，使用了numpy中的<a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ravel.html" target="_blank" rel="noopener">ravel()</a>函数，它会将原矩阵压缩成一维数组，便于画直方图。</p><h2 id="Otsu算法"><a href="#Otsu算法" class="headerlink" title="Otsu算法"></a>Otsu算法</h2><p>Otsu阈值法将整幅图分为前景（目标）和背景，以下是一些符号规定：</p><ul><li>$T$：分割阈值</li><li>$N_0$：前景像素点数</li><li>$N_1$：背景像素点数</li><li>$w_0$：前景的像素点数占整幅图像的比例</li><li>$w_1$：背景的像素点数占整幅图像的比例</li><li>$\mu_0$：前景的平均像素值</li><li>$\mu_1$：背景的平均像素值</li><li>$μ$：整幅图的平均像素值</li><li>$rows×cols$：图像的行数和列数</li></ul><p>结合下图会更容易理解一些，有一副大小为4×4的图片，假设阈值T为1，那么：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_otsu_theory_sample.jpg"></p><p>其实很好理解，$N_0+N_1$就是总的像素点个数，也就是行数乘列数：</p><script type="math/tex; mode=display">N_0 + N_1 = rows \times cols</script><p>$w_0$和$w_1$是前/背景所占的比例，也就是：</p><script type="math/tex; mode=display">w_0 = \frac{N_0}{rows\times{cols}}</script><script type="math/tex; mode=display">w_1 = \frac{N_1}{rows\times{cols}}</script><script type="math/tex; mode=display">w_0+w_1=1</script><p>整幅图的平均像素值就是：</p><script type="math/tex; mode=display">\mu=w_0\times{\mu_0}+w_1\times{\mu_1}</script><p>此时，我们定义一个前景$\mu_0$与背景$\mu_1$的方差$g$：</p><script type="math/tex; mode=display">g=w_0(\mu_0-\mu)^{2}+w_1(\mu_1-\mu)^{2}</script><p>将前述的(4)、(5)、(6)公式整合在一起，便是：</p><script type="math/tex; mode=display">g=w_0w_1(\mu_0-\mu_1)^{2}</script><p><strong>$g$就是前景与背景两类之间的方差，这个值越大，说明前景和背景的差别也就越大，效果越好。Otsu算法便是遍历阈值T，使得$g$最大，所以又称为最大类间方差法。</strong>基本上双峰图片的阈值T在两峰之间的谷底。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><ul><li><a href="https://docs.opencv.org/4.0.0/d7/d1b/group__imgproc__misc.html#gaa9e58d2860d4afa658ef70a9b1115576" target="_blank" rel="noopener">cv2.ThresholdTypes</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#gaabe8c836e97159a9193fb0b11ac52cf1" target="_blank" rel="noopener">cv2.GaussianBlur()</a></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ravel.html" target="_blank" rel="noopener">numpy.ravel</a></li><li><a href="https://en.wikipedia.org/wiki/Otsu&#39;s_method" target="_blank" rel="noopener">Otsu’s Method(wikipedia)</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_thresholding/py_thresholding.html" target="_blank" rel="noopener">Image Thresholding</a></li><li><a href="https://blog.csdn.net/u011776903/article/details/73274802" target="_blank" rel="noopener">一维OTSU法、最小交叉熵法、二维OTSU法及C++源码</a></li><li><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4310076" target="_blank" rel="noopener">Otsu N. A threshold selection method from gray-level histograms[J\]. IEEE transactions on systems, man, and cybernetics, 1979, 9(1): 62-66.</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 阈值 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程6：阈值分割</title>
      <link href="/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B6%EF%BC%9A%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/"/>
      <url>/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B6%EF%BC%9A%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/</url>
      
        <content type="html"><![CDATA[<p>学习使用不同的阈值方法”二值化”图像。</p><p>目标：</p><ul><li>使用固定阈值、自适应阈值和Otsu阈值法“二值化”图像</li><li>二值化跟阈值分割并不等同。针对不同的图片，可以采用不同的阈值方法。</li><li>OpenCV函数：<ul><li><code>cv2.threshould()</code>：用来进行固定阈值分割。</li><li><code>cv2.adaptiveThreshold()</code>：固定阈值不适用于光线不均匀的图片，所以用该函数进行自适应阈值分割。</li></ul></li></ul><a id="more"></a><h2 id="固定阈值分割"><a href="#固定阈值分割" class="headerlink" title="固定阈值分割"></a>固定阈值分割</h2><p>固定阈值分割很直接，一句话说就是像素点值大于阈值变成一类值，小于阈值变成另一类值。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_threshold_binary_demo.jpg"></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br><span class="hljs-comment"># 灰度图读入</span><br>img = cv2.imread(<span class="hljs-string">'gradient.jpg'</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 阈值分割，ret：return value缩写，代表当前的阈值，暂时不用理会</span><br>ret, th = cv2.threshold(img, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY)<br>cv2.imshow(<span class="hljs-string">'thresh'</span>, th)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><code>cv2.threshold()</code>用来实现阈值分割，ret是return value缩写，代表当前的阈值，暂时不用理会。函数有4个参数：</p><ul><li>参数1：要处理的原图，<strong>一般是灰度图</strong></li><li>参数2：设定的阈值</li><li>参数3：最大阈值，一般为255</li><li>参数4：阈值的方式，主要有5种，详情：<a href="https://docs.opencv.org/4.0.0/d7/d1b/group__imgproc__misc.html#gaa9e58d2860d4afa658ef70a9b1115576" target="_blank" rel="noopener">ThresholdTypes</a></li></ul><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># 灰度图读入</span><br>img = cv2.imread(<span class="hljs-string">'gradient.jpg'</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 应用5种不同的阈值方法</span><br>ret, th1 = cv2.threshold(img, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY)<br>ret, th2 = cv2.threshold(img, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY_INV)<br>ret, th3 = cv2.threshold(img, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_TRUNC)<br>ret, th4 = cv2.threshold(img, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_TOZERO)<br>ret, th5 = cv2.threshold(img, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_TOZERO_INV)<br><br>titles = [<span class="hljs-string">'Original'</span>, <span class="hljs-string">'BINARY'</span>, <span class="hljs-string">'BINARY_INV'</span>, <span class="hljs-string">'TRUNC'</span>, <span class="hljs-string">'TOZERO'</span>, <span class="hljs-string">'TOZERO_INV'</span>]<br>images = [img, th1, th2, th3, th4, th5]<br><br><span class="hljs-comment"># 使用Matplotlib显示</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">6</span>):<br>    plt.subplot(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, i + <span class="hljs-number">1</span>)<br>    plt.imshow(images[i], <span class="hljs-string">'gray'</span>)<br>    plt.title(titles[i], fontsize=<span class="hljs-number">8</span>)<br>    plt.xticks([]), plt.yticks([])  <span class="hljs-comment"># 隐藏坐标轴</span><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_different_threshold_demo.jpg"></p><blockquote><p>经验之谈：很多人误以为阈值分割就是<a href="https://baike.baidu.com/item/二值化" target="_blank" rel="noopener">二值化</a>。从上图中可以发现，两者并不等同，阈值分割结果是两类值，而不是两个值，所以教程开头我把二值化加了引号。</p></blockquote><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_different_thresholds_theory.jpg" width="70%"></p><h2 id="自适应阈值"><a href="#自适应阈值" class="headerlink" title="自适应阈值"></a>自适应阈值</h2><p>看得出来固定阈值是在整幅图片上应用一个阈值进行分割，<em>它并不适用于明暗分布不均的图片</em>。 <code>cv2.adaptiveThreshold()</code>自适应阈值会每次取图片的一小部分计算阈值，这样图片不同区域的阈值就不尽相同。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br><span class="hljs-comment"># 自适应阈值对比固定阈值</span><br>img = cv2.imread(<span class="hljs-string">'sudoku.jpg'</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 固定阈值</span><br>ret, th1 = cv2.threshold(img, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY)<br><br><span class="hljs-comment"># 自适应阈值</span><br>th2 = cv2.adaptiveThreshold(<br>    img, <span class="hljs-number">255</span>, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, <span class="hljs-number">11</span>, <span class="hljs-number">4</span>)<br><br>th3 = cv2.adaptiveThreshold(<br>    img, <span class="hljs-number">255</span>, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, <span class="hljs-number">17</span>, <span class="hljs-number">6</span>)<br><br>titles = [<span class="hljs-string">'Original'</span>, <span class="hljs-string">'Global(v = 127)'</span>, <span class="hljs-string">'Adaptive Mean'</span>, <span class="hljs-string">'Adaptive Gaussian'</span>]<br>images = [img, th1, th2, th3]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">4</span>):<br>    plt.subplot(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, i + <span class="hljs-number">1</span>), plt.imshow(images[i], <span class="hljs-string">'gray'</span>)<br>    plt.title(titles[i], fontsize=<span class="hljs-number">8</span>)<br>    plt.xticks([]), plt.yticks([])<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_adaptive_vs_global_thresholding.jpg"></p><p><code>cv2.adaptiveThreshold()</code>有5个参数，其实很好理解：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">th2 = cv2.adaptiveThreshold(<br>    img, <span class="hljs-number">255</span>, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, <span class="hljs-number">11</span>, <span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><ul><li>参数1：要处理的原图</li><li>参数2：最大阈值，一般为255</li><li>参数3：小区域阈值的计算方式<ul><li><code>ADAPTIVE_THRESH_MEAN_C</code>：小区域内取均值</li><li><code>ADAPTIVE_THRESH_GAUSSIAN_C</code>：小区域内加权求和，权重是个高斯核</li></ul></li><li>参数4：阈值方式（跟前面讲的那5种相同）</li><li>参数5：小区域的面积，如11就是11*11的小块</li><li>参数6：最终阈值等于小区域计算出的阈值再减去此值</li></ul><p>如果你没看懂上面的参数也不要紧，暂时会用就行，当然我建议你调整下参数看看不同的结果。</p><h2 id="Otsu阈值"><a href="#Otsu阈值" class="headerlink" title="Otsu阈值"></a>Otsu阈值</h2><p>在前面固定阈值中，我们是随便选了一个阈值如127，那如何知道我们选的这个阈值效果好不好呢？答案是：不断尝试，所以这种方法在很多文献中都被称为经验阈值。</p><p><a href="https://baike.baidu.com/item/otsu/16252828" target="_blank" rel="noopener">Otsu阈值法</a>就提供了一种自动高效的二值化方法，不过我们直方图还没学，这里暂时略过。</p><p>具体可以参考<a href="[http://huris.xyz/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%874%EF%BC%9AOtsu%E9%98%88%E5%80%BC%E6%B3%95/](http://huris.xyz/2019/08/14/Python-OpenCV教程番外篇4：Otsu阈值法/">Python+OpenCV教程番外篇4：Otsu阈值法</a>)</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><p><a href="https://docs.opencv.org/4.0.0/d7/d1b/group__imgproc__misc.html#gae8a4a146d1ca78c626a53577199e9c57" target="_blank" rel="noopener"><br>cv2.threshold()</a></p><p><a href="https://docs.opencv.org/4.0.0/d7/d1b/group__imgproc__misc.html#ga72b913f352e4a1b1b397736707afcde3" target="_blank" rel="noopener">cv2.adaptiveThreshold()</a></p><p><a href="https://docs.opencv.org/4.0.0/d7/d1b/group__imgproc__misc.html#gaa9e58d2860d4afa658ef70a9b1115576" target="_blank" rel="noopener">cv2.ThresholdTypes()</a></p><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><ul><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_thresholding/py_thresholding.html" target="_blank" rel="noopener">Image Thresholding</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 阈值 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程5：颜色空间转换</title>
      <link href="/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B5%EF%BC%9A%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2/"/>
      <url>/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B5%EF%BC%9A%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>学习如何进行图片的颜色空间转换，视频中追踪特定颜色的物体。</p><p>目标：</p><ul><li><p>颜色空间转换，如BGR↔Gray，BGR↔HSV等</p></li><li><p>追踪视频中特定颜色的物体</p></li><li><p>HSV颜色模型常用于颜色识别。要想知道某种颜色在HSV下的值，可以将它的BGR值用<code>cvtColor()</code>转换得到。</p></li><li><p>OpenCV函数：</p><ul><li><p><code>cv2.cvtColor()</code>：用来进行颜色空间转换，常用BGR↔Gray，BGR↔HSV。</p><p>  <code>hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)</code></p></li><li><p><code>cv2.inRange()</code>：指定颜色范围。</p><p> <code>mask = cv2.inRange(hsv, lower_blue, upper_blue)</code></p></li></ul></li></ul><a id="more"></a><h2 id="颜色空间转换"><a href="#颜色空间转换" class="headerlink" title="颜色空间转换"></a>颜色空间转换</h2><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br>img = cv2.imread(<span class="hljs-string">'lena.jpg'</span>)<br><br><span class="hljs-comment"># 转成灰度图</span><br><span class="hljs-comment"># cv2.cvtColor()用来进行颜色模型转换</span><br><span class="hljs-comment"># 参数1是要转换的图片</span><br><span class="hljs-comment"># 参数2是转换模式</span><br>img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br><br>cv2.imshow(<span class="hljs-string">'img'</span>, img)<br>cv2.imshow(<span class="hljs-string">'gray'</span>, img_gray)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><code>COLOR_BGR2GRAY</code>表示BGR→Gray，可用下面的代码显示所有的转换模式：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">flags = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> dir(cv2) <span class="hljs-keyword">if</span> i.startswith(<span class="hljs-string">'COLOR_'</span>)]<br>print(flags)<br><br>**************************************************************************<br><br>运行结果：<br>[<span class="hljs-string">'COLOR_BAYER_BG2BGR'</span>, <span class="hljs-string">'COLOR_BAYER_BG2BGRA'</span>, <span class="hljs-string">'COLOR_BAYER_BG2BGR_EA'</span>, <span class="hljs-string">'COLOR_BAYER_BG2BGR_VNG'</span>, <span class="hljs-string">'COLOR_BAYER_BG2GRAY'</span>, <span class="hljs-string">'COLOR_BAYER_BG2RGB'</span>, <span class="hljs-string">'COLOR_BAYER_BG2RGBA'</span>, <span class="hljs-string">'COLOR_BAYER_BG2RGB_EA'</span>, <span class="hljs-string">'COLOR_BAYER_BG2RGB_VNG'</span>, <span class="hljs-string">'COLOR_BAYER_GB2BGR'</span>, <span class="hljs-string">'COLOR_BAYER_GB2BGRA'</span>, <span class="hljs-string">'COLOR_BAYER_GB2BGR_EA'</span>, <span class="hljs-string">'COLOR_BAYER_GB2BGR_VNG'</span>, <span class="hljs-string">'COLOR_BAYER_GB2GRAY'</span>, <span class="hljs-string">'COLOR_BAYER_GB2RGB'</span>, <span class="hljs-string">'COLOR_BAYER_GB2RGBA'</span>, <span class="hljs-string">'COLOR_BAYER_GB2RGB_EA'</span>, <span class="hljs-string">'COLOR_BAYER_GB2RGB_VNG'</span>, <span class="hljs-string">'COLOR_BAYER_GR2BGR'</span>, <span class="hljs-string">'COLOR_BAYER_GR2BGRA'</span>, <span class="hljs-string">'COLOR_BAYER_GR2BGR_EA'</span>, <span class="hljs-string">'COLOR_BAYER_GR2BGR_VNG'</span>, <span class="hljs-string">'COLOR_BAYER_GR2GRAY'</span>, <span class="hljs-string">'COLOR_BAYER_GR2RGB'</span>, <span class="hljs-string">'COLOR_BAYER_GR2RGBA'</span>, <span class="hljs-string">'COLOR_BAYER_GR2RGB_EA'</span>, <span class="hljs-string">'COLOR_BAYER_GR2RGB_VNG'</span>, <span class="hljs-string">'COLOR_BAYER_RG2BGR'</span>, <span class="hljs-string">'COLOR_BAYER_RG2BGRA'</span>, <span class="hljs-string">'COLOR_BAYER_RG2BGR_EA'</span>, <span class="hljs-string">'COLOR_BAYER_RG2BGR_VNG'</span>, <span class="hljs-string">'COLOR_BAYER_RG2GRAY'</span>, <span class="hljs-string">'COLOR_BAYER_RG2RGB'</span>, <span class="hljs-string">'COLOR_BAYER_RG2RGBA'</span>, <span class="hljs-string">'COLOR_BAYER_RG2RGB_EA'</span>, <span class="hljs-string">'COLOR_BAYER_RG2RGB_VNG'</span>, <span class="hljs-string">'COLOR_BGR2BGR555'</span>, <span class="hljs-string">'COLOR_BGR2BGR565'</span>, <span class="hljs-string">'COLOR_BGR2BGRA'</span>, <span class="hljs-string">'COLOR_BGR2GRAY'</span>, <span class="hljs-string">'COLOR_BGR2HLS'</span>, <span class="hljs-string">'COLOR_BGR2HLS_FULL'</span>, <span class="hljs-string">'COLOR_BGR2HSV'</span>, <span class="hljs-string">'COLOR_BGR2HSV_FULL'</span>, <span class="hljs-string">'COLOR_BGR2LAB'</span>, <span class="hljs-string">'COLOR_BGR2LUV'</span>, <span class="hljs-string">'COLOR_BGR2Lab'</span>, <span class="hljs-string">'COLOR_BGR2Luv'</span>, <span class="hljs-string">'COLOR_BGR2RGB'</span>, <span class="hljs-string">'COLOR_BGR2RGBA'</span>, <span class="hljs-string">'COLOR_BGR2XYZ'</span>, <span class="hljs-string">'COLOR_BGR2YCR_CB'</span>, <span class="hljs-string">'COLOR_BGR2YCrCb'</span>, <span class="hljs-string">'COLOR_BGR2YUV'</span>, <span class="hljs-string">'COLOR_BGR2YUV_I420'</span>, <span class="hljs-string">'COLOR_BGR2YUV_IYUV'</span>, <span class="hljs-string">'COLOR_BGR2YUV_YV12'</span>, <span class="hljs-string">'COLOR_BGR5552BGR'</span>, <span class="hljs-string">'COLOR_BGR5552BGRA'</span>, <span class="hljs-string">'COLOR_BGR5552GRAY'</span>, <span class="hljs-string">'COLOR_BGR5552RGB'</span>, <span class="hljs-string">'COLOR_BGR5552RGBA'</span>, <span class="hljs-string">'COLOR_BGR5652BGR'</span>, <span class="hljs-string">'COLOR_BGR5652BGRA'</span>, <span class="hljs-string">'COLOR_BGR5652GRAY'</span>, <span class="hljs-string">'COLOR_BGR5652RGB'</span>, <span class="hljs-string">'COLOR_BGR5652RGBA'</span>, <span class="hljs-string">'COLOR_BGRA2BGR'</span>, <span class="hljs-string">'COLOR_BGRA2BGR555'</span>, <span class="hljs-string">'COLOR_BGRA2BGR565'</span>, <span class="hljs-string">'COLOR_BGRA2GRAY'</span>, <span class="hljs-string">'COLOR_BGRA2RGB'</span>, <span class="hljs-string">'COLOR_BGRA2RGBA'</span>, <span class="hljs-string">'COLOR_BGRA2YUV_I420'</span>, <span class="hljs-string">'COLOR_BGRA2YUV_IYUV'</span>, <span class="hljs-string">'COLOR_BGRA2YUV_YV12'</span>, <span class="hljs-string">'COLOR_BayerBG2BGR'</span>, <span class="hljs-string">'COLOR_BayerBG2BGRA'</span>, <span class="hljs-string">'COLOR_BayerBG2BGR_EA'</span>, <span class="hljs-string">'COLOR_BayerBG2BGR_VNG'</span>, <span class="hljs-string">'COLOR_BayerBG2GRAY'</span>, <span class="hljs-string">'COLOR_BayerBG2RGB'</span>, <span class="hljs-string">'COLOR_BayerBG2RGBA'</span>, <span class="hljs-string">'COLOR_BayerBG2RGB_EA'</span>, <span class="hljs-string">'COLOR_BayerBG2RGB_VNG'</span>, <span class="hljs-string">'COLOR_BayerGB2BGR'</span>, <span class="hljs-string">'COLOR_BayerGB2BGRA'</span>, <span class="hljs-string">'COLOR_BayerGB2BGR_EA'</span>, <span class="hljs-string">'COLOR_BayerGB2BGR_VNG'</span>, <span class="hljs-string">'COLOR_BayerGB2GRAY'</span>, <span class="hljs-string">'COLOR_BayerGB2RGB'</span>, <span class="hljs-string">'COLOR_BayerGB2RGBA'</span>, <span class="hljs-string">'COLOR_BayerGB2RGB_EA'</span>, <span class="hljs-string">'COLOR_BayerGB2RGB_VNG'</span>, <span class="hljs-string">'COLOR_BayerGR2BGR'</span>, <span class="hljs-string">'COLOR_BayerGR2BGRA'</span>, <span class="hljs-string">'COLOR_BayerGR2BGR_EA'</span>, <span class="hljs-string">'COLOR_BayerGR2BGR_VNG'</span>, <span class="hljs-string">'COLOR_BayerGR2GRAY'</span>, <span class="hljs-string">'COLOR_BayerGR2RGB'</span>, <span class="hljs-string">'COLOR_BayerGR2RGBA'</span>, <span class="hljs-string">'COLOR_BayerGR2RGB_EA'</span>, <span class="hljs-string">'COLOR_BayerGR2RGB_VNG'</span>, <span class="hljs-string">'COLOR_BayerRG2BGR'</span>, <span class="hljs-string">'COLOR_BayerRG2BGRA'</span>, <span class="hljs-string">'COLOR_BayerRG2BGR_EA'</span>, <span class="hljs-string">'COLOR_BayerRG2BGR_VNG'</span>, <span class="hljs-string">'COLOR_BayerRG2GRAY'</span>, <span class="hljs-string">'COLOR_BayerRG2RGB'</span>, <span class="hljs-string">'COLOR_BayerRG2RGBA'</span>, <span class="hljs-string">'COLOR_BayerRG2RGB_EA'</span>, <span class="hljs-string">'COLOR_BayerRG2RGB_VNG'</span>, <span class="hljs-string">'COLOR_COLORCVT_MAX'</span>, <span class="hljs-string">'COLOR_GRAY2BGR'</span>, <span class="hljs-string">'COLOR_GRAY2BGR555'</span>, <span class="hljs-string">'COLOR_GRAY2BGR565'</span>, <span class="hljs-string">'COLOR_GRAY2BGRA'</span>, <span class="hljs-string">'COLOR_GRAY2RGB'</span>, <span class="hljs-string">'COLOR_GRAY2RGBA'</span>, <span class="hljs-string">'COLOR_HLS2BGR'</span>, <span class="hljs-string">'COLOR_HLS2BGR_FULL'</span>, <span class="hljs-string">'COLOR_HLS2RGB'</span>, <span class="hljs-string">'COLOR_HLS2RGB_FULL'</span>, <span class="hljs-string">'COLOR_HSV2BGR'</span>, <span class="hljs-string">'COLOR_HSV2BGR_FULL'</span>, <span class="hljs-string">'COLOR_HSV2RGB'</span>, <span class="hljs-string">'COLOR_HSV2RGB_FULL'</span>, <span class="hljs-string">'COLOR_LAB2BGR'</span>, <span class="hljs-string">'COLOR_LAB2LBGR'</span>, <span class="hljs-string">'COLOR_LAB2LRGB'</span>, <span class="hljs-string">'COLOR_LAB2RGB'</span>, <span class="hljs-string">'COLOR_LBGR2LAB'</span>, <span class="hljs-string">'COLOR_LBGR2LUV'</span>, <span class="hljs-string">'COLOR_LBGR2Lab'</span>, <span class="hljs-string">'COLOR_LBGR2Luv'</span>, <span class="hljs-string">'COLOR_LRGB2LAB'</span>, <span class="hljs-string">'COLOR_LRGB2LUV'</span>, <span class="hljs-string">'COLOR_LRGB2Lab'</span>, <span class="hljs-string">'COLOR_LRGB2Luv'</span>, <span class="hljs-string">'COLOR_LUV2BGR'</span>, <span class="hljs-string">'COLOR_LUV2LBGR'</span>, <span class="hljs-string">'COLOR_LUV2LRGB'</span>, <span class="hljs-string">'COLOR_LUV2RGB'</span>, <span class="hljs-string">'COLOR_Lab2BGR'</span>, <span class="hljs-string">'COLOR_Lab2LBGR'</span>, <span class="hljs-string">'COLOR_Lab2LRGB'</span>, <span class="hljs-string">'COLOR_Lab2RGB'</span>, <span class="hljs-string">'COLOR_Luv2BGR'</span>, <span class="hljs-string">'COLOR_Luv2LBGR'</span>, <span class="hljs-string">'COLOR_Luv2LRGB'</span>, <span class="hljs-string">'COLOR_Luv2RGB'</span>, <span class="hljs-string">'COLOR_M_RGBA2RGBA'</span>, <span class="hljs-string">'COLOR_RGB2BGR'</span>, <span class="hljs-string">'COLOR_RGB2BGR555'</span>, <span class="hljs-string">'COLOR_RGB2BGR565'</span>, <span class="hljs-string">'COLOR_RGB2BGRA'</span>, <span class="hljs-string">'COLOR_RGB2GRAY'</span>, <span class="hljs-string">'COLOR_RGB2HLS'</span>, <span class="hljs-string">'COLOR_RGB2HLS_FULL'</span>, <span class="hljs-string">'COLOR_RGB2HSV'</span>, <span class="hljs-string">'COLOR_RGB2HSV_FULL'</span>, <span class="hljs-string">'COLOR_RGB2LAB'</span>, <span class="hljs-string">'COLOR_RGB2LUV'</span>, <span class="hljs-string">'COLOR_RGB2Lab'</span>, <span class="hljs-string">'COLOR_RGB2Luv'</span>, <span class="hljs-string">'COLOR_RGB2RGBA'</span>, <span class="hljs-string">'COLOR_RGB2XYZ'</span>, <span class="hljs-string">'COLOR_RGB2YCR_CB'</span>, <span class="hljs-string">'COLOR_RGB2YCrCb'</span>, <span class="hljs-string">'COLOR_RGB2YUV'</span>, <span class="hljs-string">'COLOR_RGB2YUV_I420'</span>, <span class="hljs-string">'COLOR_RGB2YUV_IYUV'</span>, <span class="hljs-string">'COLOR_RGB2YUV_YV12'</span>, <span class="hljs-string">'COLOR_RGBA2BGR'</span>, <span class="hljs-string">'COLOR_RGBA2BGR555'</span>, <span class="hljs-string">'COLOR_RGBA2BGR565'</span>, <span class="hljs-string">'COLOR_RGBA2BGRA'</span>, <span class="hljs-string">'COLOR_RGBA2GRAY'</span>, <span class="hljs-string">'COLOR_RGBA2M_RGBA'</span>, <span class="hljs-string">'COLOR_RGBA2RGB'</span>, <span class="hljs-string">'COLOR_RGBA2YUV_I420'</span>, <span class="hljs-string">'COLOR_RGBA2YUV_IYUV'</span>, <span class="hljs-string">'COLOR_RGBA2YUV_YV12'</span>, <span class="hljs-string">'COLOR_RGBA2mRGBA'</span>, <span class="hljs-string">'COLOR_XYZ2BGR'</span>, <span class="hljs-string">'COLOR_XYZ2RGB'</span>, <span class="hljs-string">'COLOR_YCR_CB2BGR'</span>, <span class="hljs-string">'COLOR_YCR_CB2RGB'</span>, <span class="hljs-string">'COLOR_YCrCb2BGR'</span>, <span class="hljs-string">'COLOR_YCrCb2RGB'</span>, <span class="hljs-string">'COLOR_YUV2BGR'</span>, <span class="hljs-string">'COLOR_YUV2BGRA_I420'</span>, <span class="hljs-string">'COLOR_YUV2BGRA_IYUV'</span>, <span class="hljs-string">'COLOR_YUV2BGRA_NV12'</span>, <span class="hljs-string">'COLOR_YUV2BGRA_NV21'</span>, <span class="hljs-string">'COLOR_YUV2BGRA_UYNV'</span>, <span class="hljs-string">'COLOR_YUV2BGRA_UYVY'</span>, <span class="hljs-string">'COLOR_YUV2BGRA_Y422'</span>, <span class="hljs-string">'COLOR_YUV2BGRA_YUNV'</span>, <span class="hljs-string">'COLOR_YUV2BGRA_YUY2'</span>, <span class="hljs-string">'COLOR_YUV2BGRA_YUYV'</span>, <span class="hljs-string">'COLOR_YUV2BGRA_YV12'</span>, <span class="hljs-string">'COLOR_YUV2BGRA_YVYU'</span>, <span class="hljs-string">'COLOR_YUV2BGR_I420'</span>, <span class="hljs-string">'COLOR_YUV2BGR_IYUV'</span>, <span class="hljs-string">'COLOR_YUV2BGR_NV12'</span>, <span class="hljs-string">'COLOR_YUV2BGR_NV21'</span>, <span class="hljs-string">'COLOR_YUV2BGR_UYNV'</span>, <span class="hljs-string">'COLOR_YUV2BGR_UYVY'</span>, <span class="hljs-string">'COLOR_YUV2BGR_Y422'</span>, <span class="hljs-string">'COLOR_YUV2BGR_YUNV'</span>, <span class="hljs-string">'COLOR_YUV2BGR_YUY2'</span>, <span class="hljs-string">'COLOR_YUV2BGR_YUYV'</span>, <span class="hljs-string">'COLOR_YUV2BGR_YV12'</span>, <span class="hljs-string">'COLOR_YUV2BGR_YVYU'</span>, <span class="hljs-string">'COLOR_YUV2GRAY_420'</span>, <span class="hljs-string">'COLOR_YUV2GRAY_I420'</span>, <span class="hljs-string">'COLOR_YUV2GRAY_IYUV'</span>, <span class="hljs-string">'COLOR_YUV2GRAY_NV12'</span>, <span class="hljs-string">'COLOR_YUV2GRAY_NV21'</span>, <span class="hljs-string">'COLOR_YUV2GRAY_UYNV'</span>, <span class="hljs-string">'COLOR_YUV2GRAY_UYVY'</span>, <span class="hljs-string">'COLOR_YUV2GRAY_Y422'</span>, <span class="hljs-string">'COLOR_YUV2GRAY_YUNV'</span>, <span class="hljs-string">'COLOR_YUV2GRAY_YUY2'</span>, <span class="hljs-string">'COLOR_YUV2GRAY_YUYV'</span>, <span class="hljs-string">'COLOR_YUV2GRAY_YV12'</span>, <span class="hljs-string">'COLOR_YUV2GRAY_YVYU'</span>, <span class="hljs-string">'COLOR_YUV2RGB'</span>, <span class="hljs-string">'COLOR_YUV2RGBA_I420'</span>, <span class="hljs-string">'COLOR_YUV2RGBA_IYUV'</span>, <span class="hljs-string">'COLOR_YUV2RGBA_NV12'</span>, <span class="hljs-string">'COLOR_YUV2RGBA_NV21'</span>, <span class="hljs-string">'COLOR_YUV2RGBA_UYNV'</span>, <span class="hljs-string">'COLOR_YUV2RGBA_UYVY'</span>, <span class="hljs-string">'COLOR_YUV2RGBA_Y422'</span>, <span class="hljs-string">'COLOR_YUV2RGBA_YUNV'</span>, <span class="hljs-string">'COLOR_YUV2RGBA_YUY2'</span>, <span class="hljs-string">'COLOR_YUV2RGBA_YUYV'</span>, <span class="hljs-string">'COLOR_YUV2RGBA_YV12'</span>, <span class="hljs-string">'COLOR_YUV2RGBA_YVYU'</span>, <span class="hljs-string">'COLOR_YUV2RGB_I420'</span>, <span class="hljs-string">'COLOR_YUV2RGB_IYUV'</span>, <span class="hljs-string">'COLOR_YUV2RGB_NV12'</span>, <span class="hljs-string">'COLOR_YUV2RGB_NV21'</span>, <span class="hljs-string">'COLOR_YUV2RGB_UYNV'</span>, <span class="hljs-string">'COLOR_YUV2RGB_UYVY'</span>, <span class="hljs-string">'COLOR_YUV2RGB_Y422'</span>, <span class="hljs-string">'COLOR_YUV2RGB_YUNV'</span>, <span class="hljs-string">'COLOR_YUV2RGB_YUY2'</span>, <span class="hljs-string">'COLOR_YUV2RGB_YUYV'</span>, <span class="hljs-string">'COLOR_YUV2RGB_YV12'</span>, <span class="hljs-string">'COLOR_YUV2RGB_YVYU'</span>, <span class="hljs-string">'COLOR_YUV420P2BGR'</span>, <span class="hljs-string">'COLOR_YUV420P2BGRA'</span>, <span class="hljs-string">'COLOR_YUV420P2GRAY'</span>, <span class="hljs-string">'COLOR_YUV420P2RGB'</span>, <span class="hljs-string">'COLOR_YUV420P2RGBA'</span>, <span class="hljs-string">'COLOR_YUV420SP2BGR'</span>, <span class="hljs-string">'COLOR_YUV420SP2BGRA'</span>, <span class="hljs-string">'COLOR_YUV420SP2GRAY'</span>, <span class="hljs-string">'COLOR_YUV420SP2RGB'</span>, <span class="hljs-string">'COLOR_YUV420SP2RGBA'</span>, <span class="hljs-string">'COLOR_YUV420p2BGR'</span>, <span class="hljs-string">'COLOR_YUV420p2BGRA'</span>, <span class="hljs-string">'COLOR_YUV420p2GRAY'</span>, <span class="hljs-string">'COLOR_YUV420p2RGB'</span>, <span class="hljs-string">'COLOR_YUV420p2RGBA'</span>, <span class="hljs-string">'COLOR_YUV420sp2BGR'</span>, <span class="hljs-string">'COLOR_YUV420sp2BGRA'</span>, <span class="hljs-string">'COLOR_YUV420sp2GRAY'</span>, <span class="hljs-string">'COLOR_YUV420sp2RGB'</span>, <span class="hljs-string">'COLOR_YUV420sp2RGBA'</span>, <span class="hljs-string">'COLOR_mRGBA2RGBA'</span>]<br></code></pre></td></tr></table></figure><blockquote><p>经验之谈：颜色转换其实是数学运算，如灰度化最常用的是：<code>gray=R*0.299+G*0.587+B*0.114</code>。</p></blockquote><h2 id="视频中特定颜色物体追踪"><a href="#视频中特定颜色物体追踪" class="headerlink" title="视频中特定颜色物体追踪"></a>视频中特定颜色物体追踪</h2><p><a href="https://baike.baidu.com/item/HSV/547122" target="_blank" rel="noopener">HSV</a>是一个常用于颜色识别的模型，相比BGR更易区分颜色，转换模式用<code>COLOR_BGR2HSV</code>表示。</p><blockquote><p>经验之谈：OpenCV中色调H范围为[0,179]，饱和度S是[0,255]，明度V是[0,255]。虽然H的理论数值是0°~360°，但8位图像像素点的最大值是255，所以OpenCV中除以了2，某些软件可能使用不同的尺度表示，所以同其他软件混用时，记得归一化。</p></blockquote><p>现在，我们实现一个使用HSV来只显示视频中蓝色物体的例子，步骤如下：</p><ol><li>捕获视频中的一帧</li><li>从BGR转换到HSV</li><li>提取蓝色范围的物体</li><li>只显示蓝色物体</li></ol><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_blue_object_tracking.jpg"></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>capture = cv2.VideoCapture(<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 蓝色的范围，不同光照条件下不一样，可灵活调整</span><br>lower_blue = np.array([<span class="hljs-number">100</span>, <span class="hljs-number">110</span>, <span class="hljs-number">110</span>])<br>upper_blue = np.array([<span class="hljs-number">130</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>])<br><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">True</span>):<br>    <span class="hljs-comment"># 1.捕获视频中的一帧</span><br>    ret, frame = capture.read()<br>    <span class="hljs-comment"># 2.从BGR转换到HSV</span><br>    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)<br>    <span class="hljs-comment"># 3.inRange()：介于lower/upper之间的为白色，其余黑色</span><br>    mask = cv2.inRange(hsv, lower_blue, upper_blue)<br>    <span class="hljs-comment"># 4.只保留原图中的蓝色部分</span><br>    res = cv2.bitwise_and(frame, frame, mask=mask)<br>    cv2.imshow(<span class="hljs-string">'frame'</span>, frame)<br>    cv2.imshow(<span class="hljs-string">'mask'</span>, mask)<br>    cv2.imshow(<span class="hljs-string">'res'</span>, res)<br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">1</span>) == ord(<span class="hljs-string">'q'</span>):<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p>蓝色的HSV值的上下限lower和upper范围是怎么得到的呢？其实很简单，我们先把标准蓝色的BGR值用<code>cvtColor()</code>转换下：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 蓝色的HSV值</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>blue = np.uint8([[[<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]]])<br>hsv_blue = cv2.cvtColor(blue, cv2.COLOR_BGR2HSV)<br>print(hsv_blue)  <span class="hljs-comment"># [[[120 255 255]]]</span><br></code></pre></td></tr></table></figure><p>结果是[120, 255, 255]，所以，我们把蓝色的范围调整成了上面代码那样。</p><p><strong>除了HSV，<a href="https://baike.baidu.com/item/Lab/1514615" target="_blank" rel="noopener">Lab</a>颜色空间也经常用来做颜色识别。</strong></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>尝试在视频中同时提取红色、蓝色、绿色的物体。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_exercise_tracking_three_colors.jpg"></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># HSV中</span><br><span class="hljs-comment"># Blue：[[[120 255 255]]]</span><br><span class="hljs-comment"># Green：[[[ 60 255 255]]]</span><br><span class="hljs-comment"># Red：[[[  0 255 255]]]</span><br><br>capture = cv2.VideoCapture(<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 蓝色的范围</span><br>lower_blue = np.array([<span class="hljs-number">100</span>, <span class="hljs-number">110</span>, <span class="hljs-number">110</span>])<br>upper_blue = np.array([<span class="hljs-number">130</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>])<br><br><span class="hljs-comment"># 绿色的范围</span><br>lower_green = np.array([<span class="hljs-number">40</span>, <span class="hljs-number">90</span>, <span class="hljs-number">90</span>])<br>upper_green = np.array([<span class="hljs-number">70</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>])<br><br><span class="hljs-comment"># 红色的范围</span><br>lower_red = np.array([<span class="hljs-number">160</span>, <span class="hljs-number">120</span>, <span class="hljs-number">120</span>])<br>upper_red = np.array([<span class="hljs-number">179</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>])<br><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">True</span>):<br>    <span class="hljs-comment"># 1.捕获视频中的一帧</span><br>    ret, frame = capture.read()<br><br>    <span class="hljs-comment"># 2.从BGR转换到HSV</span><br>    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)<br><br>    mask_blue = cv2.inRange(hsv, lower_blue, upper_blue)<br>    mask_green = cv2.inRange(hsv, lower_green, upper_green)<br>    mask_red = cv2.inRange(hsv, lower_red, upper_red)<br><br>    <span class="hljs-comment"># 3.将所有的mask相加，就可以同时显示了</span><br>    mask = mask_blue + mask_green + mask_red<br><br>    <span class="hljs-comment"># 4.保留原图中的三种颜色部分</span><br>    res = cv2.bitwise_and(frame, frame, mask=mask)<br><br>    cv2.imshow(<span class="hljs-string">'frame'</span>, frame)<br>    cv2.imshow(<span class="hljs-string">'mask'</span>, mask)<br>    cv2.imshow(<span class="hljs-string">'res'</span>, res)<br><br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">1</span>) == ord(<span class="hljs-string">'q'</span>):<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><ul><li><a href="https://docs.opencv.org/4.0.0/d8/d01/group__imgproc__color__conversions.html#ga397ae87e1288a81d2363b61574eb8cab" target="_blank" rel="noopener">cv2.cvtColor()</a></li><li><a href="https://docs.opencv.org/4.0.0/d2/de8/group__core__array.html#ga48af0ab51e36436c5d04340e036ce981" target="_blank" rel="noopener">cv2.inRange()</a></li><li><a href="https://docs.opencv.org/4.0.0/d2/de8/group__core__array.html#ga60b4d04b251ba5eb1392c34425497e14" target="_blank" rel="noopener">cv2.bitwise_and()</a></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_colorspaces/py_colorspaces.html" target="_blank" rel="noopener">Changing Colorspaces</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> HSV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程4：图像基本操作</title>
      <link href="/2019/08/13/Python-OpenCV%E6%95%99%E7%A8%8B4%EF%BC%9A%E5%9B%BE%E5%83%8F%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/08/13/Python-OpenCV%E6%95%99%E7%A8%8B4%EF%BC%9A%E5%9B%BE%E5%83%8F%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>学习<strong>获取和修改像素点的值</strong>，<strong>ROI感兴趣区域</strong>，<strong>通道分离合并</strong>等基本操作。</p><p>目标：</p><ul><li>访问和修改图片像素点的值</li><li>获取图片的宽、高、通道数等属性</li><li>了解感兴趣区域ROI</li><li>分离和合并图像通道</li></ul><p>小结：</p><ul><li><code>img[y,x]</code>获取/设置像素点值，<code>img.shape</code>：图片的形状（行数、列数、通道数）,<code>img.dtype</code>：图像的数据类型。</li><li><code>img[y1:y2,x1:x2]</code>进行ROI截取，<code>cv2.split()/cv2.merge()</code>通道分割/合并。更推荐的获取单通道方式：<code>b = img[:, :, 0]</code>。</li></ul><a id="more"></a><h2 id="获取和修改像素点值"><a href="#获取和修改像素点值" class="headerlink" title="获取和修改像素点值"></a>获取和修改像素点值</h2><p>先读取一张图片，通过行列的坐标来获取某像素点的值。</p><p>对于彩色图，结果是B, G, R三个值的列表。</p><p>对于灰度图或单通道，只有一个值。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br>img = cv2.imread(<span class="hljs-string">'lena.jpg'</span>)<br><br><span class="hljs-comment"># 获取像素的值</span><br>px = img[<span class="hljs-number">100</span>, <span class="hljs-number">90</span>]<span class="hljs-comment"># 行对应y，列对应x，所以其实是img[y, x]</span><br>print(px)  <span class="hljs-comment"># [103 98 197]</span><br><br><span class="hljs-comment"># 只获取蓝色blue通道的值</span><br>px_blue = img[<span class="hljs-number">100</span>, <span class="hljs-number">90</span>, <span class="hljs-number">0</span>]<br>print(px_blue)  <span class="hljs-comment"># 103</span><br></code></pre></td></tr></table></figure><p>修改像素的值也是同样的方式：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">img[<span class="hljs-number">100</span>, <span class="hljs-number">90</span>] = [<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>]<br>print(img[<span class="hljs-number">100</span>, <span class="hljs-number">90</span>])  <span class="hljs-comment"># [255 255 255]</span><br></code></pre></td></tr></table></figure><blockquote><p>经验之谈：还有一种性能更好的方式，获取：<code>img.item(100,100,0)</code>，修改：<code>img.itemset((100,100,0),255)</code>，但这种方式只能B,G,R逐一进行。</p></blockquote><p><strong>注意：这步操作只是内存中的img像素点值变了，因为没有保存，所以原图并没有更改。</strong></p><h2 id="图片属性"><a href="#图片属性" class="headerlink" title="图片属性"></a>图片属性</h2><p><code>img.shape</code>获取图像的形状，图片是彩色的话，返回一个包含<strong>行数（高度）、列数（宽度）和通道数</strong>的元组，灰度图只返回行数和列数：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">print(img.shape)  <span class="hljs-comment"># (263, 247, 3)</span><br><span class="hljs-comment"># 形状中包括行数、列数和通道数</span><br>height, width, channels = img.shape<br><span class="hljs-comment"># img是灰度图的话：height, width = img.shape</span><br></code></pre></td></tr></table></figure><p><code>img.size</code>获取图像总像素：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">print(img.size)  <span class="hljs-comment"># 263*247*3=194883</span><br></code></pre></td></tr></table></figure><p><code>img.dtype</code>获取图像数据类型：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">print(img.dtype)  <span class="hljs-comment"># uint8</span><br></code></pre></td></tr></table></figure><blockquote><p>经验之谈：多数错误是因为数据类型不对导致的，所以健壮的代码应该对这个属性加以判断。</p></blockquote><h2 id="ROI"><a href="#ROI" class="headerlink" title="ROI"></a>ROI</h2><p><a href="https://baike.baidu.com/item/ROI/1125333#viewPageContent" target="_blank" rel="noopener">ROI</a>：Region of Interest，感兴趣区域。</p><p>例如：我们要检测眼睛，因为眼睛肯定在脸上，所以我们感兴趣的只有脸这部分，其他都不care，所以可以单独把脸截取出来，这样就可以大大节省计算量，提高运行速度。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_lena_face_roi_crop.jpg"></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ROI截取</span><br>face = img[<span class="hljs-number">100</span>:<span class="hljs-number">200</span>, <span class="hljs-number">115</span>:<span class="hljs-number">188</span>]<br>cv2.imshow(<span class="hljs-string">'face'</span>, face)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h2 id="通道分割与合并"><a href="#通道分割与合并" class="headerlink" title="通道分割与合并"></a>通道分割与合并</h2><p>彩色图的BGR三个通道是可以分开单独访问的，也可以将单独的三个通道合并成一副图像。分别使用<code>cv2.split()</code>和<code>cv2.merge()</code>：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 通道分割与合并</span><br>b, g, r = cv2.split(img)<br>img = cv2.merge((b, g, r))<br></code></pre></td></tr></table></figure><p><code>split()</code>函数比较耗时，<strong>更高效的方式是用numpy中的索引</strong>，如提取B通道：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">b = img[:, :, <span class="hljs-number">0</span>]<br>cv2.imshow(<span class="hljs-string">'blue'</span>, b)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>打开lena.jpg，将帽子部分（高：25~120，宽：50~220）的红色通道截取出来并显示。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br>img = cv2.imread(<span class="hljs-string">'lena.jpg'</span>)<br><br><span class="hljs-comment"># 帽子ROI的红色通道</span><br>hat_r = img[<span class="hljs-number">25</span>:<span class="hljs-number">120</span>, <span class="hljs-number">50</span>:<span class="hljs-number">220</span>, <span class="hljs-number">2</span>]<br>cv2.imshow(<span class="hljs-string">'hat'</span>, hat_r)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><ul><li><a href="https://docs.opencv.org/4.0.0/d2/de8/group__core__array.html#ga0547c7fed86152d7e9d0096029c8518a" target="_blank" rel="noopener">cv2.split()</a></li><li><a href="https://docs.opencv.org/4.0.0/d2/de8/group__core__array.html#ga7d7b4d6c6ee504b30a20b1680029c7b4" target="_blank" rel="noopener">cv2.merge()</a></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_core/py_basic_ops/py_basic_ops.html#basic-ops" target="_blank" rel="noopener">Basic Operations on Images</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> ROI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程番外篇3：滑动条</title>
      <link href="/2019/08/13/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%873%EF%BC%9A%E6%BB%91%E5%8A%A8%E6%9D%A1/"/>
      <url>/2019/08/13/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%873%EF%BC%9A%E6%BB%91%E5%8A%A8%E6%9D%A1/</url>
      
        <content type="html"><![CDATA[<p>学习使用滑动条动态调整参数。</p><p>使用方式：</p><ul><li><code>cv2.createTrackbar(&#39;R&#39;, &#39;image&#39;, 0, 255, nothing)</code>：创建滑动条</li><li><code>r = cv2.getTrackbarPos(&#39;R&#39;, &#39;image&#39;)</code>：得到滑块位置</li><li>另外在回调函数中也可以获取滑块位置</li></ul><a id="more"></a><h2 id="滑动条的使用"><a href="#滑动条的使用" class="headerlink" title="滑动条的使用"></a>滑动条的使用</h2><p>首先我们需要创建一个滑动条，如<code>cv2.createTrackbar(&#39;R&#39;,&#39;image&#39;,0,255,call_back)</code>，其中</p><ul><li>参数1：滑动条的名称</li><li>参数2：所在窗口的名称</li><li>参数3：当前的值</li><li>参数4：最大值</li><li>参数5：回调函数名称，回调函数默认有一个表示当前值的参数</li></ul><p>创建好之后，可以在回调函数中获取滑动条的值。</p><p>也可以用：<code>cv2.getTrackbarPos()</code>得到，其中，参数1是滑动条的名称，参数2是窗口的名称。</p><h2 id="实例：RGB调色板"><a href="#实例：RGB调色板" class="headerlink" title="实例：RGB调色板"></a>实例：RGB调色板</h2><p>下面我们实现一个RGB的调色板，理解下滑动条的用法：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nothing</span><span class="hljs-params">(x)</span>:</span><br>    <span class="hljs-string">"""<br>    ### 回调函数,x表示滑块的位置,输出x<br>    """</span><br>    print(x)<br><br><br><span class="hljs-comment"># 创建一副300×512的纯黑色图</span><br>img = np.zeros((<span class="hljs-number">300</span>, <span class="hljs-number">512</span>, <span class="hljs-number">3</span>), np.uint8)<br>cv2.namedWindow(<span class="hljs-string">'image'</span>)<br><br><span class="hljs-comment"># 创建RGB三个滑动条</span><br>cv2.createTrackbar(<span class="hljs-string">'R'</span>, <span class="hljs-string">'image'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, nothing)<br>cv2.createTrackbar(<span class="hljs-string">'G'</span>, <span class="hljs-string">'image'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, nothing)<br>cv2.createTrackbar(<span class="hljs-string">'B'</span>, <span class="hljs-string">'image'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, nothing)<br><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">True</span>):<br>    cv2.imshow(<span class="hljs-string">'image'</span>, img)<br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">1</span>) == ord(<span class="hljs-string">'q'</span>):<br>        <span class="hljs-keyword">break</span><br><br>    <span class="hljs-comment"># 获取滑块的值</span><br>    r = cv2.getTrackbarPos(<span class="hljs-string">'R'</span>, <span class="hljs-string">'image'</span>)<br>    g = cv2.getTrackbarPos(<span class="hljs-string">'G'</span>, <span class="hljs-string">'image'</span>)<br>    b = cv2.getTrackbarPos(<span class="hljs-string">'B'</span>, <span class="hljs-string">'image'</span>)<br>    <span class="hljs-comment"># 设定img的颜色</span><br>    img[:] = [b, g, r]<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/%E8%B0%83%E8%89%B2%E6%9D%BF.png" width="70%"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><ul><li><a href="https://docs.opencv.org/4.0.0/d7/dfc/group__highgui.html#gaf78d2155d30b728fc413803745b67a9b" target="_blank" rel="noopener">cv2.createTrackbar()</a></li><li><a href="https://docs.opencv.org/4.0.0/d7/dfc/group__highgui.html#ga122632e9e91b9ec06943472c55d9cda8" target="_blank" rel="noopener">cv2.getTrackbarPos()</a></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_trackbar/py_trackbar.html" target="_blank" rel="noopener">Trackbar as the Color Palette</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程3：打开摄像头</title>
      <link href="/2019/08/13/Python-OpenCV%E6%95%99%E7%A8%8B3%EF%BC%9A%E6%89%93%E5%BC%80%E6%91%84%E5%83%8F%E5%A4%B4/"/>
      <url>/2019/08/13/Python-OpenCV%E6%95%99%E7%A8%8B3%EF%BC%9A%E6%89%93%E5%BC%80%E6%91%84%E5%83%8F%E5%A4%B4/</url>
      
        <content type="html"><![CDATA[<p>学习打开摄像头捕获照片、播放本地视频、录制视频等。</p><p>目标：</p><ul><li>打开摄像头并捕获照片</li><li>播放本地视频，录制视频</li><li>OpenCV函数：<code>cv2.VideoCapture()</code>、<code>cv2.VideoWriter()</code></li></ul><a id="more"></a><h2 id="打开摄像头"><a href="#打开摄像头" class="headerlink" title="打开摄像头"></a>打开摄像头</h2><p>要使用摄像头，需要使用<code>cv2.VideoCapture(0)</code>创建VideoCapture对象，参数0指的是摄像头的编号，如果你电脑上有两个摄像头的话，访问第2个摄像头就可以传入1，依此类推。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 打开摄像头并灰度化显示</span><br><span class="hljs-keyword">import</span> cv2<br><br>capture = cv2.VideoCapture(<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 获取捕获的分辨率</span><br><span class="hljs-comment"># propId可以直接写数字，也可以用OpenCV的符号表示</span><br>width, height = capture.get(<span class="hljs-number">3</span>), capture.get(<span class="hljs-number">4</span>)<br>print(width, height)<br><br><span class="hljs-comment"># 以原分辨率的一倍来捕获</span><br>capture.set(cv2.CAP_PROP_FRAME_WIDTH, width * <span class="hljs-number">5</span>)<br>capture.set(cv2.CAP_PROP_FRAME_HEIGHT, height * <span class="hljs-number">2</span>)<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment"># 获取一帧</span><br>    <span class="hljs-comment"># ret(return value):布尔值，表示当前这一帧是否获取正确</span><br>    ret, frame = capture.read()<br>    <span class="hljs-comment"># cv2.cvtColor()用来转换颜色，这里将这帧彩色图转化为灰度图</span><br>    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)<br><br>    cv2.imshow(<span class="hljs-string">'frame'</span>, gray)<br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">1</span>) == ord(<span class="hljs-string">'q'</span>):<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><blockquote><p>经验之谈：某些摄像头设定分辨率等参数时会无效，因为它有固定的分辨率大小支持，一般可在摄像头的资料页中找到。</p></blockquote><h2 id="播放本地视频"><a href="#播放本地视频" class="headerlink" title="播放本地视频"></a>播放本地视频</h2><p>跟打开摄像头一样，如果把摄像头的编号换成视频的路径就可以播放本地视频了。回想一下<code>cv2.waitKey()</code>，它的参数表示暂停时间，所以这个值越大，视频播放速度越慢，反之，播放速度越快，通常设置为25或30</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br><span class="hljs-comment"># 播放本地视频</span><br>capture = cv2.VideoCapture(<span class="hljs-string">'demo_video.mp4'</span>)<br><br><span class="hljs-keyword">while</span> capture.isOpened():<br>    ret, frame = capture.read()<br>    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)<br><br>    cv2.imshow(<span class="hljs-string">'frame'</span>, gray)<br>    <span class="hljs-comment"># cv2.waitKey(),参数表示暂停时间,值越大,播放速度越慢,一般设为25或30</span><br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">30</span>) == ord(<span class="hljs-string">'q'</span>):<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h2 id="录制视频"><a href="#录制视频" class="headerlink" title="录制视频"></a>录制视频</h2><p>之前我们保存图片用的是<code>cv2.imwrite()</code>，要保存视频，我们需要创建一个<code>VideoWriter</code>的对象，需要给它传入四个参数：</p><ul><li>输出的文件名，如<strong>output.avi</strong></li><li>编码方式<a href="https://baike.baidu.com/item/fourcc/6168470?fr=aladdin" target="_blank" rel="noopener">FourCC</a>码</li><li>帧率<a href="https://baike.baidu.com/item/FPS/3227416" target="_blank" rel="noopener">FPS</a></li><li>要保存的分辨率大小</li></ul><p>FourCC是用来指定视频编码方式的四字节码，所有的编码可参考<a href="http://www.fourcc.org/codecs.php" target="_blank" rel="noopener">Video Codecs</a>。如MJPG编码可以这样写： <code>cv2.VideoWriter_fourcc(*&#39;MJPG&#39;)</code>或<code>cv2.VideoWriter_fourcc(&#39;M&#39;,&#39;J&#39;,&#39;P&#39;,&#39;G&#39;)</code></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br>capture = cv2.VideoCapture(<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 定义编码方式并创建VideoWriter对象</span><br>fourcc = cv2.VideoWriter_fourcc(*<span class="hljs-string">'MJPG'</span>)<br>outfile = cv2.VideoWriter(<span class="hljs-string">'output.avi'</span>, fourcc, <span class="hljs-number">25.</span>, (<span class="hljs-number">640</span>, <span class="hljs-number">480</span>))<br><br><span class="hljs-keyword">while</span> capture.isOpened():<br>    ret, frame = capture.read()<br><br>    <span class="hljs-keyword">if</span> ret:<br>        <span class="hljs-comment"># 写入文件</span><br>        outfile.write(frame)<br><br>        cv2.imshow(<span class="hljs-string">'frame'</span>, frame)<br>        <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">1</span>) == ord(<span class="hljs-string">'q'</span>):<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>实现一个可以拖动滑块播放视频的功能。（提示：需要用到 <code>cv2.CAP_PROP_FRAME_COUNT</code>和<code>cv2.CAP_PROP_POS_FRAMES</code>两个属性）</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">track_back</span><span class="hljs-params">(x)</span>:</span><br>    <span class="hljs-string">'''<br>    ### 回调函数，x表示滑块的位置<br>    '''</span><br>    <span class="hljs-comment"># 更改视频的帧位置</span><br>    capture.set(cv2.CAP_PROP_POS_FRAMES, x)<br><br><br>cv2.namedWindow(<span class="hljs-string">'window'</span>)<br><br>capture = cv2.VideoCapture(<span class="hljs-string">'demo_video.mp4'</span>)<br><span class="hljs-comment"># 获取视频总共多少帧</span><br>frames = capture.get(cv2.CAP_PROP_FRAME_COUNT)<br><span class="hljs-comment"># 创建滑动条</span><br>cv2.createTrackbar(<span class="hljs-string">'process'</span>, <span class="hljs-string">'window'</span>, <span class="hljs-number">1</span>, int(frames), track_back)<br><br><span class="hljs-keyword">while</span> (capture.isOpened()):<br>    ret, frame = capture.read()<br><br>    cv2.imshow(<span class="hljs-string">'window'</span>, frame)<br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">30</span>) == ord(<span class="hljs-string">'q'</span>):<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><ul><li><a href="https://docs.opencv.org/4.0.0/d8/dfe/classcv_1_1VideoCapture.html" target="_blank" rel="noopener">VideoCapture Object</a></li><li><a href="https://docs.opencv.org/4.0.0/dd/d9e/classcv_1_1VideoWriter.html" target="_blank" rel="noopener">VideoWriter Object</a></li><li><a href="https://docs.opencv.org/4.0.0/d8/d01/group__imgproc__color__conversions.html#ga397ae87e1288a81d2363b61574eb8cab" target="_blank" rel="noopener">cv2.cvtColor()</a></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="http://www.fourcc.org/codecs.php" target="_blank" rel="noopener">Video Codecs by FOURCC</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_video_display/py_video_display.html" target="_blank" rel="noopener">Getting Started with Videos</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python字符串切片(slice)</title>
      <link href="/2019/08/13/Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E7%89%87-slice/"/>
      <url>/2019/08/13/Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E7%89%87-slice/</url>
      
        <content type="html"><![CDATA[<p>切片操作（slice）可以从一个字符串中获取子字符串（字符串的一部分）。我们使用<strong>一对方括号、起始偏移量start、终止偏移量end 以及可选的步长step 来定义一个分片</strong>。</p><p>格式： <code>[start:end:step]</code></p><ul><li><code>[:]</code> 提取从开头（默认位置0）到结尾（默认位置-1）的整个字符串</li><li><code>[start:]</code> 从start 提取到结尾</li><li><code>[:end]</code> 从开头提取到end - 1</li><li><code>[start:end]</code> 从start 提取到end - 1</li><li><code>[start:end:step]</code> 从start 提取到end - 1，每step 个字符提取一个</li><li>左侧第一个字符的位置偏移量为0，右侧最后一个字符的位置偏移量为-1</li></ul><a id="more"></a><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="提取最后N个字符"><a href="#提取最后N个字符" class="headerlink" title="提取最后N个字符"></a>提取最后N个字符</h3><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>letter = <span class="hljs-string">'abcdefghijklmnopqrstuvwxyz'</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>letter[<span class="hljs-number">-3</span>:]<br><span class="hljs-string">'xyz'</span><br></code></pre></td></tr></table></figure><h3 id="从开头到结尾，step为N："><a href="#从开头到结尾，step为N：" class="headerlink" title="从开头到结尾，step为N："></a>从开头到结尾，step为N：</h3><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>letter[::<span class="hljs-number">5</span>]<br><span class="hljs-string">'afkpuz'</span><br></code></pre></td></tr></table></figure><h3 id="将字符串倒转-reverse-，-通过设置步长为负数："><a href="#将字符串倒转-reverse-，-通过设置步长为负数：" class="headerlink" title="将字符串倒转(reverse)， 通过设置步长为负数："></a>将字符串倒转(reverse)， 通过设置步长为负数：</h3><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>letter[::<span class="hljs-number">-1</span>]<br><span class="hljs-string">'zyxwvutsrqponmlkjihgfedcba'</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程番外篇2：无损保存和Matplotlib使用</title>
      <link href="/2019/08/13/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%872%EF%BC%9A%E6%97%A0%E6%8D%9F%E4%BF%9D%E5%AD%98%E5%92%8CMatplotlib%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/08/13/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%872%EF%BC%9A%E6%97%A0%E6%8D%9F%E4%BF%9D%E5%AD%98%E5%92%8CMatplotlib%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>了解常用图片格式和OpenCV高质量保存图片的方式，学习如何使用Matplotlib显示OpenCV图像。</p><a id="more"></a><h2 id="无损保存"><a href="#无损保存" class="headerlink" title="无损保存"></a>无损保存</h2><p>事实上，我们日常看到的大部分图片都是压缩过的，那么都有哪些常见的图片格式呢？</p><h3 id="图片格式"><a href="#图片格式" class="headerlink" title="图片格式"></a>图片格式</h3><h4 id="格式分类"><a href="#格式分类" class="headerlink" title="格式分类"></a>格式分类</h4><ul><li>无压缩。无压缩的图片格式不对图片数据进行压缩处理，能准确地呈现原图片。BMP格式就是其中之一。</li><li>无损压缩。压缩算法对图片的所有的数据进行编码压缩，能在保证图片的质量的同时降低图片的尺寸。png是其中的代表。</li><li>有损压缩。压缩算法不会对图片所有的数据进行编码压缩，而是在压缩的时候，去除了人眼无法识别的图片细节。因此有损压缩可以在同等图片质量的情况下大幅降低图片的尺寸。其中的代表是jpg。</li></ul><h4 id="常见图片格式"><a href="#常见图片格式" class="headerlink" title="常见图片格式"></a>常见图片格式</h4><ul><li><strong>bmp：</strong>全称Bitmap，不压缩</li><li><strong>jpg：</strong>全称Joint Photographic Experts Group，有损压缩</li><li><strong>png：</strong>全称Portable Network Graphics，无损压缩</li></ul><p>简单来说，同一个文件保存成不同的格式后，<strong>文件大小上bmp肯定是最大的</strong>，而png和jpg，不同的压缩比结果会有所不同。可以用画图工具新建一副100×100的图像，分别保存成这三种格式来验证：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_high_save_mspaint_format.jpg"></p><h3 id="高质量保存"><a href="#高质量保存" class="headerlink" title="高质量保存"></a>高质量保存</h3><p>用<code>cv2.imwrite()</code>保存图片时，可以传入第三个参数（请参考<a href="https://docs.opencv.org/4.0.0/d4/da8/group__imgcodecs.html#gabbc7ef1aa2edfaa87772f1202d67e0ce" target="_blank" rel="noopener">接口文档</a>），用于控制保存质量：</p><ul><li><code>cv2.IMWRITE_JPEG_QUALITY</code>：jpg质量控制，取值0~100，值越大，质量越好，默认为95</li><li><code>cv2.IMWRITE_PNG_COMPRESSION</code>：png质量控制，取值0~9，值越大，压缩比越高，默认为1</li></ul><p>还有诸如<code>CV_IMWRITE_WEBP_QUALITY</code>的参量，不常用，请参考：<a href="https://docs.opencv.org/4.0.0/d4/da8/group__imgcodecs.html#ga292d81be8d76901bff7988d18d2b42ac" target="_blank" rel="noopener">ImwriteFlags</a>。</p><p>举例来说，原图lena.jpg的分辨率是350×350，大小49.7KB。我们把它转成不同格式看下：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>new_img = cv2.imread(<span class="hljs-string">'lena.jpg'</span>)<br><span class="hljs-comment"># new_img = np.zeros((100,100,3)) # 新建一副纯黑色图</span><br><br><span class="hljs-comment"># bmp</span><br>cv2.imwrite(<span class="hljs-string">'img_bmp.bmp'</span>, new_img)  <span class="hljs-comment"># 文件大小：359KB</span><br><br><span class="hljs-comment"># jpg 100%质量</span><br>cv2.imwrite(<span class="hljs-string">'img_jpg100.jpg'</span>, new_img, [int(cv2.IMWRITE_JPEG_QUALITY), <span class="hljs-number">100</span>])  <span class="hljs-comment"># 文件大小：82.5KB</span><br><span class="hljs-comment"># jpg 默认95%质量</span><br>cv2.imwrite(<span class="hljs-string">'img_jpg95.jpg'</span>, new_img)  <span class="hljs-comment"># 文件大小：52.3KB</span><br><span class="hljs-comment"># jpg 20%质量</span><br>cv2.imwrite(<span class="hljs-string">'img_jpg20.jpg'</span>, new_img, [int(cv2.IMWRITE_JPEG_QUALITY), <span class="hljs-number">20</span>])  <span class="hljs-comment"># 文件大小：8.01KB</span><br><br><span class="hljs-comment"># png 默认1压缩比</span><br>cv2.imwrite(<span class="hljs-string">'img_png1.png'</span>, new_img)  <span class="hljs-comment"># 文件大小：240KB</span><br><span class="hljs-comment"># png 9压缩比</span><br>cv2.imwrite(<span class="hljs-string">'img_png9.png'</span>, new_img, [int(cv2.IMWRITE_PNG_COMPRESSION), <span class="hljs-number">9</span>])  <span class="hljs-comment"># 文件大小：207KB</span><br></code></pre></td></tr></table></figure><p>可以看到：</p><ul><li>bmp文件是最大的，没有任何压缩（1个像素点1byte，3通道的彩色图总大小：350×350×3/1024 ≈ 359 KB）</li><li>jpg/png本身就有压缩的，所以就算是100%的质量保存，体积也比bmp小很多</li><li>jpg的容量优势很明显，这也是它为什么如此流行的原因</li></ul><blockquote><p>思考：为什么原图49.7KB，保存成bmp或其他格式反而大了呢？</p><p>原因：这里需要明确的是保存新格式时，<strong>容量大小跟原图的容量没有直接关系，而是取决于原图的分辨率大小和原图本身的内容（压缩方式）</strong>，所以lena.jpg保存成不压缩的bmp格式时，容量大小就是固定的350×350×3/1024 ≈ 359 KB；另外，容量变大不代表画质提升噢，不然就逆天了~~~</p></blockquote><h2 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h2><p>Matplotlib是Python的一个很常用的绘图库。</p><h3 id="显示灰度图"><a href="#显示灰度图" class="headerlink" title="显示灰度图"></a>显示灰度图</h3><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>img = cv2.imread(<span class="hljs-string">'lena.jpg'</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 显示灰度图</span><br>plt.imshow(img, cmap=<span class="hljs-string">'gray'</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><h3 id="显示彩色图"><a href="#显示彩色图" class="headerlink" title="显示彩色图"></a>显示彩色图</h3><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>img = cv2.imread(<span class="hljs-string">'lena.jpg'</span>)<br><br>img2 = img[:, :, ::<span class="hljs-number">-1</span>]<br><span class="hljs-comment"># 或使用</span><br><span class="hljs-comment"># img2 = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</span><br><span class="hljs-comment"># 显示不正确的图</span><br>plt.subplot(<span class="hljs-number">121</span>)<br>plt.imshow(img) <br><br><span class="hljs-comment"># 显示正确的图</span><br>plt.subplot(<span class="hljs-number">122</span>)<br>plt.xticks([]), plt.yticks([]) <span class="hljs-comment"># 隐藏x和y轴</span><br>plt.imshow(img2)<br><br>plt.show()<br></code></pre></td></tr></table></figure><blockquote><p><code>img[:,:,0]</code>表示图片的蓝色通道，<code>img[:,:,::-1]</code>就表示BGR翻转，变成RGB，说明一下：</p><p>熟悉Python的童鞋应该知道，对一个字符串s翻转可以这样写：<code>s[::-1]</code>，<strong>abc</strong>变成<strong>cba</strong>，-1表示逆序。图片是二维的，所以完整地复制一副图像就是：</p><p><code>img2 = img[:,:]  # 写全就是：img2 = img[0:height,0:width]</code></p><p>而图片是有三个通道，相当于一个长度为3的字符串，所以通道翻转与图片复制组合起来便是<code>img[:,:,::-1]</code>。</p></blockquote><h3 id="加载和保存图片"><a href="#加载和保存图片" class="headerlink" title="加载和保存图片"></a>加载和保存图片</h3><p>不使用OpenCV，Matplotlib也可以加载和保存图片：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 加载和保存图片</span><br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> matplotlib.image <span class="hljs-keyword">as</span> pli<br><br>img = pli.imread(<span class="hljs-string">'lena.jpg'</span>)<br>plt.imshow(img)<br><br><span class="hljs-comment"># 保存图片，需放在show()函数之前</span><br>plt.savefig(<span class="hljs-string">'lena2.jpg'</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><ul><li><a href="https://docs.opencv.org/4.0.0/d4/da8/group__imgcodecs.html#gabbc7ef1aa2edfaa87772f1202d67e0ce" target="_blank" rel="noopener">cv2.imwrite()</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/da8/group__imgcodecs.html#ga292d81be8d76901bff7988d18d2b42ac" target="_blank" rel="noopener">ImwriteFlags</a></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="https://segmentfault.com/a/1190000013589397" target="_blank" rel="noopener">聊一聊几种常用web图片格式</a></li><li><a href="http://ex2tron.wang/opencv-python-extra-high-quality-save-and-using-matplotlib/www.matplotlib.org/" target="_blank" rel="noopener">Matplotlib官网</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Matplotlib </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程2：基本元素-图片</title>
      <link href="/2019/08/13/Python-OpenCV%E6%95%99%E7%A8%8B2%EF%BC%9A%E5%9F%BA%E6%9C%AC%E5%85%83%E7%B4%A0-%E5%9B%BE%E7%89%87/"/>
      <url>/2019/08/13/Python-OpenCV%E6%95%99%E7%A8%8B2%EF%BC%9A%E5%9F%BA%E6%9C%AC%E5%85%83%E7%B4%A0-%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p>学习如何加载图片，显示并保存图片。</p><p>目标：</p><ul><li>加载图片，显示图片，保存图片</li><li>OpenCV函数：<code>cv2.imread()</code>加载图片、<code>cv2.imshow()</code>显示图片、<code>cv2.imwrite()</code>保存图片</li></ul><a id="more"></a><p>大部分人可能都知道电脑上的彩色图是以RGB(红-绿-蓝，Red-Green-Blue)颜色模式显示的，但OpenCV中彩色图是以<strong>B-G-R</strong>通道顺序存储的，灰度图只有一个通道。</p><p>图像坐标的起始点是在左上角，所以行对应的是y，列对应的是x：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/%E5%9F%BA%E6%9C%AC%E5%85%83%E7%B4%A0%E5%9B%BE%E7%89%87.jpg"></p><h2 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h2><p>使用<code>cv2.imread()</code>读取一张图片：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br><span class="hljs-comment"># 灰度图加载一张彩色图</span><br>img = cv2.imread(<span class="hljs-string">'lena.jpg'</span>, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><ul><li>参数1：图片的文件名<ul><li>如果图片放在当前文件夹下，直接写文件名就行了，如’lena.jpg’</li><li>否则需要给出绝对路径，如’D:\OpenCVSamples\lena.jpg’</li></ul></li><li>参数2：读入方式，省略即采用默认值<ul><li><code>cv2.IMREAD_COLOR</code>：彩色图，默认值(1)</li><li><code>cv2.IMREAD_GRAYSCALE</code>：灰度图(0)</li><li><code>cv2.IMREAD_UNCHANGED</code>：包含透明通道的彩色图(-1)</li></ul></li></ul><blockquote><p>经验之谈：路径中不能有中文噢，并且没有加载成功的话是不会报错的，<code>print(img)</code>的结果为None，后面处理才会报错，算是个小坑。</p></blockquote><h2 id="显示图片"><a href="#显示图片" class="headerlink" title="显示图片"></a>显示图片</h2><p>使用<code>cv2.imshow()</code>显示图片，窗口会自适应图片的大小：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 显示图片</span><br>cv2.imshow(<span class="hljs-string">'lena'</span>, img)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><code>cv2.waitKey()</code>是让程序暂停的意思，参数是等待时间(毫秒ms)。</p><p>时间一到，会继续执行接下来的程序，传入0的话表示一直等待。</p><p>等待期间可以获取用户的按键输入：<code>k=cv2.waitKey(0)</code></p><p>我们也可以先用<code>cv2.namedWindow()</code>创建一个窗口，之后再显示图片：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 先定义窗口，后显示图片</span><br>cv2.namedWindow(<span class="hljs-string">'lena2'</span>, cv2.WINDOW_NORMAL)<br>cv2.imshow(<span class="hljs-string">'lena2'</span>, img)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>参数1依旧是窗口的名字，参数2默认是<code>cv2.WINDOW_AUTOSIZE</code>，表示窗口大小自适应图片，也可以设置为<code>cv2.WINDOW_NORMAL</code>，表示窗口大小可调整。图片比较大的时候，可以考虑用后者。</p><h2 id="保存图片"><a href="#保存图片" class="headerlink" title="保存图片"></a>保存图片</h2><p>使用<code>cv2.imwrite()</code>保存图片，参数1是包含后缀名的文件名：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 保存图片</span><br>cv2.imwrite(<span class="hljs-string">'lena_gray.jpg'</span>, img)<br></code></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br><span class="hljs-comment"># 1.灰度图加载一张彩色图</span><br>img = cv2.imread(<span class="hljs-string">'lena.jpg'</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 2.显示图片</span><br>cv2.imshow(<span class="hljs-string">'lena'</span>, img)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 先定义窗口，后显示图片</span><br>cv2.namedWindow(<span class="hljs-string">'lena2'</span>, cv2.WINDOW_NORMAL)<br>cv2.imshow(<span class="hljs-string">'lena2'</span>, img)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 3.保存图片</span><br>cv2.imwrite(<span class="hljs-string">'lena_gray.jpg'</span>, img)<br></code></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>打开<strong>lena.jpg</strong>并显示，如果按下<strong>s</strong>，就保存图片为<strong>lena_save.bmp</strong>，否则就结束程序。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br>img = cv2.imread(<span class="hljs-string">'lena.jpg'</span>)<br>cv2.imshow(<span class="hljs-string">'lena'</span>, img)<br><br>k = cv2.waitKey(<span class="hljs-number">0</span>)<br><span class="hljs-comment"># ord()用来获取某个字符的编码</span><br><span class="hljs-keyword">if</span> k == ord(<span class="hljs-string">'s'</span>):<br>    cv2.imwrite(<span class="hljs-string">'lena_save.bmp'</span>, img)<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><ul><li><a href="https://docs.opencv.org/4.0.0/d3/d63/classcv_1_1Mat.html" target="_blank" rel="noopener">Mat Object</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/da8/group__imgcodecs.html#ga288b8b3da0892bd651fce07b3bbd3a56" target="_blank" rel="noopener">cv2.imread()</a></li><li><a href="https://docs.opencv.org/4.0.0/d7/dfc/group__highgui.html#ga453d42fe4cb60e5723281a89973ee563" target="_blank" rel="noopener">cv2.imshow()</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/da8/group__imgcodecs.html#gabbc7ef1aa2edfaa87772f1202d67e0ce" target="_blank" rel="noopener">cv2.imwrite()</a></li><li><a href="https://docs.opencv.org/4.0.0/d7/dfc/group__highgui.html#ga5afdf8410934fd099df85c75b2e0888b" target="_blank" rel="noopener">cv.namedWindow()</a></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_image_display/py_image_display.html" target="_blank" rel="noopener">Getting Started with Images</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程番外篇1：代码性能优化</title>
      <link href="/2019/08/13/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%871%EF%BC%9A%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2019/08/13/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%871%EF%BC%9A%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>完成一项任务很重要，高效地完成更重要。图像处理是对矩阵的操作，数据量巨大。如果代码写的不好，性能差距将很大，所以这节我们来了解下如何评估和提升代码性能。</p><a id="more"></a><h2 id="评估代码运行时间"><a href="#评估代码运行时间" class="headerlink" title="评估代码运行时间"></a>评估代码运行时间</h2><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br>start = cv2.getTickCount()<br><span class="hljs-comment"># 这里写测试代码...</span><br>end = cv2.getTickCount()<br>print((end - start) / cv2.getTickFrequency())<br></code></pre></td></tr></table></figure><p>这段代码就是用来测量程序运行时间的（单位：s），其中<code>cv2.getTickCount()</code>函数得到电脑启动以来的时钟周期数，<code>cv2.getTickFrequency()</code>返回你电脑的主频，前后相减再除以主频就是你代码的运行时间（这样解释并不完全准确，但能理解就行）。另外，也可以用Python中的time模块计时：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br>start = time.clock()<br><span class="hljs-comment"># 这里写测试代码...</span><br>end = time.clock()<br>print(end - start)<br></code></pre></td></tr></table></figure><h2 id="优化原则"><a href="#优化原则" class="headerlink" title="优化原则"></a>优化原则</h2><p>数据元素少时用Python语法，数据元素多时用Numpy：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> time<br><br>x = <span class="hljs-number">10</span><br>z = np.uint8([<span class="hljs-number">10</span>])<br><br><span class="hljs-comment"># 尝试比较下面三句话各自的运行时间</span><br>s1 = time.clock()<br>y1 = x * x * x<br>e1 = time.clock()<br>print(e1 - s1)  <span class="hljs-comment"># 1.2000000000012001e-05</span><br><br>s2 = time.clock()<br>y2 = x ** <span class="hljs-number">3</span><br>e2 = time.clock()<br>print(e2 - s2)  <span class="hljs-comment"># 8.999999999925734e-06</span><br><br>s3 = time.clock()<br>y3 = z * z * z<br>e3 = time.clock()<br>print(e3 - s3)  <span class="hljs-comment"># 0.003105999999999942</span><br></code></pre></td></tr></table></figure><p>所以Numpy的运行速度并不一定比Python本身语法快，元素数量较少时，请用Python本身格式。</p><ul><li>尽量避免使用循环，尤其嵌套循环，因为极其慢！！！</li><li>优先使用OpenCV/Numpy中封装好的函数</li><li>尽量将数据向量化，变成Numpy的数据格式</li><li>尽量避免数组的复制操作</li></ul><h2 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h2><ul><li><a href="https://docs.opencv.org/4.0.0/db/de0/group__core__utils.html#gae73f58000611a1af25dd36d496bf4487" target="_blank" rel="noopener">cv2.getTickCount()</a></li><li><a href="https://docs.opencv.org/4.0.0/db/de0/group__core__utils.html#ga705441a9ef01f47acdc55d87fbe5090c" target="_blank" rel="noopener">cv2.getTickFrequency()</a></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://wiki.python.org/moin/PythonSpeed/PerformanceTips" target="_blank" rel="noopener">Python Optimization Techniques</a></li><li><a href="http://pynash.org/2013/03/06/timing-and-profiling/" target="_blank" rel="noopener">Timing and Profiling in IPython</a></li><li><a href="http://www.scipy-lectures.org/advanced/advanced_numpy/index.html#advanced-numpy" target="_blank" rel="noopener">Advanced Numpy</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程1：简介与安装</title>
      <link href="/2019/08/13/Python+OpenCV%E6%95%99%E7%A8%8B1%EF%BC%9A%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85/"/>
      <url>/2019/08/13/Python+OpenCV%E6%95%99%E7%A8%8B1%EF%BC%9A%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>相信大部分人知道的OpenCV都是用C++来开发的，那为什么我推荐使用Python呢？</p><a id="more"></a><h2 id="Python照样快！"><a href="#Python照样快！" class="headerlink" title="Python照样快！"></a>Python照样快！</h2><p>众所周知，虽然Python语法简洁，编写高效，但相比C/C++运行慢很多。然而Python还有个重要的特性：它是一门胶水语言！Python可以很容易地扩展C/C++。<strong>OpenCV-Python</strong>就是用Python包装了C++的实现，背后实际就是C++的代码在跑，所以代码的运行速度跟原生C/C++速度一样快。</p><p>我举两个简单的例子就一目了然了：一个是读入图片，另一个是调整图片的对比度和亮度：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_python_vs_cplus_speed.jpg"></p><p><strong>可以看到某些情况下Python的运行速度甚至好于C++，代码行数也直接少一半多！</strong>另外，图像是矩阵数据，OpenCV-Python原生支持<a href="https://baike.baidu.com/item/numpy" target="_blank" rel="noopener">Numpy</a>，相当于Python中的Matlab，为矩阵运算、科学计算提供了极大的便利性。</p><h2 id="人工智能浪潮"><a href="#人工智能浪潮" class="headerlink" title="人工智能浪潮"></a>人工智能浪潮</h2><p>近些年，人工智能相关技术的快速发展大家有目共睹，不必多说。在编程语言方面，更多人希望的是具备高效开发效率、跨平台、高度扩展性的语言，尤其是一些AI巨头优先推出支持Python语言的深度学习框架，如Facebook的<a href="https://pytorch.org/" target="_blank" rel="noopener">PyTorch</a>、Google的<a href="https://tensorflow.google.cn/" target="_blank" rel="noopener">Tensorflow</a>等，可以说Python是名副其实的“网红语言”了。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_ai_ml_dl2.jpg"></p><p>从<a href="https://www.tiobe.com/tiobe-index/" target="_blank" rel="noopener">TIOBE编程语言排行榜</a>也可以看到，Python发展迅猛，已经逼近C++的份额。这个排行榜每月更新，我就不截图了，编写时TOP5：Java/C/Python/C++/C#。</p><h2 id="人生苦短，我用Python"><a href="#人生苦短，我用Python" class="headerlink" title="人生苦短，我用Python"></a>人生苦短，我用Python</h2><ul><li>如果你搞科研用，果断放弃C++（Matlab？出门左拐）</li><li>如果你是快速原型开发，验证方案，果断放弃C++</li><li>如果你懒的配置OpenCV环境，果断放弃C++</li><li>如果你的程序是在支持Python的较高硬件环境下运行，果断放弃C++</li><li>如果你担心Python写不了界面，那是你的问题o_o ….</li><li>除非你的程序是MFC或已经用C++编写其他模块或是嵌入式设备，那就用C++吧</li></ul><p><strong>“人生苦短，我用Python！！！”</strong></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>要安装OpenCV，只需执行指令：<code>pip install opencv-python</code></p><p>安装完成后，输入：<code>import cv2</code>，如果运行没有报错说明一切正常。</p><p>如果要查看OpenCV的版本，可以：<code>print(cv2.__version__)</code></p><h2 id="网络资料"><a href="#网络资料" class="headerlink" title="网络资料"></a>网络资料</h2><ul><li><a href="https://docs.opencv.org/" target="_blank" rel="noopener"><strong>OpenCV Docs官方文档</strong></a></li><li><a href="https://github.com/opencv/opencv" target="_blank" rel="noopener">OpenCV 官方Github</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_tutorials.html" target="_blank" rel="noopener">官方英文教程：OpenCV-Python Tutorials</a></li><li><a href="http://www.learnopencv.com/" target="_blank" rel="noopener">LearnOpenCV</a>、<a href="https://github.com/spmallick/learnopencv" target="_blank" rel="noopener">LearnOpenCV Github</a></li><li><a href="https://docs.scipy.org/doc/numpy-dev/user/quickstart.html" target="_blank" rel="noopener">Numpy Quickstart Tutorial</a></li><li><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/tutorials.html" target="_blank" rel="noopener">OpenCV 中文教程</a></li></ul><h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><ul><li><a href="http://programmingcomputervision.com/" target="_blank" rel="noopener">Programming Computer Vision with Python</a>、<a href="https://www.amazon.cn/dp/B00L3Y3NEM/ref=sr_1_1?ie=UTF8&amp;qid=1543929834&amp;sr=8-1&amp;keywords=Python+计算机视觉" target="_blank" rel="noopener">中文书</a></li><li><a href="https://www.pyimagesearch.com/practical-python-opencv/" target="_blank" rel="noopener">https://www.pyimagesearch.com/practical-python-opencv/</a></li></ul><h2 id="名校视觉研究所-课程"><a href="#名校视觉研究所-课程" class="headerlink" title="名校视觉研究所/课程"></a>名校视觉研究所/课程</h2><ul><li><a href="http://graphics.cs.cmu.edu/" target="_blank" rel="noopener">卡内基梅隆大学</a></li><li><a href="https://www.cs.toronto.edu/~guerzhoy/320/" target="_blank" rel="noopener">多伦多大学</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k-近邻算法</title>
      <link href="/2019/08/13/k-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/"/>
      <url>/2019/08/13/k-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NearestNeighbor</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">train</span><span class="hljs-params">(self, X, y)</span>:</span><br>        <span class="hljs-string">"""X is N x D where each row is an example. Y is 1-dimension of sizee N"""</span><br>        self.Xtr = X<br>        self.ytr = y<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">predict</span><span class="hljs-params">(self, X)</span>:</span><br>        <span class="hljs-string">"""X is N x D where each row is an example we wish to predict label for"""</span><br>        num_test = X.shape[<span class="hljs-number">0</span>]<br>        <span class="hljs-comment"># lets make sure that the output type matches the input type</span><br>        Ypred = np.zeros(num_test, dtype=self.ytr.dtype)<br><br>        <span class="hljs-comment"># loop over all test rows</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(num_test):<br>            <span class="hljs-comment"># find the nearest training image to the i'th test image</span><br>            <span class="hljs-comment"># using the L1 distance(sum of absolute value differences)</span><br>            distances = np.sum(np.abs(self.Xtr - X[i, :]), axis=<span class="hljs-number">1</span>)<br>            min_index = np.argmin(distances)  <span class="hljs-comment"># get the index with smallest distance</span><br>            Ypred[i] = self.ytr[min_index]  <span class="hljs-comment"># predict the label of the nearest example</span><br><br>        <span class="hljs-keyword">return</span> Ypred<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
          <category> 监督学习 </category>
          
          <category> 分类算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> k-近邻算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解析库的使用</title>
      <link href="/2019/08/11/%E8%A7%A3%E6%9E%90%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/08/11/%E8%A7%A3%E6%9E%90%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>对于网页节点来说，它可以定义<code>id</code>，<code>class</code>或其他属性。节点之间还有层次关系，在网页中可以通过<strong>XPath</strong>或<strong>CSS选择器</strong>来定位一个或多个节点。</p><a id="more"></a><h2 id="XPath"><a href="#XPath" class="headerlink" title="XPath"></a>XPath</h2><p>XPath(XML Path Language，XML路径语言)，它是一门在XML文档中查找信息的语言。</p><p>它最初是用来搜寻XML文档的，但是它同样适用于HTML文档的搜索。</p><h3 id="XPath简介"><a href="#XPath简介" class="headerlink" title="XPath简介"></a>XPath简介</h3><p>XPath的选择功能十分强大，它提供了非常简洁明了的<strong>路径选择表达式</strong>。另外，它还提供100个内建函数，用于字符串、数值、时间的匹配以及节点、序列的处理等。<strong>几乎所有我们想要定位的节点，都可以用XPath来选择。</strong></p><p>XPath于1999年11月16日成为W3C的标准，它被设计为供XSLT、XPointer以及其他XML解析软件使用。</p><h3 id="XPath规则"><a href="#XPath规则" class="headerlink" title="XPath规则"></a>XPath规则</h3><div class="table-container"><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>nodename</td><td>选取此节点的所有子节点</td></tr><tr><td>/</td><td>从当前节点选取直接子节点</td></tr><tr><td>//</td><td>从当前节点选取子孙节点</td></tr><tr><td>.</td><td>选取当前节点</td></tr><tr><td>..</td><td>选取当前节点的父节点</td></tr><tr><td>@</td><td>选取属性</td></tr></tbody></table></div><p>举个例子：<code>//title[@lang=&#39;eng&#39;]</code></p><p>它代表选择所有名称为<strong>title</strong>，同时属性<strong>lang</strong>的值为<strong>eng</strong>的节点。</p><h3 id="实例引入"><a href="#实例引入" class="headerlink" title="实例引入"></a>实例引入</h3><p>通过实例来感受一下使用XPath对网页进行解析的过程。</p><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python">from lxml import etree  # 导入lxml库的etree模块<br><br># 申明一段HTML文本<br>text = '''<br>&lt;div&gt;<br>&lt;ul&gt;<br>&lt;li class="item-0"&gt;&lt;a href="link1.html"&gt;first item&lt;/a&gt;&lt;/li&gt;<br>&lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt;<br>&lt;li class="item-inactive"&gt;&lt;a href="link3.html"&gt;third item&lt;/a&gt;&lt;/li&gt;<br>&lt;li class="item-1"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt;<br>&lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt;<br>&lt;/ul&gt;<br>&lt;/div&gt;<br>'''<br><br># 调用HTML类进行初始化,这样就可以成功构造一个XPath解析对象<br>html = etree.HTML(text)<br># 通过调用tostring()方法可以输出修正后的HTML代码,但是结果是bytes类型<br>result = etree.tostring(html)   <br># 利用decode()方法可以将其转成str类型<br>print(result.decode('utf-8'))<br><br>***************************************************************<br><br>运行结果：<br>&lt;html&gt;&lt;body&gt;&lt;div&gt;<br>&lt;ul&gt;<br>&lt;li class="item-0"&gt;&lt;a href="link1.html"&gt;first item&lt;/a&gt;&lt;/li&gt;<br>&lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt;<br>&lt;li class="item-inactive"&gt;&lt;a href="link3.html"&gt;third item&lt;/a&gt;&lt;/li&gt;<br>&lt;li class="item-1"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt;<br>&lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt;<br>&lt;/ul&gt;<br>&lt;/div&gt;<br>&lt;/body&gt;&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>另外也可以直接读取文本文件进行解析，如下：</p><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python">from lxml import etree  # 导入lxml库的etree模块<br><br># 调用HTML类进行初始化,这样就可以成功构造一个XPath解析对象<br># test.html存放HTML代码<br>html = etree.parse('./test.html', etree.HTMLParser())<br># 通过调用tostring()方法可以输出修正后的HTML代码,但是结果是bytes类型<br>result = etree.tostring(html)<br># 利用decode()方法可以将其转成str类型<br>print(result.decode('utf-8'))<br><br>***************************************************************<br><br>运行结果：<br>&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"&gt;<br>&lt;html&gt;&lt;body&gt;&lt;div&gt;<br>&lt;ul&gt;<br>&lt;li class="item-0"&gt;&lt;a href="link1.html"&gt;first item&lt;/a&gt;&lt;/li&gt;<br>&lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt;<br>&lt;li class="item-inactive"&gt;&lt;a href="link3.html"&gt;third item&lt;/a&gt;&lt;/li&gt;<br>&lt;li class="item-1"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt;<br>&lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt;<br>&lt;/ul&gt;<br>&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>虽然输出多了一个DOCTYPE的声明，不过对解析无影响。</p><h3 id="所有结点"><a href="#所有结点" class="headerlink" title="所有结点"></a>所有结点</h3><p>我们一般会用<code>//</code>开头的XPath规则来选取所有符合要求的节点。</p><p>以上面的HTML文本为例，如果要选取所有节点，则可以这样实现：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree  <span class="hljs-comment"># 导入lxml库的etree模块</span><br><br><span class="hljs-comment"># 调用HTML类进行初始化,这样就可以成功构造一个XPath解析对象</span><br>html = etree.parse(<span class="hljs-string">'./test.html'</span>, etree.HTMLParser())<br><span class="hljs-comment"># 这里*代表匹配所有节点,即整个HTML文本中的所有节点都会被获取</span><br>result = html.xpath(<span class="hljs-string">'//*'</span>)<br>print(result)<br><br>***************************************************************<br><br>运行结果：<br>[&lt;Element html at <span class="hljs-number">0x1078e2b48</span>&gt;, &lt;Element body at <span class="hljs-number">0x1078e2c48</span>&gt;, &lt;Element div at <span class="hljs-number">0x1078e2c88</span>&gt;, &lt;Element ul at <span class="hljs-number">0x1078e2cc8</span>&gt;, &lt;Element li at <span class="hljs-number">0x1078e2d08</span>&gt;, &lt;Element a at <span class="hljs-number">0x1078e2d48</span>&gt;, &lt;Element li at <span class="hljs-number">0x1078e2d88</span>&gt;, &lt;Element a at <span class="hljs-number">0x1078e2dc8</span>&gt;, &lt;Element li at <span class="hljs-number">0x1078e2e08</span>&gt;, &lt;Element a at <span class="hljs-number">0x1078e2e48</span>&gt;, &lt;Element li at <span class="hljs-number">0x1078e2e88</span>&gt;, &lt;Element a at <span class="hljs-number">0x1078e2ec8</span>&gt;, &lt;Element li at <span class="hljs-number">0x1078e2f08</span>&gt;, &lt;Element a at <span class="hljs-number">0x1078e2f48</span>&gt;]<br></code></pre></td></tr></table></figure><p>可以看到运行结果是一个列表，每个元素是<strong>Element类型</strong>，其后跟了节点的名称，如html、body、div、ul、li、a等，所有节点都包含在列表中了。</p><p>当然，我们也可以通过匹配指定节点名称。如果想要获取所有li节点，可以做如下选择：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree  <span class="hljs-comment"># 导入lxml库的etree模块</span><br><br><span class="hljs-comment"># 调用HTML类进行初始化,这样就可以成功构造一个XPath解析对象</span><br>html = etree.parse(<span class="hljs-string">'./test.html'</span>, etree.HTMLParser())<br><span class="hljs-comment"># 这里使用"//li"选取所有li节点</span><br>result = html.xpath(<span class="hljs-string">'//li'</span>)<br>print(result)<br><span class="hljs-comment"># 如果要取出其中的一个对象，可以直接用中括号加索引，如[0]</span><br>print(result[<span class="hljs-number">0</span>])<br><br>***************************************************************<br><br>运行结果：<br>[&lt;Element li at <span class="hljs-number">0x1067c9c48</span>&gt;, &lt;Element li at <span class="hljs-number">0x1067c9c88</span>&gt;, &lt;Element li at <span class="hljs-number">0x1067c9cc8</span>&gt;, &lt;Element li at <span class="hljs-number">0x1067c9d08</span>&gt;, &lt;Element li at <span class="hljs-number">0x1067c9d48</span>&gt;]<br>&lt;Element li at <span class="hljs-number">0x1067c9c48</span>&gt;<br></code></pre></td></tr></table></figure><p>可以看到提取结果是一个列表形式，其中每个元素都是一个<strong>Element对象</strong>。</p><h3 id="子节点"><a href="#子节点" class="headerlink" title="子节点"></a>子节点</h3><p>我们通过<code>/</code>或<code>//</code>即可查找元素的子节点或子孙节点。</p><p>假如现在想要选择li节点的所有直接a子节点，可以这样实现：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree  <span class="hljs-comment"># 导入lxml库的etree模块</span><br><br><span class="hljs-comment"># 调用HTML类进行初始化,这样就可以成功构造一个XPath解析对象</span><br>html = etree.parse(<span class="hljs-string">'./test.html'</span>, etree.HTMLParser())<br><span class="hljs-comment"># 这里通过追加"/a"即选择了所有li节点的所有直接a子节点</span><br>result = html.xpath(<span class="hljs-string">'//li/a'</span>)<br>print(result)<br><br>***************************************************************<br><br>运行结果：<br>[&lt;Element a at <span class="hljs-number">0x1065c2c48</span>&gt;, &lt;Element a at <span class="hljs-number">0x1065c2c88</span>&gt;, &lt;Element a at <span class="hljs-number">0x1065c2cc8</span>&gt;, &lt;Element a at <span class="hljs-number">0x1065c2d08</span>&gt;, &lt;Element a at <span class="hljs-number">0x1065c2d48</span>&gt;]<br></code></pre></td></tr></table></figure><p>此处的<code>/</code>用于选取直接子节点，如果要获取所有子孙节点，就可以使用<code>//</code>。</p><p>例如，要获取ul节点下的所有子孙a节点，可以这样实现：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree  <span class="hljs-comment"># 导入lxml库的etree模块</span><br><br><span class="hljs-comment"># 调用HTML类进行初始化,这样就可以成功构造一个XPath解析对象</span><br>html = etree.parse(<span class="hljs-string">'./test.html'</span>, etree.HTMLParser())<br><span class="hljs-comment"># 这里通过追加"/a"即选择了所有li节点的所有直接a子节点</span><br>result = html.xpath(<span class="hljs-string">'//ul//a'</span>)<br>print(result)<br><br>***************************************************************<br><br>运行结果：<br>[&lt;Element a at <span class="hljs-number">0x1088e2c48</span>&gt;, &lt;Element a at <span class="hljs-number">0x1088e2c88</span>&gt;, &lt;Element a at <span class="hljs-number">0x1088e2cc8</span>&gt;, &lt;Element a at <span class="hljs-number">0x1088e2d08</span>&gt;, &lt;Element a at <span class="hljs-number">0x1088e2d48</span>&gt;]<br></code></pre></td></tr></table></figure><p>但是如果这里使用<code>result = html.xpath(&#39;//ul/a&#39;)</code>，则无法获取任何结果。因为<code>/</code>用户获取直接子节点，而在ul节点下没有直接a子节点，只有li节点，所以无法获取任何匹配结果。</p><h3 id="父节点"><a href="#父节点" class="headerlink" title="父节点"></a>父节点</h3><p>可以用<code>..</code>来实现查找父节点。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree  <span class="hljs-comment"># 导入lxml库的etree模块</span><br><br><span class="hljs-comment"># 调用HTML类进行初始化,这样就可以成功构造一个XPath解析对象</span><br>html = etree.parse(<span class="hljs-string">'./test.html'</span>, etree.HTMLParser())<br><span class="hljs-comment"># 现在首先选中href属性为link4.html的a节点,</span><br><span class="hljs-comment"># 然后再获取其父节点,然后再获取其class属性</span><br>result = html.xpath(<span class="hljs-string">'//a[@href="link4.html"]/../@class'</span>)<br>print(result)<br><br>***************************************************************<br><br>运行结果：<br>[<span class="hljs-string">'item-1'</span>]<br></code></pre></td></tr></table></figure><p>检查一下结果发现，这正是我们获取目标li节点的class。</p><p>同时我们也可以通过<code>parent::</code>来获取父节点，代码如下：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree  <span class="hljs-comment"># 导入lxml库的etree模块</span><br><br><span class="hljs-comment"># 调用HTML类进行初始化,这样就可以成功构造一个XPath解析对象</span><br>html = etree.parse(<span class="hljs-string">'./test.html'</span>, etree.HTMLParser())<br><span class="hljs-comment"># 现在首先选中href属性为link4.html的a节点,</span><br><span class="hljs-comment"># 然后再获取其父节点,然后再获取其class属性</span><br>result = html.xpath(<span class="hljs-string">'//a[@href="link4.html"]/parent::*/@class'</span>)<br>print(result)<br><br>***************************************************************<br><br>运行结果：<br>[<span class="hljs-string">'item-1'</span>]<br></code></pre></td></tr></table></figure><h3 id="属性匹配"><a href="#属性匹配" class="headerlink" title="属性匹配"></a>属性匹配</h3><p>在选取的时候，我们还可以通过<code>@</code>符号进行属性过滤。</p><p>比如，我们要选取class为<code>item-0</code>的li节点，可以这样实现：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree  <span class="hljs-comment"># 导入lxml库的etree模块</span><br><br><span class="hljs-comment"># 调用HTML类进行初始化,这样就可以成功构造一个XPath解析对象</span><br>html = etree.parse(<span class="hljs-string">'./test.html'</span>, etree.HTMLParser())<br><span class="hljs-comment"># 通过加入[@class="item-0"]限制了节点的class属性为"item-0"</span><br>result = html.xpath(<span class="hljs-string">'//li[@class="item-0"]'</span>)<br>print(result)<br><br>***************************************************************<br><br>运行结果：<br>[&lt;Element li at <span class="hljs-number">0x1078e2c48</span>&gt;, &lt;Element li at <span class="hljs-number">0x1078e2c88</span>&gt;]<br></code></pre></td></tr></table></figure><h3 id="文本获取"><a href="#文本获取" class="headerlink" title="文本获取"></a>文本获取</h3><p>我们用XPath中的<code>text()</code>方法获取节点中的文本，接下来尝试获取前面li节点中的文本，相关代码如下：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree  <span class="hljs-comment"># 导入lxml库的etree模块</span><br><br><span class="hljs-comment"># 调用HTML类进行初始化,这样就可以成功构造一个XPath解析对象</span><br>html = etree.parse(<span class="hljs-string">'./test.html'</span>, etree.HTMLParser())<br><span class="hljs-comment"># 两种方式:</span><br><span class="hljs-comment"># 一种是先选取a节点再获取文本</span><br>result1 = html.xpath(<span class="hljs-string">'//li[@class="item-0"]/a/text()'</span>)<br><span class="hljs-comment"># 一种是直接使用//获取文本</span><br>result2 = html.xpath(<span class="hljs-string">'//li[@class="item-0"]//text()'</span>)<br><span class="hljs-comment"># 两者结果一样,但使用“//”有时会获取更多的内容</span><br>print(result1, result2)<br><br>***************************************************************<br><br>运行结果：<br>[<span class="hljs-string">'first item'</span>, <span class="hljs-string">'fifth item'</span>] [<span class="hljs-string">'first item'</span>, <span class="hljs-string">'fifth item'</span>]<br></code></pre></td></tr></table></figure><ul><li>如果想要获取子孙节点内部的所有文本，可以直接用<code>//text()</code>的方式，这样可以保证获取到最全面的文本信息，但是可能会夹杂一些换行符等特殊字符；</li><li>如果想要获取某些特定子孙节点下的所有文本，可以先选取到特定的子孙节点，然后再调用<code>text()</code>方法获取其内部文本，这样可以保证获取的结果是整洁的。</li></ul><h3 id="属性获取"><a href="#属性获取" class="headerlink" title="属性获取"></a>属性获取</h3><p>用<code>@</code>符号来获取属性。</p><p>例如，我们想要获取<strong>所有li节点下所有a节点的href属性</strong>，代码如下：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree  <span class="hljs-comment"># 导入lxml库的etree模块</span><br><br><span class="hljs-comment"># 调用HTML类进行初始化,这样就可以成功构造一个XPath解析对象</span><br>html = etree.parse(<span class="hljs-string">'./test.html'</span>, etree.HTMLParser())<br><span class="hljs-comment"># 通过@href即可获取节点的href属性</span><br>result = html.xpath(<span class="hljs-string">'//li/a/@href'</span>)<br>print(result)<br><br>***************************************************************<br><br>运行结果：<br>[<span class="hljs-string">'link1.html'</span>, <span class="hljs-string">'link2.html'</span>, <span class="hljs-string">'link3.html'</span>, <span class="hljs-string">'link4.html'</span>, <span class="hljs-string">'link5.html'</span>]<br></code></pre></td></tr></table></figure><p>可以看到，我们成功获取了<strong>所有li节点下a节点的href属性</strong>，它们以列表形式返回。</p><p>注意，<strong>属性获取</strong>和<strong>属性匹配</strong>不同：</p><ul><li><strong>属性匹配</strong>：是中括号加属性名和值来限定某个属性，如：<code>[@href=&quot;link1.html&quot;]</code></li><li><strong>属性获取</strong>：是值获取节点的某个属性，如：<code>@href</code></li></ul><h3 id="属性多值匹配"><a href="#属性多值匹配" class="headerlink" title="属性多值匹配"></a>属性多值匹配</h3><p>有时候，某些节点的某个属性可能有多个值，例如：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree  <span class="hljs-comment"># 导入lxml库的etree模块</span><br><br>text = <span class="hljs-string">'''<br>&lt;li class="li li-first"&gt;&lt;a href="link1.html"&gt;first item&lt;/a&gt;&lt;/li&gt;<br>'''</span><br>html = etree.HTML(text)<br>result = html.xpath(<span class="hljs-string">'//li[@class="li"]/a/text()'</span>)<br>print(result)<br><br>***************************************************************<br><br>运行结果：<br>[]<br></code></pre></td></tr></table></figure><p>这里HTML文本中li节点的<strong>class属性</strong>有两个值<strong>li</strong>和<strong>li-first</strong>，此时如果还想用之前的属性匹配获取，就无法匹配了。</p><p>因此，就需要使用<code>contains()</code>函数了，代码可以改写如下：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree  <span class="hljs-comment"># 导入lxml库的etree模块</span><br><br>text = <span class="hljs-string">'''<br>&lt;li class="li li-first"&gt;&lt;a href="link1.html"&gt;first item&lt;/a&gt;&lt;/li&gt;<br>'''</span><br>html = etree.HTML(text)<br>result = html.xpath(<span class="hljs-string">'//li[contains(@class,"li")]/a/text()'</span>)<br>print(result)<br><br>***************************************************************<br><br>运行结果：<br>[<span class="hljs-string">'first item'</span>]<br></code></pre></td></tr></table></figure><p>这样通过<code>contains()</code>方法：</p><ul><li>第一个参数传入属性名称</li><li>第二个参数传入属性值</li></ul><p>只要此属性包含所传入的属性值，就可以完成匹配了。</p><p>这种方式在某个节点的某个属性有多个值的时候经常用到，如：某个节点的class属性通常由多个。</p><h3 id="多属性匹配"><a href="#多属性匹配" class="headerlink" title="多属性匹配"></a>多属性匹配</h3><p>根据多个属性确定一个节点，这时就需要同时匹配多个属性。</p><p>此时可以使用运算符<code>and</code>来连接，实例如下：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree  <span class="hljs-comment"># 导入lxml库的etree模块</span><br><br>text = <span class="hljs-string">'''<br>&lt;li class="li li-first" name="item"&gt;&lt;a href="link1.html"&gt;first item&lt;/a&gt;&lt;/li&gt;<br>'''</span><br>html = etree.HTML(text)<br>result = html.xpath(<span class="hljs-string">'//li[contains(@class,"li") and @name="item"]/a/text()'</span>)<br>print(result)<br><br>***************************************************************<br><br>运行结果：<br>[<span class="hljs-string">'first item'</span>]<br></code></pre></td></tr></table></figure><p>这里li节点又增加了一个属性name。要确定这个节点，需要同时根据class和name属性来选择，一个条件是class属性里面包含li字符串，另一个条件是name属性为item字符串，二者需要同时满足，用<code>and</code>操作符相连，相连之后置于中括号<code>[]</code>内进行条件筛选。</p><p>另外还有其他运算符：</p><div class="table-container"><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th><th>返回值</th></tr></thead><tbody><tr><td>or</td><td>或</td><td>age=19 or age=20</td><td>如果age是19或20，则返回true。否则，返回false。</td></tr><tr><td>and</td><td>与</td><td>age&gt;19 and age&lt;21</td><td>如果age是20，则返回true。否则，返回false。</td></tr><tr><td>mod</td><td>计算机除法的余数</td><td>5 mod 2</td><td>1</td></tr><tr><td>\</td><td></td><td>计算两个节点集</td><td>//book \</td><td>//cd</td><td>返回所有拥有book和cd元素的节点集</td></tr><tr><td>+</td><td>加法</td><td>6 + 4</td><td>10</td></tr><tr><td>-</td><td>减法</td><td>6 - 4</td><td>2</td></tr><tr><td>*</td><td>乘法</td><td>6 * 4</td><td>24</td></tr><tr><td>div</td><td>除法</td><td>8 div 4</td><td>2</td></tr><tr><td>=</td><td>等于</td><td>age=19</td><td>如果age是19，则返回true。否则，返回false。</td></tr><tr><td>!=</td><td>不等于</td><td>age!=19</td><td>如果age是19，则返回false。否则，返回true。</td></tr><tr><td>&lt;</td><td>小于</td><td>age&lt;19</td><td>如果age小于19，则返回true。否则，返回false。</td></tr><tr><td>&lt;=</td><td>小于等于</td><td>age\&lt;=19</td><td>如果age小于等于19，则返回true。否则，返回false。</td></tr><tr><td>&gt;</td><td>大于</td><td>age&gt;19</td><td>如果age大于19，则返回true。否则，返回false。</td></tr><tr><td>>=</td><td>大于等于</td><td>age>=19</td><td>如果age大于等于19，则返回true。否则，返回false。</td></tr></tbody></table></div><h3 id="按序选择"><a href="#按序选择" class="headerlink" title="按序选择"></a>按序选择</h3><p>有时候，在选择的时候某些属性可能同时匹配了多个节点，但是只想要其中的某个节点，如第二个节点或者最后一个节点，此时可以 利用中括号传入索引的方法获取特定次序的节点，示例如下：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree  <span class="hljs-comment"># 导入lxml库的etree模块</span><br><br><span class="hljs-comment"># 调用HTML类进行初始化,这样就可以成功构造一个XPath解析对象</span><br>html = etree.parse(<span class="hljs-string">'./test.html'</span>, etree.HTMLParser())<br><span class="hljs-comment"># 选取第一个节点,注意从1开始</span><br>result = html.xpath(<span class="hljs-string">'//li[1]/a/text()'</span>)<br>print(result)<br><span class="hljs-comment"># 选取最后一个节点</span><br>result = html.xpath(<span class="hljs-string">'//li[last()]/a/text()'</span>)<br>print(result)<br><span class="hljs-comment"># 选取位置小于3的节点,即位置序号为1和2的节点</span><br>result = html.xpath(<span class="hljs-string">'//li[position()&lt;3]/a/text()'</span>)<br>print(result)<br><span class="hljs-comment"># 选取倒数第三个li节点</span><br>result = html.xpath(<span class="hljs-string">'//li[last()-2]/a/text()'</span>)<br>print(result)<br><br>***************************************************************<br><br>运行结果：<br>[<span class="hljs-string">'first item'</span>]<br>[<span class="hljs-string">'fifth item'</span>]<br>[<span class="hljs-string">'first item'</span>, <span class="hljs-string">'second item'</span>]<br>[<span class="hljs-string">'third item'</span>]<br></code></pre></td></tr></table></figure><p>这里使用了<code>last()</code>、<code>position()</code>函数。</p><p>在XPath中，提供了100多个函数，包括存取、数值、字符串、逻辑、节点、序列等处理功能。</p><p>具体可以参考<a href="https://www.w3school.com.cn/xpath/xpath_functions.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/xpath/xpath_functions.asp</a></p><h3 id="节点轴选择"><a href="#节点轴选择" class="headerlink" title="节点轴选择"></a>节点轴选择</h3>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> 原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 解析库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫实例1-猫眼电影排行</title>
      <link href="/2019/08/11/%E7%88%AC%E8%99%AB%E5%AE%9E%E4%BE%8B1-%E7%8C%AB%E7%9C%BC%E7%94%B5%E5%BD%B1%E6%8E%92%E8%A1%8C/"/>
      <url>/2019/08/11/%E7%88%AC%E8%99%AB%E5%AE%9E%E4%BE%8B1-%E7%8C%AB%E7%9C%BC%E7%94%B5%E5%BD%B1%E6%8E%92%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>本文简单介绍爬取猫眼电影排行前100榜单。</p><p>主要爬取的电影信息有：排名，名称，图片，详情页，演员，上映时间，评分，简介。</p><a id="more"></a><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> json<br><br><span class="hljs-comment"># 存放所有电影内容</span><br>contents = []<br><br><br><span class="hljs-comment"># 获取一个榜单页面</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_one_page</span><span class="hljs-params">(url)</span>:</span><br>    headers = &#123;<br>        <span class="hljs-string">'User-Agent'</span>: <span class="hljs-string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) \<br>                      AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36'</span><br>    &#125;<br>    response = requests.get(url, headers=headers)<br>    <span class="hljs-keyword">if</span> response.status_code == <span class="hljs-number">200</span>:    <span class="hljs-comment"># 如果正常返回请求</span><br>        <span class="hljs-keyword">return</span> response.text<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br><br><span class="hljs-comment"># 获取该电影的简单描述</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_movie_desc</span><span class="hljs-params">(url)</span>:</span><br>    headers = &#123;<br>        <span class="hljs-string">'User-Agent'</span>: <span class="hljs-string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) \<br>                          AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36'</span><br>    &#125;<br>    response = requests.get(url, headers=headers)<br>    desc = re.search(<span class="hljs-string">'&lt;meta name="description" content=".*?故事梗概:(.*?)"&gt;'</span>, response.text).group(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> desc<br><br><br><span class="hljs-comment"># 处理每一部电影</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse_one_page</span><span class="hljs-params">(html)</span>:</span><br>    pattern = re.compile(<br>        <span class="hljs-string">'&lt;i class="board-index board-index-.*?"&gt;(.*?)&lt;/i&gt;.*?(/films/.*?)" title="(.*?)".*?&lt;img data-src="(.*?)".*?&lt;p class="star"&gt;.*?主演：(.*?)\\n.*?&lt;/p&gt;.*?上映时间：(.*?)&lt;/p&gt;.*?&lt;i class="integer"&gt;(.*?).&lt;/i&gt;&lt;i class="fraction"&gt;(.*?)&lt;/i&gt;&lt;/p&gt;'</span>,<br>        re.S)<br>    items = re.findall(pattern, html)<br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> items:<br>        content = &#123;<br>            <span class="hljs-string">'index'</span>: item[<span class="hljs-number">0</span>],   <span class="hljs-comment"># 电影排名</span><br>            <span class="hljs-string">'details'</span>: <span class="hljs-string">'https://maoyan.com'</span> + item[<span class="hljs-number">1</span>],  <span class="hljs-comment"># 电影详情页</span><br>            <span class="hljs-string">'title'</span>: item[<span class="hljs-number">2</span>],   <span class="hljs-comment"># 电影名称</span><br>            <span class="hljs-string">'image'</span>: item[<span class="hljs-number">3</span>],   <span class="hljs-comment"># 电影图片</span><br>            <span class="hljs-string">'actor'</span>: item[<span class="hljs-number">4</span>],   <span class="hljs-comment"># 电影演员</span><br>            <span class="hljs-string">'time'</span>: item[<span class="hljs-number">5</span>],    <span class="hljs-comment"># 电影上映时间</span><br>            <span class="hljs-string">'score'</span>: item[<span class="hljs-number">6</span>] + <span class="hljs-string">'.'</span> + item[<span class="hljs-number">7</span>]    <span class="hljs-comment"># 电影评分</span><br>        &#125;<br>        content[<span class="hljs-string">'desc'</span>] = get_movie_desc(content[<span class="hljs-string">'details'</span>])    <span class="hljs-comment"># 电影简介</span><br>        print(content)<br>        time.sleep(<span class="hljs-number">2</span>)   <span class="hljs-comment"># 休息2s再爬,防止封ip</span><br>        contents.append(content)<br><br><br><span class="hljs-comment"># 将电影存放到maoyan.json文件中,方便以后调用</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write_to_file</span><span class="hljs-params">(contents)</span>:</span><br>    <span class="hljs-keyword">with</span> open(<span class="hljs-string">'maoyan.json'</span>, <span class="hljs-string">'w'</span>, encoding=<span class="hljs-string">'utf-8'</span>) <span class="hljs-keyword">as</span> f:<br>        f.write(json.dumps(contents, ensure_ascii=<span class="hljs-literal">False</span>) + <span class="hljs-string">'\n'</span>)<br><span class="hljs-comment"># 指定ensure_ascii为False可以确保输出结果是中文形式而不是Unicode编码</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    url = <span class="hljs-string">'https://maoyan.com/board/4?offset='</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):<br>        <span class="hljs-comment"># print(url+str(i*10))</span><br>        html = get_one_page(url + str(i * <span class="hljs-number">10</span>))<br>        parse_one_page(html)<br>    write_to_file(contents)<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> 爬虫实例 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> 正则表达式 </tag>
            
            <tag> 实例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2019/08/11/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2019/08/11/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>正则表达式是描述一组字符串特征的模式，有助于找到文本字符串中的各种模式。</p><p>更确切的说，正则表达式是经过专门编写的文本字符串，用来匹配字符串（尤其是文件内字符串）集合中符合该模式的所有字符串。</p><a id="more"></a><h2 id="常用匹配规则"><a href="#常用匹配规则" class="headerlink" title="常用匹配规则"></a>常用匹配规则</h2><div class="table-container"><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>\w</td><td>匹配字母、数字及下划线</td></tr><tr><td>\W</td><td>匹配除字母、数字及下划线以外</td></tr><tr><td>\s</td><td>匹配任意空白字符，等价于 <code>[\t\n\r\f]</code></td></tr><tr><td>\S</td><td>匹配任意非空字符</td></tr><tr><td>\d</td><td>匹配任意数字，等价于 <code>[0-9]</code></td></tr><tr><td>\D</td><td>匹配除数字外的字符</td></tr><tr><td>\A</td><td>匹配字符串开头</td></tr><tr><td>\z</td><td>匹配字符串结尾，如果存在换行，同时还会匹配换行符</td></tr><tr><td>\Z</td><td>匹配字符串结尾，如果存在换行，只匹配到换行前的结束字符串</td></tr><tr><td>\G</td><td>匹配最后匹配完成的位置</td></tr><tr><td>\n</td><td>匹配一个换行符</td></tr><tr><td>\t</td><td>匹配一个制表符</td></tr><tr><td>^</td><td>匹配一行字符串的开头</td></tr><tr><td>$</td><td>匹配一行字符串的结尾</td></tr><tr><td>.</td><td>匹配除了换行符外的任意字符。当<code>re.DOTALL</code>标记被指定时，则可以匹配包括换行符的任意字符。</td></tr><tr><td>[…]</td><td>用来表示一组字符，单独列出，比如 <code>[amk]</code>匹配a、m或k</td></tr><tr><td><sup><a href="#fn_..." id="reffn_...">...</a></sup></td><td>不在<code>[...]</code>中的字符，比如<code>[^abc]</code>匹配除了a、b、c之外的字符</td></tr><tr><td>*</td><td>匹配0个或多个表达式</td></tr><tr><td>+</td><td>匹配1个或多个表达式</td></tr><tr><td>?</td><td>匹配0个或1个前面的正则表达式定义的片段，非贪婪方式</td></tr><tr><td>{n}</td><td>精确匹配n个前面的表达式</td></tr><tr><td>{n,m}</td><td>匹配n到m个由前面正则表达式定义的片段，贪婪方式</td></tr><tr><td>a\</td><td>b</td><td>匹配a或b</td></tr><tr><td>( )</td><td>匹配括号内的表达式，也表示一个组</td></tr></tbody></table></div><h2 id="re库-Python"><a href="#re库-Python" class="headerlink" title="re库(Python)"></a>re库(Python)</h2><h3 id="match方法"><a href="#match方法" class="headerlink" title="match方法"></a>match方法</h3><p>向<code>match</code>传入要匹配的字符串以及正则表达式，就可以检测这个正则表达式是否匹配字符串。</p><p><strong><em>第一个参数传入正则表达式，第二个参数传入要匹配的字符串。</em></strong></p><p><code>match</code>从字符串的起始位置匹配正则表达式：</p><ul><li>如果匹配，就返回匹配成功的结果</li><li>如果不匹配，就返回None</li></ul><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>content = <span class="hljs-string">'Hello 123 4567 World_This is a Regex Demo'</span><br>print(len(content))<br>result = re.match(<span class="hljs-string">'^Hello\s\d\d\d\s\d&#123;4&#125;\s\w&#123;10&#125;'</span>, content)<br>print(result)<br>print(result.group())<br>print(result.span())<br><br>*************************************************************<br><br>运行结果如下:<br><span class="hljs-number">41</span><br>&lt;_sre.SRE_Match object; span=(<span class="hljs-number">0</span>, <span class="hljs-number">25</span>), match=<span class="hljs-string">'Hello 123 4567 World_This'</span>&gt;<br>Hello <span class="hljs-number">123</span> <span class="hljs-number">4567</span> World_This<br>(<span class="hljs-number">0</span>, <span class="hljs-number">25</span>)<br></code></pre></td></tr></table></figure><ol><li>开头的<code>^</code>是匹配字符串的开头，也就是以<code>Hello</code>开头；</li><li><code>\s</code>匹配空白字符，用来匹配目标串的空格；</li><li><code>\d</code>匹配数字，3个<code>\d</code>匹配123；</li><li><code>\s</code>匹配1个空格；</li><li><code>\d{4}</code>代表匹配前面的规则4次，也就是匹配4个数字；</li><li><code>\s</code>匹配1个空格；</li><li><code>\w{10}</code>匹配10个字母、数字及下划线；</li></ol><p>若输出结果是<strong>SRE_Match</strong>对象，则证明匹配成功。</p><p>该对象有两个方法：</p><ul><li><strong>group()：</strong>可以输出正则表达式规则匹配到的内容；</li><li><strong>span()：</strong>可以输出正则表达式规则所匹配到的结果字符串在原字符串中的位置范围；</li></ul><h4 id="匹配目标"><a href="#匹配目标" class="headerlink" title="匹配目标"></a>匹配目标</h4><p>可以使用<code>()</code>括号将想提取的子字符串括起来。<code>()</code>实际上标记了一个子表达式的开始和结束位置，被标记的每个子表达式会依次对应每一个分组，调用<code>group()</code>传入分组的索引即可获取提取的结果。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>content = <span class="hljs-string">'Hello 1234567 World_This is a Regex Demo'</span><br>print(len(content))<br>result = re.match(<span class="hljs-string">'^Hello\s(\d+)\s(World)'</span>, content)<br>print(result)<br>print(result.group())<br>print(result.group(<span class="hljs-number">0</span>))<br>print(result.group(<span class="hljs-number">1</span>))<br>print(result.group(<span class="hljs-number">2</span>))<br>print(result.span())<br><br>******************************************************************<br><br>运行结果：<br><span class="hljs-number">40</span><br>&lt;_sre.SRE_Match object; span=(<span class="hljs-number">0</span>, <span class="hljs-number">19</span>), match=<span class="hljs-string">'Hello 1234567 World'</span>&gt;<br>Hello <span class="hljs-number">1234567</span> World<br>Hello <span class="hljs-number">1234567</span> World<br><span class="hljs-number">1234567</span><br>World<br>(<span class="hljs-number">0</span>, <span class="hljs-number">19</span>)<br></code></pre></td></tr></table></figure><p>从结果中看出：</p><ul><li><code>group()</code>和<code>group(0)</code>结果相同，都是输出完整的匹配内容；</li><li><code>group(1)</code>输出第一个被<code>()</code>包围的内容；</li><li>如果正则表达式后面还有被<code>()</code>包围的内容，可以依次用<code>group(2)</code>、<code>group(3)</code>等来获取；</li></ul><h4 id="通用匹配"><a href="#通用匹配" class="headerlink" title="通用匹配"></a>通用匹配</h4><p>在正则表达式中，可以使用通用匹配(即万能匹配)，其中：</p><ul><li><code>.(点)</code>可以匹配<strong>除换行符外</strong>任意字符</li><li><code>*(星)</code>代表前面的字符可以匹配无线次</li></ul><p>因此，可以用<code>.*</code>组合匹配任意字符串。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>content = <span class="hljs-string">'Hello 123 4567 World_This is a Regex Demo'</span><br>print(len(content))<br>result = re.match(<span class="hljs-string">'^Hello.*Demo$'</span>, content)<br>print(result)<br>print(result.group())<br>print(result.span())<br><br>******************************************************************<br><br>运行结果：<br><span class="hljs-number">41</span><br>&lt;_sre.SRE_Match object; span=(<span class="hljs-number">0</span>, <span class="hljs-number">41</span>), match=<span class="hljs-string">'Hello 123 4567 World_This is a Regex Demo'</span>&gt;<br>Hello <span class="hljs-number">123</span> <span class="hljs-number">4567</span> World_This <span class="hljs-keyword">is</span> a Regex Demo<br>(<span class="hljs-number">0</span>, <span class="hljs-number">41</span>)<br></code></pre></td></tr></table></figure><p>可以看到，<code>group()</code>方法输出了匹配的全部字符串，也就是说我们写的正则表达式匹配到了目标字符串的全部内容，<code>span()</code>方法输出(0, 41)，这是整个字符串的长度。</p><h4 id="贪婪和非贪婪"><a href="#贪婪和非贪婪" class="headerlink" title="贪婪和非贪婪"></a>贪婪和非贪婪</h4><ul><li>在贪婪匹配下，<code>.*</code> 会匹配尽可能多的字符。</li><li>在非贪婪匹配下，<code>.*?</code> 会匹配尽可能少的字符。</li></ul><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>content = <span class="hljs-string">'Hello 1234567 World_This is a Regex Demo'</span><br>print(len(content))<br><br><span class="hljs-comment"># 贪婪匹配</span><br>result = re.match(<span class="hljs-string">'^He.*(\d+).*Demo$'</span>, content)<br>print(<span class="hljs-string">'贪婪匹配: '</span>+ result.group(<span class="hljs-number">1</span>))<br><br><span class="hljs-comment"># 非贪婪匹配</span><br>result = re.match(<span class="hljs-string">'^He.*?(\d+).*Demo$'</span>, content)<br>print(<span class="hljs-string">'非贪婪匹配: '</span>+ result.group(<span class="hljs-number">1</span>))<br><br>******************************************************************<br><br>运行结果：<br><span class="hljs-number">40</span><br>贪婪匹配: <span class="hljs-number">7</span><br>非贪婪匹配: <span class="hljs-number">1234567</span><br></code></pre></td></tr></table></figure><p><strong>在做匹配的时候，字符串中间尽量使用非贪婪匹配，也就是用 <code>.*?</code> 代替 <code>.*</code> ，以免出现匹配结果缺失的情况。</strong></p><p>但是要注意，如果匹配的结果在字符串的结尾，<code>.*?</code>就有可能匹配不到任何内容了，因为他会匹配尽可能少的字符。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>content = <span class="hljs-string">'Hello 1234567 World_This is a Regex Demo'</span><br>print(len(content))<br><br><span class="hljs-comment"># 贪婪匹配</span><br>result = re.match(<span class="hljs-string">'^He.*Regex (.*)'</span>, content)<br>print(<span class="hljs-string">'贪婪匹配: '</span>+ result.group(<span class="hljs-number">1</span>))<br><br><span class="hljs-comment"># 非贪婪匹配</span><br>result = re.match(<span class="hljs-string">'^He.*Regex (.*?)'</span>, content)<br>print(<span class="hljs-string">'非贪婪匹配: '</span>+ result.group(<span class="hljs-number">1</span>))<br><br>******************************************************************<br><br>运行结果：<br><span class="hljs-number">40</span><br>贪婪匹配: Demo<br>非贪婪匹配:<br></code></pre></td></tr></table></figure><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><p>正则表达式可以包含一些可选标志修饰符来控制匹配的模式。</p><p>修饰符被指定为一个可选的标志。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>content = <span class="hljs-string">'''Hello 1234567 World_This<br> is a Regex Demo'''</span><br>print(len(content))<br>result = re.match(<span class="hljs-string">'^He.*Regex (.*)'</span>, content)<br>print(result.group(<span class="hljs-number">1</span>))<br><br>******************************************************************<br><br>运行结果：<br><span class="hljs-number">41</span><br>Traceback (most recent call last):<br>  File <span class="hljs-string">"/Users/huben/Desktop/spider/cs.py"</span>, line <span class="hljs-number">7</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    print(result.group(<span class="hljs-number">1</span>))<br>AttributeError: <span class="hljs-string">'NoneType'</span> object has no attribute <span class="hljs-string">'group'</span><br></code></pre></td></tr></table></figure><p>运行直接报错，也就是说正则表达式没有匹配到这个字符串，返回的结果为None，而又调用了<code>group()</code>方法导致<code>AttributeError</code>。</p><p><strong>原因：</strong> <code>.</code> 匹配的是除了换行符之外的任意字符，当遇到换行符时，<code>.*?</code> 就不能匹配了，所以导致失败。</p><p>这里可以加上修饰符 <code>re.S</code> ，即可修正这个错误。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>content = <span class="hljs-string">'''Hello 1234567 World_This<br> is a Regex Demo'''</span><br>print(len(content))<br>result = re.match(<span class="hljs-string">'^He.*Regex (.*)'</span>, content, re.S)<br>print(result.group(<span class="hljs-number">1</span>))<br><br>******************************************************************<br><br>运行结果：<br><span class="hljs-number">41</span><br>Demo<br></code></pre></td></tr></table></figure><p>这个<code>re.S</code>在网页匹配中经常用到。因为HTML节点经常会有换行，加上它，就可以匹配节点与节点之间的换行了。</p><p>另外还有一些修饰符如下：</p><div class="table-container"><table><thead><tr><th>修饰符</th><th>描述</th></tr></thead><tbody><tr><td>re.I</td><td>使匹配与大小写不敏感</td></tr><tr><td>re.L</td><td>做本地化识别(locale-aware)匹配</td></tr><tr><td>re.M</td><td>多行匹配，影响 ^ 和 $</td></tr><tr><td>re.S</td><td>使 . (点) 匹配包括换行在内的所有字符</td></tr><tr><td>re.U</td><td>根据Unicode字符集解析字符。这个标志影响\w, \W, \b, \B</td></tr><tr><td>re.X</td><td>该标志通过给予更灵活的格式以便将正则表达式写的更易于理解</td></tr></tbody></table></div><p>较为常用的是 <code>re.I</code> ，和 <code>re.S</code> 。</p><h4 id="转义匹配"><a href="#转义匹配" class="headerlink" title="转义匹配"></a>转义匹配</h4><p>在正则表达式中定义了很多匹配，但是如果要匹配包含 <code>.</code> 等特殊字符时，就需要使用转义匹配了。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>content = <span class="hljs-string">'(百度)www.baidu.com'</span><br>result = re.match(<span class="hljs-string">'\(百度\)www\.baidu\.com'</span>, content)<br>print(result.group())<br><br>******************************************************************<br><br>运行结果：<br>(百度)www.baidu.com<br></code></pre></td></tr></table></figure><p>当遇到用于正则匹配模式的特殊字符时，<strong>在前面加反斜杠转义一下即可</strong>。</p><h3 id="search方法"><a href="#search方法" class="headerlink" title="search方法"></a>search方法</h3><p><code>match()</code>方法在匹配时是从字符串的开头开始匹配的，一旦开头不匹配，那么整个匹配就会失败。这在做匹配时会非常不方便，它更适合用来检测某个字符串是否符合某个正则表达式的规则。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>content = <span class="hljs-string">'Extra strings Hello 1234567 World_This is a Regex Demo'</span><br>print(len(content))<br>result = re.match(<span class="hljs-string">'He.*Regex (.*)'</span>, content)<br>print(result.group(<span class="hljs-number">1</span>))<br><br>******************************************************************<br><br>运行结果：<br>Traceback (most recent call last):<br>  File <span class="hljs-string">"/Users/huben/Desktop/spider/cs.py"</span>, line <span class="hljs-number">6</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br><span class="hljs-number">54</span><br>    print(result.group(<span class="hljs-number">1</span>))<br>AttributeError: <span class="hljs-string">'NoneType'</span> object has no attribute <span class="hljs-string">'group'</span><br></code></pre></td></tr></table></figure><p>而<code>search()</code>方法在匹配的时候会扫描整个字符串，然后<strong>返回第一个成功匹配的结果</strong>。</p><p>即，<strong>正则表达式可以是字符串的一部分</strong>，在匹配时，<code>search()</code>方法会依次扫描字符串，直到找到第一个符合规则的字符串，然后返回匹配内容，如果搜索完了还没有找到，则返回<strong>None</strong>。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>content = <span class="hljs-string">'Extra strings Hello 1234567 World_This is a Regex Demo'</span><br>print(len(content))<br>result = re.search(<span class="hljs-string">'He.*Regex (.*)'</span>, content)<br>print(result.group())<br><br>******************************************************************<br><br>运行结果：<br><span class="hljs-number">54</span><br>Hello <span class="hljs-number">1234567</span> World_This <span class="hljs-keyword">is</span> a Regex Demo<br></code></pre></td></tr></table></figure><p>因此，为了匹配方便，我们尽量使用<code>search()</code>方法。</p><h3 id="findall方法"><a href="#findall方法" class="headerlink" title="findall方法"></a>findall方法</h3><p>如果想要获取正则表达式的所有内容，则需要借助 <code>findall()</code> 方法。</p><p>该方法会搜索整个字符串，然后返回匹配正则表达式的所有内容。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">results = re.findall(RegEx, content, re.S) <span class="hljs-comment"># 匹配所有结果</span><br><span class="hljs-keyword">for</span> result <span class="hljs-keyword">in</span> results:<br>    print(result)<br>    print(result[<span class="hljs-number">0</span>],result[<span class="hljs-number">1</span>],result[<span class="hljs-number">2</span>])<span class="hljs-comment"># 这里相当于group(1),group(2)...</span><br></code></pre></td></tr></table></figure><p>可以看出，返回的列表中的每个元素都是元组类型，可以用对应的索引依次取出即可。</p><h3 id="sub方法"><a href="#sub方法" class="headerlink" title="sub方法"></a>sub方法</h3><p>除了使用正则表达式提取信息外，有时候还需要借助它来修改文本。</p><p>比如要把一串文本中的所有数字都去掉，如果只用字符串的<code>replace()</code>方法，那就太繁琐了。</p><p>可以使用<code>sub()</code>方法。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>content = <span class="hljs-string">"Hello 1234567 World_This is a Regex Demo"</span><br>content = re.sub(<span class="hljs-string">' \d+'</span>, <span class="hljs-string">''</span>, content)<br>print(content)<br><br>******************************************************************<br><br>运行结果：<br>Hello World_This <span class="hljs-keyword">is</span> a Regex Demo<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><strong>第一个参数：</strong>传入<code>\d+</code>来匹配所有的数字；</li><li><strong>第二个参数：</strong>替换成的字符串(如果去掉该参数的话，可以赋值为空)；</li><li><strong>第三个参数：</strong>原字符串；</li></ul><h3 id="compile方法"><a href="#compile方法" class="headerlink" title="compile方法"></a>compile方法</h3><p><code>compile()</code>方法可以将正则字符串编译成正则表达式对象，以便在后面的匹配中复用。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>content1 = <span class="hljs-string">'2016-12-15 12:00'</span><br>content2 = <span class="hljs-string">'2016-12-17 12:55'</span><br>content3 = <span class="hljs-string">'2016-12-22 13:21'</span><br><br>pattern = re.compile(<span class="hljs-string">'\d&#123;2&#125;:\d&#123;2&#125;'</span>)<br><br>result1 = re.sub(pattern, <span class="hljs-string">''</span>, content1)<br>result2 = re.sub(pattern, <span class="hljs-string">''</span>, content2)<br>result3 = re.sub(pattern, <span class="hljs-string">''</span>, content3)<br><br>print(result1, result2, result3)<br><br>******************************************************************<br><br>运行结果：<br><span class="hljs-number">2016</span><span class="hljs-number">-12</span><span class="hljs-number">-15</span>  <span class="hljs-number">2016</span><span class="hljs-number">-12</span><span class="hljs-number">-17</span>  <span class="hljs-number">2016</span><span class="hljs-number">-12</span><span class="hljs-number">-22</span><br></code></pre></td></tr></table></figure><p>例如，如果我们想要将三个日期中的时间去掉，此时可以借助<code>sub()</code>方法。</p><p>该方法的第一个参数是正则表达式，但是这里没有必要重复写3个同样的正则表达式，此时可以借助<code>compile()</code>方法将正则表达式编译成一个正则表达式对象，以便复用。</p><p>另外，<code>compile()</code>还可以传入修饰符，例如<code>re.S</code>等修饰符，这样在<code>search()</code>、<code>findall()</code>等方法中就不需要额外传了。例如：<code>pattern = re.compile(&#39;\d{2}:\d{2}&#39;, re.S)</code></p>]]></content>
      
      
      <categories>
          
          <category> 计算机工具 </category>
          
          <category> 正则表达式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> 正则表达式 </tag>
            
            <tag> 字符串处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代理的基本原理</title>
      <link href="/2019/08/11/%E4%BB%A3%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
      <url>/2019/08/11/%E4%BB%A3%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>当我们在做爬虫的时候，刚开始可以正常抓取数据，然而一段时间过后可能会出现错误，比如<strong>403 Forbidden</strong>，这时候打开网页一看，可能会看到<strong>IP访问频率过高</strong>这样的提示。出现这种现象的原因是网站采取了反爬虫措施。</p><p>当服务器检测到某个IP在单位时间内的请求次数，如果超过了这个阈值，就会直接拒绝服务，返回一些错误信息，这种情况可以称为封IP。</p><p>既然服务器检测的是某个IP单位时间的请求次数，那么借助某种方式来伪装我们的IP，让服务器识别不出是由我们本机发起的请求，就可以防止封IP了。</p><p>一种有效的方式就是使用代理，本文主要介绍了代理的一些基本原理。</p><a id="more"></a><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>代理实际上指的是代理服务器(proxy server)，功能是代理网络用户去取得网络信息，即网络信息的中转站。</p><p>如果设置了代理服务器，就可以在本机和服务器之间搭建一个桥，此时本机不是直接向Web服务器发起请求，而是向代理服务器发起请求，请求会发送给代理服务器，然后由代理服务器再发送给Web服务器，接着由代理服务器再把Web服务器返回的响应转发给本机。</p><p>这样我们同样可以正常访问页面，但这个过程中Web服务器识别出的真实IP就不再是我们本机的IP，就成功实现了IP伪装，即代理。</p><h2 id="代理的作用"><a href="#代理的作用" class="headerlink" title="代理的作用"></a>代理的作用</h2><ul><li>突破自身IP访问限制，访问一些平时不能访问的站点。</li><li>访问一些单位或团体内部资源：比如使用教育网内地址段免费代理服务器，就可以用于对教育网开放的各类FTP下载上传，以及各类资料查询共享等服务。</li><li>提高访问速度：通常代理服务器都设置一个较大的硬盘缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时，则直接由缓冲区中取信息，传给用户，以提高访问速度。</li><li>隐藏真实IP：上网者也可以通过这种方法隐藏自己的IP，免受攻击。对于爬虫来说，我们用代理就是为了隐藏自身的IP，防止自身的IP被封锁。</li></ul><h2 id="代理分类"><a href="#代理分类" class="headerlink" title="代理分类"></a>代理分类</h2><p>代理分类时，既可以根据协议区分，也可以根据其匿名程度区分。</p><h3 id="根据协议区分"><a href="#根据协议区分" class="headerlink" title="根据协议区分"></a>根据协议区分</h3><p>根据代理的协议，代理可以分为如下类别：</p><ul><li><strong>FTP代理服务器：</strong>主要用于访问FTP服务器，一般有上传、下载以及缓存功能，短裤一般为21、2121等。</li><li><strong>HTTP代理服务器：</strong>主要用于访问网页，一般有内容过滤和缓存功能，端口一般为80、8080、3128等。</li><li><strong>SSL/TLS代理：</strong>主要用于访问加密网站，一般有SSL或TLS加密功能(最高支持128位加密强度)，端口一般为443。</li><li><strong>RTSP代理：</strong>主要用于访问Real流媒体服务器，一般有缓存功能，端口一般为554。</li><li><strong>Telnet代理：</strong>主要用于telnet远程控制(黑客入侵计算机时常用于隐藏身份)，端口一把为23。</li><li><strong>POP3/SMTP代理：</strong>主要用于POP3/SMTP方式收发邮件，一般有缓存功能，端口一般为110/25。</li><li><strong>SOCKS代理：</strong>只是单纯传递数据包，不关心具体协议和用法，所以速度快很多，一般有缓存功能，端口一般为1080。SOCKS代理又分为SOCKS4和SOCKS5，前者只支持TCP，后者支持TCP和UDP，还支持各种身份验证机制、服务器域名解析等。SOCKS4能做的，SOCKS5都能做。</li></ul><h3 id="根据匿名程度区分"><a href="#根据匿名程度区分" class="headerlink" title="根据匿名程度区分"></a>根据匿名程度区分</h3><p>根据代理的匿名程度，代理可以分为如下类别：</p><ul><li><strong>高度匿名代理：</strong>会将数据包原封不动地转发，在服务端看来就好像真的是一个普通客户端在访问，而记录的IP是代理服务器的IP。</li><li><strong>普通匿名代理：</strong>会在数据包上做一些改动，服务端上有可能发现这是个代理服务器，也有一定几率追查到客户端的真实IP。代理服务器通常会加入的HTTP头有<code>HTTP_VIA</code>和<code>HTTP_X_FORWARDED_FOR</code>。</li><li><strong>透明代理：</strong>不但改动了数据包，还会告诉服务器客户端的真实IP。这种代理除了能用缓存的技术提高浏览速度，能用内容过滤提高安全性外，并无其他显著作用，最常见的例子是内网中的硬件防火墙。</li><li><strong>间谍代理：</strong>指组织或个人创建的用于记录用户传输的数据，然后进行研究、监控等目的的代理服务器。</li></ul><h2 id="常见的代理设置"><a href="#常见的代理设置" class="headerlink" title="常见的代理设置"></a>常见的代理设置</h2><ul><li><strong>使用网上的免费代理：</strong>最好使用高匿代理，另外可用的代理不多，需要在使用前筛选一下可用代理，也可以进一步维护一个代理池。</li><li><strong>使用付费代理：</strong>互联网上存在许多代理商，可以付费使用，质量比免费代理好很多。</li><li><strong>ASDL拨号：</strong>拨一次换一次IP，稳定性高，也是一种比较有效的解决方案。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> 原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>会话和Cookies</title>
      <link href="/2019/08/07/%E4%BC%9A%E8%AF%9D%E5%92%8CCookies/"/>
      <url>/2019/08/07/%E4%BC%9A%E8%AF%9D%E5%92%8CCookies/</url>
      
        <content type="html"><![CDATA[<p>在浏览网站的时候，我们经常会遇到需要登录的情况，有些页面只有登录之后才可以访问，而且登录之后可以连续访问很多次网站，但是有时候过一段时间就需要重新登录。</p><p>还有一些网站，再打开浏览器时就自动登录了，而且很长时间都不会失效，这里面涉及会话(<strong>Session</strong>)和<strong>Cookies</strong>的相关知识。</p><a id="more"></a><h2 id="静态网页和动态网页"><a href="#静态网页和动态网页" class="headerlink" title="静态网页和动态网页"></a>静态网页和动态网页</h2><p>在开始之前，需要先了解一下动态网页和静态网页的概念，代码如下：</p><figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>This is a Demo<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"container"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"wrapper"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title"</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"text"</span>&gt;</span>Hello, this is a paragraph.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这种网页的内容是HTML代码编写的，文字、图片等内容均通过写好的HTML代码来指定，这种网页叫作静态网页。它<strong>加载速度快</strong>，<strong>编写简单</strong>，但是存在很大的缺陷，如<strong>可维护性差</strong>，<strong>不能根据URL灵活多变地显示内容</strong>等。例如，我们想要给这个网页的URL传入一个name参数，让其在网页中显示出来，是无法做到的。</p><p>动态网站可以动态解析URL中参数的变化，关联数据库并动态呈现不同页面内容，非常灵活多变。我们现在遇到的大多数网站都是动态网站，它们不再是一个简单的HTML，而是可能由<strong>JSP</strong>、<strong>PHP</strong>、<strong>Python</strong>等语言编写的，其功能比静态网页强大和丰富。</p><p>此外，动态网站还可以实现用户登录和注册的功能。很多页面时需要登录之后才可以查看的。按照一般的逻辑来说，输入用户名和密码登录之后，肯定是拿到了一种类似于<strong>凭证</strong>（会话和Cookies共同产生的结果）的东西，有了它，我们才能保持登录状态，才能访问登录之后才能看到的页面。</p><h2 id="无状态HTTP"><a href="#无状态HTTP" class="headerlink" title="无状态HTTP"></a>无状态HTTP</h2><p>HTTP的无状态是指HTTP协议对事务处理是没有记忆能力的，也就说<strong>服务器不知道客户端是什么状态</strong>。</p><blockquote><p>当我们向服务器发送请求后，服务器解析此请求，然后返回对应的响应，服务器负责完成这个过程，而且这个过程是完全独立的，服务器不会记录前后状态的变化，也就是缺少状态记录。</p></blockquote><p>这意味着如果后续需要处理前面的信息，则必须重传，这导致需要额外传递一些前面的重复请求，才能获取后续响应，然而这种效果显然不是我们想要的。为了保持前后状态，我们肯定不能将前面的请求全部重传一次，这太浪费资源了，对于这种需要用户登录的页面来说，更为棘手。</p><p>这时，两个用于保持HTTP连接状态的技术就出现了，它们分别是<strong>会话</strong>和<strong>Cookies</strong>。</p><ul><li><strong>会话</strong>在服务端，也就是网站的服务器，用来保存用户的会话信息。</li><li><strong>Cookies</strong>在客户端，也可以理解为浏览器端，有了Cookies，浏览器在下次访问网页时会自动附带上它发送给服务器，服务器通过识别Cookies并鉴定出是哪个用户，然后再判断用户是否是登录状态，然后返回对应的响应。</li></ul><p>可以理解为Cookies里面保存了登陆的凭证，有了它，只需要在下次<strong>携带Cookies发送请求</strong>，而不必重新输入用户名、密码等信息重新登录了。</p><p>因此在爬虫中，有时候处理需要登录才能访问的页面时，我们一般会直接将登录成功后获取的Cookies放在请求头里面直接请求，而不必重新模拟登录。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p>会话，本来的含义是指有始有终的一系列动作/消息。比如，打电话时，从拿起电话拨号到挂断电话这中间的一系列过程可以称为一个会话。</p><p>在Web中，会话对象用来存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的Web页之间跳转时，存储在会话对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当用户请求来自应用程序的Web页时，如果该用户还没有会话，则Web服务器将自动创建一个会话对象。当会话过期或被放弃后，服务器将终止该会话。</p><h3 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h3><p>Cookies指某些网站为了辨别用户身份、进行会话跟踪而存储在用户本地终端上的数据。</p><h4 id="会话维持"><a href="#会话维持" class="headerlink" title="会话维持"></a>会话维持</h4><p>当客户端第一次请求服务器时，服务器会返回一个请求头中带有<strong>Set-Cookie</strong>字段的响应给客户端，用来标记是哪一个用户，客户端浏览器会把Cookies保存起来。当浏览器下一次再请求该网站时，浏览器会把此Cookies放到请求头一起提交给服务器，Cookies携带了会话ID消息，服务器检查该Cookies即可找到对应的会话是什么，然后再判断会话来辨认用户状态。</p><p>在成功登录某个网站时，服务器会告诉客户端设置哪些Cookies信息，在后续访问页面时客户端会把Cookies发送给服务器，服务器再找到对应的会话加以判断。如果会话中的某些设置登录状态的变量是有效的，那就证明用户处于登录状态，此时返回登录之后才可以查看的网页内容，浏览器再进行解析便可以看到了。</p><p>反之，如果传给服务器的Cookies是无效的，或者会话已经过期了，我们将不能继续访问页面，此时可能会收到错误的响应或者跳转到登录界面重新登录。</p><p>Cookies和会话需要配合，一个处于客户端，一个处于服务端，二者协作，就实现了登录会话控制。</p><h4 id="属性结构"><a href="#属性结构" class="headerlink" title="属性结构"></a>属性结构</h4><ul><li>Name：该Cookie的名称。一旦创建，该名称便不可更改。</li><li>Value：该Cookie的值。如果值为Unicode字符，需要为字符编码。如果值为二进制数据，则需要使用BASE64编码。</li><li>Domain：可以访问该Cookie的域名。例如，如果设置为<code>.zhihu.com</code>，则所有以<code>zhihu.com</code>结尾的域名都可以访问该Cookie。</li><li>Max Age：该Cookie失效的时间，单位为秒，也常和<strong>Expires</strong>一起使用，通过它可以计算出其有效时间。Max Age如果为正数，则该Cookie在Max Age秒之后失效。如果为负数，则关闭浏览器时Cookie即失效，浏览器不会以任何形式保存该Cookie。</li><li>Path：该Cookie的使用路径。如果设置为<code>/path/</code>，则只有路径为<code>/path/</code>的页面可以访问该Cookie。如果设置为<code>/</code>，则本域名下的所有页面都可以访问该Cookie。</li><li>Size字段：此Cookie的大小。</li><li>HTTP字段：Cookie的<strong>httponly</strong>属性。若此属性为<strong>true</strong>，则只有在HTTP头中会带有此Cookie的信息，而不能通过<code>document.cookie</code>来访问此Cookie。</li><li>Secure：该Cookie是否仅被使用安全协议传输。安全协议有HTTPS和SSL等，在网络上传输数据之前先将数据加密。默认为<strong>false</strong>。</li></ul><h4 id="会话Cookie和持久Cookie"><a href="#会话Cookie和持久Cookie" class="headerlink" title="会话Cookie和持久Cookie"></a>会话Cookie和持久Cookie</h4><ul><li>会话Cookie：把Cookie放在浏览器的内存里，浏览器在关闭之后该Cookie即失效。</li><li>持久Cookie：会将Cookie保存到客户端的硬盘中，下次还可以继续使用，用于长久保存用户登录状态。</li></ul><p>一些持久化登录的网站其实就是把Cookie的有效时间和会话有效期设置得比较长，下次我们再访问页面时仍然携带之前的Cookie，就可以直接保持登录状态。</p><h2 id="常见误区"><a href="#常见误区" class="headerlink" title="常见误区"></a>常见误区</h2><p><strong>关闭浏览器，会话结束</strong></p><p>当我们关闭浏览器时，浏览器不会主动在关闭之前通知服务器它将要关闭，所以服务器不会有机会知道浏览器已经关闭。</p><p>之所以会有这种误区，是因为大部分会话机制都使用<strong>会话Cookie</strong>来保存会话ID信息，而关闭浏览器后Cookies就消失了，再次连接服务器时，也就无法找到原来的会话了。</p><p>如果服务器设置的Cookies保存在硬盘上，或者使用某种手段改写浏览器发出的HTTP请求头，把原来的Cookies发送给服务器，则再次打开浏览器，仍然能够找到原来的会话ID，依旧还是可以保持登录状态的。</p><p>由于关闭浏览器不会导致会话删除，这就需要服务器为会话设置一个失效时间，当距离客户端上一次使用会话的时间超过这个失效时间时，服务器就可以认为客户端已经停止了活动，才会把会话删除以节省存储空间。</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> 原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> cookies </tag>
            
            <tag> 会话 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫的基本原理</title>
      <link href="/2019/08/07/%E7%88%AC%E8%99%AB%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
      <url>/2019/08/07/%E7%88%AC%E8%99%AB%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>我们可以把互联网比作一张大网，而爬虫便是在网上爬行的蜘蛛。</p><p>把网的节点比作一个个网页，爬虫爬到这就相当于访问了该页面，获取了其信息。</p><p>可以把节点间的连线比作网页与网页之间的链接关系，这样蜘蛛通过一个节点后，可以顺着节点连线继续爬行到达下一个节点，即通过一个网页继续获取后续的网页，这样整个网的节点便可以被蜘蛛全部爬行到，网站的数据就可以被抓取下来了。</p><a id="more"></a><h2 id="爬虫概述"><a href="#爬虫概述" class="headerlink" title="爬虫概述"></a>爬虫概述</h2><p>简单来说，爬虫就是获取网页并提取和保存信息的自动化程序。</p><h3 id="获取网页"><a href="#获取网页" class="headerlink" title="获取网页"></a>获取网页</h3><p>爬虫首先要做的工作就是获取网页，这里就是获取网页的源代码。源代码里包含了网页的部分有用信息，所以只要把源代码获取下来，，就可以从中提取想要的信息了。</p><p><strong>最关键的部分就是构造一个请求并发送给服务器，然后接收到响应并将其解析出来。</strong></p><p>Python提供了很多库来帮我们实现这个操作，如<code>urllib</code>、<code>requests</code>等。我们可以用这些库来帮助我们实现HTTP请求操作，请求和响应都可以用类库提供的数据结构来表示，得到相应之后只需要解析数据结构中的<strong>Body</strong>部分即可得到网页的源代码，这样我们可以用程序来实现获取网页的过程了。</p><h3 id="提取信息"><a href="#提取信息" class="headerlink" title="提取信息"></a>提取信息</h3><p>获取网页源代码后，接下来就是分析网页源代码，从中提取我们想要的数据。</p><p>最通用的方法是采用正则表达式提取，这是一个万能的方法，但是在构造正则表达式时比较复杂且容易出错。</p><p>另外，由于网页的结构有一定的规则，所以还有一些根据网页节点属性、CSS选择器或XPath来提取网页信息的库，如<strong>Beautiful Soup</strong>、<strong>Pyquery</strong>、<strong>lxml</strong>等，使用这些库，我们可以高效快速地从中提取网页信息，如节点属性、文本值等。</p><p>提取信息是爬虫非常重要的部分，他可以使杂乱的数据变得条理清晰，以便我们后续处理和分析数据。</p><h3 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h3><p>提取信息后，我们一般会将提取到的数据保存在某处以便后续使用。这里保存形式有多种多样，如可简单保存为<strong>TXT文本</strong>或<strong>JSON文本</strong>，也可以保存到数据库，如<strong>MySQL</strong>和<strong>MongoDB</strong>等，也可保存至远程服务器，如借助<strong>SFTP</strong>进行操作等。</p><h3 id="自动化程序"><a href="#自动化程序" class="headerlink" title="自动化程序"></a>自动化程序</h3><p>即爬虫可以代替人来完成这些操作。当量特别大或者想快速获取大量数据的话，肯定要借助程序。爬虫就是替我们来完成这份爬取工作的自动化程序，它可以在抓取过程中进行各种异常处理、错误重试等操作，确保爬取持续高效地运行。</p><h2 id="能抓怎样的数据"><a href="#能抓怎样的数据" class="headerlink" title="能抓怎样的数据"></a>能抓怎样的数据</h2><ul><li>最常抓取的是<strong>HTML源代码</strong>。</li><li>有些网页返回的是一个<strong>JSON字符串</strong>(其中API接口大多采用这样的形式)，这种格式的数据方便传输和解析，它们同样可以抓取，而且数据提取方便。</li><li><strong>各种二进制数据</strong>，如图片、视频和音频等。利用爬虫，我们可以将这些二进制数据抓取下来，然后保存成对应的文件名。</li><li><strong>各种扩展名的文件</strong>，如CSS、JavaScript和配置文件等，这些其实也是最普通的文件，只要在浏览器里面可以访问到，就可以将其抓取下来。</li></ul><p>上述内容其实都对应各自的URL，是基于HTTP或HTTPS协议的，只要是这种数据，爬虫都可以抓取。</p><h2 id="JavaScript渲染页面"><a href="#JavaScript渲染页面" class="headerlink" title="JavaScript渲染页面"></a>JavaScript渲染页面</h2><p>有时候，我们使用<code>urllib</code>和<code>requests</code>抓取网页时，得到的源代码实际和浏览器中看到的不一样。</p><p>这是由于现在越来越多的网页采用<strong>Ajax</strong>、<strong>前端模块化工具</strong>来构建，整个网页可能都是由JavaScript渲染出来的，也就是说原始的HTML代码就是一个空壳，例如：</p><figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>This is a Demo<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"container"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"app.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>body</code>节点里面只有一个<strong>id为container</strong>的节点，但是需要注意在<code>body</code>节点后引入了<code>app.js</code>，它便负责整个网站的渲染。</p><p>在浏览器中打开这个页面时，首先会加载这个HTML内容，接着浏览器会发现其中引入了一个<code>app.js</code>文件，然后便会接着去请求这个文件，获取到该文件后，便会执行其中的JavaScript代码，而JavaScript则会改变HTML中的节点，向其添加内容，最后得到完整的页面。</p><p>但是用<code>urllib</code>或<code>requests</code>等库请求当前页面时，我们得到的只是这个HTML代码，它不会帮助我们继续去加载这个JavaScript文件，这样也就看不到浏览器中的内容了。</p><p>这也就解释了为什么有时我们得到的源代码和浏览器中看到的不一样。</p><p>因此，使用基本HTTP请求库得到的源代码可能跟浏览器中的页面源代码不太一样。对于这样的情况，我们可以分析其后台<strong>Ajax接口</strong>，也可使用<strong>Selenium</strong>、<strong>Splash</strong>这样的库来实现模拟JavaScript渲染。</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> 原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网页基础</title>
      <link href="/2019/08/06/%E7%BD%91%E9%A1%B5%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/08/06/%E7%BD%91%E9%A1%B5%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>用浏览器访问网站时，网页各不相同，本文简单介绍了网页的基本组成、结构和结点等内容。</p><p>了解了这些内容，我们才有更加清晰的思路去解析和提取网页内容。</p><a id="more"></a><h2 id="网页的组成"><a href="#网页的组成" class="headerlink" title="网页的组成"></a>网页的组成</h2><p>网页可以分为三个部分(<strong>HTML</strong>、<strong>CSS</strong>和<strong>JavaScript</strong>)。</p><p>如果把一个网页比作一个人的话，HTML相当于骨架，CSS相当于皮肤，JavaScript相当于肌肉。</p><p>即，HTML定义了网页的内容和结构，CSS描述了网页的布局，JavaScript定义了网页的行为。</p><p>三者结合起来才能形成一个完善的网页。</p><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p>HTML(Hyper Text Markup Language，超文本标记语言)是用来描述网页的一种语言。</p><p>网页包括文字、按钮、图片和视频等各种复杂元素，其基础架构就是HTML。</p><p>不同类型的元素通过不同类型的标签来表示，如图片用<code>img</code>标签表示，视频用<code>video</code>标签表示，段落用<code>p</code>标签表示。</p><p>它们之间的布局又常通过布局标签<code>div</code>嵌套组合而成，各种标签通过不同的排列和嵌套才形成了网页的框架。</p><p>在浏览器中可以查看网页源代码，以下为www.baidu.com的网页源代码：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E7%BD%91%E9%A1%B5%E5%9F%BA%E7%A1%80/%E7%99%BE%E5%BA%A6%E6%BA%90%E4%BB%A3%E7%A0%81.png" width="70%"></p><p>这就是HTML，整个网页就是由各种标签嵌套组合而成的。这些标签定义的节点元素相互嵌套和组合形成了复杂的层次关系，就形成了网页的架构。</p><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p>HTML定义了网页的结构，但是只有HTML页面的布局并不美观，可能只是简单的节点元素的排列，为了让网页看起来更好看一些，可以借助CSS。</p><p>CSS(Cascading Style Sheets，层叠样式表)。”层叠”是指当在HTML中引用了数个样式文件，并且样式发生冲突时，浏览器能依据层叠顺序处理。”样式”指网页中文字大小、颜色、元素间距、排列等格式。</p><p>CSS是目前唯一的网页页面排版样式标准，有了它的帮助，页面才会变得更为美观。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E7%BD%91%E9%A1%B5%E5%9F%BA%E7%A1%80/CSS.png" width="70%"></p><p>上图中右边<strong>Styles</strong>中存放的即是CSS，例如：</p><figure class="hljs highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">min-width</span>: <span class="hljs-number">1000px</span>;<br>    <span class="hljs-attribute">cursor</span>: default<br>&#125;<br></code></pre></td></tr></table></figure><p>就是一个CSS样式。</p><p>在网页中，一般会统一定义整个网页的样式规则，并写入CSS文件中(其后缀为css)。在HTML中，只需要用link标签即可引入写好的CSS文件，这样整个页面就会变得美观、优雅。</p><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>JavaScript是一种脚本语言。</p><p>若仅仅HTML和CSS配合使用，提供给用户的只是一种静态信息，缺乏交互性。</p><p>我们在网页里可能会看到一些交互和动画效果，如下载进度条、提示框、轮播图等，这通常就是JavaScript的功劳。它的出现使得用户与信息之间不只是一种浏览与现实的关系，而是实现了一种实时、动态、交互的页面功能。</p><p>JavaScript通常也是以单独的文件形式加载的，后缀为<code>js</code>，在HTML中通过<code>script</code>即可引入，例如：</p><p><code>&lt;script src=&quot;jquery-2.1.0.js&quot;&gt;&lt;/script&gt;</code></p><h2 id="网页的结构"><a href="#网页的结构" class="headerlink" title="网页的结构"></a>网页的结构</h2><p>首先以一个例子来讲解一些HTML的基本结构。</p><p>新建一个文本文件，名字可以自取，后缀为<code>html</code>。</p><p>内容如下：</p><figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>This is a Demo<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"container"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"wrapper"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title"</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"text"</span>&gt;</span>Hello, this is a paragraph.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这就是一个最简单的HTML实例。</p><p>开头用<strong>DOCTYPE</strong>定义了文档类型，其次最外层是<code>html</code>标签，最后还有对应的结束标签来表示闭合，其内部是<code>head</code>标签和<code>body</code>标签，分别代表网页头和网页体，它们也需要结束标签。</p><p><code>head</code>标签内定义了一些页面的配置和引用，如：<code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code>指定了网页的编码为UTF-8。</p><p><code>title</code>标签则定义了网页的标题，会显示在网页的选项卡中，不会显示在正文中。</p><p><code>body</code>标签内则是在网页正文中显示的内容。</p><p><code>div</code>标签定义了网页中的区块，它的id是container，这是一个非常常用的属性，且id的内容在网页中是唯一的，我们可以通过它来获取这个区块。然后在此区块内又有一个div标签，它的class为wrapper，这也是一个非常常用的属性，经常与CSS配合使用来设定样式。</p><p><code>h2</code>标签代表一个二级标题。</p><p><code>p</code>标签代表一个段落。</p><p>将代码保存后，在浏览器中打开该文件，可以看到下图所示的内容。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E7%BD%91%E9%A1%B5%E5%9F%BA%E7%A1%80/Demo%E7%BD%91%E9%A1%B5.png" width="70%"></p><p>这个实例便是网页的一般结构。一个网页的标准形式是<code>html</code>标签内嵌套<code>head</code>和<code>body</code>标签。</p><h2 id="节点树及节点间的关系"><a href="#节点树及节点间的关系" class="headerlink" title="节点树及节点间的关系"></a>节点树及节点间的关系</h2><p>在HTML中，所有标签定义的内容都是节点，他们构成了一个<strong>HTML DOM树</strong>。</p><p><strong>DOM(Document Object Model，文档对象模型)</strong>是W3C(万维网联盟)的标准，定义了访问HTML和XML文档的标准：</p><blockquote><p>W3C文档对象模型(DOM)是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。</p></blockquote><p>W3C DOM标准被分为3个不同的部分：</p><ul><li><strong>核心DOM：</strong>针对任何结构化文档的标准模型</li><li><strong>XML DOM：</strong>针对XML文档的标准模型</li><li><strong>HTML DOM：</strong>针对HTML文档的标准模型</li></ul><p>根据W3C的HTML DOM标准，HTML文档中的所有内容都是节点。</p><ul><li>整个文档是一个文档节点</li><li>每个HTML元素是元素节点</li><li>HTML元素内的文本是文本节点</li><li>每个HTML属性是属性节点</li><li>注释是注释节点</li></ul><p><strong>HTML DOM</strong>将HTML文档视作树结构，这种结构被称为节点树，如下图所示：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E7%BD%91%E9%A1%B5%E5%9F%BA%E7%A1%80/HTML%20DOM" width="70%"></p><p><em>通过HTML DOM树中所有的节点均可通过JavaScript访问</em>，所有HTML节点元素均可被修改，也可以被创建或删除。</p><p>节点树中的节点彼此拥有层级关系。常用<strong>父(parent)、子(child)和兄弟(sibling)</strong>等术语描述这些关系。父节点拥有子节点，同级的子节点被称为兄弟。</p><p>在节点树中，顶端节点称为根(root)。除了根结点之外，每个节点都有父节点，同时可拥有任意数量的子节点或兄弟结点。</p><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>网页由一个个节点组成，<strong>CSS选择器</strong>会根据不同的节点设置不同的样式规则。</p><p>在CSS中，我们使用CSS选择器来定位节点。一共有三种方式：</p><ul><li><code>&lt;div id=&quot;container&quot;&gt;</code>，则可以表示为<code>#container</code>，其中#开头代表选择id，其后紧跟id的名称。</li><li>若想选择<strong>class为wrapper</strong>的节点，可以使用<code>.wrapper</code>，这里的<code>.</code>代表选择class，其后紧跟class的名称。</li><li>根据<strong>标签名</strong>筛选，例如想选择二级标题，直接用<code>h2</code>即可。</li></ul><p>另外，CSS选择器还支持<em>嵌套选择</em>，各个选择器之间加上空格分隔开便可以代表嵌套关系，如：<code>#container .wrapper p</code>则代表先选择id为container的节点，然后选其内部的class为wrapper的节点，然后再进一步选其内部的p节点。另外，若不加空格，则代表并列关系，如<code>div#container .wrapper p.text</code>代表先选择id为container的div节点，然后选其中内部的class为wrapper的节点，再进一步选其内部的class为text的p节点。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 网页 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP基本原理</title>
      <link href="/2019/08/06/HTTP%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
      <url>/2019/08/06/HTTP%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>在本文中，我们会详细了解HTTP的基本原理，了解在浏览器中敲入URL到获取网页内容之间发生了什么。</p><a id="more"></a><h2 id="URI和URL"><a href="#URI和URL" class="headerlink" title="URI和URL"></a>URI和URL</h2><ul><li>URI：Uniform Resource Identifier，统一资源标志符。</li><li>URL：Uniform Resource Locator，统一资源定位符。</li></ul><p><a href="https://github.com/favicon.ico" target="_blank" rel="noopener">https://github.com/favicon.ico</a> 是Github的网站图标链接，它是一个URL，也是一个URI。</p><p>即有这样一个图标资源，我们用URL/URI来唯一指定了它的访问方式，这其中包括了<strong>访问协议https</strong>、<strong>访问路径(/即根目录)</strong>、<strong>资源名称</strong>(favicon.ico)。通过这样一个链接，我们便可以从互联网上找到这个资源，这就是URL/URI。</p><p><strong>URL是URI的子集</strong>。URI还包括一个子类<strong>URN</strong>(Uniform Resource Name，即统一资源名称)。URN只命名资源而不指定如何定位资源，比如<code>urn:isbn:0451450523</code>指定了一本书的ISBN，可以唯一标识这本书，但是没有指定到哪里定位这本书。</p><p>URL、URN和URI的关系如下图所示。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/HTTP%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/URN%3AURL%3AURI%E5%85%B3%E7%B3%BB.png" width="30%"></p><p>在目前的互联网中，URN用的非常少，所以几乎所有的URI都是URL。</p><h2 id="超文本-Hypertext"><a href="#超文本-Hypertext" class="headerlink" title="超文本(Hypertext)"></a>超文本(Hypertext)</h2><p>我们在浏览器里看到的网页就是超文本解析而成的，其网页源代码是一系列HTML代码，里面包含了一系列标签，比如img显示图片，p指定显示段落等。浏览器解析这些标签后，便形成了平常看到的网页，而网页的源代码HTML就可以称作超文本。下图是百度网页的源代码。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/HTTP%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/%E7%99%BE%E5%BA%A6%E7%BD%91%E9%A1%B5%E6%BA%90%E4%BB%A3%E7%A0%81.png" width="70%"></p><h3 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h3><p><strong>HTTP</strong>和<strong>HTTPS</strong>是访问资源所需要的协议类型，另外还有<strong>ftp</strong>、<strong>sftp</strong>、<strong>smb</strong>等。</p><p><strong>HTTP</strong>(Hyper Text Transfer Protocol，超文本传输协议)。HTTP协议是用于从网络传输超文本数据到本地浏览器的传送协议，它能保证高效而准确地传送超文本文档。HTTP由<strong>万维网协会</strong>(World Wide Web Consortium)和<strong>Internet工作小组IETF</strong>(Internet Engineering Task Force)共同合作制定的规范，目前广泛使用的是<strong>HTTP1.1版本</strong>。</p><p><strong>HTTPS</strong>(Hyper Text Transfer Protocol over Secure Socket Layer)，以安全为目标的HTTP通道，即HTTP下加入<strong>SSL层</strong>。HTTPS的安全基础是SSL，因此<em>通过它传输的内容都是经过SSL加密的</em>，主要作用可以分为两种：</p><ul><li>建立一个信息安全通道来保证数据传输的安全。</li><li>确认网站的真实性，凡是使用了HTTPS的网站，都可以通过点击浏览器地址栏的锁头标志来查看网站认证之后的真实信息，也可以通过CA机构颁发的安全签章来查询。</li></ul><h2 id="HTTP请求过程"><a href="#HTTP请求过程" class="headerlink" title="HTTP请求过程"></a>HTTP请求过程</h2><ol><li>在浏览器中输入一个URL。</li><li>浏览器向网站所在的服务器发送了一个请求。</li><li>网络服务器接收到这个请求后进行处理和解析，然后返回对应的响应，接着传回给浏览器。</li><li>响应里包含了页面的源代码等内容，浏览器再对其进行解析，便将网页呈现了出来。</li></ol><h2 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h2><p>请求，由客户端向服务端发出，可以分为4部分内容：</p><ul><li>请求方法(Request Method)</li><li>请求的网址(Request URL)</li><li>请求头(Request Header)</li><li>请求体(Request Body)</li></ul><h3 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h3><p>常见的请求方法有两种：<strong>GET</strong>和<strong>POST</strong>。</p><p>在浏览器中直接输入URL并回车，这便发起了一个<strong>GET请求</strong>，请求的参数会直接包含到URL里。例如：在百度中搜索Python，这就是一个GET请求，链接为：<a href="https://www.baidu.com/s?wd=Python，其中URL中包含了请求的参数信息，这里参数wd表示要搜寻的关键字。" target="_blank" rel="noopener">https://www.baidu.com/s?wd=Python，其中URL中包含了请求的参数信息，这里参数wd表示要搜寻的关键字。</a></p><p><strong>POST请求</strong>大多在表单提交时发起。比如，对于一个登录表单，输入用户名和密码后，点击”登录”按钮，这通常会发起一个POST请求，其数据通常以表单的形式传输，而不会体现在URL中。</p><p><strong>GET</strong>和<strong>POST</strong>请求方法的区别：</p><ul><li>GET请求中的参数包含在URL里面，数据可以在URL中看到，而POST请求的URL不会包含这些数据，数据都是通过表单形式传输的，会包含在请求体中。</li><li>GET请求提交的数据最多只有1024个字节，而POST方式没有限制。</li></ul><p>一般来说，登录时，需要提供账号和密码，其中包含了敏感信息，使用GET方法请求的话，密码就会暴露在URL里面，造成密码的泄露，所以最好选择POST方式传输。上传文件时，由于文件的内容比较大，也会选择使用POST方式。</p><p>另外还有其他的一些请求方法，如下表所示：</p><div class="table-container"><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>GET</td><td>请求网页，并返回页面内容</td></tr><tr><td>POST</td><td>大多用于提交表单或上传文件，数据包含在请求体中</td></tr><tr><td>HEAD</td><td>类似于GET请求， 只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td>PUT</td><td>从客户端向服务器传送的数据取代指定文档中的内容</td></tr><tr><td>DELETE</td><td>请求服务器删除指定页面</td></tr><tr><td>CONNECT</td><td>把服务器当做跳板，让服务器代替客户端访问其他网页</td></tr><tr><td>OPTIONS</td><td>允许客户端查看服务器的性能</td></tr><tr><td>TRACE</td><td>回显服务器收到的请求，主要用于测试或诊断</td></tr></tbody></table></div><h3 id="请求网址"><a href="#请求网址" class="headerlink" title="请求网址"></a>请求网址</h3><p>请求的网址，即统一资源定位符URL，它可以唯一确定我们想请求的资源。</p><h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h3><p>用来说明服务器要使用的附加信息，比较重要的信息有Cookie、Referer、User-Agent等。</p><p>常用的请求头信息：</p><ul><li>Accept：请求报头域，用于指定客户端可接受哪些类型的信息。</li><li>Accept-Language：指定客户端可接受的语言类型。</li><li>Accept-Encoding：指定客户端可接受的内容编码。</li><li>Host：用于指定请求资源的主机IP和端口号，其内容为请求URL的原始服务器或网关的位置。从HTTP1.1版本开始，请求必须包含此内容。</li><li>Cookie：常用复数形式Cookies，这是网站为了辨别用户进行会话跟踪而存储在用户本地的数据。它的主要功能是维持当前访问会话。例如：我们输入用户名和密码成功登录某而过网站后，服务器会用会话保存登录状态信息，后面我们每次刷新或请求该站点的其他网页时，会发现都是登录状态，这就是Cookies的功劳。Cookies里有信息标识了我们所对应的服务器的会话，每次浏览器在请求该站点的页面时，都会在请求头中加入Cookies并将其发送给服务器，服务器通过Cookies识别出是我们自己，并且查出当前状态是登录状态，所以返回结果就是登录之后才能看到的网页内容。</li><li>Referer：此内容用来标识这个请求时从哪个页面发过来的，服务器可以拿到这一信息并做出相应的处理，如做来源统计，防盗链处理等。</li><li>User-Agent：简称UA，它是一个特殊的字符串头，可以是服务器识别客户使用的操作系统及版本、浏览器及版本信息。在做爬虫时加上此信息，可以伪装为浏览器；如果不加，很可能会被识别出为爬虫。</li><li>Content-Type：也叫互联网媒体类型(Internet Media Type)或者MIME类型，在HTTP协议消息头中，它用来表示具体请求中的媒体类型信息。例如：text/html代表HTML格式，image/gif代表GIF图片，application/json代表JSON类型等(具体可以查看<a href="[http://tool.oschina.net/commons](http://tool.oschina.net/commons">这里</a>))。</li></ul><p>请求头是请求的重要组成部分，在写爬虫时，大部分情况下都需要设定请求头。</p><h3 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h3><p>请求体一般承载的内容是<strong>POST请求中的表单数据</strong>，而对于GET请求，请求体则为空。</p><p><strong>Content-Type</strong>和<strong>POST提交数据方式</strong>的联系。</p><div class="table-container"><table><thead><tr><th>Content-Type</th><th>提交数据的方式</th></tr></thead><tbody><tr><td>application/x-www-form-urlencoded</td><td>表单数据</td></tr><tr><td>multipart/form-data</td><td>表单文件上传</td></tr><tr><td>application/json</td><td>序列化JSON数据</td></tr><tr><td>text/xml</td><td>XML数据</td></tr></tbody></table></div><p>在爬虫时，如果要构造POST请求，需要使用正确的Content-Type，并了解各种请求库的各个参数设置时使用的是哪种Content-Type，不然可能会导致POST提交后无法正常相应。</p><h2 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h2><p>由服务端返回给客户端，可以分为三部分：</p><ul><li>响应状态码(Response Status Code)</li><li>响应头(Response Headers)</li><li>响应体(Response Body)</li></ul><h3 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h3><p>响应状态码表示服务器的响应状态，如<em>200代表服务器正常响应</em>，<em>404代表页面未找到</em>，<em>500代表服务器内部发生错误</em>。</p><p>在爬虫过程中，我们可以根据状态码来判断服务器响应状态，如状态码为200，则证明成功返回数据，再进行处理，否则直接忽略。</p><p>响应状态码一共分五大类：</p><ul><li>消息响应</li></ul><div class="table-container"><table><thead><tr><th>状态码</th><th>说明</th><th>详情</th></tr></thead><tbody><tr><td>100</td><td>继续</td><td>请求者应当继续提出请求。服务器已收到请求的一部分，正在等待其他部分</td></tr><tr><td>101</td><td>切换协议</td><td>请求者已要求服务器切换协议，服务器已确认并准备切换</td></tr></tbody></table></div><ul><li>成功响应</li></ul><div class="table-container"><table><thead><tr><th>状态码</th><th>说明</th><th>详情</th></tr></thead><tbody><tr><td>200</td><td>成功</td><td>服务器已成功处理了请求</td></tr><tr><td>201</td><td>已创建</td><td>请求成功并且服务器创建了新的资源</td></tr><tr><td>202</td><td>已接受</td><td>服务器已接受请求，但尚未处理</td></tr><tr><td>203</td><td>非授权信息</td><td>服务器已成功处理了请求，但返回的信息可能来自另一个源</td></tr><tr><td>204</td><td>无内容</td><td>服务器成功处理了请求，但没有返回任何内容</td></tr><tr><td>205</td><td>重置内容</td><td>服务器成功处理了请求，内容被重置</td></tr><tr><td>206</td><td>部分内容</td><td>服务器成功处理了部分请求</td></tr></tbody></table></div><ul><li>重定向</li></ul><div class="table-container"><table><thead><tr><th>状态码</th><th>说明</th><th>详情</th></tr></thead><tbody><tr><td>300</td><td>多种选择</td><td>针对请求，服务器可执行多种操作</td></tr><tr><td>301</td><td>已创建</td><td>请求的网页已永久移动到新位置，即永久重定向</td></tr><tr><td>302</td><td>临时移动</td><td>请求的网页暂时跳转到其他页面，即暂时重定向</td></tr><tr><td>303</td><td>非授权信息</td><td>如果原来的请求是POST，重定向目标文档应该通过GET提取</td></tr><tr><td>304</td><td>无内容</td><td>此次请求返回的页面未修改，继续使用上次的资源</td></tr><tr><td>305</td><td>重置内容</td><td>请求者应该使用代理访问该页面</td></tr><tr><td>307</td><td>部分内容</td><td>请求的资源临时从其他位置响应</td></tr></tbody></table></div><ul><li>客户端错误</li></ul><div class="table-container"><table><thead><tr><th>状态码</th><th>说明</th><th>详情</th></tr></thead><tbody><tr><td>400</td><td>错误请求</td><td>服务器无法解析该请求</td></tr><tr><td>401</td><td>未授权</td><td>请求没有进行身份验证或验证未通过</td></tr><tr><td>403</td><td>禁止访问</td><td>服务器拒绝此请求</td></tr><tr><td>404</td><td>未找到</td><td>服务器找不到请求的页面</td></tr><tr><td>405</td><td>方法禁用</td><td>服务器禁用了请求中指定的方法</td></tr><tr><td>406</td><td>不接受</td><td>无法使用请求的内容响应请求的页面</td></tr><tr><td>407</td><td>需要代理授权</td><td>请求者需要使用代理授权</td></tr><tr><td>408</td><td>请求超时</td><td>服务器请求超时</td></tr><tr><td>409</td><td>冲突</td><td>服务器在完成请求时发生冲突</td></tr><tr><td>410</td><td>已删除</td><td>请求的资源已永久删除</td></tr><tr><td>411</td><td>需要有效长度</td><td>服务器不接受不含有效内容长度标头字段的请求</td></tr><tr><td>412</td><td>未满足前提条件</td><td>服务器未满足请求者在请求中设置的其中一个前提条件</td></tr><tr><td>413</td><td>请求实体过大</td><td>请求实体过大，超出服务器的处理能力</td></tr><tr><td>414</td><td>请求URL过长</td><td>请求网址过长，服务器无法处理</td></tr><tr><td>415</td><td>不支持类型</td><td>请求格式不被请求页面支持</td></tr><tr><td>416</td><td>请求范围不符</td><td>页面无法提供请求的范围</td></tr><tr><td>417</td><td>未满足期望值</td><td>服务器未满足期望请求标头字段的要求</td></tr></tbody></table></div><ul><li>服务器端错误</li></ul><div class="table-container"><table><thead><tr><th>状态码</th><th>说明</th><th>详情</th></tr></thead><tbody><tr><td>500</td><td>成功</td><td>服务器遇到错误，无法完成请求</td></tr><tr><td>501</td><td>未实现</td><td>服务器不具备完成请求的功能</td></tr><tr><td>502</td><td>错误网关</td><td>服务器作为网关或代理，从上游服务器收到无效响应</td></tr><tr><td>503</td><td>服务不可用</td><td>服务器目前无法使用</td></tr><tr><td>504</td><td>网关超时</td><td>服务器作为网关或代理。但是没有及时从上游服务器收到请求</td></tr></tbody></table></div><h3 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h3><p>响应头包含了服务器对请求的应答信息，如Content-Type、Server、Set-Cookie等。</p><p>下面简要说明一些常用的头信息：</p><ul><li>Date：标识响应产生的时间。</li><li>Last-Modified：指定资源的最后修改时间。</li><li>Content-Encoding：指定响应内容的编码。</li><li>Server：包含服务器的信息，比如名称、版本号。</li><li>Content-Type：文档类型，指定返回的数据类型是什么，如text/html代表返回HTML文档，application/x-javascript则代表返回JavaScript文件，image/jpeg则代表返回图片。</li><li>Set-Cookie：设置Cookies。响应头中的Set-Cookie告诉浏览器需要将此内容放在Cookies中，下次请求携带Cookies请求。</li><li>Expires：指定响应的过期时间，可以使代理服务器或浏览器将加载的内容更新到缓存中。如果再次访问时，就可以直接从缓存中加载，降低服务器负载，缩短加载时间。</li></ul><h3 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h3><p>响应的正文数据都在响应体中，比如请求网页时，它的响应体就是网页的HTML代码，请求一张图片时，它的响应体就是图片的二进制数据。做爬虫请求网页后，要解析的内容就是响应体。</p><p>在浏览器开发者工具中点击<strong>Preview</strong>，就可以看到网页的源代码，也就是响应体的内容，它是解析的目标。</p><p>在做爬虫时，我们主要通过响应体得到网页的源代码、JSON数据等，然后从中做相应内容的提取。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> HTTP </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell后台执行</title>
      <link href="/2019/08/05/shell%E5%90%8E%E5%8F%B0%E6%89%A7%E8%A1%8C/"/>
      <url>/2019/08/05/shell%E5%90%8E%E5%8F%B0%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>后台执行：<code>nohup sh run.sh &gt;log.txt 2&gt;&amp;1 &amp;</code></p><p>后台查看：<code>ps -ef | grep 13549</code></p><p>终止进程：<code>kill -9 pid</code></p><a id="more"></a><h2 id="后台执行"><a href="#后台执行" class="headerlink" title="后台执行"></a>后台执行</h2><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nohup sh run.sh &gt;log.txt 2&gt;&amp;1 &amp;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[1] 13549  <span class="hljs-comment"># 进程号，后面查看相关信息用到。</span><br></code></pre></td></tr></table></figure><p>这个命令分为五个部分，分别是<code>nohup</code>、<code>sh run.sh</code>、<code>&gt;log.txt</code>、<code>2&gt;&amp;1</code>、<code>&amp;</code>。</p><ul><li><code>nohup</code>和最后的<code>&amp;</code>：表示命令在后台执行</li><li><code>sh run.sh</code>执行<strong>run.sh</strong>脚本</li><li><code>&gt;log.txt</code>是将信息输出到<strong>log.txt</strong>日志中</li><li><code>2&gt;&amp;1</code>是将标准错误信息转变成标准输出，这样就可以将错误信息输出到<strong>log.txt</strong>日志里。</li></ul><p>其中0、1、2分别代表如下含义：</p><ul><li>0：stdin(标准输入)</li><li>1：stdout(标准输出)</li><li>2：stderr(标准错误)</li></ul><h2 id="后台查看"><a href="#后台查看" class="headerlink" title="后台查看"></a>后台查看</h2><h3 id="查看本地进程"><a href="#查看本地进程" class="headerlink" title="查看本地进程"></a>查看本地进程</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps -ef | grep 13549<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">work  12929 44118  0 11:36 pts/2    00:00:00 grep 13549<br></code></pre></td></tr></table></figure><p>这个命令也是分五个部分<code>ps</code> 、<code>-ef</code>、 <code>|</code>、 <code>grep</code>、 <code>13549</code>。</p><ul><li><code>ps</code>表示将某个进程显示出来</li><li><code>-e</code>表示显示所有程序、<code>-f</code>表示显示UID,PPIP,C与STIME栏位</li><li><code>grep</code>表示查找和其后面内容相关的信息，即和<code>13549</code>相关的信息</li><li><code>|</code>是管道命令 是指ps命令与grep同时执行</li></ul><p>输出的信息分别是：UID 、 PID 、PPID 、 C STIME 、 TTY、 TIME 、 CMD。</p><ul><li>UID 程序被该 UID 所拥有</li><li>PID 就是这个程序的 ID</li><li>PPID 则是其上级父程序的ID</li><li>C CPU 使用的资源百分比</li><li>STIME 系统启动时间</li><li>TTY 登入者的终端机位置</li><li>TIME 使用掉的 CPU 时间</li></ul><h3 id="查看hadoop进程"><a href="#查看hadoop进程" class="headerlink" title="查看hadoop进程"></a>查看hadoop进程</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim log.txt<br></code></pre></td></tr></table></figure><h2 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h2><h3 id="终止本地进程"><a href="#终止本地进程" class="headerlink" title="终止本地进程"></a>终止本地进程</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">kill</span> -9 pid<br><span class="hljs-comment"># kill -9 13549</span><br></code></pre></td></tr></table></figure><h3 id="终止hadoop进程"><a href="#终止hadoop进程" class="headerlink" title="终止hadoop进程"></a>终止hadoop进程</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop job -<span class="hljs-built_in">kill</span> jobid<br><span class="hljs-comment"># hadoop job -kill job_20180809144936_572433</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>App爬取相关库的安装</title>
      <link href="/2019/08/05/App%E7%88%AC%E5%8F%96%E7%9B%B8%E5%85%B3%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2019/08/05/App%E7%88%AC%E5%8F%96%E7%9B%B8%E5%85%B3%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>爬虫也可以抓取App的数据。App中的页面要加载出来，首先需要获取数据，而这些数据一般是通过请求服务器的接口来获取的。由于App没有浏览器这种可以比较直观地看到后台请求的工具，所以主要用一些抓包技术来抓取数据。</p><p>本文介绍的抓包工具有 <strong>Charles</strong> 、 <strong>mitmproxy</strong> 和 <strong>mitmdump</strong> 。一些简单的接口可以通过<strong>Charles</strong>或<strong>mitmproxy</strong>分析，找出规律，然后直接用程序模拟来抓取。但是如果遇到更复杂的接口，就需要利用<strong>mitmdump</strong>对接Python来对抓取的请求和响应进行实时处理和保存。</p><p>另外，既然要做规模采集，就需要自动化App的操作而不是人工去采集，所以之力还需要一个工具叫做<strong>Appium</strong>，它可以对App进行自动化控制，如自动化模拟App的点击、下拉等操作。</p><a id="more"></a><h2 id="Charles"><a href="#Charles" class="headerlink" title="Charles"></a>Charles</h2><p>Charles是一个网络抓包工具，相比Fiddler，其功能更为强大，而且跨平台支持得更好，所以可以选用它来作为主要的移动端抓包工具。</p><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>官方网站：<a href="https://www.charlesproxy.com" target="_blank" rel="noopener">https://www.charlesproxy.com</a></li><li>下载链接：<a href="https://www.charlesproxy.com/download" target="_blank" rel="noopener">https://www.charlesproxy.com/download</a></li></ul><h3 id="下载Charles"><a href="#下载Charles" class="headerlink" title="下载Charles"></a>下载Charles</h3><p>可以选择官方正版或者破解版下载。</p><h3 id="证书配置"><a href="#证书配置" class="headerlink" title="证书配置"></a>证书配置</h3><p>现在很多页面都在向HTTPS方向发展，HTTPS通信协议应用得越来越广泛。如果一个App通信应用了HTTPS协议，那么它通信的数据都会是被加密的，常规的截包方法是无法识别请求内部的数据的。</p><p>安装完成后，如果我们想要做HTTPS抓包的话，那么还需要配置一下相关的<strong>SSL证书</strong>。</p><p><strong>Charles</strong>是运行在PC端的，我们要抓取的是App端的数据，所以要在<strong>PC和手机</strong>端都安装证书。</p><p>具体内容配置可以参考这篇<a href="https://www.jianshu.com/p/0bc767840e42" target="_blank" rel="noopener">博客</a>。</p><h2 id="mitmproxy"><a href="#mitmproxy" class="headerlink" title="mitmproxy"></a>mitmproxy</h2><p><strong>mitmproxy</strong>是一个支持HTTP和HTTPS的抓包程序，类似Fiddler、Charles的功能，只不过它是通过控制台的形式操作。</p><p>此外，<strong>mitmproxy</strong>还有两个关联组件：</p><ul><li><strong>mitmdump</strong>：它是<strong>mitmproxy</strong>的命令行接口，利用它可以对接Python脚本，实现监听后的处理。</li><li><strong>mitmweb</strong>：它是一个web程序，通过它可以清楚地观察到mitmproxy捕获的请求。</li></ul><h3 id="相关链接-1"><a href="#相关链接-1" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>Github：<a href="https://github.com/mitmproxy/mitmproxy" target="_blank" rel="noopener">https://github.com/mitmproxy/mitmproxy</a></li><li>官方网站：<a href="https://mitmproxy.org" target="_blank" rel="noopener">https://mitmproxy.org</a></li><li>官方文档：<a href="http://docs.mitmproxy.org" target="_blank" rel="noopener">http://docs.mitmproxy.org</a></li><li>mitmdump脚本：<a href="http://docs.mitmproxy.org/en/stable/scripting/overview.html" target="_blank" rel="noopener">http://docs.mitmproxy.org/en/stable/scripting/overview.html</a></li></ul><h3 id="pip安装"><a href="#pip安装" class="headerlink" title="pip安装"></a>pip安装</h3><p>输入命令：<code>pip3 install mitmproxy</code></p><p>执行完毕后即可完成<strong>mitmproxy</strong>的安装，另外还附带安装了<strong>mitmdump</strong>和<strong>mitmweb</strong>两个组件。</p><h3 id="证书配置-1"><a href="#证书配置-1" class="headerlink" title="证书配置"></a>证书配置</h3><p>对于mitmproxy来说，如果想要截获HTTPS请求，就需要设置证书（该证书在安装后会提供，只需信任即可）。</p><p>首先运行以下命令产生CA证书，并启动mitmproxy：<code>mitmdump</code></p><p>接下来我们可以在用户目录下的<code>.mitmproxy</code>目录里找到CA证书。</p><p>在Mac中，点击<code>mitmproxy-ca-cert.pem</code>这个证书，然后授权信任即可。</p><h2 id="Appium"><a href="#Appium" class="headerlink" title="Appium"></a>Appium</h2><p>Appium是移动端的自动化测试工具，类似于Selenium，利用它可以驱动Android、iOS等设备完成自动化测试，比如模拟点击、滑动、输入等操作。</p><h3 id="相关链接-2"><a href="#相关链接-2" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>Github：<a href="https://github.com/appium/appium" target="_blank" rel="noopener">https://github.com/appium/appium</a></li><li>官方网站：<a href="http://appium.io" target="_blank" rel="noopener">http://appium.io</a></li><li>官方文档：<a href="http://appium.io/introduction.html" target="_blank" rel="noopener">http://appium.io/introduction.html</a></li><li>Python Client：<a href="https://github.com/appium/python-client" target="_blank" rel="noopener">https://github.com/appium/python-client</a></li><li>下载链接：<a href="https://github.com/appium/appium-desktop/releases" target="_blank" rel="noopener">https://github.com/appium/appium-desktop/releases</a></li></ul><h3 id="安装Appium"><a href="#安装Appium" class="headerlink" title="安装Appium"></a>安装Appium</h3><p>首先需要安装Appium。Appium负责驱动移动端来完成一系列操作，对于<strong>iOS</strong>设备来说，它使用苹果的<strong>UIAutomation</strong>来实现驱动；对于<strong>Android</strong>来说，它使用<strong>UIAutomation</strong>和<strong>Selendroid</strong>来实现驱动。</p><p>同时Appium也相当于一个服务器，我们可以向他发送一些操作指令，它会根据不同的指令对移动设备进行驱动，以完成不同的动作。</p><p>两种方法安装：</p><ul><li>Appium Desktop：<a href="https://github.com/appium/appium-desktop/releases" target="_blank" rel="noopener">https://github.com/appium/appium-desktop/releases</a> 选择对应的版本下载安装。</li><li>Node.js：使用命令：<code>npm install -g appium</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> 开发环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发环境配置 </tag>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web库的安装</title>
      <link href="/2019/08/05/Web%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2019/08/05/Web%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>现在日常访问的网站都是Web服务程序搭建而成的。</p><p>Python也有一些这样的Web服务程序，比如Flask、Django等，我们可以拿它来开发网站和接口等。</p><p>在爬虫中主要使用这些Web服务程序来搭建一些API接口。例如：维护一个代理池，代理保存在Redis数据库中，我们要将代理池作为一个公共的组件使用，那么如何构建一个方便的平台来供我们获取这些代理呢？最合适不过的就是通过Web服务提供一个API接口，我们只需要请求接口即可获取新的代理，这样做，简单、高效、实用！</p><p>本文主要介绍Web服务程序<strong>Flask</strong>和<strong>Tornado</strong>。</p><a id="more"></a><h2 id="Flask"><a href="#Flask" class="headerlink" title="Flask"></a>Flask</h2><p>Flask是一个轻量级的Web服务程序，它简单、易用、灵活，这里主要用来做一些API服务。</p><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>Github：<a href="https://github.com/pallets/flask" target="_blank" rel="noopener">https://github.com/pallets/flask</a></li><li>官方文档：<a href="http://flask.pocoo.org" target="_blank" rel="noopener">http://flask.pocoo.org</a></li><li>中文文档：<a href="http://docs.jinkan.org/docs/flask" target="_blank" rel="noopener">http://docs.jinkan.org/docs/flask</a></li><li>PyPI：<a href="https://pypi.python.org/pypi/Flask" target="_blank" rel="noopener">https://pypi.python.org/pypi/Flask</a></li></ul><h3 id="pip安装"><a href="#pip安装" class="headerlink" title="pip安装"></a>pip安装</h3><p>执行命令：<code>pip3 install flask</code></p><h3 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h3><p>安装成功后，可以运行如下实例代码测试：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><br>app = Flask(__name__)<br><br><br><span class="hljs-meta">@app.route("/")</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello World!"</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    app.run()<br></code></pre></td></tr></table></figure><p>可以发现，系统会在<strong>5000端口</strong>开启Web服务，控制台输出如下：</p><p> <strong>* Running on <a href="http://127.0.0.1:5000/" target="_blank" rel="noopener">http://127.0.0.1:5000/</a> (Press CTRL+C to quit)</strong></p><p>直接访问<a href="http://127.0.0.1:5000/" target="_blank" rel="noopener">http://127.0.0.1:5000/</a>，可以观察到网页中呈现了 <strong>Hello World!</strong> ，如下图所示，一个简单的Flask程序就运行成功了。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Web%E5%BA%93%E5%AE%89%E8%A3%85/Flask%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" width="70%"></p><h2 id="Tornado安装"><a href="#Tornado安装" class="headerlink" title="Tornado安装"></a>Tornado安装</h2><p>Tornado是一个支持异步的Web框架，通过使用非阻塞I/O流，它可以支撑成千上万的开放连接，效率非常高。</p><h3 id="相关链接-1"><a href="#相关链接-1" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>Github：<a href="https://github.com/tornadoweb/tornado" target="_blank" rel="noopener">https://github.com/tornadoweb/tornado</a></li><li>PyPI：<a href="https://pypi.python.org/pypi/tornado" target="_blank" rel="noopener">https://pypi.python.org/pypi/tornado</a></li><li>官方文档：<a href="http://www.tornadoweb.org" target="_blank" rel="noopener">http://www.tornadoweb.org</a></li></ul><h3 id="pip安装-1"><a href="#pip安装-1" class="headerlink" title="pip安装"></a>pip安装</h3><p>执行命令：<code>pip3 install tornado</code></p><h3 id="验证安装-1"><a href="#验证安装-1" class="headerlink" title="验证安装"></a>验证安装</h3><p>安装成功后，可以运行如下实例代码测试：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tornado.ioloop<br><span class="hljs-keyword">import</span> tornado.web<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainHandler</span><span class="hljs-params">(tornado.web.RequestHandler)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span><span class="hljs-params">(self)</span>:</span><br>        self.write(<span class="hljs-string">"Hello World!"</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_app</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-keyword">return</span> tornado.web.Application([(<span class="hljs-string">r"/"</span>, MainHandler), ])<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>  app = make_app()<br>  app.listen(<span class="hljs-number">8888</span>)<br>  tornado.ioloop.IOLoop.current().start()<br></code></pre></td></tr></table></figure><p>可以发现，系统会在<strong>8888端口</strong>开启Web服务，控制台没有输出内容。</p><p>直接访问<a href="http://127.0.0.1:8888/" target="_blank" rel="noopener">http://127.0.0.1:8888/</a>，可以观察到网页中呈现了 <strong>Hello World!</strong> ，如下图所示，一个简单的<strong>Tornado</strong>程序就运行成功了。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Web%E5%BA%93%E5%AE%89%E8%A3%85/tornado.png" width="70%"></p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> 开发环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发环境配置 </tag>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>存储库的安装</title>
      <link href="/2019/08/05/%E5%AD%98%E5%82%A8%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2019/08/05/%E5%AD%98%E5%82%A8%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>数据库想要和Python进行交互的话，还需要安装一些Python存储库，如：<strong>MySQL</strong>需要安装<strong>PyMySQL</strong>、<strong>MongoDB</strong>需要安装<strong>PyMongo</strong>等。</p><p>本文主要说明这些存储库的安装方式。</p><a id="more"></a><h2 id="PyMySQL"><a href="#PyMySQL" class="headerlink" title="PyMySQL"></a>PyMySQL</h2><p>在<strong>Python3</strong>中，如果想要将数据存储到<strong>MySQL</strong>中，就需要借助<strong>PyMySQL</strong>来操作。</p><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>Github：<a href="https://github.com/PyMySQL/PyMySQL" target="_blank" rel="noopener">https://github.com/PyMySQL/PyMySQL</a></li><li>官方文档：<a href="http://pymysql.readthedocs.io" target="_blank" rel="noopener">http://pymysql.readthedocs.io</a></li><li>PyPI：<a href="https://pypi.python.org/pypi/PyMySQL" target="_blank" rel="noopener">https://pypi.python.org/pypi/PyMySQL</a></li></ul><h3 id="pip安装"><a href="#pip安装" class="headerlink" title="pip安装"></a>pip安装</h3><p>安装命令：<code>pip3 install pymysql</code></p><h3 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h3><p>使用以下命令进行验证：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python3<br>&gt;&gt;&gt; import pymysql<br>&gt;&gt;&gt; pymysql.VERSION<br>(0, 9, 3, None)<br></code></pre></td></tr></table></figure><p>如果成功输出了其版本内容，则证明PyMySQL成功安装。</p><h2 id="PyMongoDB"><a href="#PyMongoDB" class="headerlink" title="PyMongoDB"></a>PyMongoDB</h2><p>在Python中，如果想要和<strong>MongoDB</strong>进行交互，就需要借助于<strong>PyMongo</strong>库。</p><h3 id="相关链接-1"><a href="#相关链接-1" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>Github：<a href="https://github.com/mongodb/mongo-python-driver" target="_blank" rel="noopener">https://github.com/mongodb/mongo-python-driver</a></li><li>官方文档：<a href="http://api.mongodb.com/python/current" target="_blank" rel="noopener">http://api.mongodb.com/python/current</a></li><li>PyPI：<a href="https://pypi.python.org/pypi/pymongo" target="_blank" rel="noopener">https://pypi.python.org/pypi/pymongo</a></li></ul><h3 id="pip安装-1"><a href="#pip安装-1" class="headerlink" title="pip安装"></a>pip安装</h3><p>安装命令：<code>pip3 install pymongo</code></p><h3 id="验证安装-1"><a href="#验证安装-1" class="headerlink" title="验证安装"></a>验证安装</h3><p>使用以下命令进行验证：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python3<br>&gt;&gt;&gt; import pymongo<br>&gt;&gt;&gt; pymongo.VERSION<br><span class="hljs-string">'3.8.0'</span><br></code></pre></td></tr></table></figure><p>如果成功输出了其版本内容，则证明<strong>PyMongo</strong>成功安装。</p><h2 id="redis-py"><a href="#redis-py" class="headerlink" title="redis-py"></a>redis-py</h2><p>在Python中，如果想要和<strong>Redis</strong>进行交互，就需要借助于<strong>redis-py</strong>库。</p><h3 id="相关链接-2"><a href="#相关链接-2" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>Github：<a href="https://github.com/andymccurdy/redis-py" target="_blank" rel="noopener">https://github.com/andymccurdy/redis-py</a></li><li>官方文档：<a href="https://redis-py.readthedocs.io/" target="_blank" rel="noopener">https://redis-py.readthedocs.io/</a></li></ul><h3 id="pip安装-2"><a href="#pip安装-2" class="headerlink" title="pip安装"></a>pip安装</h3><p>安装命令：<code>pip3 install redis</code></p><h3 id="验证安装-2"><a href="#验证安装-2" class="headerlink" title="验证安装"></a>验证安装</h3><p>使用以下命令进行验证：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python3<br>&gt;&gt;&gt; import redis<br>&gt;&gt;&gt; redis.VERSION<br>(3, 3, 5)<br></code></pre></td></tr></table></figure><p>如果成功输出了其版本内容，则证明<strong>redis-py</strong>成功安装。</p><h2 id="RedisDump"><a href="#RedisDump" class="headerlink" title="RedisDump"></a>RedisDump</h2><p>RedisDump是一个用于Redis数据导入/导出的工具，是基于Ruby实现的，所以要安装RedisDump，需要先安装Ruby。</p><h3 id="相关链接-3"><a href="#相关链接-3" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>Github：<a href="https://github.com/delano/redis-dump" target="_blank" rel="noopener">https://github.com/delano/redis-dump</a></li><li>官方文档：<a href="http://delanotes.com/redis-dump" target="_blank" rel="noopener">http://delanotes.com/redis-dump</a></li></ul><h3 id="gem安装"><a href="#gem安装" class="headerlink" title="gem安装"></a>gem安装</h3><p>安装Ruby(参考<a href="http://www.ruby-lang.org/zh_cn/documentation/installation" target="_blank" rel="noopener">这里</a>)后，利用<strong>gem命令</strong>安装RedisDump：<code>gem install redis-dump</code></p><h3 id="验证安装-3"><a href="#验证安装-3" class="headerlink" title="验证安装"></a>验证安装</h3><p>安装成功后，可以执行如下两个命令：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">redis-dump<br>redis-load<br></code></pre></td></tr></table></figure><p>如果可以成功调用，则说明安装成功。</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> 开发环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发环境配置 </tag>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库的安装</title>
      <link href="/2019/08/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2019/08/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>作为数据存储的重要部分，数据库同样是必不可少的，数据库可以分为关系型数据库和非关系型数据库。</p><p>关系型数据库如SQLite、MySQL、Oracle、SQL Server、DB2等，其数据库是以表的形式存储。</p><p>非关系型数据库如MongoDB、Redis它们的存储形式是键值对，存储形式更加灵活。</p><p>本文主要介绍关系型数据库MySQL以及非关系型数据库MongoDB、Redis的安装。</p><a id="more"></a><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>MySQL是一个轻量级的关系型数据库。</p><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>官方网站：<a href="https://www.mysql.com/cn" target="_blank" rel="noopener">https://www.mysql.com/cn</a></li><li>下载地址：<a href="https://www.mysql.com/cn/downloads" target="_blank" rel="noopener">https://www.mysql.com/cn/downloads</a></li><li>中文教程：<a href="http://www.runoob.com/mysql/mysql-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/mysql/mysql-tutorial.html</a></li></ul><h3 id="Mac下安装"><a href="#Mac下安装" class="headerlink" title="Mac下安装"></a>Mac下安装</h3><p>使用<strong>HomeBrew</strong>安装，直接执行brew命令即可：<code>brew install mysql</code></p><p>启动、停止和重启MySQL服务的命令如下：</p><ul><li><code>sudo mysql.server start</code></li><li><code>sudo mysql.server stop</code></li><li><code>sudo mysql.server restart</code></li></ul><p>Mac一般不会作为服务器使用，如果想取消本地host绑定，那么需要修改<strong>my.cnf</strong>文件，然后重启服务。</p><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><p>MongoDB是由<strong>C++</strong>语言编写的非关系型数据库，是一个基于分布式文件存储的开源数据库系统，其内容存储形式类似JSON对象，它的字段值可以包含其他文档，数组及文档数据，非常灵活。</p><h3 id="相关链接-1"><a href="#相关链接-1" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>官方网站：<a href="https://www.mongodb.com" target="_blank" rel="noopener">https://www.mongodb.com</a></li><li>官方文档：<a href="https://docs.mongodb.com" target="_blank" rel="noopener">https://docs.mongodb.com</a></li><li>Github：<a href="https://github.com/mongodb" target="_blank" rel="noopener">https://github.com/mongodb</a></li><li>中文教程：<a href="https://www.runoob.com/mongodb/mongodb-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/mongodb/mongodb-tutorial.html</a></li></ul><h3 id="Mac下安装-1"><a href="#Mac下安装-1" class="headerlink" title="Mac下安装"></a>Mac下安装</h3><p>使用<strong>HomeBrew</strong>安装，直接执行brew命令即可：<code>brew install mongodb</code></p><p>然后创建一个新文件夹/data/db，用于存放MongoDB数据。</p><p>启动MongoDB命令：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew services start mongodb<br>sudo mongod<br></code></pre></td></tr></table></figure><p>停止和重启MongoDB服务的命令：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew services stop mongodb<br>brew services restart mongodb<br></code></pre></td></tr></table></figure><h3 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h3><p>二选一即可。</p><p><strong>RoboMongo/Robo 3T</strong>：</p><ul><li>官方网址：<a href="https://robomongo.org" target="_blank" rel="noopener">https://robomongo.org</a></li><li>下载链接：<a href="https://robomongo.org/download" target="_blank" rel="noopener">https://robomongo.org/download</a></li></ul><p><strong>Studio 3T</strong>：</p><ul><li>官方网站：<a href="https://studio3t.com" target="_blank" rel="noopener">https://studio3t.com</a></li><li>下载链接：<a href="https://studio3t.com/download" target="_blank" rel="noopener">https://studio3t.com/download</a></li></ul><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>Redis是一个基于内存的高效的非关系型数据库。</p><h3 id="相关链接-2"><a href="#相关链接-2" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>官方网站：<a href="https://redis.io" target="_blank" rel="noopener">https://redis.io</a></li><li>官方文档：<a href="https://redis.io/documentation" target="_blank" rel="noopener">https://redis.io/documentation</a></li><li>中文官网：<a href="http://www.redis.cn" target="_blank" rel="noopener">http://www.redis.cn</a></li><li>Github：<a href="https://github.com/antirez/redis" target="_blank" rel="noopener">https://github.com/antirez/redis</a></li><li>中文教程：<a href="https://www.runoob.com/redis/redis-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/redis/redis-tutorial.html</a></li></ul><h3 id="Mac下安装-2"><a href="#Mac下安装-2" class="headerlink" title="Mac下安装"></a>Mac下安装</h3><p>使用<strong>HomeBrew</strong>安装，直接执行brew命令即可：<code>brew install redis</code></p><p>启动<strong>redis</strong>命令：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew services start redis<br>redis-server /usr/<span class="hljs-built_in">local</span>/etc/redis.conf<br></code></pre></td></tr></table></figure><p>这里可以使用命令：<code>redis-cli</code>进入Redis命令行模式。</p><p>Mac下的Redis配置文件路径是：<code>/usr/local/etc/redis.conf</code>，可以通过修改它来配置访问密码。</p><p>修改配置文件后，需要重启Redis服务。停止和重启Redis服务的命令如下：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew services stop redis<br>brew services restart redis<br></code></pre></td></tr></table></figure><p>另外Mac下可以安装<strong>Redis Desktop Manager</strong>可视化管理工具来管理Redis。</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> 开发环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发环境配置 </tag>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解析库的安装</title>
      <link href="/2019/08/05/%E8%A7%A3%E6%9E%90%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2019/08/05/%E8%A7%A3%E6%9E%90%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>爬取网页代码后，下一步就是从网页中提取信息。</p><p>提取信息的方式有多种多样，可以使用正则表达式来提取，但是写起来相对比较繁琐。</p><p>这里还有许多强大的解析库，如lxml、Beautiful Soup、pyquery等。</p><p>此外还有非常强大的解析方法，如XPath解析和CSS选择器解析等，利用它们，我们可以高效便捷地从网页中提取有效信息。</p><a id="more"></a><h2 id="lxml库"><a href="#lxml库" class="headerlink" title="lxml库"></a>lxml库</h2><p>lxml是Python的一个解析库，支持HTML和XML的解析，支持XPath解析方式而且解析效率非常高。</p><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>官方网站：<a href="http://lxml.de" target="_blank" rel="noopener">http://lxml.de</a></li><li>Github：<a href="https://github.com/lxml/lxml" target="_blank" rel="noopener">https://github.com/lxml/lxml</a></li><li>PyPI：<a href="https://pypi.python.org/pypi/lxml" target="_blank" rel="noopener">https://pypi.python.org/pypi/lxml</a></li></ul><h3 id="pip安装"><a href="#pip安装" class="headerlink" title="pip安装"></a>pip安装</h3><p>命令行输入：<code>pip3 install lxml</code></p><p>如果产生错误，可以执行如下命令将必要的类库安装(Mac操作系统)：<code>xcode-select --install</code></p><p>lxml是一个非常重要的库，后面的Beautiful Soup、Scrapy框架都需要用到此库。</p><h3 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h3><p>安装完成之后，可以在Python命令下测试：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python3<br>&gt;&gt;&gt;import lxml<br></code></pre></td></tr></table></figure><p>如果没有报错，则证明库已经安装好了。</p><h2 id="Beautiful-Soup库"><a href="#Beautiful-Soup库" class="headerlink" title="Beautiful Soup库"></a>Beautiful Soup库</h2><p>Beautiful Soup是Python的一个HTML或XML的解析库，我们可以用它来方便地从网页中提取数据。</p><p>它拥有强大的API和多样的解析方式。</p><h3 id="相关链接-1"><a href="#相关链接-1" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>官方文档：<a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/" target="_blank" rel="noopener">https://www.crummy.com/software/BeautifulSoup/bs4/doc</a></li><li>中文文档：<a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/" target="_blank" rel="noopener">https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/</a></li><li>PyPI：<a href="https://pypi.python.org/pypi/beautifulsoup4" target="_blank" rel="noopener">https://pypi.python.org/pypi/beautifulsoup4</a></li></ul><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>Beautiful Soup的HTML和XML解析器是依赖于lxml库的，所以在此之前请确保已经安装了<strong>lxml库</strong>。</p><h3 id="pip安装-1"><a href="#pip安装-1" class="headerlink" title="pip安装"></a>pip安装</h3><p>目前，Beautiful Soup的最新版本是4.x版本，之前的版本以及停止开发。</p><p>这里推荐使用pip安装，命令为：<code>pip3 install beautifulsoup4</code></p><h3 id="验证安装-1"><a href="#验证安装-1" class="headerlink" title="验证安装"></a>验证安装</h3><p>安装完成之后，可以运行如下代码验证一下：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br>soup = BeautifulSoup(<span class="hljs-string">'&lt;p&gt;hello&lt;/p&gt;'</span>, <span class="hljs-string">'lxml'</span>)<br>print(soup.p.string)<br></code></pre></td></tr></table></figure><p>若输出结果为：<code>hello</code>，则证明安装成功。</p><p><strong>注意</strong>：</p><p>这里我们虽然安装的是beautifulsoup4这个包，但在引入的时候却是bs4。这是因为这个包源代码本身的库文件夹名称就是bs4，所以安装完成之后，这个库文件夹就被移入到本机Python3的lib库里，所以识别到的库文件名就叫做bs4。</p><p>因此，<em>包本身的名称和我们使用时导入的包的名称并不一定是一致的</em>。</p><h2 id="pyquery库"><a href="#pyquery库" class="headerlink" title="pyquery库"></a>pyquery库</h2><p>pyquery是一个强大的网页解析工具，它提供了和jQuery类似的语法来解析HTML文档，支持CSS选择器。</p><h3 id="相关链接-2"><a href="#相关链接-2" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>Github：<a href="https://github.com/gawel/pyquery" target="_blank" rel="noopener">https://github.com/gawel/pyquery</a></li><li>PyPI：<a href="https://pypi.python.org/pypi/pyquery" target="_blank" rel="noopener">https://pypi.python.org/pypi/pyquery</a></li><li>官方文档：<a href="http://pyquery.readthedocs.io" target="_blank" rel="noopener">http://pyquery.readthedocs.io</a></li></ul><h3 id="pip安装-2"><a href="#pip安装-2" class="headerlink" title="pip安装"></a>pip安装</h3><p>命令行：<code>pip3 install pyquery</code></p><h3 id="验证安装-2"><a href="#验证安装-2" class="headerlink" title="验证安装"></a>验证安装</h3><p>安装完成之后，可以在Python命令下测试：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python3<br>&gt;&gt;&gt;import pyquery<br></code></pre></td></tr></table></figure><p>如果没有报错，则证明库已经安装好了。</p><h2 id="tesserocr库"><a href="#tesserocr库" class="headerlink" title="tesserocr库"></a>tesserocr库</h2><p>在爬虫过程中，难免会遇到各种各样的验证码，而大多数验证码还是图形验证码，这时候我们可以直接使用OCR来识别。</p><p>OCR( Optical Character Recognition )，光学字符识别，是指通过扫描字符，然后通过其形状将其翻译成电子文本的过程。对于图形验证码来说，它们都是一些不规则的字符，这些符确实是由字符稍加扭曲变换得到的内容。</p><p>tesserocr是Python的一个OCR识别库，但其实是对tesseract做的一层Python API封装，所以它的核心是tesseract。因此，在安装tesserocr之前，我们需要安装tesseract。</p><h3 id="相关链接-3"><a href="#相关链接-3" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>tesserocr Github：<a href="https://github.com/sirfz/tesserocr" target="_blank" rel="noopener">https://github.com/sirfz/tesserocr</a></li><li>tesserocr PyPI：<a href="https://pypi.python.org/pypi/tesserocr" target="_blank" rel="noopener">https://pypi.python.org/pypi/tesserocr</a></li><li>tesseract 下载地址：<a href="http://digi.bib.uni-mannheim.de/tesseract" target="_blank" rel="noopener">http://digi.bib.uni-mannheim.de/tesseract</a></li><li>tesseract Github：<a href="https://github.com/tesseract-ocr/tesseract" target="_blank" rel="noopener">https://github.com/tesseract-ocr/tesseract</a></li><li>tesseract 语言包：<a href="https://github.com/tesseract-ocr/tessdata" target="_blank" rel="noopener">https://github.com/tesseract-ocr/tessdata</a></li><li>tesseract文档：<a href="https://github.com/tesseract-ocr/tesseract/wiki/Documentation" target="_blank" rel="noopener">https://github.com/tesseract-ocr/tesseract/wiki/Documentation</a></li></ul><h3 id="Mac下安装"><a href="#Mac下安装" class="headerlink" title="Mac下安装"></a>Mac下安装</h3><ol><li>使用<strong>HomeBrew</strong>安装<strong>ImageMagick</strong>和<strong>tesseract</strong>库。</li></ol><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install imagemagick<br>//先安装依赖库libpng, jpeg, libtiff, leptonica<br>brew install leptonica<br>brew install tesseract<br></code></pre></td></tr></table></figure><ol><li><p>下载语言库</p><p> 下载地址:<a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Ftesseract-ocr%2Ftessdata" target="_blank" rel="noopener">https://github.com/tesseract-ocr/tessdata</a></p><p> 根据自己的需求选择所要的语言库，在这里我们选择的是简体中文和英文，所以选择的库是<code>chi_sim.traineddata</code>、<code>eng.traineddata</code><br>  将文件拷贝到到：/usr/local/Cellar/tesseract/4.1.0/share/tessdata目录下。</p></li><li><p>接下来再安装tesserocr即可</p></li></ol><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip3 install tesserocr pillow<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：</p><p>这里可能会出现无法安装<strong>tesserocr</strong>的错误，需要执行以下两个步骤：</p><ol><li>命令行中输入：<code>xcode-select --install</code></li></ol><p>输出：</p><p><strong>xcode-select: error: command line tools are already installed, use “Software Update” to install updates</strong></p><p>不用管它。</p><ol><li>命令行中输入：<code>export MACOSX_DEPLOYMENT_TARGET=10.13</code></li></ol><p>这里 <strong>10.13</strong> 是我自己的macOS的系统版本号。换成自己电脑相对应的就行。</p><ol><li>执行以上两个步骤，再次执行<code>pip3 install tesserocr pillow</code>就能成功安装啦。</li></ol><h3 id="验证安装-3"><a href="#验证安装-3" class="headerlink" title="验证安装"></a>验证安装</h3><p>可以使用tesseract和tesserocr来分别进行测试。</p><p>从<a href="https://raw.githubusercontent.com/Python3WebSpider/TestTess/master/image.png" target="_blank" rel="noopener">链接</a>中获取样例图片，如下所示。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E8%A7%A3%E6%9E%90%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/%E9%AA%8C%E8%AF%81%E7%A0%81.png" width="50%"></p><p>首先使用命令进行测试，将图片下载来并保存为<strong>image.png</strong>，然后用<code>tesseract</code>命令测试：</p><p><code>tesseract image.png result -l eng &amp;&amp; cat result.txt</code></p><p>运行结果如下：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Tesseract Open Source OCR Engine v4.1.0 with Leptonica<br>Python3WebSpider<br></code></pre></td></tr></table></figure><p>这里我们调用了<code>tesseract</code>命令，其中</p><ul><li>第一个参数为图片名称。</li><li>第二个参数result为结果保存的目标文件名称。</li><li><code>-l</code>指定使用的语言包，此处使用英文(eng)。</li><li>然后再用cat命令将结果输出。</li></ul><p>运行结果便是图片的识别结果：<code>Python3WebSpider</code>，可以看到，这时已经成功将图片转化为文本了。</p><p>然后还可以利用Python代码来进行测试，这里就需要借助于tesserocr库了，测试代码如下：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tesserocr<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br>image = Image.open(<span class="hljs-string">'image.png'</span>)<br>print(tesserocr.image_to_text(image))<br></code></pre></td></tr></table></figure><p>我们首先使用<code>Image</code>读取了图片文件，然后调用了<strong>tesserocr</strong>的<code>image_to_text()</code>方法，再将其识别结果输出。</p><p>运行结果如下：</p><p><code>Python3WebSpider</code></p><p>另外，我们还可以直接调用<code>file_to_text()</code>方法，达到同样的效果：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tesserocr<br>print(tesserocr.file_to_text(<span class="hljs-string">'image.png'</span>))<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><code>Python3WebSpider</code></p><p>如果成功输出结果，则证明<strong>tesseract</strong>和<strong>tesserocr</strong>都已经成功安装。</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> 开发环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发环境配置 </tag>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>请求库的安装</title>
      <link href="/2019/08/03/%E8%AF%B7%E6%B1%82%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2019/08/03/%E8%AF%B7%E6%B1%82%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>爬虫可以简单分为几步：抓取页面、分析页面和存储数据。</p><p>在抓取页面的过程中，我们需要模拟浏览器向服务器发出请求，所以需要用到一些Python库来实现HTTP请求操作。</p><p>我们要用到的第三方库有requests、Selenium和aiohttp等。</p><a id="more"></a><h2 id="requests库"><a href="#requests库" class="headerlink" title="requests库"></a>requests库</h2><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>Github：<a href="https://github.com/requests/requests" target="_blank" rel="noopener">https://github.com/requests/requests</a></li><li>PyPI：<a href="https://pypi.python.org/pypi/requests" target="_blank" rel="noopener">https://pypi.python.org/pypi/requests</a></li><li>官方文档：<a href="https://www.python-requests.org" target="_blank" rel="noopener">https://www.python-requests.org</a>  (需要科学上网)</li><li>中文文档：<a href="http://docs.python-requests.org/zh_CN/latest" target="_blank" rel="noopener">http://docs.python-requests.org/zh_CN/latest</a></li></ul><h3 id="pip安装-推荐"><a href="#pip安装-推荐" class="headerlink" title="pip安装(推荐)"></a>pip安装(推荐)</h3><p>在命令行界面中运行如下命令，即可完成requests库的安装。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip3 install requests<br></code></pre></td></tr></table></figure><h3 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h3><p>如果想要获取某一特定版本，可以选择下载源码安装。</p><p>requests项目的地址是：<a href="https://github.com/psf/requests" target="_blank" rel="noopener">https://github.com/psf/requests</a></p><p>可以通过Git来下载源代码：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/psf/requests.git<br></code></pre></td></tr></table></figure><p>下载完成后，进入目录，进行安装</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> requests<br>python3 setup.py install<br></code></pre></td></tr></table></figure><h3 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h3><p>进入Python命令行交互模式，导入requests包，如果没有报错，则证明安装成功：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python3<br>&gt;&gt;&gt; import requests<br></code></pre></td></tr></table></figure><h2 id="Selenium库"><a href="#Selenium库" class="headerlink" title="Selenium库"></a>Selenium库</h2><p>Selenium是一个自动化测试工具，利用它我们可以驱动浏览器执行特定的动作，如点击、下拉等操作。</p><p>对于一些JavaScript渲染的页面来说，这种抓取方式非常有效。</p><h3 id="相关链接-1"><a href="#相关链接-1" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>Github：<a href="https://github.com/SeleniumHQ/selenium/tree/master/py" target="_blank" rel="noopener">https://github.com/SeleniumHQ/selenium/tree/master/py</a></li><li>PyPI：<a href="https://pypi.org/project/selenium/" target="_blank" rel="noopener">https://pypi.org/project/selenium/</a></li><li>官方文档：<a href="https://selenium-python.readthedocs.io/" target="_blank" rel="noopener">https://selenium-python.readthedocs.io/</a></li><li>中文文档：<a href="https://selenium-python-zh.readthedocs.io/en/latest/" target="_blank" rel="noopener">https://selenium-python-zh.readthedocs.io/en/latest/</a></li></ul><h3 id="pip安装-推荐-1"><a href="#pip安装-推荐-1" class="headerlink" title="pip安装(推荐)"></a>pip安装(推荐)</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip3 install selenium<br></code></pre></td></tr></table></figure><h3 id="验证安装-1"><a href="#验证安装-1" class="headerlink" title="验证安装"></a>验证安装</h3><p>进入Python命令行交互模式，导入selenium包，如果没有报错，则证明安装成功：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python3<br>&gt;&gt;&gt; import selenium<br></code></pre></td></tr></table></figure><p>但是这样做还不够，还需要用浏览器(如Chrome、Firefox等)来配合Selenium工作。</p><h2 id="ChromeDriver的安装"><a href="#ChromeDriver的安装" class="headerlink" title="ChromeDriver的安装"></a>ChromeDriver的安装</h2><p>上一部已经安装好Selenium，但是它是一个自动化测试工具，需要浏览器来配合使用。</p><p>该节中我们就介绍一下Chrome浏览器及ChromeDriver驱动的配置。</p><h3 id="相关链接-2"><a href="#相关链接-2" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>官方网址：<a href="https://sites.google.com/a/chromium.org/chromedriver" target="_blank" rel="noopener">https://sites.google.com/a/chromium.org/chromedriver</a> (需要科学上网)</li><li>下载地址：<a href="https://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">https://chromedriver.storage.googleapis.com/index.html</a></li></ul><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>确保安装好Chrome浏览器并可以正常运行。</p><h3 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h3><p>点击Chrome菜单 “帮助” -&gt; “关于Google Chrome(G)”，即可查看Chrome的版本号，如下图所示。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E7%89%88%E6%9C%AC.png" width="70%"></p><p>这里我的版本号是 <em>75.0</em> ，这个版本号在选择ChromeDriver版本的时候会用到。</p><h3 id="下载ChromeDriver"><a href="#下载ChromeDriver" class="headerlink" title="下载ChromeDriver"></a>下载ChromeDriver</h3><p>打开<a href="https://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">下载链接</a>，选择对应的版本进行下载。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/ChromeDriver%E7%89%88%E6%9C%AC.png" width="70%"></p><h3 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h3><p>下载完成后，将ChromeDriver的可执行文件配置到环境变量下。</p><ul><li>在Windows下，建议直接将ChromeDriver.exe文件拖到Python的Scripts目录下。</li><li>在Linux和Mac下，需要将可执行文件配置到环境变量或将文件移动到属于环境变量的目录里。</li></ul><p>Mac配置：</p><p>方法一：</p><p>例如要移动文件到<code>/usr/bin</code>目录。首先需要在命令行模式下进入其所在路径，然后将其移动到<code>/usr/bin</code>：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo mv chromedriver /usr/bin<br></code></pre></td></tr></table></figure><p>另外，若系统为Mac OS X EI Capitan 10.11 及以上版本时，需要先关闭Rootless内核保护机制。具体操作如下：</p><ol><li>重启电脑后按住<code>command+R</code>进入恢复分区。</li><li>在<code>实用工具栏</code>找到<code>终端</code>启动运行。</li><li>输入：<code>csrutil disable; reboot</code>。</li><li>执行上述移动语句：<code>sudo mv chromedriver /usr/bin</code>。</li><li>重复执行1-2，在3中输入：<code>csrutil enable; reboot</code>，开启保护。</li></ol><p>方法二：</p><p>将ChromeDriver配置到<code>$PATH</code>：</p><ol><li><p>将可执行文件放到某一目录，目录可以任意选择。例如将当前可执行文件放在<code>/usr/local/chromedriver</code>目录下。</p></li><li><p>Linux修改<code>~/.profile</code>文件，mac修改<code>~/.bash_profile</code>文件，添加如下内容：</p><p> <code>export PATH=&quot;$PATH:/usr/local/chromedriver&quot;</code></p></li><li><p>保存后，</p><ul><li>在linux执行：<code>source ~/.profile</code></li><li>在mac执行：<code>source ~/.bash_profile</code></li></ul></li></ol><h3 id="验证安装-2"><a href="#验证安装-2" class="headerlink" title="验证安装"></a>验证安装</h3><p>配置完成后，可以在命令行中直接执行<code>chromedriver</code>命令了</p><p>如果输入控制台有如下所示的输出，则证明ChromeDriver的环境变量配置好了。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/chromedriver%E6%8E%A7%E5%88%B6%E5%8F%B0.png" width="70%"></p><p>随后再在程序中测试，执行如下Python代码：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br>browser = webdriver.Chrome()<br></code></pre></td></tr></table></figure><p>运行后，如果弹出一个空白的Chrome浏览器，则证明所有的配置都没有问题。如果没有弹出，则检查之前的每一步配置。</p><p>如果弹出后闪退，则可能是ChromeDriver版本和Chrome版本不兼容，请更换ChromeDriver版本。</p><h2 id="PhantomJS的安装"><a href="#PhantomJS的安装" class="headerlink" title="PhantomJS的安装"></a>PhantomJS的安装</h2><p>PhantomJS是一个无界面的、可脚本编程的WebKit浏览器引擎，它原生支持多种Web标准：DOM操作，CSS选择器，JSON，Canvas以及SVG。</p><p>Selenium支持PhantomJS，这样在运行的时候就不会再弹出一个浏览器了。而且PhantomJS的运行效率也很高，还支持各种参数配置，使用非常方便。</p><h3 id="相关链接-3"><a href="#相关链接-3" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>官方网站：<a href="http://phantomjs.org" target="_blank" rel="noopener">http://phantomjs.org</a></li><li>官方文档：<a href="https://phantomjs.org/quick-start.html" target="_blank" rel="noopener">https://phantomjs.org/quick-start.html</a></li><li>下载地址：<a href="https://phantomjs.org/download.html" target="_blank" rel="noopener">https://phantomjs.org/download.html</a></li><li>API接口说明：<a href="https://phantomjs.org/api/command-line.html" target="_blank" rel="noopener">https://phantomjs.org/api/command-line.html</a></li></ul><h3 id="下载PhantomJS"><a href="#下载PhantomJS" class="headerlink" title="下载PhantomJS"></a>下载PhantomJS</h3><p>在<a href="https://phantomjs.org/download.html" target="_blank" rel="noopener">下载页面</a>选择对应的操作系统版本进行下载，并将PhantomJS可执行文件所在的路径配置到环境变量里（与ChromeDriver安装一致）。</p><p>配置成功后，可以在命令行下测试，输入：<code>phantomjs</code></p><p>如果可以进入到PhantomJS的命令行，则证明配置完成。</p><h3 id="验证安装-3"><a href="#验证安装-3" class="headerlink" title="验证安装"></a>验证安装</h3><p>在Selenium中使用的话，只需要将Chrome切换成PhantomJS即可：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br>driver = webdriver.PhantomJS()<br>driver.get(<span class="hljs-string">"http://www.baidu.com/"</span>)<br>print(driver.current_url)<br></code></pre></td></tr></table></figure><p>运行之后就会发现没有浏览器弹出了，但实际上PhantomJS已经运行起来了。</p><p>这里我们访问了百度，然后将当前URL打印出来了。</p><p>控制台的输出为：<code>https://www.baidu.com</code></p><p>如此一来，我们便完成了PhantomJS的配置，后面可以利用它来完成一些页面的抓取。</p><h2 id="aiohttp库"><a href="#aiohttp库" class="headerlink" title="aiohttp库"></a>aiohttp库</h2><p>上述提到的requests库是一个阻塞式HTTP请求库。(当我们发出一个请求后，程序会一直等待服务器响应，直到得到响应后，程序才会进行下一步处理)。其实，这个过程比较耗费时间。</p><p>如果程序可以在这个等待过程中做一些其他事情，如进行请求的调度、响应的处理等，那么爬取的效率会大大提高。</p><p>aiohttp就是这样一个提供异步Web服务的库，从Python3.5版本开始，Python中加入了<code>async/await</code>关键字，使得回调的写法更加直观和人性化。aiohttp的异步操作借助于<code>async/await</code>关键字的写法变得更加简洁，架构更加清晰。使用异步请求库进行数据抓取时，会大大提高效率。</p><h3 id="相关链接-4"><a href="#相关链接-4" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>官方文档：<a href="http://aiohttp.readthedocs.io/en/stable" target="_blank" rel="noopener">http://aiohttp.readthedocs.io/en/stable</a></li><li>Github：<a href="https://github.com/aio-libs/aiohttp/" target="_blank" rel="noopener">https://github.com/aio-libs/aiohttp/</a></li><li>PyPI：<a href="https://pypi.org/project/aiohttp/3.5.4/" target="_blank" rel="noopener">https://pypi.org/project/aiohttp/3.5.4/</a></li></ul><h3 id="pip安装"><a href="#pip安装" class="headerlink" title="pip安装"></a>pip安装</h3><p>安装命令：<code>pip3 install aiohttp</code></p><p>另外，官方还推荐安装如下两个库：</p><ul><li>字符编码检测库<strong>cchardet</strong></li><li>加速DNS的解析库<strong>aiodns</strong></li></ul><p>安装命令：<code>pip3 install cchardet aiodns</code></p><h3 id="测试安装"><a href="#测试安装" class="headerlink" title="测试安装"></a>测试安装</h3><p>安装完成后，可以在Python命令行下测试：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python3<br>&gt;&gt;&gt; import aiohttp<br></code></pre></td></tr></table></figure><p>如果没有错误报出，则证明库已经安装好了。</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> 开发环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发环境配置 </tag>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天一个linux命令(1): ls</title>
      <link href="/2019/08/03/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4-1-ls/"/>
      <url>/2019/08/03/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4-1-ls/</url>
      
        <content type="html"><![CDATA[<p>ls命令是linux下最常用的命令。ls命令就是list的缩写，缺省下ls用来打印出当前目录的清单，如果ls指定其他目录，那么就会显示指定目录里的文件及文件夹清单。</p><p>通过ls命令不仅可以查看linux文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限)、查看目录信息等等。ls命令在日常的linux操作中用的很多。</p><a id="more"></a><h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ls [选项] [目录名]<br></code></pre></td></tr></table></figure><h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p>列出目标目录中所有的子目录和文件。</p><h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">-a,—all</td><td style="text-align:left">列出目录下的所有文件，包括以 . 开头的隐含文件</td></tr><tr><td style="text-align:left">-A</td><td style="text-align:left">同-a，但不列出“.”(表示当前目录)和“..”(表示当前目录的父目录)。</td></tr><tr><td style="text-align:left">-c  配合 -lt</td><td style="text-align:left">根据 ctime 排序及显示 ctime (文件状态最后更改的时间)配合 -lt：显示 ctime 但根据名称排序否则：根据 ctime 排序</td></tr><tr><td style="text-align:left">-C</td><td style="text-align:left">每栏由上至下列出项目</td></tr><tr><td style="text-align:left">-color[=WHEN]</td><td style="text-align:left">控制是否使用色彩分辨文件。WHEN 可以是’never’、’always’或’auto’其中之一</td></tr><tr><td style="text-align:left">-d,—directory</td><td style="text-align:left">将目录象文件一样显示，而不是显示其下的文件。</td></tr><tr><td style="text-align:left">-D,—dired</td><td style="text-align:left">产生适合 Emacs 的 dired 模式使用的结果</td></tr><tr><td style="text-align:left">-f</td><td style="text-align:left">对输出的文件不进行排序，-aU 选项生效，-lst 选项失效</td></tr><tr><td style="text-align:left">-g</td><td style="text-align:left">类似 -l,但不列出所有者</td></tr><tr><td style="text-align:left">-G, —no-group</td><td style="text-align:left">不列出任何有关组的信息</td></tr><tr><td style="text-align:left">-h,—human-readable</td><td style="text-align:left">以容易理解的格式列出文件大小 (例如 1K 234M 2G)</td></tr><tr><td style="text-align:left">—si</td><td style="text-align:left">类似 -h,但文件大小取 1000 的次方而不是 1024</td></tr><tr><td style="text-align:left">-H, —dereference-command-line</td><td style="text-align:left">使用命令列中的符号链接指示的真正目的地</td></tr><tr><td style="text-align:left">—indicator-style=&lt;方式&gt;</td><td style="text-align:left">指定在每个项目名称后加上指示符号&lt;方式&gt;：none (默认)，classify (-F)，file-type (-p)</td></tr><tr><td style="text-align:left">-i, —inode</td><td style="text-align:left">印出每个文件的 inode 号</td></tr><tr><td style="text-align:left">-I,—ignore=样式</td><td style="text-align:left">不印出任何符合 shell 万用字符&lt;样式&gt;的项目</td></tr><tr><td style="text-align:left">-k</td><td style="text-align:left">即 –block-size=1K,以 k 字节的形式表示文件的大小</td></tr><tr><td style="text-align:left">-l</td><td style="text-align:left">除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来。</td></tr><tr><td style="text-align:left">-L, —dereference</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">-m</td><td style="text-align:left">所有项目以逗号分隔，并填满整行行宽</td></tr><tr><td style="text-align:left">-o</td><td style="text-align:left">类似 -l,显示文件的除组信息外的详细信息。</td></tr><tr><td style="text-align:left">-r, —reverse</td><td style="text-align:left">依相反次序排列</td></tr><tr><td style="text-align:left">-R, —recursive</td><td style="text-align:left">同时列出所有子目录层</td></tr><tr><td style="text-align:left">-s,—size</td><td style="text-align:left">以块大小为单位列出所有文件的大小</td></tr><tr><td style="text-align:left">-S</td><td style="text-align:left">根据文件大小排序</td></tr><tr><td style="text-align:left">—sort=WORD</td><td style="text-align:left">可选用的 WORD 和它们代表的相应选项： <br>extension -X status -c<br>none -U time -t<br>size -S atime -u<br>time -t access -u<br>version -v use -u</td></tr><tr><td style="text-align:left">-t</td><td style="text-align:left">以文件修改时间排序</td></tr><tr><td style="text-align:left">-u</td><td style="text-align:left">配合 -lt:显示访问时间而且依访问时间排序<br>配合 -l:显示访问时间但根据名称排序<br>否则：根据访问时间排序</td></tr><tr><td style="text-align:left">-U</td><td style="text-align:left">不进行排序;依文件系统原有的次序列出项目</td></tr><tr><td style="text-align:left">-v</td><td style="text-align:left">根据版本进行排序</td></tr><tr><td style="text-align:left">-w, —width=COLS</td><td style="text-align:left">自行指定屏幕宽度而不使用目前的数值</td></tr><tr><td style="text-align:left">-x</td><td style="text-align:left">逐行列出项目而不是逐栏列出</td></tr><tr><td style="text-align:left">-X</td><td style="text-align:left">根据扩展名排序</td></tr><tr><td style="text-align:left">-1</td><td style="text-align:left">每行只列出一个文件</td></tr><tr><td style="text-align:left">—help</td><td style="text-align:left">显示此帮助信息并离开</td></tr><tr><td style="text-align:left">—version</td><td style="text-align:left">显示版本信息并离开</td></tr></tbody></table></div><h2 id="常用范例"><a href="#常用范例" class="headerlink" title="常用范例"></a>常用范例</h2><p><code>例一</code>：<strong>列出/home/huben/ 文件夹下的所有文件和目录的详细信息</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ls -l -R /home/huben<br>$ ls -lR /home/huben<br></code></pre></td></tr></table></figure><p><code>例二</code>：<strong>列出当前目录中所有以“t”开头的目录的详细内容，可以使用如下命令</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ls -l t*<br></code></pre></td></tr></table></figure><p><code>例三</code>：<strong>只列出文件下的子目录</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ls -F /opt/soft |grep /$<br></code></pre></td></tr></table></figure><p><code>例四</code>：<strong>列出文件下的子目录详细情况</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ls -l /opt/soft | grep <span class="hljs-string">"^d"</span><br></code></pre></td></tr></table></figure><p><code>例五</code>：<strong>列出目前工作目录下所有名称是s 开头的文件，愈新的排愈后面，可以使用如下命令</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ls -ltr s*<br></code></pre></td></tr></table></figure><p><code>例六</code>：<strong>列出目前工作目录下所有档案及目录;目录于名称后加”/“, 可执行档于名称后加*</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ls -AF<br></code></pre></td></tr></table></figure><p><code>例七</code>：<strong>计算当前目录下的文件数和目录数</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ls -l * |grep <span class="hljs-string">"^-"</span>|wc -l    ---文件个数<br>$ ls -l * |grep <span class="hljs-string">"^d"</span>|wc -l    ---目录个数<br></code></pre></td></tr></table></figure><p><code>例八</code>：<strong>在ls中列出文件的绝对路径</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ls | sed <span class="hljs-string">"s:^:`pwd`/:"</span><br></code></pre></td></tr></table></figure><p><code>例九</code>：<strong>列出当前目录下的所有文件（包括隐藏文件）的绝对路径， 对目录不做递归</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ find <span class="hljs-variable">$PWD</span> -maxdepth 1 | xargs ls -ld<br></code></pre></td></tr></table></figure><p><code>例十</code>：<strong>列出当前目录下的所有文件（包括隐藏文件）的绝对路径， 对目录不做递归</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ find <span class="hljs-variable">$PWD</span> -maxdepth 1 | xargs ls -ld<br></code></pre></td></tr></table></figure><p><code>例十一</code>：<strong>递归列出当前目录下的所有文件（包括隐藏文件）的绝对路径</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ find <span class="hljs-variable">$PWD</span> | xargs ls -ld<br></code></pre></td></tr></table></figure><p><code>例十二</code>：<strong>指定文件时间输出格式</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ls -tl --time-style=full-iso<br>$ ls -ctl --time-style=long-iso<br><br>2016-08-05 22:17:06.020535551 +0800<br>2016-10-29 12:03<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> linux基础命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python多线程</title>
      <link href="/2019/08/03/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2019/08/03/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>本文主要介绍了以下内容:</strong></p><p>Python多线程相关基础</p><a id="more"></a><h2 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h2><p>Python中多线程用在IO密集型代码中。</p><ul><li>计算密集型：需要大量计算，绝大部分时间都消耗在CPU计算上，此时，无论开多少线程，所需要的时间就是那么多，甚至比原来时间还长，因为全局解释器锁(GIL)一个时刻只让跑一个线程，大部分计算密集型任务分了很多线程但是依然会按照代码顺序线性执行，甚至代码变得冗长了，反而使执行时间增加了。</li><li>IO密集型：90%以上的时间都花费在网络、硬盘、输入输出上，CPU执行完命令之后剩下的就不需要在CPU中跑了，就可以释放内存在跑下一条命令了。</li></ul><p>每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。</p><p>但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p><p>每个线程都有自己的一组CPU寄存器，称为线程的上下文，该上下文反映了线程上次运行该线程的CPU寄存器的状态。</p><p>指令指针和堆栈指针寄存器是线程上下文中两个最重要的寄存器，线程总是在进程得到上下文中运行的，这些地址都用于标志拥有线程的进程的进程地址空间中的内存。</p><ul><li>线程可以被抢断(中断)</li><li>在其他线程正在运行时，线程可以暂时搁置(也称为睡眠）— — 即线程的退让。</li></ul><p>线程可分为：</p><ul><li>内核线程：由操作系统内核创建和撤销。</li><li>用户线程：不需要内核支持而在用户程序中实现的线程。</li></ul><h2 id="Threading模块"><a href="#Threading模块" class="headerlink" title="Threading模块"></a>Threading模块</h2><h4 id="Threading模块对象"><a href="#Threading模块对象" class="headerlink" title="Threading模块对象"></a>Threading模块对象</h4><div class="table-container"><table><thead><tr><th style="text-align:center">对象</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">Thread</td><td style="text-align:center">线程对象</td></tr><tr><td style="text-align:center">Lock</td><td style="text-align:center">互斥锁</td></tr><tr><td style="text-align:center">Condition</td><td style="text-align:center">条件变量</td></tr><tr><td style="text-align:center">Event</td><td style="text-align:center">事件，该事件发生后所有等待该事件的线程将被激活</td></tr><tr><td style="text-align:center">Semaphore</td><td style="text-align:center">信号量</td></tr><tr><td style="text-align:center">Timer</td><td style="text-align:center">定时器，运行前会等待一段时间</td></tr><tr><td style="text-align:center">Barrier</td><td style="text-align:center">创建一个障碍，必须达到指定数量的线程才开始运行</td></tr></tbody></table></div><h4 id="Threading模块的Thread类"><a href="#Threading模块的Thread类" class="headerlink" title="Threading模块的Thread类"></a>Threading模块的Thread类</h4><div class="table-container"><table><thead><tr><th style="text-align:center">对象</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">name</td><td style="text-align:center">线程名(属性)</td></tr><tr><td style="text-align:center">ident</td><td style="text-align:center">线程标识符(属性)</td></tr><tr><td style="text-align:center">daemon</td><td style="text-align:center">线程是否是守护线程(属性)</td></tr><tr><td style="text-align:center">__init__(group=None,tatget=None,name=None,args=(),kwargs={},verbose=None,daemon=None)</td><td style="text-align:center">实例化一个线程对象，需要有一个可调用的target，以及其参数args或kwargs。还可以传递name或group参数，不过后者还未实现。此外，verbose标志也是可接受的。而daemon的值将会设定thread.daemon属性/标志</td></tr><tr><td style="text-align:center">start()</td><td style="text-align:center">开启线程活动</td></tr><tr><td style="text-align:center">run()</td><td style="text-align:center">定义线程活动的方法(通常在子类中被应用开发者重写)</td></tr><tr><td style="text-align:center">join([time])</td><td style="text-align:center">等待至线程中止。阻塞调用线程直至线程的join()方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生</td></tr><tr><td style="text-align:center">Barrier</td><td style="text-align:center">创建一个障碍，必须达到指定数量线程才开始运行</td></tr><tr><td style="text-align:center">isAlive()</td><td style="text-align:center">返回线程是否活动的</td></tr><tr><td style="text-align:center">getName()</td><td style="text-align:center">返回线程名</td></tr><tr><td style="text-align:center">setName()</td><td style="text-align:center">设置线程名</td></tr></tbody></table></div><h5 id="Threading模块常用方法"><a href="#Threading模块常用方法" class="headerlink" title="Threading模块常用方法"></a>Threading模块常用方法</h5><ol><li>threading.Lock()</li></ol><p>如果多个线程共同对某个数据修改，则可能出现不可预料的结果，为了保证数据的正确性，需要对多个线程进行同步。</p><p>使用Thread对象的<code>Lock</code>和<code>RLock</code>可以实现简单的线程同步，这两个对象都有<code>acquire</code>方法和<code>release</code>方法，对于那些需要每次只允许一个线程操作的数据，可以将其放到<code>acquire</code>和<code>release</code>方法之间。</p><p>多个线程同时操作一个变量可能会把内容给改乱了</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><br><span class="hljs-keyword">import</span> time, threading<br><br><span class="hljs-comment"># 假定这是你的银行存款:</span><br>balance = <span class="hljs-number">0</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">change_it</span><span class="hljs-params">(n)</span>:</span><br>    <span class="hljs-comment"># 先存后取，结果应该为0:</span><br>    <span class="hljs-keyword">global</span> balance<br>    balance = balance + n<br>    balance = balance - n<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_thread</span><span class="hljs-params">(n)</span>:</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1000000</span>):<br>        change_it(n)<br><br><br>t1 = threading.Thread(target=run_thread, args=(<span class="hljs-number">5</span>,))<br>t2 = threading.Thread(target=run_thread, args=(<span class="hljs-number">8</span>,))<br>t1.start()<br>t2.start()<br>t1.join()<br>t2.join()<br>print(balance)<br></code></pre></td></tr></table></figure><p>上述代码中首先定义了一个共享变量<strong>balance</strong>，初始值为0，并且启动两个线程，先存后取，理论上结果应该为0。但是，由于线程的调度是由操作系统决定的，当<strong>t1</strong>,<strong>t2</strong>交替执行时，只要循环次数足够多，<strong>balance</strong>的结果就不一定是0了。</p><p>如果要确保balance计算争取，就要给<code>change_it()</code>上一把锁，当某个线程开始执行<code>change_it()</code>时，由于该进程获得了锁，因此其他线程不能同时执行<code>change_it()</code>，只能等待，直到锁被释放后，获得该锁以后才能改。</p><p>由于锁只有一个，无论多少线程，同一时刻最多只有一个线程持有该锁，所以，不会造成修改的冲突。</p><p>创建一个锁就是<code>threading.Lock()</code>来实现</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><br><span class="hljs-keyword">import</span> time, threading<br><br>balance = <span class="hljs-number">0</span><br>lock = threading.Lock()<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">change_it</span><span class="hljs-params">(n)</span>:</span><br>    <span class="hljs-comment"># 先存后取，结果应该为0:</span><br>    <span class="hljs-keyword">global</span> balance<br>    balance = balance + n<br>    balance = balance - n<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_thread</span><span class="hljs-params">(n)</span>:</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1000000</span>):<br>        <span class="hljs-comment"># 先要获取锁:</span><br>        lock.acquire()<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 放心地改吧:</span><br>            change_it(n)<br>        <span class="hljs-keyword">finally</span>:<br>            <span class="hljs-comment"># 改完了一定要释放锁:</span><br>            lock.release()<br><br><br>t1 = threading.Thread(target=run_thread, args=(<span class="hljs-number">5</span>,))<br>t2 = threading.Thread(target=run_thread, args=(<span class="hljs-number">8</span>,))<br>t1.start()<br>t2.start()<br>t1.join()<br>t2.join()<br>print(balance)<br></code></pre></td></tr></table></figure><p>当多个线程同时执行<code>lock.acquire()</code>时，只有一个线程能成功地获取锁，然后继续执行代码，其他线程就继续等待直到获得锁为止。</p><p>获得锁的线程用完后一定要释放锁，否则那些苦苦等待锁的线程将永远等待下去，成为死线程。此处可以用try…finally来确保锁一定会被释放。</p><p>锁的好处就是确保了某段关键代码只能由一个线程从头到尾完整地执行，坏处当然也有很多：</p><ul><li>首先是阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了。</li><li>其次，由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁，导致多个线程全部挂起，既不能执行，也无法结束，只能靠操作系统强制终止。</li></ul><ol><li>threading.RLock()</li></ol><p>RLock允许在同一线程中被多次<code>acquire</code>。而Lock却不允许这种情况。注意：如果使用RLock，那么<code>acquire</code>和<code>release</code>必须成对出现，即调用了n次<code>acquire</code>，必须调用n次的<code>release</code>才能真正释放所占用的锁。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br>lock = threading.Lock() <br><span class="hljs-comment">#Lock对象</span><br>lock.acquire()<br>lock.acquire() <br><span class="hljs-comment">#产生了死琐。</span><br>lock.release()<br>lock.release()<br>  <br><span class="hljs-keyword">import</span> threading<br>rLock = threading.RLock() <br><span class="hljs-comment">#RLock对象</span><br>rLock.acquire()<br>rLock.acquire() <br><span class="hljs-comment">#在同一线程内，程序不会堵塞。</span><br>rLock.release()<br>rLock.release()<br></code></pre></td></tr></table></figure><ol><li>threading.Condition()</li></ol><p>可以把Condition理解为一把高级的锁，它提供了比Lock，RLock更高级的功能，允许我们能够控制复杂的线程同步问题。threading.Condition在内部维护一个锁对象(默认是RLock)，可以在创建Condition对象的时候把锁对象作为参数传入。Condition也提供了<code>acquire</code>，<code>release</code>方法，其含义与锁的<code>acquire</code>，<code>release</code>方法一致，其实它只是简单的调用内部锁对象的对应的方法而已。Condition还提供<code>wait</code>方法、<code>notify</code>方法、<code>notifyAll</code>方法(特别要注意：这些方法只有在占用锁(<code>acquire</code>)之后才能调用，否则将会报<code>RuntimeError</code>异常。)</p><blockquote><p><code>acquire()</code>/<code>release()</code>：获得/释放 Lock</p><p><code>wait([timeout])</code>：线程挂起，直到收到一个<code>notify</code>通知或者超时(可选的，浮点数，单位是秒s)才会被唤醒继续执行。<strong><code>wait()</code>必须在已获得Lock前提下才能调用，否则会触发RuntimeError。调用<code>wait()</code>释放Lock，直至该线程被<code>Notify()</code>、<code>NotifyAll()</code>或者超时线程又重新获得Lock</strong>。</p><p><code>notify(n=1)</code>通知其他线程，那些挂起的线程接到这个通知之后会开始运行，默认是通知一个正等待该condition的线程，最多唤醒n个等待的线程。</p><p><strong><code>notify()</code>必须在已获得Lock前提下才能调用，否则会触发RuntimeError。<code>notify()</code>不会主动释放Lock</strong></p><p><code>notifyAll()</code>如果wait状态线程比较多，notifyAll的作用就是通知所有线程(这个一般用的比较少)</p></blockquote><p>捉迷藏游戏：</p><p>假设该游戏有两个人玩，一个藏(Hider)，一个找(Seeker)。</p><p>游戏规则如下：</p><ul><li>游戏开始后，Seeker先把自己眼睛蒙上，蒙上眼睛后，就通知Hider；</li><li>Hider接收到通知后开始找地方将自己藏起来，藏好之后，再通知Seeker可以找了；</li><li>Seeker就收到通知后，就开始找Hider</li></ul><p>Hider和Seeker都是独立的个体，在程序中用两个独立的线程表示，在游戏过程中，两者之间的行为有一定的时序关系，我们可以通过Condition来控制这种关系。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Seeker</span><span class="hljs-params">(cond, name)</span>:</span><br>    time.sleep(<span class="hljs-number">2</span>)<br>    cond.acquire()<br>    print(<span class="hljs-string">'%s :我已经把眼睛蒙上了！'</span> % name)<br>    cond.notify()<br>    cond.wait()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):<br>        print(<span class="hljs-string">'%s is finding!!!'</span> % name)<br>        time.sleep(<span class="hljs-number">2</span>)<br>    cond.notify()<br>    cond.release()<br>    print(<span class="hljs-string">'%s :我赢了！'</span> % name)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Hider</span><span class="hljs-params">(cond, name)</span>:</span><br>    cond.acquire()<br>    cond.wait()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>):<br>        print(<span class="hljs-string">'%s is hiding!!!'</span> % name)<br>        time.sleep(<span class="hljs-number">3</span>)<br>    print(<span class="hljs-string">'%s :我已经藏好了，你快来找我吧！'</span> % name)<br>    cond.notify()<br>    cond.wait()<br>    cond.release()<br>    print(<span class="hljs-string">'%s :被你找到了，唉~^~!'</span> % name)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    cond = threading.Condition()<br>    seeker = threading.Thread(target=Seeker, args=(cond, <span class="hljs-string">'seeker'</span>))<br>    hider = threading.Thread(target=Hider, args=(cond, <span class="hljs-string">'hider'</span>))<br>    seeker.start()<br>    hider.start()<br></code></pre></td></tr></table></figure><ol><li>threading.Semaphore和BoundedSemaphore</li></ol><p>Semaphore：Semaphore在内部管理者一个计数器。调用<code>acquire()</code>会使这个计数器-1，<code>release()</code>则是+1(可以多次<code>release()</code>，所以计数器的值理论上可以无限)，计数器的值永远不会小于0，当计数器到0时，再调用<code>acquire()</code>就会阻塞，直到其他线程来调用<code>release()</code></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(n)</span>:</span><br>    <span class="hljs-comment"># 获得信号量，信号量减一</span><br>    semaphore.acquire()<br>    time.sleep(<span class="hljs-number">1</span>)<br>    print(<span class="hljs-string">"run the thread: %s"</span> % n)<br><br>    <span class="hljs-comment"># 释放信号量，信号量加一</span><br>    semaphore.release()<br>    <span class="hljs-comment"># semaphore.release()    # 可以多次释放信号量，每次释放计数器+1</span><br>    <span class="hljs-comment"># semaphore.release()    # 可以多次释放信号量，每次释放计数器+1</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br><br>    num = <span class="hljs-number">0</span><br>    semaphore = threading.Semaphore(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 最多允许2个线程同时运行(即计数器值)；在多次释放信号量后，计数器值增加后每次可以运行的线程数也会增加</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">20</span>):<br>        t = threading.Thread(target=run, args=(i,))<br>        t.start()<br><br><span class="hljs-keyword">while</span> threading.active_count() != <span class="hljs-number">1</span>:<br>    <span class="hljs-keyword">pass</span>  <span class="hljs-comment"># print threading.active_count()</span><br><span class="hljs-keyword">else</span>:<br>    print(<span class="hljs-string">'----all threads done---'</span>)<br>    print(num)<br></code></pre></td></tr></table></figure><p>BoundedSemaphore：类似于Semaphore，不同在于BoundedSemaphore会检查内部计数器的值，并保证它不会大于初始值，如果超了，就引发一个ValueError。</p><p>多数情况下，semaphore用于守护限制(但不限于1)的资源，如果semaphore被<code>release()</code>过多次，这意味着存在bug</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(n)</span>:</span><br>    semaphore.acquire()<br>    time.sleep(<span class="hljs-number">1</span>)<br>    print(<span class="hljs-string">"run the thread: %s"</span> % n)<br>    semaphore.release()<br>    <span class="hljs-comment"># 如果再次释放信号量，信号量加一，这是超过限定的信号量数目，这时会报错ValueError: Semaphore released too many times</span><br>    <span class="hljs-comment"># semaphore.release()</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br><br>    num = <span class="hljs-number">0</span><br>    semaphore = threading.BoundedSemaphore(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 最多允许2个线程同时运行</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">20</span>):<br>        t = threading.Thread(target=run, args=(i,))<br>        t.start()<br><br><span class="hljs-keyword">while</span> threading.active_count() != <span class="hljs-number">1</span>:<br>    <span class="hljs-keyword">pass</span>  <span class="hljs-comment"># print threading.active_count()</span><br><span class="hljs-keyword">else</span>:<br>    print(<span class="hljs-string">'----all threads done---'</span>)<br>    print(num)<br></code></pre></td></tr></table></figure><ol><li>threading.Event</li></ol><p>时间处理的机制：全局定义了一个”Flag”，如果“Flag“值为False，那么当程序执行<code>event.wait</code>方法时就会阻塞；如果”Flag”值为True，那么执行<code>event.wait</code>方法时便不再阻塞。</p><ul><li>clear：将”Flag”设置为False</li><li>set：将”Flag”设置为True</li></ul><p>用threading.Event实现线程间通信，使用threading.Event可以使一个线程等待其他线程的通知，我们把这个Event传递到线程对象中。</p><p>Event默认内置了一个标志，初始值为False。一旦该线程通过<code>wait()</code>方法进入等待状态，知道另一个线程调用该Event的<code>set()</code>方法将内置标志设置为True时，该Event会通知所有等待状态的线程恢复运行。</p><p>通过Event来实现两个或多个线程间的交互，下面是一个红绿灯的例子，即启动一个线程做交通指挥灯，生成几个线程做车辆，车辆行驶按红灯停，绿灯行的规则。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time<br><span class="hljs-keyword">import</span> random<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">light</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> event.isSet():  <span class="hljs-comment"># 初始化evet的flag为真</span><br>        event.set()  <span class="hljs-comment"># wait就不阻塞 #绿灯状态</span><br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">if</span> count &lt; <span class="hljs-number">10</span>:<br>            print(<span class="hljs-string">'\033[42;1m---green light on---\033[0m'</span>)<br>        <span class="hljs-keyword">elif</span> count &lt; <span class="hljs-number">13</span>:<br>            print(<span class="hljs-string">'\033[43;1m---yellow light on---\033[0m'</span>)<br>        <span class="hljs-keyword">elif</span> count &lt; <span class="hljs-number">20</span>:<br>            <span class="hljs-keyword">if</span> event.isSet():<br>                event.clear()<br>            print(<span class="hljs-string">'\033[41;1m---red light on---\033[0m'</span>)<br>        <span class="hljs-keyword">else</span>:<br>            count = <span class="hljs-number">0</span><br>            event.set()  <span class="hljs-comment"># 打开绿灯</span><br>        time.sleep(<span class="hljs-number">1</span>)<br>        count += <span class="hljs-number">1</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">car</span><span class="hljs-params">(n)</span>:</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>        time.sleep(random.randrange(<span class="hljs-number">3</span>, <span class="hljs-number">10</span>))<br>        <span class="hljs-comment"># print(event.isSet())</span><br>        <span class="hljs-keyword">if</span> event.isSet():<br>            print(<span class="hljs-string">"car [%s] is running..."</span> % n)<br>        <span class="hljs-keyword">else</span>:<br>            print(<span class="hljs-string">'car [%s] is waiting for the red light...'</span> % n)<br>            event.wait()  <span class="hljs-comment"># 红灯状态下调用wait方法阻塞，汽车等待状态</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    car_list = [<span class="hljs-string">'BMW'</span>, <span class="hljs-string">'AUDI'</span>, <span class="hljs-string">'SANTANA'</span>]<br>    event = threading.Event()<br>    Light = threading.Thread(target=light)<br>    Light.start()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> car_list:<br>        t = threading.Thread(target=car, args=(i,))<br>        t.start()<br></code></pre></td></tr></table></figure><ol><li>threading.active_count()</li></ol><p>返回当前存活的线程对象数量；通过计算len(threading.enumerate())长度而来</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">()</span>:</span><br>    thread = threading.current_thread()<br>    print(<span class="hljs-string">'%s is running...'</span>% thread.getName())    <span class="hljs-comment">#返回线程名称</span><br>    time.sleep(<span class="hljs-number">10</span>)    <span class="hljs-comment">#休眠10S方便统计存活线程数量</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    <span class="hljs-comment">#print('The current number of threads is: %s' % threading.active_count())</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):<br>        print(<span class="hljs-string">'The current number of threads is: %s'</span> % threading.active_count())    <span class="hljs-comment">#返回当前存活线程数量</span><br>        thread_alive = threading.Thread(target=run, name=<span class="hljs-string">'Thread-***%s***'</span> % i)<br>        thread_alive.start()<br>    thread_alive.join()<br>    print(<span class="hljs-string">'\n%s thread is done...'</span>% threading.current_thread().getName())<br></code></pre></td></tr></table></figure><ol><li>threading.current_thread()</li></ol><p>返回当前线程对象</p><p>继承线程threading方法；通过help(threading.current_thread())查看</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(n)</span>:</span><br>    thread = threading.current_thread()<br>    thread.setName(<span class="hljs-string">'Thread-***%s***'</span> % n)  <span class="hljs-comment"># 自定义线程名称</span><br>    print(<span class="hljs-string">'-'</span> * <span class="hljs-number">30</span>)<br>    print(<span class="hljs-string">"Pid is :%s"</span> % thread.ident)  <span class="hljs-comment"># 返回线程pid</span><br>    <span class="hljs-comment"># print('ThreadName is :%s' % thread.name)  # 返回线程名称</span><br>    print(<span class="hljs-string">'ThreadName is :%s'</span> % thread.getName())  <span class="hljs-comment"># 返回线程名称</span><br>    time.sleep(<span class="hljs-number">2</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    <span class="hljs-comment"># print('The current number of threads is: %s' % threading.active_count())</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):<br>        <span class="hljs-comment"># print('The current number of threads is: %s' % threading.active_count())    #返回当前存活线程数量</span><br>        thread_alive = threading.Thread(target=run, args=(i,))<br>        thread_alive.start()<br>    thread_alive.join()<br>    print(<span class="hljs-string">'\n%s thread is done...'</span> % threading.current_thread().getName())<br></code></pre></td></tr></table></figure><ol><li>threading.enumerate()</li></ol><p>返回当前存在的所有线程对象的列表</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(n)</span>:</span><br>    thread = threading.current_thread()<br>    thread.setName(<span class="hljs-string">'Thread-***%s***'</span> % n)<br>    print(<span class="hljs-string">'-'</span> * <span class="hljs-number">30</span>)<br>    print(<span class="hljs-string">"Pid is :%s"</span> % thread.ident)  <span class="hljs-comment"># 返回线程pid</span><br>    <span class="hljs-comment"># print('ThreadName is :%s' % thread.name)  # 返回线程名称</span><br>    print(<span class="hljs-string">'ThreadName is :%s'</span> % threading.enumerate())  <span class="hljs-comment"># 返回所有线程对象列表</span><br>    time.sleep(<span class="hljs-number">2</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    <span class="hljs-comment"># print('The current number of threads is: %s' % threading.active_count())</span><br>    threading.main_thread().setName(<span class="hljs-string">'Chengd---python'</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):<br>        <span class="hljs-comment"># print('The current number of threads is: %s' % threading.active_count())    #返回当前存活线程数量</span><br>        thread_alive = threading.Thread(target=run, args=(i,))<br>        thread_alive.start()<br>    thread_alive.join()<br>    print(<span class="hljs-string">'\n%s thread is done...'</span> % threading.current_thread().getName())<br></code></pre></td></tr></table></figure><ol><li>threading.get_ident()</li></ol><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(n)</span>:</span><br>    print(<span class="hljs-string">'-'</span> * <span class="hljs-number">30</span>)<br>    print(<span class="hljs-string">"Pid is :%s"</span> % threading.get_ident())  <span class="hljs-comment"># 返回线程pid</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    threading.main_thread().setName(<span class="hljs-string">'Chengd---python'</span>)  <span class="hljs-comment"># 自定义线程名</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):<br>        thread_alive = threading.Thread(target=run, args=(i,))<br>        thread_alive.start()<br>    thread_alive.join()<br>    print(<span class="hljs-string">'\n%s thread is done...'</span> % threading.current_thread().getName())  <span class="hljs-comment"># 获取线程名</span><br></code></pre></td></tr></table></figure><ol><li>threading.main_thread()</li></ol><p>返回主线程对象，类似threading.current_thread()；只不过一个是返回当前线程对象，一个是返回主线程对象。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(n)</span>:</span><br>    print(<span class="hljs-string">'-'</span> * <span class="hljs-number">30</span>)<br>    print(<span class="hljs-string">"Now Pid is :%s"</span> % threading.current_thread().ident)  <span class="hljs-comment"># 返回当前线程pid</span><br>    print(<span class="hljs-string">"Main Pid is :%s"</span> % threading.main_thread().ident)  <span class="hljs-comment"># 返回主线程pid</span><br>    print(<span class="hljs-string">'Now thread is %s...'</span> % threading.current_thread().getName())  <span class="hljs-comment"># 获取当前线程名</span><br>    print(<span class="hljs-string">'Main thread is %s...'</span> % threading.main_thread().getName())  <span class="hljs-comment"># 获取主线程线程名</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    threading.main_thread().setName(<span class="hljs-string">'Chengd---python'</span>)  <span class="hljs-comment"># 自定义线程名</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):<br>        thread_alive = threading.Thread(target=run, args=(i,))<br>        thread_alive.start()<br>        time.sleep(<span class="hljs-number">2</span>)<br>    thread_alive.join()<br></code></pre></td></tr></table></figure><h4 id="Threading模块的Thread类方法"><a href="#Threading模块的Thread类方法" class="headerlink" title="Threading模块的Thread类方法"></a>Threading模块的Thread类方法</h4><div class="table-container"><table><thead><tr><th style="text-align:center">类方法</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">threading.currentThread()</td><td>返回当前的线程变量</td></tr><tr><td style="text-align:center">threading.enumerate()</td><td>返回一个包含正在运行的线程的list，正在运行指线程启动后、结束前，不包括启动前和终止后的线程</td></tr><tr><td style="text-align:center">threading.activeCount()</td><td>返回正在运行的线程数量，与len(threading.enumerate())有相同的结果</td></tr></tbody></table></div><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-comment"># 继承类threading.Thread</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(threading.Thread)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, n)</span>:</span><br>        <span class="hljs-comment"># 这里要继承构造函数</span><br>        super(MyThread, self).__init__()<br>        <span class="hljs-comment"># 可以定义自己的实例变量</span><br>        self.n = n<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span><br>        print(<span class="hljs-string">'running task'</span>, self.n)<br>        time.sleep(<span class="hljs-number">2</span>)<br><br><br>t1 = MyThread(<span class="hljs-string">'t1'</span>)<br>t2 = MyThread(<span class="hljs-string">'t2'</span>)<br><br>t1.start()<br>t2.start()<br></code></pre></td></tr></table></figure><p>这样就实现了通过继承父类的方式使用多线程，这里注意的几个点：</p><ul><li>继承类之后还要继承构造函数</li><li>这里的<code>run</code>函数时重写的，所以说<code>t1.start()</code>之后才会自动调用<code>run</code>函数</li><li>线程是通过start()函数激活，而不是对象建立时激活的！</li></ul><p>循环创建多个进程</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-comment"># 继承类threading.Thread</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(threading.Thread)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, n)</span>:</span><br>        <span class="hljs-comment"># 这里要继承构造函数</span><br>        super(MyThread, self).__init__()<br>        <span class="hljs-comment"># 可以定义自己的实例变量</span><br>        self.n = n<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span><br>        print(<span class="hljs-string">'running task'</span>, self.n)<br>        time.sleep(<span class="hljs-number">2</span>)<br><br><br><span class="hljs-comment"># t1 = MyThread('t1')</span><br><span class="hljs-comment"># t2 = MyThread('t2')</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">50</span>):<br>    t = MyThread(i)<br>    t.start()<br><br><span class="hljs-comment"># t1.start()</span><br><span class="hljs-comment"># t2.start()</span><br></code></pre></td></tr></table></figure><h4 id="计算这些线程执行所花费的时间join"><a href="#计算这些线程执行所花费的时间join" class="headerlink" title="计算这些线程执行所花费的时间join()"></a>计算这些线程执行所花费的时间<code>join()</code></h4><p>能够使主线程等待子线程的执行完毕才会继续主线程</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-comment"># 继承类threading.Thread</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(threading.Thread)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, n)</span>:</span><br>        <span class="hljs-comment"># 这里要继承构造函数</span><br>        super(MyThread, self).__init__()<br>        <span class="hljs-comment"># 可以定义自己的实例变量</span><br>        self.n = n<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span><br>        print(<span class="hljs-string">'running task'</span>, self.n)<br>        time.sleep(<span class="hljs-number">2</span>)<br><br><br><span class="hljs-comment"># 得到开始时间</span><br>start_time = time.time()<br><span class="hljs-comment"># 声明空列表</span><br>threads = []<br><br><span class="hljs-comment"># 循环开启50线程</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">50</span>):<br>    t = MyThread(i)<br>    t.start()<br>    <span class="hljs-comment"># 线程实例放入列表中</span><br>    threads.append(t)<br><br><span class="hljs-comment"># 对线程实例所在列表再循环</span><br><span class="hljs-keyword">for</span> res <span class="hljs-keyword">in</span> threads:<br>    <span class="hljs-comment"># 对每一个实例使用jion()方法</span><br>    res.join()<br><span class="hljs-comment"># 获得结束时间</span><br>end_time = time.time()<br><span class="hljs-comment"># 计算花费时间</span><br>spend_time = end_time - start_time<br><span class="hljs-comment"># 打印花费时间</span><br>print(spend_time)<br></code></pre></td></tr></table></figure><p>这里需要注意的点就是<code>join()</code>方法不能在线程启动之后就使用，这样的话50个线程就会变成串行，必须要等50个线程全部启动之后才能使用<code>join()</code>方法，这里就用到了一个小技巧新建了一个空列表，再将50个线程实例放进去，这样后面就可以实现对这50个线程使用<code>join()</code>方法了。</p><h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><p>多线程的优势在于可以同时运行多个任务(至少感觉起来是这样)。但是当线程需要共享数据时，可能存在数据不同步的问题。</p><p>使用Threading对象的Lock和Rlock可以实现简单的线程同步，这两个对象都有<code>acquire</code>方法和<code>release</code>方法，对于那些需要每次只允许一个线程操作的数据，可以将其操作放到acquire和release方法之间。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time<br><br><span class="hljs-comment"># 创建锁</span><br>threadLock = threading.Lock()<br><span class="hljs-comment"># 创建线程列表</span><br>threads = []<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myThread</span><span class="hljs-params">(threading.Thread)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, threadID, name, counter)</span>:</span><br>        threading.Thread.__init__(self)<br>        self.threadID = threadID<br>        self.name = name<br>        self.counter = counter<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span><br>        print(<span class="hljs-string">"Thread Start: "</span> + self.name)<br>        <span class="hljs-comment"># 获取锁，同步线程</span><br>        threadLock.acquire()<br>        print_time(self.name, self.counter, <span class="hljs-number">3</span>)<br>        <span class="hljs-comment"># 释放锁，开启下一个线程</span><br>        threadLock.release()<br>        print(<span class="hljs-string">"Thread Exit: "</span> + self.name)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_time</span><span class="hljs-params">(threadName, delay, counter)</span>:</span><br>    <span class="hljs-keyword">while</span> counter:<br>        time.sleep(delay)<br>        print(<span class="hljs-string">"&#123;&#125;: &#123;&#125;"</span>.format(threadName, time.ctime()))<br>        counter -= <span class="hljs-number">1</span><br><br><br><span class="hljs-comment"># 创建线程</span><br>thread1 = myThread(<span class="hljs-number">1001</span>, <span class="hljs-string">"Thread-1"</span>, <span class="hljs-number">1</span>)<br>thread2 = myThread(<span class="hljs-number">1002</span>, <span class="hljs-string">"Thread-2"</span>, <span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 开启线程</span><br>thread1.start()<br>thread2.start()<br><br><span class="hljs-comment"># 添加线程列表</span><br>threads.append(thread1)<br>threads.append(thread2)<br><br><span class="hljs-comment"># 等待所有线程完成</span><br><span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads:<br>    t.join()<br>print(<span class="hljs-string">"exit"</span>)<br></code></pre></td></tr></table></figure><h5 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h5><p>同一个进程下的线程数据之间可以共享，多线程中GIL锁，一个时刻只有一线程在运行，所以说就是有很多线程在修改这些共享数据。</p><p>当开启了很多个线程，当这些线程一起修改全局变量的时候，最后得出的结果可能跟期望的不太一样。</p><p>Python提供了另一把锁，给用户的锁，叫做<strong>线程锁</strong>，可以在多个线程操作共享数据时更加有规律，来防止操作数据失误的情况出现。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-comment"># 获取锁</span><br>    lock.acquire()<br>    <span class="hljs-comment"># 声明全局变量num</span><br>    <span class="hljs-keyword">global</span> num<br>    <span class="hljs-comment"># num+=1</span><br>    num += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 释放锁</span><br>    lock.release()<br><br><br><span class="hljs-comment"># 生成线程锁实例</span><br>lock = threading.Lock()<br>num = <span class="hljs-number">0</span><br><br><span class="hljs-comment"># 开启1000个线程</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1000</span>):<br>    t = threading.Thread(target=run)<br>    t.start()<br><br>print(<span class="hljs-string">"-----all thread has finshed"</span>)<br>print(<span class="hljs-string">"num:"</span>, num)<br></code></pre></td></tr></table></figure><p>注意获取锁与释放锁之间的这一段锁操作的数据量不是很大，如果数据量很大，需要的时间很多，那么程序就会变成串行。</p><h5 id="递归锁"><a href="#递归锁" class="headerlink" title="递归锁"></a>递归锁</h5><p>在我们分出一个线程，使用线程锁之后里面再调用别的函数，然后调用的这个函数中再使用线程锁的话就不能在使用Lock()实例了， 不然就会出现死循环错误，这是因为一把锁对应一个钥匙，锁里面再加一把锁就会导致程序分不清哪把钥匙开哪把锁，导致程序一直在锁中出不来，如下：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run1</span><span class="hljs-params">()</span>:</span><br>    print(<span class="hljs-string">"grab the first part data"</span>)<br>    <span class="hljs-comment"># 获取锁</span><br>    lock.acquire()<br>    <span class="hljs-keyword">global</span> num<br>    num += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 释放锁</span><br>    lock.release()<br>    <span class="hljs-keyword">return</span> num<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run2</span><span class="hljs-params">()</span>:</span><br>    print(<span class="hljs-string">"grab the second part data"</span>)<br>    <span class="hljs-comment"># 获取锁</span><br>    lock.acquire()<br>    <span class="hljs-keyword">global</span> num2<br>    num2 += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 释放锁</span><br>    lock.release()<br>    <span class="hljs-keyword">return</span> num2<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run3</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-comment"># 获取锁</span><br>    lock.acquire()<br>    <span class="hljs-comment"># 去跑run1</span><br>    res = run1()<br>    print(<span class="hljs-string">'--------between run1 and run2-----'</span>)<br>    <span class="hljs-comment"># 去跑run2</span><br>    res2 = run2()<br>    <span class="hljs-comment"># 释放锁</span><br>    lock.release()<br>    print(res, res2)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    <span class="hljs-comment"># 初始化两个为0的变量</span><br>    num, num2 = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 生成lock实例</span><br>    lock = threading.Lock()<br>    <span class="hljs-comment"># 开始10个线程</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):<br>        <span class="hljs-comment"># 线程跑的是run3</span><br>        t = threading.Thread(target=run3)<br>        t.start()<br><br><span class="hljs-comment"># 判读是否有多个线程，有多个就继续打印，只剩一个说明子线程都执行完了，只剩主线程了，然后跳出循环程序结束</span><br><span class="hljs-comment"># 可以用之前学到的join()方法来实现一样的效果</span><br><span class="hljs-keyword">while</span> threading.active_count() != <span class="hljs-number">1</span>:<br>    print(threading.active_count())<br><span class="hljs-keyword">else</span>:<br>    print(<span class="hljs-string">'----all threads done---'</span>)<br>    print(num, num2)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Iimage3.png" width="50%"></p><p>可以看到一直在打印线程数11，说明一直有11个线程在活跃，说明分出的10个线程一直在运行不结束，这个时候就不能使用<code>Lock()</code>了，而是使用<code>RLock()</code></p><p>修改后结果：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run1</span><span class="hljs-params">()</span>:</span><br>    print(<span class="hljs-string">"grab the first part data"</span>)<br>    <span class="hljs-comment"># 获取锁</span><br>    lock.acquire()<br>    <span class="hljs-keyword">global</span> num<br>    num += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 释放锁</span><br>    lock.release()<br>    <span class="hljs-keyword">return</span> num<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run2</span><span class="hljs-params">()</span>:</span><br>    print(<span class="hljs-string">"grab the second part data"</span>)<br>    <span class="hljs-comment"># 获取锁</span><br>    lock.acquire()<br>    <span class="hljs-keyword">global</span> num2<br>    num2 += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 释放锁</span><br>    lock.release()<br>    <span class="hljs-keyword">return</span> num2<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run3</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-comment"># 获取锁</span><br>    lock.acquire()<br>    <span class="hljs-comment"># 去跑run1</span><br>    res = run1()<br>    print(<span class="hljs-string">'--------between run1 and run2-----'</span>)<br>    <span class="hljs-comment"># 去跑run2</span><br>    res2 = run2()<br>    <span class="hljs-comment"># 释放锁</span><br>    lock.release()<br>    print(res, res2)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    <span class="hljs-comment"># 初始化两个为0的变量</span><br>    num, num2 = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 生成lock实例</span><br>    lock = threading.RLock()<br>    <span class="hljs-comment"># 开始10个线程</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):<br>        <span class="hljs-comment"># 线程跑的是run3</span><br>        t = threading.Thread(target=run3)<br>        t.start()<br><br><span class="hljs-comment"># 判读是否有多个线程，有多个就继续打印，只剩一个说明子线程都执行完了，只剩主线程了，然后跳出循环程序结束</span><br><span class="hljs-comment"># 可以用之前学到的join()方法来实现一样的效果</span><br><span class="hljs-keyword">while</span> threading.active_count() != <span class="hljs-number">1</span>:<br>    print(threading.active_count())<br><span class="hljs-keyword">else</span>:<br>    print(<span class="hljs-string">'----all threads done---'</span>)<br>    print(num, num2)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Iimage4.png" width="50%"></p><h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><p>信号量的用法和线程锁非常相似。</p><p>线程锁锁住一个线程在运行和修改数据，而信号量可以自己控制同一时刻运行几个线程和几个线程修改数据，也就是设置最大同时运行的线程数。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(n)</span>:</span><br>    <span class="hljs-comment"># 获取信号量</span><br>    semaphore.acquire()<br>    print(<span class="hljs-string">'task %s is running'</span> % n)<br>    <span class="hljs-comment"># 暂停1s方便看出一次运行几个线程</span><br>    time.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 释放信号量</span><br>    semaphore.release()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    <span class="hljs-comment"># 生成信号量实例并设置信号量为5</span><br>    semaphore = threading.BoundedSemaphore(<span class="hljs-number">5</span>)<br>    <span class="hljs-comment"># 开启50个线程</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">50</span>):<br>        t = threading.Thread(target=run, args=(i,))<br>        t.start()<br><br><span class="hljs-comment"># 线程没有运行完就不退出</span><br><span class="hljs-keyword">while</span> threading.active_count() != <span class="hljs-number">1</span>:<br>    <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">else</span>:<br>    print(<span class="hljs-string">'----all threads done---'</span>)<br></code></pre></td></tr></table></figure><p>虽然我们看到的是一次执行五个线程，但并不是五个一组五个一组分组执行的，因为这五个线程同时完成，所以我们看不出来，但是其中的过程是执行完一个线程放进去一个线程，加入这五个中有两个先完成，那么就会立刻再放进去两个，也就是说这五个线程之间不会互相等待，这个设置的信号量5不是按5来分组，而是同时运行的线程最大数，可以写多个执行时间不同的函数然后一次执行几个来证明这一点。</p><h4 id="区分主-子线程"><a href="#区分主-子线程" class="headerlink" title="区分主/子线程"></a>区分主/子线程</h4><p>子线程可能比较明白的看出来，而主线程有的时候是看不到的，主线程就是程序本身，但是跟子线程还是有区分的，而threading module提供给我们方法让我们可以知道当前线程是主线程还是子线程。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">threading.current_thread() <span class="hljs-comment"># 返回当前线程类型</span><br>threading.active_count()<span class="hljs-comment"># 返回当前活跃线程数</span><br></code></pre></td></tr></table></figure><p>实例</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-comment"># 继承类threading.Thread</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(threading.Thread)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, n)</span>:</span><br>        <span class="hljs-comment"># 这里要继承构造函数</span><br>        super(MyThread, self).__init__()<br>        <span class="hljs-comment"># 可以定义自己的实例变量</span><br>        self.n = n<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-comment"># 打印当前线程类型</span><br>        print(<span class="hljs-string">'running task'</span>, self.n, threading.current_thread())<br>        time.sleep(<span class="hljs-number">2</span>)<br><br><br><span class="hljs-comment"># 得到开始时间</span><br>start_time = time.time()<br><span class="hljs-comment"># 声明空列表</span><br>threads = []<br><br><span class="hljs-comment"># 循环开启50线程</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">50</span>):<br>    t = MyThread(i)<br>    t.start()<br>    <span class="hljs-comment"># 线程实例放入列表中</span><br>    threads.append(t)<br><span class="hljs-comment"># 打印当前活跃的线程数</span><br>print(threading.active_count())<br><span class="hljs-comment"># 对线程实例所在列表再循环</span><br><span class="hljs-keyword">for</span> res <span class="hljs-keyword">in</span> threads:<br>    <span class="hljs-comment"># 对每一个实例使用jion()方法</span><br>    res.join()<br><span class="hljs-comment"># 获得结束时间</span><br>end_time = time.time()<br><span class="hljs-comment"># 计算花费时间</span><br>spend_time = end_time - start_time<br><span class="hljs-comment"># 打印当前线程类型</span><br>print(<span class="hljs-string">'all thread has finished'</span>, threading.current_thread())<br><span class="hljs-comment"># 打印花费时间</span><br>print(spend_time)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Iimage1.png" width="50%"></p><p>可以看到在开启50个子线程后活跃线程数为51，这些线程的类型都为Thread(子线程)，而最后的则为Main Thread(主线程)</p><p>这样，我们就可以知道当前线程是主线程还是子线程了，甚至还可以知道当前活跃的线程数。</p><h4 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h4><p>顾名思义，守护进程就是用来守护主线程的，一旦主线程没了，那这些守护线程也就没有存在的意义了。</p><p>threading module提供<code>setDaemon(True)</code>来使子线程变为守护线程，守护线程就是一旦主线程结束了，即使子线程还在运行，也会跟着一起结束。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-comment"># 继承类threading.Thread</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(threading.Thread)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, n)</span>:</span><br>        <span class="hljs-comment"># 这里要继承构造函数</span><br>        super(MyThread, self).__init__()<br>        <span class="hljs-comment"># 可以定义自己的实例变量</span><br>        self.n = n<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-comment"># 打印当前线程类型</span><br>        print(<span class="hljs-string">'running task'</span>, self.n, threading.current_thread())<br>        time.sleep(<span class="hljs-number">2</span>)<br>        <span class="hljs-comment"># 线程结束打印一句话</span><br>        print(<span class="hljs-string">'done'</span>)<br><br><br><span class="hljs-comment"># 得到开始时间</span><br>start_time = time.time()<br><br><span class="hljs-comment"># 循环开启50线程</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">50</span>):<br>    t = MyThread(i)<br>    <span class="hljs-comment"># 设置这个线程为守护线程</span><br>    t.setDaemon(<span class="hljs-literal">True</span>)<br>    t.start()<br><span class="hljs-comment"># 打印当前活跃的线程数</span><br>print(threading.active_count())<br><br><span class="hljs-comment"># 获得结束时间</span><br>end_time = time.time()<br><span class="hljs-comment"># 计算花费时间</span><br>spend_time = end_time - start_time<br><span class="hljs-comment"># 打印当前线程类型</span><br>print(<span class="hljs-string">'all thread has finished'</span>, threading.current_thread())<br><span class="hljs-comment"># 打印花费时间</span><br>print(spend_time)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Iimage2.png" width="50%"></p><p>可以看到，直到程序结束都没有执行每一个线程中的打印<code>done</code>的这段代码，这是因为子线程变成了守护线程，一旦主线程结束，这些守护线程也会跟着结束。</p><p>这里也有注意的地方，就是设置子线程为守护线程时必须要在子线程开始之前也就是<code>start()</code>之前。</p><p>程序会等待主线程的完成，而不会等待守护线程</p><h2 id="queue模块-线程间通信"><a href="#queue模块-线程间通信" class="headerlink" title="queue模块(线程间通信)"></a>queue模块(线程间通信)</h2><p>Python的Queue模块中提供了同步的、线程安全的队列类，包括：</p><ul><li>FIFO队列Queue</li><li>LIFO队列LifoQueue</li><li>优先级队列PriorityQueue</li></ul><h4 id="Queue模块中常用方法"><a href="#Queue模块中常用方法" class="headerlink" title="Queue模块中常用方法"></a>Queue模块中常用方法</h4><div class="table-container"><table><thead><tr><th style="text-align:center">对象</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">Queue(maxsize=0)</td><td style="text-align:left">创建一个先入先出队列。如果给定最大值，则在队列没有空间时阻塞；否则(没有指定最大值)，为无限队列</td></tr><tr><td style="text-align:center">LifoQueue(maxsize=0)</td><td style="text-align:left">创建一个后入先出队列。如果给定最大值，则在队列没有空间时阻塞；否则(没有指定最大值)，为无限队列</td></tr><tr><td style="text-align:center">PriorityQueue(maxsize=0)</td><td style="text-align:left">创建一个优先级队列。如果给定最大值，则在队列没有空间时阻塞，否则(没有指定最大值)，为无限队列</td></tr><tr><td style="text-align:center">Empty</td><td style="text-align:left">当对空队列调用get*()方法时抛出异常</td></tr><tr><td style="text-align:center">Full</td><td style="text-align:left">当对已满的队列调用put*()方法时抛出异常</td></tr><tr><td style="text-align:center">qsize()</td><td style="text-align:left">返回队列大小</td></tr><tr><td style="text-align:center">empty()</td><td style="text-align:left">如果队列为空，则返回True；否则，返回False</td></tr><tr><td style="text-align:center">full()</td><td style="text-align:left">如果队列为满，则返回True；否则，返回False</td></tr><tr><td style="text-align:center">put(item,block=True,timeout=None)</td><td style="text-align:left">将item放入队列。如果block为True(默认)且timeout为None，则在有可用空间之前阻塞；如果timeout为正值，则最多阻塞timeout秒；如果block为False，则抛出Empty异常</td></tr><tr><td style="text-align:center">put_nowait(item)</td><td style="text-align:left">相当于put(item,False)</td></tr><tr><td style="text-align:center">get(blcok=True,timeout=None)</td><td style="text-align:left">获取队列。如果给定了block(非0)，则一直阻塞到有可用的元素为止</td></tr><tr><td style="text-align:center">get_nowait()</td><td style="text-align:left">相当于get(False)</td></tr><tr><td style="text-align:center">join()</td><td style="text-align:left">在队列中所有元素执行完毕并调用上面的task_done()信号之前，保持阻塞</td></tr></tbody></table></div><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> randint<br><span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> ctime, sleep<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mythread</span><span class="hljs-params">(threading.Thread)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, func, name=<span class="hljs-string">''</span>)</span>:</span><br>        threading.Thread.__init__(self)<br>        self.name = name<br>        self.func = func<br><br>    <span class="hljs-string">''' rewrite run() '''</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span><br>        self.func()<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, q, loops)</span>:</span><br>        self.q = q<br>        self.loops = loops<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">WriteQueue</span><span class="hljs-params">(self)</span>:</span><br>        self.q.put(<span class="hljs-string">'xxx'</span>, <span class="hljs-number">1</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ReadQueue</span><span class="hljs-params">(self)</span>:</span><br>        value = self.q.get(<span class="hljs-number">1</span>)<br>        print(<span class="hljs-string">'value: '</span> + str(value))<br>        <span class="hljs-keyword">return</span> value<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Writer</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(self.loops):<br>                self.WriteQueue()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Reader</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(self.loops):<br>                aaa = self.ReadQueue()<br>                print(<span class="hljs-string">"aaa = "</span> + str(aaa))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span><br>    que = Queue(<span class="hljs-number">32</span>)<br>    nloops = randint(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>)<br>    q = MyQueue(que, nloops)<br><br>    t1 = Mythread(q.Writer, q.Writer.__name__)<br><br>    t2 = Mythread(q.Reader, q.Reader.__name__)<br><br>    t1.start()<br>    t2.start()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    main()<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matplotlib基础</title>
      <link href="/2019/08/03/Matplotlib%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/08/03/Matplotlib%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p><strong>本文主要介绍了以下内容:</strong></p><p>Matplotlib的一些基础画图命令</p><a id="more"></a><h3 id="标准头文件"><a href="#标准头文件" class="headerlink" title="标准头文件"></a>标准头文件</h3><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>plt.rcParams[<span class="hljs-string">'font.sans-serif'</span>] = [<span class="hljs-string">'STHeiti'</span>]  <span class="hljs-comment"># 用来正常显示中文标签</span><br>plt.rcParams[<span class="hljs-string">'axes.unicode_minus'</span>] = <span class="hljs-literal">False</span>  <span class="hljs-comment"># 用来正常显示负号</span><br><br>plt.show()<br></code></pre></td></tr></table></figure><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h5 id="figure-函数，创建图表"><a href="#figure-函数，创建图表" class="headerlink" title="figure()函数，创建图表"></a><code>figure()</code>函数，创建图表</h5><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> matplotlib.patches <span class="hljs-keyword">import</span> Polygon<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>plt.figure(<span class="hljs-number">1</span>)   <span class="hljs-comment"># 创建图表1</span><br>plt.figure(<span class="hljs-number">2</span>)   <span class="hljs-comment"># 创建图表2</span><br><br>plt.show()<br></code></pre></td></tr></table></figure><h5 id="subplot-创建子图"><a href="#subplot-创建子图" class="headerlink" title="subplot()创建子图"></a><code>subplot()</code>创建子图</h5><p>子图序号排序顺序：从左到右，从上到下，逐次增加1</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> matplotlib.patches <span class="hljs-keyword">import</span> Polygon<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>plt.figure(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 创建图表1</span><br>plt.subplot(<span class="hljs-number">221</span>)  <span class="hljs-comment"># 创建2*2的图表矩阵，绘制的子图为矩阵中的1序号</span><br>plt.subplot(<span class="hljs-number">222</span>)  <span class="hljs-comment"># 创建2*2的图表矩阵，绘制的子图为矩阵中的2序号</span><br>plt.subplot(<span class="hljs-number">223</span>)  <span class="hljs-comment"># 创建2*2的图表矩阵，绘制的子图为矩阵中的3序号</span><br>plt.subplot(<span class="hljs-number">224</span>)  <span class="hljs-comment"># 创建2*2的图表矩阵，绘制的子图为矩阵中的4序号</span><br><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Image1.png" width="50%"></p><h5 id="在多个表中创建子图"><a href="#在多个表中创建子图" class="headerlink" title="在多个表中创建子图"></a>在多个表中创建子图</h5><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> matplotlib.patches <span class="hljs-keyword">import</span> Polygon<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>plt.figure(<span class="hljs-number">1</span>, dpi=<span class="hljs-number">50</span>)  <span class="hljs-comment"># 创建图表1</span><br>plt.subplot(<span class="hljs-number">111</span>)  <span class="hljs-comment"># 在图表1中创建子图</span><br>plt.figure(<span class="hljs-number">2</span>, dpi=<span class="hljs-number">50</span>)  <span class="hljs-comment"># 创建图表2</span><br>plt.subplot(<span class="hljs-number">221</span>)  <span class="hljs-comment"># 在图表2中创建子图</span><br>plt.show()  <span class="hljs-comment"># 显示所有图表</span><br></code></pre></td></tr></table></figure><h5 id="plot-函数，画函数图像"><a href="#plot-函数，画函数图像" class="headerlink" title="plot()函数，画函数图像"></a><code>plot()</code>函数，画函数图像</h5><p><code>splot(x,y)</code>中<code>x</code>表示横坐标，<code>y</code>表示纵坐标</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>plt.figure(<span class="hljs-number">1</span>, dpi=<span class="hljs-number">100</span>)<br><span class="hljs-comment"># x轴的定义域为 -3.14~3.14，中间间隔100个元素</span><br>x = np.linspace(-np.pi, np.pi, <span class="hljs-number">100</span>) <br>plt.plot(x, np.sin(x))<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Image2.png" width="50%"></p><h5 id="sca-函数，选择子图"><a href="#sca-函数，选择子图" class="headerlink" title="sca()函数，选择子图"></a><code>sca()</code>函数，选择子图</h5><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>plt.figure(<span class="hljs-number">1</span>, dpi=<span class="hljs-number">100</span>)<br>ax1 = plt.subplot(<span class="hljs-number">211</span>)  <span class="hljs-comment"># 创建子图 ax1</span><br>ax2 = plt.subplot(<span class="hljs-number">212</span>)  <span class="hljs-comment"># 创建子图 ax2</span><br><br>x = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>)  <span class="hljs-comment"># x轴定义域</span><br><br>plt.sca(ax1)  <span class="hljs-comment"># 选择子图ax1</span><br>plt.plot(x, np.exp(x))  <span class="hljs-comment"># 在子图ax1 中绘制函数 exp(x)</span><br><br>plt.sca(ax2)  <span class="hljs-comment"># 选择子图ax2</span><br>plt.plot(x, np.sin(x))  <span class="hljs-comment"># 在子图ax2 中绘制函数 sin(x)</span><br><br>plt.show()  <span class="hljs-comment"># 展示所有图表</span><br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Image3.png" width="50%"></p><h5 id="在一张图中画多条曲线"><a href="#在一张图中画多条曲线" class="headerlink" title="在一张图中画多条曲线"></a>在一张图中画多条曲线</h5><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pylab <span class="hljs-keyword">as</span> plt<br><br>x = np.linspace(-np.pi * <span class="hljs-number">2</span>, np.pi * <span class="hljs-number">2</span>, <span class="hljs-number">100</span>)  <span class="hljs-comment"># 定义域为： -2pi 到 2pi</span><br>plt.figure(<span class="hljs-number">1</span>, dpi=<span class="hljs-number">100</span>)  <span class="hljs-comment"># 创建图表1</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>):  <span class="hljs-comment"># 画四条线</span><br>    plt.plot(x, np.sin(x / i))<br><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Image4.png" width="50%"></p><h3 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h3><p>使用<code>plot()</code>函数</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>x = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>y = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]<br><br>x1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>y1 = [<span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">12</span>, <span class="hljs-number">14</span>]<br><br>plt.plot(x, y, label=<span class="hljs-string">'line one'</span>)<br>plt.plot(x1, y1, label=<span class="hljs-string">'line two'</span>)<br><br>plt.xlabel(<span class="hljs-string">'x_data'</span>)<br>plt.ylabel(<span class="hljs-string">'y_data'</span>)<br>plt.title(<span class="hljs-string">'title is here!'</span>)<br><br>plt.legend(loc=<span class="hljs-number">0</span>)<br><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Image9.png" width="50%"></p><h3 id="条形图"><a href="#条形图" class="headerlink" title="条形图"></a>条形图</h3><p>使用<code>bar()</code>函数</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>x = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>]<br>y = [<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]<br><br>plt.bar(x, y)<br><br>plt.axis([<span class="hljs-number">0</span>, <span class="hljs-number">12</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>])<br><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Image10.png" width="50%"></p><h3 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h3><p>使用<code>hist()</code>函数</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>plt.figure(<span class="hljs-number">1</span>, dpi=<span class="hljs-number">100</span>)  <span class="hljs-comment"># 创建图表1</span><br>data = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>]<br>plt.hist(data)  <span class="hljs-comment"># 只要传入数据，直方图就会统计数据出现的次数</span><br><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Image5.png" width="50%"></p><h3 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h3><p>散点图用<code>scatter(x,y)</code>绘制，x参数传入x轴的坐标，y参数传入y轴坐标</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># 产生测试数据</span><br>x = np.arange(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)<br>y = x<br>fig = plt.figure()<br>plt.scatter(x, y, c=<span class="hljs-string">'r'</span>, marker=<span class="hljs-string">'o'</span>)  <span class="hljs-comment"># c = 'r'表示散点的颜色为红色，marker 表示指定三点多形状为圆形</span><br><span class="hljs-comment"># 显示所画的图</span><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Image6.png" width="50%"></p><h3 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h3><p>使用<code>pie()</code>函数</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>data = [<span class="hljs-number">100</span>, <span class="hljs-number">500</span>, <span class="hljs-number">300</span>]  <span class="hljs-comment"># 饼图中的数据</span><br>fig = plt.figure(dpi=<span class="hljs-number">100</span>)<br>plt.pie(data,  <span class="hljs-comment"># 每个饼块的实际数据，如果大于1，会进行归一化，计算percentage</span><br>        explode=[<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.1</span>],  <span class="hljs-comment"># 每个饼块离中心的距离</span><br>        colors=[<span class="hljs-string">'y'</span>, <span class="hljs-string">'r'</span>, <span class="hljs-string">'g'</span>],  <span class="hljs-comment"># 每个饼块的颜色,黄红绿</span><br>        labels=[<span class="hljs-string">'A part'</span>, <span class="hljs-string">'B part'</span>, <span class="hljs-string">'C part'</span>],  <span class="hljs-comment"># 每个饼块的标签</span><br>        labeldistance=<span class="hljs-number">1.2</span>,  <span class="hljs-comment"># 每个饼块标签到中心的距离</span><br>        autopct=<span class="hljs-string">'%1.1f%%'</span>,  <span class="hljs-comment"># 百分比的显示格式</span><br>        pctdistance=<span class="hljs-number">0.5</span>,  <span class="hljs-comment"># 百分比到中心的距离</span><br>        shadow=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 每个饼块是否显示阴影</span><br>        startangle=<span class="hljs-number">0</span>,  <span class="hljs-comment"># 默认从x轴正半轴逆时针起</span><br>        radius=<span class="hljs-number">1</span>  <span class="hljs-comment"># 饼块的半径</span><br>        )<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Image7.png" width="50%"></p><h3 id="图标的注释与标识"><a href="#图标的注释与标识" class="headerlink" title="图标的注释与标识"></a>图标的注释与标识</h3><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>fig = plt.figure(dpi=<span class="hljs-number">100</span>)<br>x = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>)<br>plt.plot(x, np.sin(x), label=<span class="hljs-string">"sin(x)"</span>)  <span class="hljs-comment"># 先设置一个label用于显示图例</span><br>plt.xlabel(<span class="hljs-string">"X axe"</span>)  <span class="hljs-comment"># 设置X轴的文字</span><br>plt.ylabel(<span class="hljs-string">"Y axe"</span>)  <span class="hljs-comment"># 设置Y轴的文字</span><br><span class="hljs-comment"># 设置x轴y轴的起点和终点</span><br>plt.axis([np.min(x), np.max(x), np.min(np.sin(x)), np.max(np.sin(x))])<br>plt.title(<span class="hljs-string">"sin(x) function"</span>)  <span class="hljs-comment"># 设置图的标题</span><br>plt.legend()  <span class="hljs-comment"># 显示图例。</span><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Image8.png" width="50%"></p><h3 id="插入Latex公式"><a href="#插入Latex公式" class="headerlink" title="插入Latex公式"></a>插入Latex公式</h3><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> matplotlib.patches <span class="hljs-keyword">import</span> Polygon<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>plt.rcParams[<span class="hljs-string">'font.sans-serif'</span>] = [<span class="hljs-string">'STHeiti'</span>]  <span class="hljs-comment"># 用来正常显示中文标签</span><br>plt.rcParams[<span class="hljs-string">'axes.unicode_minus'</span>] = <span class="hljs-literal">False</span>  <span class="hljs-comment"># 用来正常显示负号</span><br><br><br><span class="hljs-comment"># 定义一个求积分的函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(x)</span>:</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0.3</span> * (x ** <span class="hljs-number">2</span>) + (<span class="hljs-number">0.1</span> * x) + <span class="hljs-number">1</span><br><br><br><span class="hljs-comment"># 定义积分区间</span><br>a, b = <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br>x = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)<br>y = func(x)<br><br><span class="hljs-comment"># 绘制曲线</span><br>fig, ax = plt.subplots(figsize=(<span class="hljs-number">14</span>, <span class="hljs-number">8</span>))<br>plt.plot(x, y, <span class="hljs-string">'g'</span>)<br><br><span class="hljs-comment"># 使用Polygon生成阴影部分</span><br>Ix = np.linspace(a, b)<br>Iy = func(Ix)<br>verts = [(a, <span class="hljs-number">0</span>)] + list(zip(Ix, Iy)) + [(b, <span class="hljs-number">0</span>)]<br>ploy = Polygon(verts, facecolor=<span class="hljs-string">'0.7'</span>, edgecolor=<span class="hljs-string">'0.5'</span>)<br>ax.add_patch(ploy)<br><br><span class="hljs-comment"># 添加数学公式和坐标轴标签</span><br><span class="hljs-comment"># r" "中间为LaTex语法表示的公式</span><br>plt.text(<span class="hljs-number">0.5</span> * (a + b), <span class="hljs-number">1</span>, <span class="hljs-string">r"$\int_a^b f(x)\mathrm&#123;d&#125;x$"</span>,<br>         horizontalalignment=<span class="hljs-string">'center'</span>, fontsize=<span class="hljs-number">20</span>)<br><span class="hljs-comment"># 前两个参数是放置文本的坐标</span><br>plt.figtext(<span class="hljs-number">0.9</span>, <span class="hljs-number">0.075</span>, <span class="hljs-string">'$x$'</span>)<br>plt.figtext(<span class="hljs-number">0.075</span>, <span class="hljs-number">0.9</span>, <span class="hljs-string">'$f(x)$'</span>)<br><br>ax.set_xticks((a, b))<br>ax.set_xticklabels((<span class="hljs-string">'$a$'</span>, <span class="hljs-string">'$b$'</span>))<br>ax.set_yticks((func(a), func(b)))<br>ax.set_yticklabels((<span class="hljs-string">'$f(a)$'</span>, <span class="hljs-string">'$f(b)$'</span>))<br>plt.grid(<span class="hljs-literal">True</span>)<span class="hljs-comment"># 网格</span><br>plt.show()<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 画图 </tag>
            
            <tag> Matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTex学习</title>
      <link href="/2019/08/02/Latex%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/08/02/Latex%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><strong>本文主要介绍了以下内容:</strong></p><p>LaTex一些基础知识</p><a id="more"></a><h3 id="开始第一个LaTex文档"><a href="#开始第一个LaTex文档" class="headerlink" title="开始第一个LaTex文档"></a>开始第一个LaTex文档</h3><p>打开TeXstudio,新建一个TeX文件,写入以下内容</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass&#123;article&#125;<br>\begin&#123;document&#125;<br>Here comes \LaTeX!<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><p>​    此处的第一行<code>\documentclass{article}</code>中包含了一个控制序列(或称命令/标记).所谓控制序列,是以反斜杠<code>\</code>开头,以第一个空格或非字母的字符结束的一串文字.它们不能被输出,但是它们会影响输出文档的效果.这里的控制序列是<code>documentclass</code>,它后面紧跟着的<code>{article}</code>代表这个控制序列有一个必要的参数,该参数的值为<code>article</code>这个控制序列的作用,是调用名为<code>article</code>的文档类.</p><p>​    <strong>Tex对控制序列的大小写是敏感的</strong></p><ul><li><p>部分控制序列还有被方括号<code>[]</code>包括的可选参数</p></li><li><p>所谓文档类,即是Tex系统预设的(或是用户自定的)一些格式的集合.不同文档类在输出效果上会有差别.</p><p>  此处的第二行以<code>%</code>开头.Tex以<code>%</code>作为注释标记符.具体来说,Tex会忽略从<code>%</code>开始当当前行末尾的所有内容.这些内容不会被输出,也不影响最终的排版效果,只供人类阅读.若要输出<code>%</code>字符本身,则需要在<code>%</code>之前加上反斜杠<code>\</code>进行转义(escape).例如</p>  <figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">今年的净利润为20\%, 比去年高<br></code></pre></td></tr></table></figure><p>  此处<code>%</code>被当做正常的百分号来处理, 其后的文字也将被正常输出.</p><p>  在注释行之后出现了控制序列<code>begin</code>.这个控制序列总是与<code>end</code>成对出现.这两个控制序列以及它们中间的内容被称为[环境],它们之后的第一个必要参数总是一致,被称为环境名.</p><p>  只有在<code>document</code>环境中的内容,才会被正常输出到文档中去或是作为控制序列对文档产生影响.也就是说,在<code>\end{document}</code>之后插入任何内容都是无效的.</p><p>  从<code>\documentclass{article}</code>开始到<code>\begin{document}</code>之前的部分被称为导言区.你可以将导言区理解为时对整篇文档进行设置的区域——在导言区出现的控制序列,往往会影响整篇文档的格式.</p><p>  <strong>通常在导言区设置页面的大小,页眉页脚样式,章节标题等等</strong></p></li></ul><h3 id="实现中英文混排"><a href="#实现中英文混排" class="headerlink" title="实现中英文混排"></a>实现中英文混排</h3><p>​    <strong>关于LaTeX的中文支持,首先要说明的是:在现在,一切教你使用<code>CJK</code>宏包的模板,人,网页,书,都是糟糕的,有害的,恼人的,邪恶的和应该摒弃的</strong></p><p>​    成功编译出一个文档后,中国Tex用户面临的第二个普遍问题大概就是<strong>实现中英文混排</strong>了.</p><p>​    宏包,就是一系列控制序列的合集.这里控制序列太常用,以至于人们会觉得每次将他们写在导言区太过繁琐,于是将他们打包在同一个文件架中,称为所谓的宏包.<code>\usepackage{}</code>可以用来调用宏包</p><p>​    除去中文支持,中文的板式处理和标点禁则也是不小的挑战.好在由刘海洋,李清等人维护的<code>CTeX</code>宏集一次性解决了这些问题.<code>CTeX</code>宏集的优势在于,他能适配于多种编译方式,在内部处理好了中文和中文版式的支持,影藏了这些细节,并且提供了不少中文用户需要的功能接口.</p><figure class="hljs highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&gt;请注意,`CTeX`宏集和`CTeX`套装是两个不同的东西.`CTeX`宏集的本质是LaTeX宏的集合,包含若干文档类(`.cls`文件)和宏包(`.sty`文件).`CTeX`套装是一个过时的TeX系统.<br>&gt;<br>&gt;新版`CTeX`宏集默认能够自动检测用户的操作系统,并为之配置合适的字库.<br></code></pre></td></tr></table></figure><p>​    使用以下代码来完成对<code>CTeX</code>宏集的调用:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[UTF8]&#123;ctexart&#125;<br>\begin&#123;document&#125;<br>你好, world!<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><h3 id="组织你的文章"><a href="#组织你的文章" class="headerlink" title="组织你的文章"></a>组织你的文章</h3><h4 id="作者-标题-日期"><a href="#作者-标题-日期" class="headerlink" title="作者,标题,日期"></a>作者,标题,日期</h4><p>保存并用XeLaTeX编译如下文档:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[UTF8]&#123;ctexart&#125;<br>\title&#123;你好, world!&#125;<br>\author&#123;胡奔&#125;<br>\date&#123;\today&#125;<br>\begin&#123;document&#125;<br>\maketitle<br>你好, 胡奔<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><p>导言区复杂了很多,但和之前的文档区别只有一处: 定义了<strong>标题,作者,日期</strong></p><p>在<code>document</code>环境中,除了原本的<code>你好,world!</code>,还多了一个控制序列<code>\maketitle</code>,这个控制序列能将在导言区中定义的标题,作者,日期按照预定义的格式展现出来.</p><blockquote><p>使用<code>titling</code>红包可以修改上述默认格式,参考<a href="http://texdoc.net/texmf-dist/doc/latex/titling/titling.pdf" target="_blank" rel="noopener">TeXdoc</a>    </p></blockquote><h4 id="章节和段落"><a href="#章节和段落" class="headerlink" title="章节和段落"></a>章节和段落</h4><p>保存并用XeLaTeX编译如下文档,查看效果:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[UTF8]&#123;ctexart&#125;<br>\title&#123;你好,\LaTeX&#125;<br>\author&#123;Huris&#125;<br>\date&#123;\today&#125;<br>\begin&#123;document&#125;<br>\maketitle<br>\section&#123;你好中国&#125;<br>中国在East Asia.<br>\subsection&#123;Hello Beijing&#125;<br>北京是 captical of China<br>\subsubsection&#123;Hello Dongcheng District&#125;<br>\paragraph&#123;Tian&apos;anmen Square&#125;<br>is in the center of Beijing<br>\subparagraph&#123;Chairman Mao&#125;<br>is in the center of 天安门广场<br>\subsection&#123;Hello 山东&#125;<br>\paragraph&#123;山东大学&#125;<br>is one of the best university in 山东.<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><p>在文档类<code>article</code>/<code>ctexart</code>中,定义了五个控制序列(只有五个)来调整行文组织结构,他们分别是:</p><ul><li><code>\section{.}</code></li><li><code>\subsection{.}</code></li><li><code>\subsubsection{.}</code></li><li><code>\paragraph{.}</code></li><li><code>\subparagraph</code></li></ul><h4 id="插入目录"><a href="#插入目录" class="headerlink" title="插入目录"></a>插入目录</h4><p>在上一节文档中,找到<code>\maketitle</code>,在他的下面插入控制序列<code>\tableofcontents</code>,保存并用XeLaTeX编译两次,观察结果:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[UTF8]&#123;ctexart&#125;<br>\title&#123;你好,\LaTeX&#125;<br>\author&#123;Huris&#125;<br>\date&#123;\today&#125;<br>\begin&#123;document&#125;<br>\maketitle<br>\tableofcontents<br>\section&#123;你好中国&#125;<br>中国在East Asia.<br>\subsection&#123;Hello Beijing&#125;<br>北京是 captical of China<br>\subsubsection&#123;Hello Dongcheng District&#125;<br>\paragraph&#123;Tian&apos;anmen Square&#125;<br>is in the center of Beijing<br>\subparagraph&#123;Chairman Mao&#125;<br>is in the center of 天安门广场<br>\subsection&#123;Hello 山东&#125;<br>\paragraph&#123;山东大学&#125;<br>is one of the best university in 山东.<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意<code>\maketitle</code>与<code>\tableofcontents</code>位置不能交换</p></blockquote><p>另外,LaTeX中间一个换行当做是一个简单的空格来处理,如果需要换行另起一段,则需要使用两个换行(一个空行)来实现.</p><h4 id="插入数学公式"><a href="#插入数学公式" class="headerlink" title="插入数学公式"></a>插入数学公式</h4><p>为了使用AMS-LaTeX提供的数学功能,我们需要在导言区加载<code>amsmath</code>宏包</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\usepackage&#123;amsmath&#125;<br></code></pre></td></tr></table></figure><h5 id="数学模式"><a href="#数学模式" class="headerlink" title="数学模式"></a>数学模式</h5><p>LaTex的数学模式有两种: 行内模式(inline)和行间模式(display).前者在正文的行文中,插入数学公式;后者独立排列单独成行</p><p>在行文中,使用<script type="math/tex">...</script>可以插入行内公式,使用<code>\[...\]</code>可以插入行间公式,如果需要对行间公式进行编号,可以使用equation环境.</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex">\begin&#123;equation&#125;<br>...<br>\end&#123;equation&#125;<br></code></pre></td></tr></table></figure><h5 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h5><p>示例代码:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[UTF8]&#123;ctexart&#125;<br>\usepackage&#123;amsmath&#125;<br>\begin&#123;document&#125;<br>Einsten&apos;s $E=mc^2$.<br>\[E=mc^2.\]<br>\begin&#123;equation&#125;<br>E=mc^2.<br>\end&#123;equation&#125;<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><blockquote><p>标点公式使用的规范</p><p>行内公式: 应该放在数学模式限定符之外</p><p>行间公式: 应该放在数学模式限定符之内</p></blockquote><p><code>_{...}</code>表示下标,<code>^{...}</code>表示上标.它默认只作用于之后的一个字符,如果想对连续的几个字符起作用,请将这些字符用花括号<code>{}</code>括起来.</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\[ z = r\cdot e^&#123;2\pi i&#125;. \]<br></code></pre></td></tr></table></figure><h5 id="根式与分式"><a href="#根式与分式" class="headerlink" title="根式与分式"></a>根式与分式</h5><p>根式用<code>\sqrt{.}</code>表示,分式用<code>\frac{.}{.}</code>表示(第一个参数为分子,第二个参数为分母).</p><p>示例代码:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[UTF8]&#123;ctexart&#125;<br>\usepackage&#123;amsmath&#125;<br>\begin&#123;document&#125;<br>$\sqrt&#123;x&#125;$, $\frac&#123;1&#125;&#123;2&#125;$.<br><br>\[ \sqrt&#123;x&#125;, \]<br><br>\[ \frac&#123;1&#125;&#123;2&#125;. \]<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><p>可以发现,在行间公式和行内公式中,分式的输出效果是由差异的. 如果要强制行内模式的分式显示为行间模式的大小,可以使用<code>\dfrac</code>,反之可以使用<code>\tfrac</code></p><blockquote><p>在行内写分式,可能会喜欢<code>xfrac</code>宏包提供的<code>\sfrac</code>命令的效果</p><p>排版繁公式时,应该使用<code>\cfrac</code>命令</p></blockquote><h5 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h5><p>一些小的运算符,可以在数学模式下直接输入;另一些要用控制序列生成</p><blockquote><p>控制序列</p><p>凡是键盘不能够直接表示的符号或者起着特定作用的皆有命令,类似转义,叫做<strong>控制序列(control sequence)</strong>,比如求和符合$\sum$对应的命令为<code>\sum</code></p></blockquote><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex">\[ \pm\; \times \; \div\; \cdot\; \cap\; \cup\;<br>   \geq\; \leq\; \neq\; \approx\; \equiv \]<br></code></pre></td></tr></table></figure><p>连加,连乘,极限,积分符号等大型运算符分别用<code>\sum</code>,<code>\prod</code>,<code>\lim</code>,<code>\int</code>生成</p><p>他们的上下标在行内公式中被压缩,以适应行高.我们可以使用<code>\limits</code>和<code>\nolimits</code>来强制显示地指定是否压缩这些上下标.</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">$ \sum_&#123;i=1&#125;^n i\quad \prod_&#123;i=1&#125;^n $<br>$ \sum\limits _&#123;i=1&#125;^n i\quad \prod\limits _&#123;i=1&#125;^n $<br>\[ \lim_&#123;x\to0&#125;x^2 \quad \int_a^b x^2 dx \]<br>\[ \lim\nolimits _&#123;x\to0&#125;x^2\quad \int\nolimits_a^b x^2 dx \]<br></code></pre></td></tr></table></figure><p>多重积分可以使用<code>\iint</code>,<code>\iiint</code>,<code>\iiint</code>,<code>\idotsint</code>等命令输入</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\[ \iint\quad \iiint\quad \iiint\quad \idotsint \]<br></code></pre></td></tr></table></figure><h5 id="定界符"><a href="#定界符" class="headerlink" title="定界符"></a>定界符</h5><p>各种括号用<code>()</code>,<code>[]</code>,<code>\{\}</code>,<code>\langle\rangle</code>等命令表示</p><p>注意花括号通常用来输入命令和环境的参数,所以在数学公式中它们前面要加<code>\</code></p><p>因为LaTeX中<code>|</code>和<code>\|</code>的应用过于随意,amsmath宏包推荐用<code>\lvert\rvert</code>和<code>\lVert\rVert</code>取而代之.</p><p>为了调整这些定界符的大小,amsmath宏包推荐使用<code>\big</code>,<code>\Big</code>,<code>\bigg</code>,<code>\Bigg</code>等一系列命令放在上述括号前面调整大小</p><blockquote><p>有时候可能会觉得amsmath宏包提供的定界符放大命令不太够用.</p><p>通常这就意味着你的公式过于复杂</p><p>此时应当首先考虑将公式中的部分提出去,以字母符号代替以简化公式</p><p>如果真的想排版出如此复杂的公式,可以参考<a href="https://liam.page/2018/11/09/the-bigger-than-bigger-delimiter-in-LaTeX/" target="_blank" rel="noopener">这篇博文</a></p></blockquote><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs latex">\[ \Biggl(\biggl(\Bigl(\bigl((x)\bigr)\Bigr)\biggr)\Biggr) \]<br>\[ \Biggl[\biggl[\Bigl[\bigl[[x]\bigr]\Bigr]\biggr]\Biggr] \]<br>\[ \Biggl \&#123;\biggl \&#123;\Bigl \&#123;\bigl \&#123;\&#123;x\&#125;\bigr \&#125;\Bigr \&#125;\biggr \&#125;\Biggr\&#125; \]<br>\[ \Biggl\langle\biggl\langle\Bigl\langle\bigl\langle\langle x<br>\rangle\bigr\rangle\Bigr\rangle\biggr\rangle\Biggr\rangle \]<br>\[ \Biggl\lvert\biggl\lvert\Bigl\lvert\bigl\lvert\lvert x<br>\rvert\bigr\rvert\Bigr\rvert\biggr\rvert\Biggr\rvert \]<br>\[ \Biggl\lVert\biggl\lVert\Bigl\lVert\bigl\lVert\lVert x<br>\rVert\bigr\rVert\Bigr\rVert\biggr\rVert\Biggr\rVert \]<br></code></pre></td></tr></table></figure><h5 id="省略号"><a href="#省略号" class="headerlink" title="省略号"></a>省略号</h5><p>省略号用<code>\dots</code>,<code>\cdots</code>,<code>\vdots</code>,<code>\ddots</code>等命令表示.</p><p><code>\dots</code>和<code>\cdots</code>的纵向位置不同,前者一般用于有下标的序列.</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex">\[ x_1,x_2,\dots ,x_n\quad 1,2,\cdots ,n\quad<br>\vdots\quad \ddots \]<br></code></pre></td></tr></table></figure><h5 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h5><p><code>amsmath</code>的<code>pmatrix</code>,<code>bmatrix</code>,<code>Bmatrix</code>,<code>vmatrix</code>,<code>Vmatrix</code>等环境可以在矩阵两边加上各种分隔符.</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs latex">\[ \begin&#123;pmatrix&#125; a&amp;b\\c&amp;d \end&#123;pmatrix&#125; \quad<br>\begin&#123;bmatrix&#125; a&amp;b\\c&amp;d \end&#123;bmatrix&#125; \quad<br>\begin&#123;Bmatrix&#125; a&amp;b\\c&amp;d \end&#123;Bmatrix&#125; \quad<br>\begin&#123;vmatrix&#125; a&amp;b\\c&amp;d \end&#123;vmatrix&#125; \quad<br>\begin&#123;Vmatrix&#125; a&amp;b\\c&amp;d \end&#123;Vmatrix&#125; \]<br></code></pre></td></tr></table></figure><p>使用<code>smallmatrix</code>环境,可以生成行内公式的小矩阵</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">Marry has a little matrix $(\begin&#123;smallmatrix&#125; a&amp;b\\c&amp;d \end&#123;smallmatrix&#125; )$.<br></code></pre></td></tr></table></figure><h5 id="多行公式"><a href="#多行公式" class="headerlink" title="多行公式"></a>多行公式</h5><ul><li>有的公式特别长,需要手动为他们换行</li><li>有几个公式是一组,我们需要将他们放在一起</li><li>还有些类似分段函数,我们需要给他加上一个左边的花括号</li></ul><h6 id="长公式"><a href="#长公式" class="headerlink" title="长公式"></a>长公式</h6><h6 id="不对齐"><a href="#不对齐" class="headerlink" title="不对齐"></a>不对齐</h6><p>无须对齐的长公式可以使用<code>multline</code>环境.</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">\begin&#123;multline&#125;<br>x = a+b+c+&#123;&#125; \\<br>d+e+f+g<br>\end&#123;multline&#125;<br></code></pre></td></tr></table></figure><p>如果不需要编号,则可以使用<code>multline*</code>环境代替.</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[UTF8]&#123;ctexart&#125;<br>\usepackage&#123;amsmath&#125;<br>\begin&#123;document&#125;<br>\begin&#123;multline*&#125;<br>x = a+b+c+&#123;&#125; \\<br>d+e+f+g<br>\end&#123;multline*&#125;<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><h6 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h6><p>需要对齐公式,可以使用<code>aligned</code>次环境来实现,它必须包含在数学环境之内</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">\[\begin&#123;aligned&#125;<br>x =&#123;&#125;&amp; a+b+c+&#123;&#125; \\<br>&amp;d+e+f+g<br>\end&#123;aligned&#125;\]<br></code></pre></td></tr></table></figure><h6 id="公式组"><a href="#公式组" class="headerlink" title="公式组"></a>公式组</h6><p>无需对齐公式的公式组可以使用<code>gather</code>环境,需要对齐的公式组可以使用<code>align</code>环境</p><p>他们都带有编号,如果不需要编号可以使用待星花的版本.</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs latex">\begin&#123;gather&#125;<br>a=b+c+d \\<br>x=y+z<br>\end&#123;gather&#125;<br>\begin&#123;align&#125;<br>a &amp;= b+c+d \\<br>x &amp;= y+z<br>\end&#123;align&#125;<br></code></pre></td></tr></table></figure><h6 id="分段函数"><a href="#分段函数" class="headerlink" title="分段函数"></a>分段函数</h6><p>分段函数可以用<code>cases</code>次环境来实现,它必须包含在数学环境之内.</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">\[ y\begin&#123;cases&#125;<br>-x,\quad x\leq 0 \\<br>x,\quad x&gt;0<br>\end&#123;cases&#125; \]<br></code></pre></td></tr></table></figure><h4 id="插入图片和表格"><a href="#插入图片和表格" class="headerlink" title="插入图片和表格"></a>插入图片和表格</h4><h5 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h5><p>LaTeX中插入图片,有很多种方式.</p><p>最好用的应当属利用<code>graphicx</code>宏包提供的<code>\includegraphics</code>命令</p><p>比如,在TeX源文件同目录下,有名为<code>a.jpg</code>的图片,可以用这样的方式将他插入到输出文档中:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[UTF8]&#123;ctexart&#125;<br>\usepackage&#123;graphicx&#125;<br>\begin&#123;document&#125;<br>\includegraphics&#123;a.jpg&#125;<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><p>图片可能很大,超过了输出文件的纸张大小,或者输出效果不是很好</p><p>此时可以用<code>\includegraphics</code>控制序列的可选参数来控制.</p><p>比如:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\includegraphics[width = .8\textwidth]&#123;a.jpg&#125;<br></code></pre></td></tr></table></figure><p>这样图片的高度会缩小为原来的80%,图片的总高度会按比例缩放</p><p><code>\includegraphics</code>控制序列还有若干其他的可选参数,一般用不到,具体可以查看该宏包的<a href="http://texdoc.net/texmf-dist/doc/latex/graphics/graphicx.pdf" target="_blank" rel="noopener">参考文档</a></p><h5 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h5><p><code>tabular</code>环境提供了最简单的表格功能.它用<code>\hline</code>命令表示横线,在列格式中用<code>|</code>表示竖线,用<code>&amp;</code>来进行分列,用<code>\\</code>来换行,每列可以采用居左,居中,居右等横向对齐方式,分别用<code>l</code>,<code>c</code>,<code>r</code>来表示</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs latex">\begin&#123;tabular&#125;&#123;l|c|r&#125;<br>\hline<br>操作系统&amp;发行版&amp;编辑器\\<br>\hline<br>Windows &amp; MikTeX &amp;TexMakerX \\<br>\hline<br>Unix/Linux &amp; teTeX &amp; Kile \\<br>\hline<br>Mac OS &amp; MacTeX &amp; TeXShop \\<br>\hline<br>通用&amp; TeX Live &amp; TeXworks \\<br>\hline<br>\end&#123;tabular&#125;<br></code></pre></td></tr></table></figure><p>浮动体</p><p>插图和表格通常需要占据大块空间,所以在文字处理软件中我们经常需要调整他们的位置</p><p><code>figure</code>和<code>table</code>环境可以自动完成这样的任务</p><p>这种自动调整位置的环境称作浮动体(float)</p><p>以<code>figure</code>为例</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs latex">\begin&#123;figure&#125;[htbp]<br>\centering% 使插图居中<br>\includegraphics&#123;a.jpg&#125;<br>\caption&#123;有图有真相&#125;% 设置插图标题<br>\label&#123;fig:myphoto&#125;  <br>\end&#123;figure&#125;<br></code></pre></td></tr></table></figure><p><code>htbp</code>选项用来指定插图的理想位置,如下表所示:</p><div class="table-container"><table><thead><tr><th style="text-align:center">here</th><th style="text-align:center">top</th><th style="text-align:center">bottom</th><th style="text-align:center">float page(专门放浮动体的单独页面或芬兰)</th></tr></thead><tbody><tr><td style="text-align:center">这里</td><td style="text-align:center">页眉</td><td style="text-align:center">页尾</td><td style="text-align:center">浮动页</td></tr></tbody></table></div><h3 id="版面设置"><a href="#版面设置" class="headerlink" title="版面设置"></a>版面设置</h3><h4 id="页边距"><a href="#页边距" class="headerlink" title="页边距"></a>页边距</h4><p>设置页边距,推荐使用<code>geometry</code>宏包,可以看到<a href="http://texdoc.net/texmf-dist/doc/latex/geometry/geometry.pdf" target="_blank" rel="noopener">文档</a></p><p>将纸张的长度设置为20cm,宽度设置为15cm,左边距1cm,右边距2cm,上边距3cm,下边距4cm,可以在导言区加上这样的几行:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex">\usepackage&#123;geometry&#125;<br>\geometry&#123;papersize=&#123;20cm,15cm&#125;&#125;<br>\geometry&#123;left=1cm,right=2cm,top=3cm,bottom=4cm&#125;<br></code></pre></td></tr></table></figure><p>页眉页脚,推荐使用<code>fancyhdr</code>宏包,可以在这里查看它的<a href="http://texdoc.net/texmf-dist/doc/latex/fancyhdr/fancyhdr.pdf" target="_blank" rel="noopener">说明文档</a></p><p>页眉左边写上我的名字,中间写上今天的日期,右边写上我的电话</p><p>页脚的正中写上页码,页眉和正文之间有一道宽为0.4pt的横线分割,可以在导言区加上如下几行:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs latex">\usepackage&#123;fancyhdr&#125;<br>\pagestyle&#123;fancy&#125;<br>\lhead&#123;\author&#125;<br>\chead&#123;\date&#125;<br>\rhead&#123;18757479599&#125;<br>\lfoot&#123;&#125;<br>\cfoot&#123;\thepage&#125;<br>\rfoot&#123;&#125;<br>\renewcommand&#123;\headrulewidth&#125;&#123;0.4pt&#125;<br>\renewcommand&#123;\headwidth&#125;&#123;\textwidth&#125;<br>\renewcommand&#123;\footrulewidth&#125;&#123;0pt&#125;<br></code></pre></td></tr></table></figure><h4 id="首行缩进"><a href="#首行缩进" class="headerlink" title="首行缩进"></a>首行缩进</h4><p>CTeX宏集已经处理好了首行缩进的问题(自然段前空两格汉字宽度)</p><p>因此,使用CTeX宏集进行中西文混合排版时,不需要关注首行缩进的问题.</p><h4 id="行间距"><a href="#行间距" class="headerlink" title="行间距"></a>行间距</h4><p>可以通过<code>setspace</code>宏包提供的命令来调整行间距</p><p>在导言区添加如下内容,可以将行距设置为字号的1.5倍</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex">\usepackage&#123;setspace&#125;<br>\onehalfspacing<br></code></pre></td></tr></table></figure><p>注意用词的差别</p><ul><li>行距是字号的1.5倍</li><li>1.5倍行距</li></ul><p>事实上,这不是设置1.5倍行距的正确方法,具体可看<a href>此处</a></p><h4 id="段间距"><a href="#段间距" class="headerlink" title="段间距"></a>段间距</h4><p>可以通过修改长度<code>\parskip</code>的值来调整段间距.</p><p>在导言区添加如下内容:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\addtolength&#123;\parskip&#125;&#123;.4em&#125;<br></code></pre></td></tr></table></figure><h3 id="命令与环境"><a href="#命令与环境" class="headerlink" title="命令与环境"></a>命令与环境</h3><p>LaTeX中的命令通常是由一个反斜杠加上命令名称，再加上花括号内的参数构成的(有的命令不带参数，例如<code>\TeX</code>)</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass&#123;ctexart&#125;<br></code></pre></td></tr></table></figure><p>如果有一些选项是备选的，那么通常会在花括号前用方括号标出，比如：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[a4paper]&#123;ctexart&#125;<br></code></pre></td></tr></table></figure><p>还有一种重要指令叫做环境。它被定义于控制命令<code>\begin{environment}</code>和<code>\end{environment}</code>间的内容。比如：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex">\begin&#123;document&#125;<br>...内容...<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><p>环境如果有备选参数，只需要写在<code>\begin[...]{name}</code>这里就行。</p><p>注意：不带花括号的命令后面如果想打印空格，需加上<strong>一对内部为空的花括号</strong>再键入空格。否则空格会被忽略。例如<code>\LaTeX{}Studio</code></p><p><strong>有时候LaTeX编译出现异常，需要删除文件夹下除了tex以外的文件再编译。</strong></p><p><strong>另外，在某些独占程序打开了以上文件时(比如用Acrobat打开了pdf)，编译可能出现错误。在编译时确保关闭这些独占程序。</strong></p><h3 id="保留字符-共8个"><a href="#保留字符-共8个" class="headerlink" title="保留字符(共8个)"></a>保留字符(共8个)</h3><p>#：自定义命令时，用于标明参数序号</p><p>$： 数学环境命令符</p><p>%：注释符，在其后的该行命令都会视为注释。如果在回车前输入这个命令，可以防止行末LaTeX插入一些奇怪的空白符。</p><p>^：数学环境中的上标命令符。</p><p>&amp;：表格环境中的跳列符</p><p>_：数学环境中的下标命令符</p><p>{与}：花括号用于标记命令的必选参数，或者标记某一部分命令称为一个整体。</p><p>\：反斜杠用于开始各种LaTeX命令。</p><blockquote><p>以上命令除了反斜杠，均能在前加反斜杠的形式输出。</p></blockquote><p>反斜杠输出：<code>\texttt{\char92}</code></p><p>其中命令<code>\char[num]</code>是一个特殊的命令，使用环境需要是tt字体环境，用于输出USCII码对应的字符，92对应的即反斜杠。</p><p>也可以使用   <strong>\char`</strong>  后加字符的方式输出想要的命令，但需要包裹在<code>\texttt</code>或者<code>\ttfamily</code>内、如果想要输出的字符是保留字，则需要在前面加一个反斜杠。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex">\texttt&#123;\char`~&#125;% 输出一个波浪线<br>\texttt&#123;\char`\\&#125;% 输出保留字反斜杠<br>\texttt&#123;\char`@&#125;% 实际上可直接输入@<br></code></pre></td></tr></table></figure><p>另外上面说的波浪线<code>~</code>用来输出一个禁止在该处断行的空格，也不能能够直接输出。</p><p>尝试：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">a $\sim$ b<br>a\~b<br>a\~&#123;&#125; b<br>a\textasciitilde b<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/image1.png" width="30%"></p><h3 id="导言区"><a href="#导言区" class="headerlink" title="导言区"></a>导言区</h3><p>任何一份LaTeX文档都应当包含如下结构：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[options]&#123;doc-class&#125;<br>% 导言区<br>\begin&#123;document&#125;<br>...<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><p>其中，在语句<code>\begin{document}</code>之前的内容称为<strong>导言区</strong>。导言区可以留空，以可以进行一些文档的准备操作。即，<strong>导言区即为模板定义</strong>。</p><p>文档类参数<strong>doc-class</strong>和可选选项<strong>options</strong>由表3.1取值。</p><div class="table-container"><table><thead><tr><th>doc-class</th><th>文档类</th></tr></thead><tbody><tr><td>article</td><td>科学期刊，演示文稿，段报告，邀请函</td></tr><tr><td>proc</td><td>基于article的会议论文集</td></tr><tr><td>report</td><td>多章节的长报告、博士论文、短篇书</td></tr><tr><td>book</td><td>书籍</td></tr><tr><td>slides</td><td>幻灯片，使用了大号Scans Serif字体</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>options</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td>字体</td><td style="text-align:left">默认10pt，可选11pt和12pt</td></tr><tr><td>页面方向</td><td style="text-align:left">默认竖向protrait，可选横向landscape</td></tr><tr><td>纸张尺寸</td><td style="text-align:left">默认letterpaper，可选用a4paper，b5paper等</td></tr><tr><td>分栏</td><td style="text-align:left">默认onecolumn，还有twocolumn</td></tr><tr><td>双面打印</td><td style="text-align:left">有oneside/twoside两个选项，用于排版奇偶页。article/report默认单页</td></tr><tr><td>章节分页</td><td style="text-align:left">有openright/openany两个选项，决定是在奇数页开启新页或是任意页开启新页。注意article是没有chapter(“章”)命令的，默认任意页。</td></tr><tr><td>公式对齐</td><td style="text-align:left">默认居中，可改为左对齐fleqn，默认编号居中，可改为左对齐leqno</td></tr><tr><td>草稿选项</td><td style="text-align:left">默认final，可改为draft，使行溢出的部分显示为黑块。</td></tr></tbody></table></div><p>在导言区最常见的是<strong>宏包</strong>的加载工作，命令形如：<code>\usepackage{package}</code>。</p><p>宏包是一系列已经制作好的功能”模块”，在需要使用一些原生LaTeX不带有的功能时，只需要调用这些宏包就可以了。</p><h3 id="标点与强调"><a href="#标点与强调" class="headerlink" title="标点与强调"></a>标点与强调</h3><p>英文符号$|&lt;&gt;+=$一般用于数学环境中，如果在文本中使用，在两侧加上”$”</p><p>如果在LaTeX中直接输入大于，小于号而不把他们放在数学环境中，它们并不会被正确地打印。</p><p>应该使用<code>\textgreater</code>、<code>\textless</code>命令。</p><h4 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h4><p>英文单引号：左单引号是重音符`(键盘上1左侧)，右单引号是常用的引号符</p><p>英文双引号：左双引号是连续两个重音符``(键盘上1左侧)，右双引号是常用的引号符</p><p>英文下的引号嵌套需要借助<code>\thinspace</code>命令分隔，比如：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">``\thinspace`Max&apos; is here.&apos;&apos;<br></code></pre></td></tr></table></figure><p>中文下册单引号和双引号可用中文输入法直接输入。</p><h4 id="破折、省略号与短横"><a href="#破折、省略号与短横" class="headerlink" title="破折、省略号与短横"></a>破折、省略号与短横</h4><p>英文短横分为三种：</p><ul><li>连字符：输入一个短横：-，效果如daughter-in-law</li><li>数字起止符：输入链各个短横：- -，效果如：page 1-2</li><li>破折号：输入三个短横 - - -，效果如：Listen—I’m serious.</li></ul><p>中文的破折号可以直接使用日常的输入方式。中文的省略号同样。但是注意，英文的省略号使用<code>\ldots</code>这个命令而不是三个句点。</p><h4 id="强调：粗与斜"><a href="#强调：粗与斜" class="headerlink" title="强调：粗与斜"></a>强调：粗与斜</h4><p>LaTeX中专门有个叫做<code>\emph{text}</code>的命令，可以强调文本。对于通常的西文文本，上述命令的作用就是斜体。如果对一段已经这样转为斜体的文本再使用这个命令，他就会取消斜体，而成为正体。</p><p><strong>因为一般采用斜体强调的方式而不是粗体</strong></p><h4 id="下划线与删除线"><a href="#下划线与删除线" class="headerlink" title="下划线与删除线"></a>下划线与删除线</h4><p>建议使用<strong>ulem</strong>宏包中的uline命令代替原生的，<strong>ulem</strong>宏包还提供了一些实用命令：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[a4paper]&#123;ctexart&#125;<br>\usepackage[normalem]&#123;ulem&#125;<br><br>\begin&#123;document&#125;<br>\uline&#123;下划线&#125;<br>\uuline&#123;双下划线&#125;<br>\dashuline&#123;虚下划线&#125;<br>\dotuline&#123;点下划线&#125;<br>\uwave&#123;波浪线&#125;<br>\sout&#123;删除线&#125;<br>\xout&#123;斜删除线&#125;<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/image2.png" width="30%"></p><p>需要注意，<strong>ulem</strong>宏包冲定义了<code>\emph</code>命令，<strong>使得原来的加斜强调变成了下划线，原来的两次强调就取消强调变成了两次强调就双下划线。</strong></p><p>通过宏包的<strong>normalem</strong>选项可以取消这个更改：<code>\usepackage[normalem]{ulem}</code></p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>角度符号或者温度符号需要借助数学模式$…$输入：</li></ul><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex">$30\,^&#123;\circ&#125;$ 三角形<br>$37\,^&#123;\circ&#125;\mathrm&#123;C&#125;$<br></code></pre></td></tr></table></figure><ul><li>欧元符号可能需要用到<strong>textcomp</strong>宏包支持的<code>\texteuro</code>命令</li><li>千分位分隔符，如果不想它在中间断行，就在外侧再加上一个<code>\mbox</code>命令：<code>\mbox{1\,000\,000}</code></li><li>注音符号</li></ul><p><strong>hologo</strong>宏包，它允许输出许多TeX家族标志。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">\LaTeX<br>\TeX<br>\hologo&#123;XeLaTeX&#125;<br>\hologo&#123;BibTex&#125;<br></code></pre></td></tr></table></figure><h3 id="格式控制"><a href="#格式控制" class="headerlink" title="格式控制"></a>格式控制</h3><p>LaTeX的长度单位：</p><ul><li><strong>pt</strong>：point，磅</li><li><strong>pc</strong>：pica，1pc=12pt，四号字大小</li><li><strong>in</strong>：inch，英寸，1in=72.72pt</li><li><strong>bp</strong>：bigpoint，大点。1bp=$\tfrac1{12}$in</li><li><strong>cm</strong>：centimeter，厘米，1cm=$\tfrac1{2.54}$in</li><li><strong>mm</strong>：millimeter，毫米，1mm=$\tfrac1{10}$cm</li><li><strong>sp</strong>：scaled point，TeX的基本长度单位，1sp=$\tfrac1{65536}$pt</li><li><strong>em</strong>：当前字号下，大写字母的宽度</li><li><strong>ex</strong>：当前字号下，小写字母x的高度</li></ul><p>几个常用的长度宏：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex">\textwidth % 页面上文字的总宽度，即页宽减去两侧边距<br>\linewidth % 当前行允许的行宽<br></code></pre></td></tr></table></figure><p>有时候可以使用可变长度，比如”5pt plus 3pt minus 2pt”，表示一个能收缩到3pt也能伸长到8pt的长度，直接使用倍数也是允许的，例如：1.5<code>\parindent</code>等。</p><p>通常使用<code>\hspace{len}</code>和<code>\vspace{len}</code>这两个命令控制特殊的空格。</p><h4 id="空格、换行与分段"><a href="#空格、换行与分段" class="headerlink" title="空格、换行与分段"></a>空格、换行与分段</h4><p>在LaTeX中，多个空格会被视为一个，多个换行也会被视为一个，如果想要禁止LaTeX在某个空格处的换行，将空格用~命令替代即可，比如”Fig .~8”</p><p>通常的换行方法非常简单：LaTeX会自动转行，然后在每一段的末尾，只需要输入两个回车即可完成分段。如果需要一个空白段落(实质是一个空白行)，先输入两个回车，再输入<code>\mbox{}</code>，最后再输入两个回车即可。也可以用<code>\par</code>来产生一个带缩进的新段。</p><p><strong>正文中想要换行，直接使用两个回车。</strong></p><p>段落之间的距离由<code>\parskip</code>控制，默认”0pt plus 1pt”</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\setlength&#123;\parskip&#125;&#123;0pt&#125;<br></code></pre></td></tr></table></figure><p>宏包<strong>lettrine</strong>能够产生首字下沉的效果：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex">\lettrine&#123;T&#125;&#123;his&#125; is an example.<br>Hope you like this package,<br>and enjoy your \LaTeX\ trip!<br></code></pre></td></tr></table></figure><h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><p>用<code>\newpage</code>命令开始新的一页</p><p>用<code>\clearpage</code>命令清空浮动体队列，并开始新的一页</p><p>用<code>\cleardoublepage</code>命令清空浮动体队列，并在偶数页上开始新的一页</p><p>注意：以上命令都是基于<code>\vfill</code>的，如果要连续新开两页，在中间加上一个空的箱子(<code>\mbox{}</code>)，如<code>\newpage\mbox{}\newpage</code></p><h4 id="缩进、对齐与行距"><a href="#缩进、对齐与行距" class="headerlink" title="缩进、对齐与行距"></a>缩进、对齐与行距</h4><p>英文的段首不需要缩进，但是对中文而言，段首缩进需要借助<strong>indentfirst</strong>宏包来完成</p><p>可能还需要使用<code>\setlength\parindent{2em}</code>这样的命令来设置缩进距离</p><p>如果在行首强制取消缩进，可以在段首使用<code>\noindent</code>命令</p><p>LaTeX默认使用两端对齐的排版方式。也可以使用<code>flushleft</code>，<code>flushright</code>，<code>center</code>这三种环境来构造居左，居中，居右三种效果。</p><h4 id="字体与颜色"><a href="#字体与颜色" class="headerlink" title="字体与颜色"></a>字体与颜色</h4><p>字族：宋体，黑体，楷体，罗马体，等宽体</p><p>字系和字形：加粗，加斜</p><p>字号：五号，小四</p><p><strong>字族+字系和字形+字号=字体</strong></p><h5 id="原生字体命令"><a href="#原生字体命令" class="headerlink" title="原生字体命令"></a>原生字体命令</h5><p>LaTeX提供了基本的字体命令</p><p>字族</p><ul><li><code>\rmfamily</code>：把字体设置为Roman罗马字族</li><li><code>\saffamily</code>：把字体设置为Sans Serif无衬线字族</li><li><code>\ttfamily</code>：把字体设置为Typewriter等宽字族</li></ul><p>字系</p><ul><li><code>\bfseries</code>：粗体BoldSeries字系属性</li><li><code>\mdseries</code>：中粗体MiddleSeries字系属性</li></ul><p>字形</p><ul><li><code>\upshape</code>：竖直Upright字形</li><li><code>\slshape</code>：斜体Slant字形</li><li><code>\itshape</code>：强调体Italic字形</li><li><code>\scshape</code>：小号大写体SCAP字形</li></ul><p>如果临时改变字体，使用<code>\textrm</code>，<code>\textbf</code>这类命令</p><p>字族，字系，字形三种命令是相互独立的，可以任意组合使用。</p><p>但这种复合字体的效果有时候无法达到(因为没有对应的设计)，比如<code>\scshape</code>字形和<code>\bfseries</code>字系。</p><p>如果在文中多次使用某种字体变换，可以将其自定义成一个命令。</p><p>使用text系列的命令而不要使用family，series或shape系列的命令。</p><p>否则需要多加一组花括号防止”泄露”。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">􏲨􏲫􏱌􏲲􏲩􏰾􏲪􏲪􏲬􏲫􏰼􏲮􏲨􏲩􏰾􏲫􏲩􏱌􏱖􏰺􏲯􏳭􏰉􏳮􏲮􏲨􏰺􏱌􏱛􏰺􏲰􏲿􏲮􏸙􏰉􏲯􏲯􏲨􏲫􏱌􏲲􏲩􏰾􏲪􏲪􏲬􏲫􏰼􏲮􏲨􏲩􏰾􏲫􏲩􏱌􏱖􏰺􏲯􏳭􏰉􏳮􏲮􏲨􏰺􏱌􏱛􏰺􏲰􏲿􏲮􏸙􏰉􏲯􏲯􏲨􏲫􏱌􏲲􏲩􏰾􏲪􏲪􏲬􏲫􏰼􏲮􏲨􏲩􏰾􏲫􏲩􏱌􏱖􏰺􏲯􏳭􏰉􏳮􏲮􏲨􏰺􏱌􏱛􏰺􏲰􏲿􏲮􏸙􏰉\newcommand&#123;\concept&#125;[1]&#123;\textbf&#123;#1&#125;&#125;<br></code></pre></td></tr></table></figure><h6 id="字号命令"><a href="#字号命令" class="headerlink" title="字号命令"></a>字号命令</h6><p>在行文中会有一个默认的”标准”字号，比如在documentclass的选项中设置的12pt</p><p>在LaTeX中给出了一系列”相对字号命令”，此外，<strong>ctex</strong>宏包的<code>\zihao</code>命令，参数0-8以及-0–8表示初号到八号，小初到小八</p><p>日常使用的小四为12pt，五号为10.5pt</p><div class="table-container"><table><thead><tr><th>命令</th><th>10pt</th><th>11pt</th><th>12pt</th></tr></thead><tbody><tr><td>\tiny</td><td>5pt</td><td>6pt</td><td>6pt</td></tr><tr><td>\scriptsize</td><td>7pt</td><td>8pt</td><td>8pt</td></tr><tr><td>\footnotesize</td><td>8pt</td><td>9pt</td><td>10pt</td></tr><tr><td>\small</td><td>9pt</td><td>10pt</td><td>11pt</td></tr><tr><td>\normalsize</td><td>10pt</td><td>11pt</td><td>12pt</td></tr><tr><td>\large</td><td>12pt</td><td>12pt</td><td>14pt</td></tr><tr><td>\Large</td><td>14pt</td><td>14pt</td><td>17pt</td></tr><tr><td>\LARGE</td><td>17pt</td><td>17pt</td><td>20pt</td></tr><tr><td>\huge</td><td>20pt</td><td>20pt</td><td>25pt</td></tr><tr><td>\Huge</td><td>25pt</td><td>25pt</td><td>25pt</td></tr></tbody></table></div><p>如果想要设置特殊的字号，使用：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\fontsize&#123;font-size&#125;&#123;line-height&#125;&#123;\selectfont &lt;text&gt;&#125;<br></code></pre></td></tr></table></figure><p>其中<strong>font-size</strong>填数字，单位pt，一般而言，<strong>line-height</strong>填<code>\baselineskip</code></p><p>默认全文的字体使用<code>\rmfamily</code>族的字体。可以通过重定义的方式改变他，使<code>\rmfamily</code>，<code>\textrm</code>命令都指向新的字体。甚至把默认字体改为sf/tt字族。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs latex">\renewcommand&#123;\rmdefault&#125;&#123;font-name&#125;<br>% 默认字体改为sf字族，也可以用\ttdefault<br>\renewcommand&#123;\familydefault&#125;&#123;\sfdefault&#125;<br>\renewcommand&#123;\sfdefault&#125;&#123;font-name&#125;<br>% 如果你的排版CJK文档，还需要更改CJK默认字体<br>\renewcommand&#123;\CJKfamilydefault&#125;&#123;\CJKsfdefault&#125;<br></code></pre></td></tr></table></figure><h6 id="西文字体"><a href="#西文字体" class="headerlink" title="西文字体"></a>西文字体</h6><p>LaTeX预报含如下字体：</p><div class="table-container"><table><thead><tr><th>命令</th><th>字体名</th></tr></thead><tbody><tr><td>cmr</td><td>Computer Modern Roman(默认)</td></tr><tr><td>lmr</td><td>Latin Modern Roman</td></tr><tr><td>pbk</td><td>Bookman</td></tr><tr><td>ppl</td><td>Palatino</td></tr><tr><td>lmss</td><td>Latin Modern Roman Serif</td></tr><tr><td>phv</td><td>Helvetica</td></tr><tr><td>lmtt</td><td>Latin Modern</td></tr></tbody></table></div><p>以上可以这样使用</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">\newcommand&#123;\myfont&#125;[2]&#123;&#123;\fontfamily&#123;#1&#125;\selectfont #2&#125;&#125;<br>\renewcommand&#123;\rmdefault&#125;&#123;ptm&#125;% 可更改默认字体，同理可改sfdefault等<br>% 以上在导言区定义，在正文中：<br>Let&apos;s change font to \myfont&#123;pp1&#125;&#123;Palatino&#125;!<br></code></pre></td></tr></table></figure><h6 id="中文支持与CJK字体"><a href="#中文支持与CJK字体" class="headerlink" title="中文支持与CJK字体"></a>中文支持与CJK字体</h6><p>中文方面，<strong>ctex</strong>宏包直接定义了新的中文文档类ctexart，ctexrep，ctexbook，ctexbeamer</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[a4paper,zihao=-4,linespread=1]&#123;ctexrep&#125;<br>\renewcommand&#123;\CTEXthechapter&#125;&#123;\thechapter&#125;<br></code></pre></td></tr></table></figure><p> 以上设置字号为小四，行距因子为1(故行距为1x1.2=1.2倍，其中1.2是LaTeX默认的基线间距)</p><p>a4paper选项继承与原生文档类report，可见ctex文档类还是很好地保留了原生文档类的特征</p><p>值得注意的是，<strong>ctex文档类会用<code>\CTEX</code>开头的计数器命令代替原有的</strong></p><p><strong>除非使用scheme=plain来让ctex文档类仅支持中文而不做任何文档细节更改</strong></p><p><strong>ctex</strong>宏包支持一下字体命令：</p><ul><li>宋体：<code>\songti</code></li><li>黑体：<code>\heiti</code></li><li>仿宋：<code>\fangsong</code></li><li>楷书：<code>\kaishu</code></li><li>雅黑：<code>\yahei</code></li><li>隶书：<code>\lishu</code></li><li>幼圆：<code>\youyuan</code></li></ul><h5 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h5><p>使用<strong>xcolor</strong>宏包来方便地调用颜色</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs latex">\usepackage&#123;xcolor&#125;<br>\definecolor&#123;keywordcolor&#125;&#123;RGB&#125;&#123;34,34,250&#125;<br><br>% 指定颜色的text<br>&#123;\color&#123;color-name&#125;&#123;text&#125;&#125;<br></code></pre></td></tr></table></figure><p><strong>xcolor</strong>宏包预定义的颜色：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/image3.png" width="70%"></p><p>还可以通过”调色”做出新的效果</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex">&#123;\color&#123;red!70&#125;百分之70红色&#125;<br>&#123;\color&#123;blue!50!black!20!white!30&#125;50蓝20黑30白&#125;<br>&#123;\color&#123;-yellow&#125;黄色的互补色&#125;<br></code></pre></td></tr></table></figure><h3 id="引用与注释"><a href="#引用与注释" class="headerlink" title="引用与注释"></a>引用与注释</h3><p>电子文档最大优越性在于能够使用超链接，跳转标签、目录，甚至访问外部网站。这些功能都需要引用。</p><h4 id="标签和引用"><a href="#标签和引用" class="headerlink" title="标签和引用"></a>标签和引用</h4><p>使用<code>\label</code>命令插入标签(在MS Word中称为”题注”)，然后在其他地方用<code>\ref</code>或者<code>\pageref</code>命令进行引用，分别引用标签的序号、标签所在的页的页码。</p><figure class="hljs highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">\<span class="hljs-selector-tag">label</span>&#123;<span class="hljs-attribute">section</span>:this&#125;<br>\<span class="hljs-selector-tag">ref</span>&#123;<span class="hljs-attribute">section</span>:this&#125;<br>\<span class="hljs-selector-tag">pageref</span><br></code></pre></td></tr></table></figure><h3 id="中英文之间空格问题解决"><a href="#中英文之间空格问题解决" class="headerlink" title="中英文之间空格问题解决"></a>中英文之间空格问题解决</h3><p><code>&lt;\hspace{0em}变量\hspace{0em}&gt;</code></p><h3 id="空格设置"><a href="#空格设置" class="headerlink" title="空格设置"></a>空格设置</h3><p><code>\hspace{0em}</code></p><h3 id="空行距离"><a href="#空行距离" class="headerlink" title="空行距离"></a>空行距离</h3><p><code>\vspace{3mm}</code></p><h3 id="两端对齐"><a href="#两端对齐" class="headerlink" title="两端对齐"></a>两端对齐</h3><p><code>\usepackage{ragged2e}</code></p><p><code>\justifying</code></p><h3 id="分数"><a href="#分数" class="headerlink" title="分数"></a>分数</h3><p>分数小：$\tfrac{1}{2}$</p><p>分数大：$\dfrac{1}{2}$</p><h3 id="摄氏度"><a href="#摄氏度" class="headerlink" title="摄氏度"></a>摄氏度</h3><p>$^{\circ}$C</p><h3 id="max下面加限制范围"><a href="#max下面加限制范围" class="headerlink" title="max下面加限制范围"></a>max下面加限制范围</h3><p>$y_{N+1}=\arg \max \limits_{y_{N+1}} \hat{P}(y_{N+1}|x_{N+1})$</p><p><a herf="https://huris.oss-cn-hangzhou.aliyuncs.com/avatar.jpg"></a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机工具 </category>
          
          <category> LaTex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matlab画图总结</title>
      <link href="/2019/08/02/Matlab%E7%94%BB%E5%9B%BE%E6%80%BB%E7%BB%93/"/>
      <url>/2019/08/02/Matlab%E7%94%BB%E5%9B%BE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-built_in">plot</span><br>数据点: . o x + * S(正方形) H(六角星) D(菱形) p(五角星) V(倒三角) ^(三角形) &gt;(右三角) &lt;(左三角)<br>线型:  -  -.  --  : <br>颜色:r-red，g-green，b-blue，w-white，k-black，<span class="hljs-built_in">i</span>-invisible(无色)，y-yellow<br><br><span class="hljs-built_in">legend</span>(<span class="hljs-string">'a'</span>)<br>title(<span class="hljs-string">'a'</span>)<br>xlabel(<span class="hljs-string">'T'</span>)<br>ylabel(<span class="hljs-string">'a'</span>)<br><br>set(gca, <span class="hljs-string">'Box'</span>, <span class="hljs-string">'off'</span>, <span class="hljs-string">'TickDir'</span>, <span class="hljs-string">'out'</span>, <span class="hljs-string">'TickLength'</span>, [<span class="hljs-number">.02</span> <span class="hljs-number">.02</span>], ...<br>    <span class="hljs-string">'XMinorTick'</span>, <span class="hljs-string">'on'</span>, <span class="hljs-string">'YMinorTick'</span>, <span class="hljs-string">'on'</span>, <span class="hljs-string">'XGrid'</span>, <span class="hljs-string">'on'</span>, <span class="hljs-string">'YGrid'</span>, <span class="hljs-string">'on'</span>,...<br>    <span class="hljs-string">'box'</span>,<span class="hljs-string">'on'</span>, <span class="hljs-string">'XColor'</span>, [<span class="hljs-number">.3</span> <span class="hljs-number">.3</span> <span class="hljs-number">.3</span>], <span class="hljs-string">'YColor'</span>, [<span class="hljs-number">.3</span> <span class="hljs-number">.3</span> <span class="hljs-number">.3</span>],<span class="hljs-string">'LineWidth'</span>, <span class="hljs-number">1</span>)<br><br>LineWidth    线宽,数值,如<span class="hljs-number">0.5</span>,<span class="hljs-number">1</span>等,单位为points<br>MarkerEdgeColor   标记点边框线条颜色,颜色字符,如’g’,’b’等<br>MarkerFaceColor   标记点内部区域填充颜色,颜色字符<br>MarkerSize   标记点大小,数值,单位为points<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
            <tag> 画图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim速查表</title>
      <link href="/2019/08/02/vim%E9%80%9F%E6%9F%A5%E8%A1%A8/"/>
      <url>/2019/08/02/vim%E9%80%9F%E6%9F%A5%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>本文主要介绍了以下内容:</strong></p><p>本文主要介绍了vim的一些快捷键，方便自己要用的时候查找。</p><a id="more"></a><h2 id="VIM使用说明与快捷键"><a href="#VIM使用说明与快捷键" class="headerlink" title="VIM使用说明与快捷键"></a>VIM使用说明与快捷键</h2><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/vim%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E4%B8%8E%E5%BF%AB%E6%8D%B7%E9%94%AE.jpg"></p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><div class="table-container"><table><thead><tr><th style="text-align:center">移动方向</th><th style="text-align:center">快捷键</th></tr></thead><tbody><tr><td style="text-align:center">左</td><td style="text-align:center">h</td></tr><tr><td style="text-align:center">上</td><td style="text-align:center">j</td></tr><tr><td style="text-align:center">下</td><td style="text-align:center">k</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">l</td></tr></tbody></table></div><h3 id="进入插入模式"><a href="#进入插入模式" class="headerlink" title="进入插入模式"></a>进入插入模式</h3><div class="table-container"><table><thead><tr><th style="text-align:center">插入模式</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">i</td><td style="text-align:center">在光标前面插入</td></tr><tr><td style="text-align:center">I</td><td style="text-align:center">在光标所在行最前面插入</td></tr><tr><td style="text-align:center">a</td><td style="text-align:center">在光标后面插入</td></tr><tr><td style="text-align:center">A</td><td style="text-align:center">在光标所在行最后面插入</td></tr><tr><td style="text-align:center">o</td><td style="text-align:center">光标所在行的下一行插入</td></tr><tr><td style="text-align:center">O</td><td style="text-align:center">光标所在行的上一行插入</td></tr><tr><td style="text-align:center">s</td><td style="text-align:center">删除光标指向的字符并进入插入模式</td></tr><tr><td style="text-align:center">S</td><td style="text-align:center">删除光标所在的行并插入</td></tr></tbody></table></div><h3 id="操作范围"><a href="#操作范围" class="headerlink" title="操作范围"></a>操作范围</h3><div class="table-container"><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">将光标移到行首</td></tr><tr><td style="text-align:center">$</td><td style="text-align:center">将光标移到行尾</td></tr><tr><td style="text-align:center">b  (begin)</td><td style="text-align:center">将光标移到单词起始处</td></tr><tr><td style="text-align:center">e  (end)</td><td style="text-align:center">将光标移到单词末尾</td></tr><tr><td style="text-align:center">w</td><td style="text-align:center">将光标移到下一个单词的开头</td></tr><tr><td style="text-align:center">gg</td><td style="text-align:center">将光标移到文件的开头</td></tr><tr><td style="text-align:center">G</td><td style="text-align:center">将光标移到文件的末尾</td></tr></tbody></table></div><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><div class="table-container"><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">d0</td><td style="text-align:center">删除光标到行首的所有字符</td></tr><tr><td style="text-align:center">d$</td><td style="text-align:center">删除光标到行尾的所有字符</td></tr><tr><td style="text-align:center">db</td><td style="text-align:center">删除光标到该单词行首的所有字符</td></tr><tr><td style="text-align:center">de</td><td style="text-align:center">删除光标到该单词行尾的所有字符</td></tr><tr><td style="text-align:center">dw</td><td style="text-align:center">删除光标到下一个单词开头的所有字符</td></tr><tr><td style="text-align:center">dh</td><td style="text-align:center">删除光标所在字符的上一个字符</td></tr><tr><td style="text-align:center">dl</td><td style="text-align:center">删除光标所在字符</td></tr><tr><td style="text-align:center">dj</td><td style="text-align:center">删除光标所在行和下一行</td></tr><tr><td style="text-align:center">dk</td><td style="text-align:center">删除光标所在行和上一行</td></tr><tr><td style="text-align:center">dd</td><td style="text-align:center">删除光标所在行</td></tr><tr><td style="text-align:center">dgg</td><td style="text-align:center">删除光标所在行到文件开头所有字符</td></tr><tr><td style="text-align:center">dG</td><td style="text-align:center">删除光标所在行到文件末尾所有字符</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 计算机工具 </category>
          
          <category> vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
            <tag> 速查表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数阶乘</title>
      <link href="/2019/08/02/%E5%A4%A7%E6%95%B0%E9%98%B6%E4%B9%98/"/>
      <url>/2019/08/02/%E5%A4%A7%E6%95%B0%E9%98%B6%E4%B9%98/</url>
      
        <content type="html"><![CDATA[<p><strong>本文主要介绍了以下内容:</strong></p><p>求n!具体值c++实现</p><a id="more"></a><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;//大数N!  </span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;  </span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;  <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  <br></span>&#123;  <br>    <span class="hljs-keyword">int</span> n,a[<span class="hljs-number">100000</span>],i,j,wei,up;  <br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n)!=EOF)  <br>    &#123;  <br>        <span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(a));<span class="hljs-comment">//一定要清零  </span><br>        up=<span class="hljs-number">0</span>;  <br>        wei=<span class="hljs-number">1</span>;  <br>        a[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-comment">//当前结果的位数，便于相乘和最后输出   </span><br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>||n==<span class="hljs-number">0</span>)  <br>        &#123;  <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"1\n"</span>);  <br>            <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//如果为1!或0!则输出后直接进行下一个阶乘计算  </span><br>        &#125;  <br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>; i&lt;=n; i++)<span class="hljs-comment">//N!中的每个数  </span><br>        &#123;  <br>            <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>,up=<span class="hljs-number">0</span>; j&lt;=wei; j++)  <br>            &#123;  <br>                a[j]=a[j]*i+up; <span class="hljs-comment">//当前j数加 进位  </span><br>                up=a[j]/<span class="hljs-number">10</span>;<span class="hljs-comment">//进位整除10  </span><br>                a[j]=a[j]%<span class="hljs-number">10</span>;<span class="hljs-comment">//当前数取余存储  </span><br>            &#125;  <br>            <span class="hljs-keyword">while</span>(up&gt;<span class="hljs-number">0</span>)<span class="hljs-comment">//最后首位大于0则要取余进位  </span><br>            &#123;  <br>                a[j++]+=up%<span class="hljs-number">10</span>;<span class="hljs-comment">//j++的值为进位取余 注意 j++导致后面的j加了一  </span><br>                up=up/<span class="hljs-number">10</span>;  <br>            &#125;  <br>            wei=j<span class="hljs-number">-1</span>;<span class="hljs-comment">//减去上面的j++  </span><br>        &#125;  <br>        <span class="hljs-keyword">for</span>(i=wei; i&gt;=<span class="hljs-number">1</span>; i--)  <br>            (i!=<span class="hljs-number">1</span>)? <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,a[i]) : <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,a[i]);<span class="hljs-comment">//三目 判断是否为最后一位 则输出换行  </span><br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
          <category> 算法模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数 </tag>
            
            <tag> 算法模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++文件操作</title>
      <link href="/2018/05/11/c++%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/05/11/c++%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p><strong>本文主要介绍了以下内容:</strong></p><p>c++的读取文件/输入方式总结</p><a id="more"></a><p><strong>getline(istream &amp;in,string &amp;s)</strong></p><p>​    从输入流读入一行到string s</p><p>功能</p><ul><li>从输入流中读取字符，存到string 变量中</li><li>一直到出现以下情况为止<ul><li>读入了文件结束标志</li><li>读到了一个新行</li><li>达到字符串的最大长度</li></ul></li><li>如果getline没有读入字符，将返回false,可用于判断文件是否结束</li></ul><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;<br>    <span class="hljs-built_in">string</span> buff;<br>    ifstream infile;<br>    ofstream outfile;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Input file name: "</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;buff;<br>    infile.open(buff.c_str());<br><br>    <span class="hljs-keyword">if</span>(!infile)<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"error"</span>&lt;&lt;buff&lt;&lt;<span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Input outfile name: "</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;buff;<br>    outfile.open(buff.c_str());<br><br>    <span class="hljs-keyword">while</span>(getline(infile, buff))<br>        outfile&lt;&lt;buff&lt;&lt;<span class="hljs-built_in">endl</span>;<br><br>    infile.close();<br>    outfile.close();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab学习笔记(8)</title>
      <link href="/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-8/"/>
      <url>/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-8/</url>
      
        <content type="html"><![CDATA[<p><strong>本文主要介绍了以下内容:</strong></p><p>matlab程序流程控制:</p><ol><li>M文件的概念与基本操作</li><li>matlab程序控制结构</li><li>matlab函数文件</li><li>matlab程序调试与优化</li></ol><a id="more"></a><h1 id="M文件"><a href="#M文件" class="headerlink" title="M文件"></a>M文件</h1><p>用matlab语言编写的程序,称为M文件</p><p>M文件是由若干matlab命令组合在一起构成的,它可以完成某些操作,也可以实现某种算法</p><p>matlab提供的内部函数以及各种工具箱,都是利用matlab命令开发的M文件</p><p>用户可以根据自己的需要,开发具体的程序或工具箱</p><h2 id="M文件的分类"><a href="#M文件的分类" class="headerlink" title="M文件的分类"></a>M文件的分类</h2><p>通常,M文件可以根据调用方式的不同分为两类:<strong>命令文件(脚本文件)</strong>和<strong>函数文件</strong>,它们的扩展名均为<strong>.m</strong></p><p>主要区别:</p><ol><li><p>命令文件没有参数,也不会返回输出参数,而函数文件可以带参数,也可以返回输出参数</p></li><li><p>命令文件对matlab工作空间中的变量进行操作,文件中所有命令的执行结果也完全返回到工作空间中,而函数文件中定义的变量为<strong>局部变量</strong>,当函数文件执行完毕时,这些变量被清除</p></li><li><p>命令文件可以直接运行,在matlab命令行窗口输入命令文件的名字,就会顺序执行命令文件中的命令,而函数文件不能直接运行,要以函数调用的方式来调用</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab学习笔记(7)</title>
      <link href="/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-7/"/>
      <url>/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-7/</url>
      
        <content type="html"><![CDATA[<p><strong>本文主要介绍了以下内容:</strong></p><p>字符串</p><a id="more"></a><h3 id="字符串的表示"><a href="#字符串的表示" class="headerlink" title="字符串的表示"></a>字符串的表示</h3><p>在matlab中,字符串是用单撇号括起来的字符序列,例如:</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; s=<span class="hljs-string">'hello world'</span><br><br>s =<br><br>    <span class="hljs-string">'hello world'</span><br></code></pre></td></tr></table></figure><p>matlab将字符串当做一个行向量,每个元素对应一个字符,其标识方法和数值向量相同,也可以建立多行字符串矩阵,例如:</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; s=[<span class="hljs-string">'hello '</span>,<span class="hljs-string">'hu ben'</span>]<br><br>s =<br><br>    <span class="hljs-string">'hello hu ben'</span><br></code></pre></td></tr></table></figure><p>这里要求各行字符数要相等,为此,有时候必须添加几个空格来保证各行的长度相等</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; ch=<span class="hljs-string">'abcdefg1234567ABCDEFG'</span><br><br>ch =<br><br>    <span class="hljs-string">'abcdefg1234567ABCDEFG'</span><br><br>&gt;&gt; subch=ch(<span class="hljs-number">1</span>:<span class="hljs-number">5</span>)<span class="hljs-comment">%取子串</span><br><br>subch =<br><br>    <span class="hljs-string">'abcde'</span><br><br>&gt;&gt; revch=ch(<span class="hljs-keyword">end</span>:<span class="hljs-number">-1</span>:<span class="hljs-number">1</span>)<span class="hljs-comment">%反转字符串</span><br><br>revch =<br><br>    <span class="hljs-string">'GFEDCBA7654321gfedcba'</span><br> <br>&gt;&gt; k=<span class="hljs-built_in">find</span>(ch&gt;=<span class="hljs-string">'a'</span>&amp;ch&lt;=<span class="hljs-string">'z'</span>)<span class="hljs-comment">%找到特定字符</span><br><br>k =<br><br>     <span class="hljs-number">1</span>     <span class="hljs-number">2</span>     <span class="hljs-number">3</span>     <span class="hljs-number">4</span>     <span class="hljs-number">5</span>     <span class="hljs-number">6</span>     <span class="hljs-number">7</span><br><br>&gt;&gt; ch(k)=ch(k)-<span class="hljs-string">'a'</span>+<span class="hljs-string">'A'</span><span class="hljs-comment">%修改特定字符</span><br><br>ch =<br><br>    <span class="hljs-string">'ABCDEFG1234567ABCDEFG'</span><br><br>&gt;&gt; <span class="hljs-built_in">length</span>(ch)<span class="hljs-comment">%计算字符串ch的长度</span><br><br><span class="hljs-built_in">ans</span> =<br><br>    <span class="hljs-number">21</span><br></code></pre></td></tr></table></figure><h3 id="字符串的操作"><a href="#字符串的操作" class="headerlink" title="字符串的操作"></a>字符串的操作</h3><h4 id="字符串的执行"><a href="#字符串的执行" class="headerlink" title="字符串的执行"></a>字符串的执行</h4><p>与字符串有关的一个重要函数是<strong>eval</strong>,它的作用是把字符串的内容作为对应的matlab命令来执行,其调用格式为:<strong>eval(s)</strong></p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; t=<span class="hljs-built_in">pi</span><br><br>t =<br><br>   <span class="hljs-number">3.141592653589793</span><br><br>&gt;&gt; m=<span class="hljs-string">'[t,sin(t),cos(t)]'</span>;<br>&gt;&gt; y=eval(m)<br><br>y =<br><br>   <span class="hljs-number">3.141592653589793</span>   <span class="hljs-number">0.000000000000000</span>  <span class="hljs-number">-1.000000000000000</span><br></code></pre></td></tr></table></figure><h4 id="字符串与数值之间的转换"><a href="#字符串与数值之间的转换" class="headerlink" title="字符串与数值之间的转换"></a>字符串与数值之间的转换</h4><p>字符串是以ASCII码来保存的,<strong>abs</strong>和<strong>double</strong>函数都可以用来获取字符串矩阵对应的ASCII码数值矩阵</p><p>相反,<strong>char</strong>函数可以把ASCII码矩阵转换为字符串矩阵,例如:</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; s1=<span class="hljs-string">'matlab'</span><br><br>s1 =<br><br>    <span class="hljs-string">'matlab'</span><br><br>&gt;&gt; a=<span class="hljs-built_in">abs</span>(s1)<br><br>a =<br><br>   <span class="hljs-number">109</span>    <span class="hljs-number">97</span>   <span class="hljs-number">116</span>   <span class="hljs-number">108</span>    <span class="hljs-number">97</span>    <span class="hljs-number">98</span><br><br>&gt;&gt; char(a)<br><br><span class="hljs-built_in">ans</span> =<br><br>    <span class="hljs-string">'matlab'</span><br></code></pre></td></tr></table></figure><p>matlab还有很多用于字符串和数值数据之间转换的函数,例如,<strong>setstr</strong>函数将ASCII码值转换为对应的字符,<strong>str2num</strong>函数或<strong>str2double</strong>函数将数字字符串转换成数值,<strong>num2str</strong>函数将数值转换成字符串,<strong>int2str</strong>函数将整数转换成字符串</p><h4 id="字符串的连接"><a href="#字符串的连接" class="headerlink" title="字符串的连接"></a>字符串的连接</h4><p>用中括号将若干个字符串括起来,从而得到一个更大的字符串</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; a=<span class="hljs-string">'12345'</span>;<br>&gt;&gt; b=<span class="hljs-string">'4321'</span>;<br>&gt;&gt; [a,b]<br><br><span class="hljs-built_in">ans</span> =<br><br>    <span class="hljs-string">'123454321'</span><br></code></pre></td></tr></table></figure><h4 id="字符串的比较"><a href="#字符串的比较" class="headerlink" title="字符串的比较"></a>字符串的比较</h4><h5 id="利用关系运算符进行比较"><a href="#利用关系运算符进行比较" class="headerlink" title="利用关系运算符进行比较"></a>利用关系运算符进行比较</h5><p>当两个字符串长度相等时,可以<strong>直接</strong>利用关系运算符进行比较,比较的规则是按ASCII值大小进行比较的</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; a=<span class="hljs-string">'134567'</span>;<br>&gt;&gt; b=<span class="hljs-string">'213145'</span>;<br>&gt;&gt; a&gt;b<br><br><span class="hljs-built_in">ans</span> =<br><br>  <span class="hljs-number">1</span>×<span class="hljs-number">6</span> logical 数组<br><br>   <span class="hljs-number">0</span>   <span class="hljs-number">1</span>   <span class="hljs-number">1</span>   <span class="hljs-number">1</span>   <span class="hljs-number">1</span>   <span class="hljs-number">1</span><br><br>&gt;&gt; a&lt;b<br><br><span class="hljs-built_in">ans</span> =<br><br>  <span class="hljs-number">1</span>×<span class="hljs-number">6</span> logical 数组<br><br>   <span class="hljs-number">1</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span><br><br>&gt;&gt; a==b<br><br><span class="hljs-built_in">ans</span> =<br><br>  <span class="hljs-number">1</span>×<span class="hljs-number">6</span> logical 数组<br><br>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h5 id="利用字符串比较函数进行比较"><a href="#利用字符串比较函数进行比较" class="headerlink" title="利用字符串比较函数进行比较"></a>利用字符串比较函数进行比较</h5><ol><li><strong>strcmp(s1,s2)</strong>:比较s1和s2<strong>所有字符是否完全相等</strong></li><li><strong>strncmp(s1,s2)</strong>:比较s1和s2<strong>前n个字符是否完全相等</strong></li><li><strong>strcmpi(s1,s2)</strong>:<strong>在忽略字母大小写的情况下</strong>,比较s1和s2<strong>所有字符是否相等</strong></li><li><strong>strncmpi(s1,s2)</strong>:<strong>在忽略字母大小写的情况下</strong>,比较s1和s2<strong>前n个字符是否相等</strong></li></ol><h4 id="字符串的查找与替换"><a href="#字符串的查找与替换" class="headerlink" title="字符串的查找与替换"></a>字符串的查找与替换</h4><h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><p><strong>findstr(s1,s2)</strong>:返回短字符串s2在长字符串s1中出现的位置</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; a=<span class="hljs-string">'12321232123'</span>;<br>&gt;&gt; b=<span class="hljs-string">'123'</span>;<br>&gt;&gt; findstr(a,b)<br><br><span class="hljs-built_in">ans</span> =<br><br>     <span class="hljs-number">1</span>     <span class="hljs-number">5</span>     <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h5 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h5><p><strong>strrep(s1,s2,s3)</strong>:将字符串s1中<strong>所有</strong>子字符串s2替换为字符串s3</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; a=<span class="hljs-string">'12321232123'</span>;<br>&gt;&gt; b=<span class="hljs-string">'123'</span>;<br>&gt;&gt; findstr(a,b)<br><br><span class="hljs-built_in">ans</span> =<br><br>     <span class="hljs-number">1</span>     <span class="hljs-number">5</span>     <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab学习笔记(6)</title>
      <link href="/2018/04/30/matalb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6/"/>
      <url>/2018/04/30/matalb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6/</url>
      
        <content type="html"><![CDATA[<p><strong>matlab学习笔记(6)主要介绍了以下内容:</strong></p><p>矩阵分析</p><ol><li>对角阵与三角阵</li><li>矩阵的转置与旋转</li><li>矩阵的逆与伪逆</li><li>方阵的行列式</li><li>矩阵的秩与迹</li><li>向量和矩阵的范数</li><li>矩阵的条件数</li><li>矩阵的特征值与特征向量</li><li>矩阵的超越函数</li></ol><a id="more"></a><h3 id="对角阵与三角阵"><a href="#对角阵与三角阵" class="headerlink" title="对角阵与三角阵"></a>对角阵与三角阵</h3><h4 id="对角阵"><a href="#对角阵" class="headerlink" title="对角阵"></a>对角阵</h4><p>只有对角线上有非0元素的矩阵称为<strong>对角矩阵</strong>,对角线上的元素相等的对角矩阵称为<strong>数量矩阵</strong>,对角线上都为1的矩阵称为<strong>单位矩阵</strong></p><h5 id="提取矩阵的对角线元素"><a href="#提取矩阵的对角线元素" class="headerlink" title="提取矩阵的对角线元素"></a>提取矩阵的对角线元素</h5><p>调用函数diag(a)</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br><span class="hljs-built_in">diag</span>(a)=<br><span class="hljs-number">1.00</span><br><span class="hljs-number">5.00</span><br><span class="hljs-number">9.00</span><br></code></pre></td></tr></table></figure><ul><li>diag(a)函数还有一种形式diag(a,k),其功能是提取<strong>第k条对角线元素</strong></li><li>与主对角线平行,往上为第1条,第2条,…,第n条对角线,往下为第-1条,第-2条,…,第-n条</li><li>主对角线为第0条对角线</li></ul><h5 id="构造对角矩阵"><a href="#构造对角矩阵" class="headerlink" title="构造对角矩阵"></a>构造对角矩阵</h5><p>设<strong>V</strong>为具有m个元素的向量,diag(<strong>V</strong>)将产生一个m×m对角矩阵,其主对角线元素即为向量<strong>V</strong>的元素</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-built_in">diag</span>(<span class="hljs-number">1</span>:<span class="hljs-number">3</span>)=<br><span class="hljs-number">1.00</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span><br>   <span class="hljs-number">0</span>    <span class="hljs-number">2.00</span>       <span class="hljs-number">0</span><br>   <span class="hljs-number">0</span>       <span class="hljs-number">0</span>    <span class="hljs-number">3.00</span><br></code></pre></td></tr></table></figure><p>diag(<strong>V</strong>,k)创建一个矩阵,对角线向上或者向下移动k个单位,<strong>还是形成方阵</strong></p><h5 id="三角阵"><a href="#三角阵" class="headerlink" title="三角阵"></a>三角阵</h5><p>三角阵分为<strong>上三角阵</strong>(矩阵对角线以下的元素全为0的矩阵)和<strong>下三角阵</strong>(矩阵对角线以上的元素全为0的矩阵)</p><h6 id="上三角矩阵"><a href="#上三角矩阵" class="headerlink" title="上三角矩阵"></a>上三角矩阵</h6><p>调用函数<strong>triu(a)</strong></p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br><span class="hljs-built_in">triu</span>(a)=<br>          <span class="hljs-number">1.00</span>          <span class="hljs-number">2.00</span>          <span class="hljs-number">3.00</span><br>             <span class="hljs-number">0</span>          <span class="hljs-number">5.00</span>          <span class="hljs-number">6.00</span><br>             <span class="hljs-number">0</span>             <span class="hljs-number">0</span>          <span class="hljs-number">9.00</span><br></code></pre></td></tr></table></figure><p><strong>triu(a,k)</strong>求矩阵a的第k条对角线以上的元素</p><h6 id="下三角矩阵"><a href="#下三角矩阵" class="headerlink" title="下三角矩阵"></a>下三角矩阵</h6><p>调用函数<strong>tril(a)</strong></p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br><span class="hljs-built_in">tril</span>(a)=<br>          <span class="hljs-number">1.00</span>             <span class="hljs-number">0</span>             <span class="hljs-number">0</span><br>          <span class="hljs-number">4.00</span>          <span class="hljs-number">5.00</span>             <span class="hljs-number">0</span><br>          <span class="hljs-number">7.00</span>          <span class="hljs-number">8.00</span>          <span class="hljs-number">9.00</span><br></code></pre></td></tr></table></figure><p><strong>tril(a,k)</strong>求矩阵a的第k条对角线以下的元素</p><h3 id="矩阵的转置与旋转"><a href="#矩阵的转置与旋转" class="headerlink" title="矩阵的转置与旋转"></a>矩阵的转置与旋转</h3><h4 id="矩阵的转置"><a href="#矩阵的转置" class="headerlink" title="矩阵的转置"></a>矩阵的转置</h4><p>把源矩阵的第1行变成目标矩阵的第1列,第2行变成第2列,…,以此类推</p><p>转置运算符是  <strong>.’</strong></p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">71</span>,<span class="hljs-number">3</span>,<span class="hljs-number">-8</span>;<span class="hljs-number">2</span>,<span class="hljs-number">-9</span>,<span class="hljs-number">8</span>;<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br>a.'=<br>         <span class="hljs-number">71.00</span>          <span class="hljs-number">2.00</span>             <span class="hljs-number">0</span><br>          <span class="hljs-number">3.00</span>         <span class="hljs-number">-9.00</span>          <span class="hljs-number">4.00</span><br>         <span class="hljs-number">-8.00</span>          <span class="hljs-number">8.00</span>          <span class="hljs-number">5.00</span><br></code></pre></td></tr></table></figure><p>还有一种转置叫做共轭转置,其运算符是单个引号  <strong>‘</strong>  ,它在转置的基础上还要取每个数的复共轭</p><p>例如: <strong>b=a’</strong>得到的b就是a的共轭转置矩阵,等价于<strong>b=conj(a).’</strong>或者<strong>b=conj(a.’)</strong></p><p>如果矩阵元素都是实数,那么转置和共轭转置得到的结果是一样的</p><h4 id="矩阵的旋转"><a href="#矩阵的旋转" class="headerlink" title="矩阵的旋转"></a>矩阵的旋转</h4><p>调用函数<strong>rot90(a,k)</strong></p><p>将矩阵a逆时针旋转90的k倍,当k=1时可省略不写</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br><span class="hljs-built_in">rot90</span>(a,<span class="hljs-number">2</span>)=<br>          <span class="hljs-number">9.00</span>          <span class="hljs-number">8.00</span>          <span class="hljs-number">7.00</span><br>          <span class="hljs-number">6.00</span>          <span class="hljs-number">5.00</span>          <span class="hljs-number">4.00</span><br>          <span class="hljs-number">3.00</span>          <span class="hljs-number">2.00</span>          <span class="hljs-number">1.00</span><br></code></pre></td></tr></table></figure><h4 id="矩阵的左右翻"><a href="#矩阵的左右翻" class="headerlink" title="矩阵的左右翻"></a>矩阵的左右翻</h4><p>对矩阵实施左右翻转是将矩阵的第1列和最后1列调换,第2列和倒数第2列调换,…,依次类推</p><p>matlab对矩阵a实施左右翻转的函数是fliplr(a)</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br><span class="hljs-built_in">fliplr</span>(a)=<br>          <span class="hljs-number">3.00</span>          <span class="hljs-number">2.00</span>          <span class="hljs-number">1.00</span><br>          <span class="hljs-number">6.00</span>          <span class="hljs-number">5.00</span>          <span class="hljs-number">4.00</span><br>          <span class="hljs-number">9.00</span>          <span class="hljs-number">8.00</span>          <span class="hljs-number">7.00</span><br></code></pre></td></tr></table></figure><h4 id="矩阵的上下翻转"><a href="#矩阵的上下翻转" class="headerlink" title="矩阵的上下翻转"></a>矩阵的上下翻转</h4><p>对矩阵实施上下翻转是将矩阵的第1行和最后1行调换,第2行和倒数第2行调换,…,依次类推</p><p>matlab对矩阵a实施上下翻转的函数是flipud(a)</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br><span class="hljs-built_in">flipud</span>(a)=<br>          <span class="hljs-number">7.00</span>          <span class="hljs-number">8.00</span>          <span class="hljs-number">9.00</span><br>          <span class="hljs-number">4.00</span>          <span class="hljs-number">5.00</span>          <span class="hljs-number">6.00</span><br>          <span class="hljs-number">1.00</span>          <span class="hljs-number">2.00</span>          <span class="hljs-number">3.00</span><br></code></pre></td></tr></table></figure><h3 id="矩阵的逆与伪逆"><a href="#矩阵的逆与伪逆" class="headerlink" title="矩阵的逆与伪逆"></a>矩阵的逆与伪逆</h3><h4 id="矩阵的逆"><a href="#矩阵的逆" class="headerlink" title="矩阵的逆"></a>矩阵的逆</h4><p>对于一个方阵a,如果存在一个与其同阶的方阵b,使得</p><script type="math/tex; mode=display">a·b=b·a=I(I为单位矩阵)</script><p>则称b为a的逆矩阵,当然,a也是b的逆矩阵</p><p>在matlab中求逆矩阵直接使用<strong>inv(a)</strong>即可</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>;<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>;<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br>inv(a)=<br>          <span class="hljs-number">5.22</span>          <span class="hljs-number">1.44</span>         <span class="hljs-number">-3.22</span><br>         <span class="hljs-number">-5.11</span>         <span class="hljs-number">-1.22</span>          <span class="hljs-number">3.11</span><br>          <span class="hljs-number">2.22</span>          <span class="hljs-number">0.44</span>         <span class="hljs-number">-1.22</span><br></code></pre></td></tr></table></figure><h4 id="矩阵的伪逆"><a href="#矩阵的伪逆" class="headerlink" title="矩阵的伪逆"></a>矩阵的伪逆</h4><p>如果矩阵a不是一个方阵,或者a是一个非满秩的方阵时,矩阵a没有逆矩阵,但可以找到一个与a的转置矩阵a’同型的矩阵b使得</p><script type="math/tex; mode=display">a·b·a=a\\\b·a·b=b</script><p>此时称矩阵b为矩阵a的伪逆,也称为广义逆矩阵,可以使用函数<strong>pinv(a)</strong>求解</p><figure class="hljs highlight Matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Matlab">a=[<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>];<br>pinv(a)=<br>          <span class="hljs-number">0.39</span>         <span class="hljs-number">-0.11</span>         <span class="hljs-number">-0.11</span><br>         <span class="hljs-number">-0.11</span>          <span class="hljs-number">0.39</span>         <span class="hljs-number">-0.11</span><br>         <span class="hljs-number">-0.11</span>         <span class="hljs-number">-0.11</span>          <span class="hljs-number">0.39</span><br>          <span class="hljs-number">0.04</span>          <span class="hljs-number">0.04</span>          <span class="hljs-number">0.04</span><br></code></pre></td></tr></table></figure><p>若a是一个奇异矩阵(行列式为0),无一般意义上的逆矩阵,但可以求a得伪逆矩阵,例如:</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>];<br>pinv(a)=<br>             <span class="hljs-number">0</span>             <span class="hljs-number">0</span>             <span class="hljs-number">0</span><br>             <span class="hljs-number">0</span>          <span class="hljs-number">1.00</span>             <span class="hljs-number">0</span><br>             <span class="hljs-number">0</span>             <span class="hljs-number">0</span>          <span class="hljs-number">1.00</span><br></code></pre></td></tr></table></figure><h3 id="方阵的行列式"><a href="#方阵的行列式" class="headerlink" title="方阵的行列式"></a>方阵的行列式</h3><p>调用函数det(a)求解</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>;<span class="hljs-number">-3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>];<br>det(a)=<br><span class="hljs-number">-10.00</span><br></code></pre></td></tr></table></figure><h3 id="矩阵的秩与迹"><a href="#矩阵的秩与迹" class="headerlink" title="矩阵的秩与迹"></a>矩阵的秩与迹</h3><h4 id="矩阵的秩"><a href="#矩阵的秩" class="headerlink" title="矩阵的秩"></a>矩阵的秩</h4><p>矩阵线性无关的行数与列数称为矩阵的秩</p><p>调用函数rank(a)</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>];<br>rank(a)=<br><span class="hljs-number">3.00</span><br></code></pre></td></tr></table></figure><h4 id="矩阵的迹"><a href="#矩阵的迹" class="headerlink" title="矩阵的迹"></a>矩阵的迹</h4><p>矩阵的迹等于矩阵的对角线元素之和,也等于矩阵的特征值之和</p><p>调用函数trace(a)</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>];<br>trace(a)=<br><span class="hljs-number">3.00</span><br></code></pre></td></tr></table></figure><h3 id="向量和矩阵范数"><a href="#向量和矩阵范数" class="headerlink" title="向量和矩阵范数"></a>向量和矩阵范数</h3><p>矩阵或向量的范数用来度量矩阵或向量在某种意义下的长度</p><p>范数有多种方法定义,其定义不同,范数值也就不同,因此,讨论范数时,一定要弄清是哪一种范数</p><h4 id="向量的三种常用范数及其计算函数"><a href="#向量的三种常用范数及其计算函数" class="headerlink" title="向量的三种常用范数及其计算函数"></a>向量的三种常用范数及其计算函数</h4><p>向量的1-范数:向量元素的绝对值之和     <strong>norm(V,1)</strong></p><script type="math/tex; mode=display">\\left\\| v\\right\\| \_{1}=\\sum ^{n}\_{i=1}\\left| v\_{i}\\right|</script><p>向量的2-范数:向量元素平方和的平方根    <strong>norm(V,2)</strong></p><script type="math/tex; mode=display">\\left\\| v\\right\\|\_{2} =\\sqrt {\\sum ^{n}\_{i=1}v^{2}\_{i}}</script><p>向量的∞-范数:所有向量元素绝对值中的最大值     <strong>norm(V,inf)</strong></p><script type="math/tex; mode=display">\\left\\|v\\right\\|\_{∞} =\\max \_{1\\leq i\\leq n}\\left\\{ \\left| V\_{i}\\right| \\right\\}</script><h4 id="矩阵的范数及其计算函数"><a href="#矩阵的范数及其计算函数" class="headerlink" title="矩阵的范数及其计算函数"></a>矩阵的范数及其计算函数</h4><p>设a是一个m×n的矩阵,V是一个含有n个元素的列向量,定义</p><script type="math/tex; mode=display">\\left\\| a\\right\\|=max\\left\\| a·V\\right\\| ,\\left\\| V\\right\\| =1</script><p>矩阵a的1-范数:所有矩阵列元素绝对值之和的最大值  <strong>norm(a,1)</strong></p><script type="math/tex; mode=display">\\left\\| a\\right\\| \_{1}=\\max \_{1\\leq j\\leq n}\\left\\{ \\sum ^{m}\_{i=1}\\left| a\_{ij}\\right|  \\right\\}</script><p>矩阵a的2-范数:a’a矩阵的最大特征值的平方根    <strong>norm(V,2)</strong></p><script type="math/tex; mode=display">\\left\\| a\\right\\|\_{2} =\\sqrt {\\lambda \_{1}}     (其中\\lambda \_{1}为a'a的最大特征值)</script><p>向量的∞-范数:所有向量元素绝对值中的最大值     <strong>norm(V,inf)</strong></p><script type="math/tex; mode=display">\\left\\| a\\right\\|\_{∞} =\\max\_{1\\leq i\\leq m}\\left\\{\\sum ^{n}\_{j=1}\\left| a\_{ij}\\right|  \\right\\}</script><h3 id="矩阵的条件数"><a href="#矩阵的条件数" class="headerlink" title="矩阵的条件数"></a>矩阵的条件数</h3><p>在求解线性方程组AX=B时,一般认为,系数矩阵A中个别元素的微小扰动不会引起解向量的很大变化</p><p>这样的假设在工程应用中非常重要,因为一般系数矩阵的数据是由实验数据获得的,并非精确值,但与精确值误差不大</p><p>由上面的假设可以得出如下结论:</p><p><strong>当参与运算的系数与实数精确值误差很小时,所获得的解与问题的准确解误差也很小</strong></p><p>遗憾的是,上述假设并非总是正确的</p><p>对于有的系数矩阵,个别元素的微小扰动会引起解的很大变化,在计算数学中,称这种矩阵为<strong>病态矩阵</strong>,而称解不因其系数矩阵的微小扰动而发生大的变化的矩阵为<strong>良性矩阵</strong></p><p>当然,<strong>良性</strong>与<strong>病态</strong>是相对的,需要一个参数来描述,条件数就是用来描述矩阵的这种性能的一个参数</p><p>矩阵a的条件数等于a的范数与a的逆矩阵的范数的乘积,这样定义的条件数总是大于1的</p><p>计算a的1-范数下的条件数    <strong>cond(a,1)</strong></p><script type="math/tex; mode=display">cond(a,1)=\\left\\| a\\right\\|\_{1}·\\left\\| a^{-1}\\right\\|\_{1}</script><p>计算a的2-范数下的条件数    <strong>cond(a,2)</strong></p><script type="math/tex; mode=display">cond(a,2)=\\left\\| a\\right\\|\_{2}·\\left\\| a^{-1}\\right\\|\_{2}</script><p>计算a的∞-范数下的条件数    <strong>cond(a,inf)</strong></p><script type="math/tex; mode=display">cond(a,∞)=\\left\\| a\\right\\|\_{∞}·\\left\\| a^{-1}\\right\\|\_{∞}</script><p><strong>条件数越接近于1,矩阵的性能越好,反之,矩阵的性能越差</strong></p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">-6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br>b=[<span class="hljs-number">2</span>,<span class="hljs-number">-5</span>,<span class="hljs-number">4</span>;<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">-2</span>;<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>];<br>cond(a)=<br>         <span class="hljs-number">87.98</span><br>cond(b)=<br>          <span class="hljs-number">3.75</span><br></code></pre></td></tr></table></figure><h3 id="矩阵的特征值与特征向量"><a href="#矩阵的特征值与特征向量" class="headerlink" title="矩阵的特征值与特征向量"></a>矩阵的特征值与特征向量</h3><p>对于n阶方阵a,求数λ和向量ξ,使得等式aξ=λξ成立</p><p>满足等式的数λ称为a的特征值,向量ξ称为a的特征向量</p><p>实际上,方程aξ=λξ和(a-λE)ξ=0是两个等价方程</p><p>要使方程(a-λE)ξ=0有非零解ξ,必须使其系数行列式为0,即|a-λE|=0</p><p>线性代数中已经证明,行列式|a-λE|是一个关于λ的n阶多项式,因而|a-λE|=0是一个n次方程,有n个根(含重根),就是矩阵a的n个特征值每一个特征值对应无穷多个特征向量</p><p><strong>矩阵的特征值问题有确定解,但特征向量问题没有确定解</strong></p><p>在matlab中,计算矩阵a的特征值和特征向量的函数是<strong>eig(a)</strong>,常用的调用格式有三种:</p><ol><li><strong>e=eig(a)</strong>:求矩阵a的全部特征值,构成<strong>向量e</strong></li><li><strong>[V,D]=eig(a)</strong>:求矩阵a的全部特征值,构成<strong>对角阵D</strong>,并求a得特征向量构成<strong>V</strong>的列向量</li><li><strong>[V,D]=eig(a,’nobalance’)</strong>:与2功能类似,第2种方法是先对a做相似变换后求矩阵a的特征值和特征向量,而第3种方法是直接求矩阵a的特征值和特征向量</li></ol><p>一个矩阵的特征向量有无穷多个,eig函数只找其中的n个,a的其他特征向量,均可由这n个特征向量的线性组合表示,例如:</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0.5</span>;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0.25</span>;<span class="hljs-number">0.5</span>,<span class="hljs-number">0.25</span>,<span class="hljs-number">2</span>];<br>[V,D]=eig(a)<br>V =<br>   <span class="hljs-number">0.721207129830347</span>   <span class="hljs-number">0.444281058188505</span>   <span class="hljs-number">0.531483411986466</span><br>  <span class="hljs-number">-0.686349287710169</span>   <span class="hljs-number">0.562109420455869</span>   <span class="hljs-number">0.461473352095774</span><br>  <span class="hljs-number">-0.093727963498713</span>  <span class="hljs-number">-0.697601133004864</span>   <span class="hljs-number">0.710329309608377</span><br>D =<br>  <span class="hljs-number">-0.016647283606310</span>                   <span class="hljs-number">0</span>                   <span class="hljs-number">0</span><br>                   <span class="hljs-number">0</span>   <span class="hljs-number">1.480121423189129</span>                   <span class="hljs-number">0</span><br>                   <span class="hljs-number">0</span>                   <span class="hljs-number">0</span>   <span class="hljs-number">2.536525860417180</span><br></code></pre></td></tr></table></figure><p>求得的三个特征值是-0.0166,1.4801和2.5365,各特征值对应的特征向量为V的各列构成的向量</p><h3 id="矩阵的超越函数"><a href="#矩阵的超越函数" class="headerlink" title="矩阵的超越函数"></a>矩阵的超越函数</h3><p>matlab的数学函数,如sqrt,exp,log等都是作用在矩阵的各元素上的</p><p>matlab还提供了一些直接作用于矩阵的超越函数,其函数名都是上述数学函数名之后缀以m,并规定输入参数a必须是方阵</p><h4 id="矩阵平方根sqrtm"><a href="#矩阵平方根sqrtm" class="headerlink" title="矩阵平方根sqrtm"></a>矩阵平方根sqrtm</h4><p><strong>sqrtm(a)</strong>计算矩阵a的平方根,这是在矩阵意义下的平方根,它与sqrt(a)的结果是不同的</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; a=[<span class="hljs-number">4</span>,<span class="hljs-number">2</span>;<span class="hljs-number">3</span>,<span class="hljs-number">6</span>];<br>&gt;&gt; b1=sqrtm(a)<br><br>b1 =<br><br>   <span class="hljs-number">1.917137824293506</span>   <span class="hljs-number">0.465175638988947</span><br>   <span class="hljs-number">0.697763458483421</span>   <span class="hljs-number">2.382313463282453</span><br><br>&gt;&gt; b1*b1<br><br><span class="hljs-built_in">ans</span> =<br><br>   <span class="hljs-number">4.000000000000000</span>   <span class="hljs-number">2.000000000000000</span><br>   <span class="hljs-number">3.000000000000000</span>   <span class="hljs-number">6.000000000000000</span><br><br>&gt;&gt; b2=<span class="hljs-built_in">sqrt</span>(a)<br><br>b2 =<br><br>   <span class="hljs-number">2.000000000000000</span>   <span class="hljs-number">1.414213562373095</span><br>   <span class="hljs-number">1.732050807568877</span>   <span class="hljs-number">2.449489742783178</span><br><br>&gt;&gt; b2*b2<br><br><span class="hljs-built_in">ans</span> =<br><br>   <span class="hljs-number">6.449489742783179</span>   <span class="hljs-number">6.292528739883945</span><br>   <span class="hljs-number">7.706742302257039</span>   <span class="hljs-number">8.449489742783177</span><br><br>&gt;&gt; b2.*b2<br><br><span class="hljs-built_in">ans</span> =<br><br>   <span class="hljs-number">4.000000000000000</span>   <span class="hljs-number">2.000000000000000</span><br>   <span class="hljs-number">3.000000000000000</span>   <span class="hljs-number">5.999999999999999</span><br></code></pre></td></tr></table></figure><p>若a为实对称<a href="https://en.wikipedia.org/wiki/Positive-definite_matrix" target="_blank" rel="noopener">正定矩阵</a>或复<a href="https://en.wikipedia.org/wiki/Hermitian_matrix" target="_blank" rel="noopener">埃尔米特(Hermitian)</a>正定阵,则一定能算出它的平方根</p><p><strong>但某些矩阵,如a=[0,1;0,0]就得不到平方根</strong></p><p>如果矩阵a含有负的特征值,则sqrtm(a)将会得到一个复矩阵,例如:</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; a=[<span class="hljs-number">4</span>,<span class="hljs-number">9</span>;<span class="hljs-number">16</span>,<span class="hljs-number">25</span>];<br>&gt;&gt; eig(a)<br><br><span class="hljs-built_in">ans</span> =<br><br>  <span class="hljs-number">-1.445218719101973</span><br>  <span class="hljs-number">30.445218719101973</span><br><br>&gt;&gt; b=sqrtm(a)<br><br>b =<br><br>  <span class="hljs-number">0.942137741124329</span> + <span class="hljs-number">0.996904315125749</span><span class="hljs-built_in">i</span>  <span class="hljs-number">1.557189914222098</span> - <span class="hljs-number">0.339272627367266</span><span class="hljs-built_in">i</span><br>  <span class="hljs-number">2.768337625283729</span> - <span class="hljs-number">0.603151337541807</span><span class="hljs-built_in">i</span>  <span class="hljs-number">4.575580874309223</span> + <span class="hljs-number">0.205268184602128</span><span class="hljs-built_in">i</span><br></code></pre></td></tr></table></figure><h4 id="矩阵对数logm"><a href="#矩阵对数logm" class="headerlink" title="矩阵对数logm"></a>矩阵对数logm</h4><p><strong>logm(a)</strong>计算矩阵a的自然对数</p><p>此函数输入参数的条件与输出结果间的关系和函数<strong>sqrtm(a)</strong>完全一样,例如:</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; a=[<span class="hljs-number">4</span>,<span class="hljs-number">9</span>;<span class="hljs-number">1</span>,<span class="hljs-number">5</span>];<br>&gt;&gt; l=logm(a)<br><br>l =<br><br>   <span class="hljs-number">1.063900819033590</span>   <span class="hljs-number">2.430842712580726</span><br>   <span class="hljs-number">0.270093634731192</span>   <span class="hljs-number">1.333994453764781</span><br></code></pre></td></tr></table></figure><h4 id="矩阵指数expm"><a href="#矩阵指数expm" class="headerlink" title="矩阵指数expm"></a>矩阵指数expm</h4><p><strong>expm(a)</strong>的功能就是求矩阵指数e^a^,例如,对上面计算所得到的a的自然对数l,求其矩阵指数b=e^l^</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; a=[<span class="hljs-number">4</span>,<span class="hljs-number">9</span>;<span class="hljs-number">1</span>,<span class="hljs-number">5</span>];<br>l=logm(a)<br><br>l =<br><br>   <span class="hljs-number">1.063900819033590</span>   <span class="hljs-number">2.430842712580726</span><br>   <span class="hljs-number">0.270093634731192</span>   <span class="hljs-number">1.333994453764781</span><br><br>&gt;&gt; expm(l)<br><br><span class="hljs-built_in">ans</span> =<br><br>   <span class="hljs-number">4.000000000000001</span>   <span class="hljs-number">9.000000000000002</span><br>   <span class="hljs-number">1.000000000000000</span>   <span class="hljs-number">5.000000000000000</span><br></code></pre></td></tr></table></figure><p>从这个结果可以看出,这里所得到的结果恰好和a相同,即<strong>expm函数</strong>和<strong>logm函数</strong>是互逆的</p><h4 id="普通矩阵函数funm"><a href="#普通矩阵函数funm" class="headerlink" title="普通矩阵函数funm"></a>普通矩阵函数funm</h4><p><strong>funm(a,@fun)</strong>对方阵a计算由fun定义的函数的矩阵函数值</p><p>例如,当fun取exp时,<strong>funm(a,@exp)</strong>可以计算矩阵a的指数,与<strong>expm(a)</strong>的计算结果是一样的</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; a=[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>;<span class="hljs-number">2</span>,<span class="hljs-number">-1</span>];<br>&gt;&gt; funm(a,@<span class="hljs-built_in">exp</span>)<br><br><span class="hljs-built_in">ans</span> =<br><br>   <span class="hljs-number">2.718281828459046</span>                   <span class="hljs-number">0</span><br>   <span class="hljs-number">2.350402387287603</span>   <span class="hljs-number">0.367879441171442</span><br><br>&gt;&gt; expm(a)<br><br><span class="hljs-built_in">ans</span> =<br><br>   <span class="hljs-number">2.718281828459046</span>                   <span class="hljs-number">0</span><br>   <span class="hljs-number">2.350402387287603</span>   <span class="hljs-number">0.367879441171442</span><br></code></pre></td></tr></table></figure><p><strong>funm函数</strong>可以用于<strong>exp</strong>,<strong>log</strong>,<strong>sin</strong>,<strong>cos</strong>,<strong>sinh</strong>和<strong>cosh</strong>等函数,但求矩阵的平方根只能使用<strong>sqrtm函数</strong></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab学习笔记(5)</title>
      <link href="/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/"/>
      <url>/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/</url>
      
        <content type="html"><![CDATA[<p><strong>matlab学习笔记(5)主要介绍了以下内容:</strong></p><ol><li>基本算术运算</li><li>点运算</li></ol><a id="more"></a><h4 id="基本算术运算"><a href="#基本算术运算" class="headerlink" title="基本算术运算"></a>基本算术运算</h4><p>matlab的基本算数运算有:+(加),-(减),*(乘),/(右除),\(左除),^(乘方)</p><h5 id="矩阵加减运算"><a href="#矩阵加减运算" class="headerlink" title="矩阵加减运算"></a>矩阵加减运算</h5><p>a和b必须同型(即大小相同)</p><h5 id="矩阵乘法运算"><a href="#矩阵乘法运算" class="headerlink" title="矩阵乘法运算"></a>矩阵乘法运算</h5><p>a为n×m矩阵,b为m×p矩阵才能进行乘法运算</p><h5 id="矩阵除法运算"><a href="#矩阵除法运算" class="headerlink" title="矩阵除法运算"></a>矩阵除法运算</h5><ul><li>在matlab中,有两种矩阵除法运算:/和\\,分别表示左除和右除</li><li>只有矩阵a的行列式不为零(即矩阵a为非奇异矩阵)才能进行实现</li><li>a\\b等效于a的逆左乘b矩阵,即inv(a)*b</li><li>b/a等效于a的逆右乘b矩阵,即b*inv(a)</li><li>对于标量的运算,两种除法运算的结果都相等</li><li>对于矩阵来说,左除和右除代表两种不同的除数矩阵和被除数矩阵的关系</li><li>对于矩阵来说,一般a\b不等于b/a</li></ul><h5 id="矩阵的乘方"><a href="#矩阵的乘方" class="headerlink" title="矩阵的乘方"></a>矩阵的乘方</h5><ul><li><p>a^x</p></li><li><p>要求a为方阵,x为标量</p></li><li><p>可以计算一个矩阵的方根,例如:</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br>a^<span class="hljs-number">0.1</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="点运算"><a href="#点运算" class="headerlink" title="点运算"></a>点运算</h4><p>在matlab中,有一种特殊的运算,因为其运算符是在有关算术运算符前面加点,所以叫点运算</p><p>点运算符有  .*  ,  ./  ,  .\  ,  .^</p><p>两矩阵进行点运算是指他们对应的对应元素进行相关运算,要求两矩阵的维数相同</p><h5 id="a-b"><a href="#a-b" class="headerlink" title="a.*b"></a>a.*b</h5><p>表示a和b单个元素之间对应相乘,例如</p><figure class="hljs highlight Matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br>b=[<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>;<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>;<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>];<br>a.*b=<br><span class="hljs-number">9</span> <span class="hljs-number">16</span> <span class="hljs-number">21</span><br><span class="hljs-number">24</span> <span class="hljs-number">25</span> <span class="hljs-number">24</span><br><span class="hljs-number">21</span> <span class="hljs-number">16</span> <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h5 id="a-b与b-a"><a href="#a-b与b-a" class="headerlink" title="a./b与b.\a"></a>a./b与b.\a</h5><p>a./b等价于b.\a,例如</p><figure class="hljs highlight Matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];<br>b=[<span class="hljs-number">-2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>;<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>];<br>a./b=<br><span class="hljs-number">-0.5</span> <span class="hljs-number">2.0</span> <span class="hljs-number">1.0</span><br><span class="hljs-number">-4.0</span> <span class="hljs-number">5.0</span> <span class="hljs-number">1.5</span><br>b.\a=<br><span class="hljs-number">-0.5</span> <span class="hljs-number">2.0</span> <span class="hljs-number">1.0</span><br><span class="hljs-number">-4.0</span> <span class="hljs-number">5.0</span> <span class="hljs-number">1.5</span><br></code></pre></td></tr></table></figure><h5 id="a-b-1"><a href="#a-b-1" class="headerlink" title="a.^b"></a>a.^b</h5><p>若两个矩阵同型,则<strong>a.^b</strong>表示两矩阵对应元素进行乘方运算,例如:</p><figure class="hljs highlight Matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>b=[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];<br>a.^b=<br><span class="hljs-number">1</span> <span class="hljs-number">32</span> <span class="hljs-number">729</span><br></code></pre></td></tr></table></figure><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>a.^<span class="hljs-number">2</span>=<br><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><figure class="hljs highlight Matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>b=[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];<br><span class="hljs-number">2.</span>^[a b]=<br><span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">8</span> <span class="hljs-number">16</span> <span class="hljs-number">32</span> <span class="hljs-number">64</span><br></code></pre></td></tr></table></figure><figure class="hljs highlight Matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Matlab"><span class="hljs-comment">%当x分别为0.1,0.4,0.7,1时,分别求y=sin(x)cos(x)的值</span><br>x=[<span class="hljs-number">0.1</span>,<span class="hljs-number">0.4</span>,<span class="hljs-number">0.7</span>,<span class="hljs-number">1</span>];<br><span class="hljs-built_in">sin</span>(x).*<span class="hljs-built_in">cos</span>(x)=<br> <span class="hljs-number">0.10</span>          <span class="hljs-number">0.36</span>          <span class="hljs-number">0.49</span>          <span class="hljs-number">0.45</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab学习笔记(4)</title>
      <link href="/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4/"/>
      <url>/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4/</url>
      
        <content type="html"><![CDATA[<p><strong>matlab学习笔记(4)主要介绍了以下内容:</strong></p><p>矩阵</p><a id="more"></a><h3 id="矩阵的建立"><a href="#矩阵的建立" class="headerlink" title="矩阵的建立"></a>矩阵的建立</h3><h4 id="直接输入法建立矩阵"><a href="#直接输入法建立矩阵" class="headerlink" title="直接输入法建立矩阵"></a>直接输入法建立矩阵</h4><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]<br></code></pre></td></tr></table></figure><h4 id="冒号表达式建立一个向量"><a href="#冒号表达式建立一个向量" class="headerlink" title="冒号表达式建立一个向量"></a>冒号表达式建立一个向量</h4><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=<span class="hljs-number">0</span>:<span class="hljs-number">1</span>:<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>如果冒号表达式中省略第二个冒号,则默认步长为1</p><h4 id="用linspace函数产生行向量"><a href="#用linspace函数产生行向量" class="headerlink" title="用linspace函数产生行向量"></a>用linspace函数产生行向量</h4><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-built_in">linspace</span>(l,r,n)<br></code></pre></td></tr></table></figure><p>其中l,r是生成向量的第一个元素和最后一个元素,n是元素总数,当n省略时,自动产生100个元素</p><h4 id="利用已建好的小矩阵拼接成大矩阵"><a href="#利用已建好的小矩阵拼接成大矩阵" class="headerlink" title="利用已建好的小矩阵拼接成大矩阵"></a>利用已建好的小矩阵拼接成大矩阵</h4><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>:<span class="hljs-number">2</span>:<span class="hljs-number">6</span>;<span class="hljs-number">2</span>:<span class="hljs-number">2</span>:<span class="hljs-number">6</span>];<br>b=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];<br>c=[a;b]<br></code></pre></td></tr></table></figure><h3 id="矩阵的拆分"><a href="#矩阵的拆分" class="headerlink" title="矩阵的拆分"></a>矩阵的拆分</h3><h4 id="直接通过下标来引用"><a href="#直接通过下标来引用" class="headerlink" title="直接通过下标来引用"></a>直接通过下标来引用</h4><p>如<code>a(3,2)</code>表示a矩阵第3行第2列元素,通常情况下,是对矩阵的单个元素进行赋值或其他操作</p><p><strong>如果给出的行下标或者列下标大于原矩阵的行数和列数,则matlab将自动扩展原来的矩阵,并将扩展后未赋值的元素置为0</strong></p><h4 id="通过冒号表达式获得子矩阵"><a href="#通过冒号表达式获得子矩阵" class="headerlink" title="通过冒号表达式获得子矩阵"></a>通过冒号表达式获得子矩阵</h4><ol><li>可以直接用单个的冒号来作为行下标或列下标<ul><li><strong>a(i,:)</strong>表示a矩阵第i行的全部元素</li><li><strong>a(:,j)</strong>表示a矩阵第j列的全部元素</li><li><strong>a(i:i+m,j:j+k)</strong>表示a矩阵第i~i+m行,第j ~j+k列所有的元素</li></ul></li><li>速度比循环结构快</li><li>此外还可以用<strong>end</strong>关键字来表示某一维的末尾元素下标</li></ol><h4 id="利用空矩阵删除矩阵的元素"><a href="#利用空矩阵删除矩阵的元素" class="headerlink" title="利用空矩阵删除矩阵的元素"></a>利用空矩阵删除矩阵的元素</h4><p>在matlab中,定义[]为空矩阵,给变量x赋空矩阵的语句为</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">x=[]<br></code></pre></td></tr></table></figure><p><strong>x=[]与clear x不同,clear是将x从工作空间中删除,而空矩阵则存在于工作空间中,只是维数为0</strong></p><p>将矩阵中的某些元素删除,可以采用空矩阵的方法,例如:</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>;<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>;<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>];<br>a(:,<span class="hljs-number">2</span>:<span class="hljs-number">4</span>)=[]       <span class="hljs-comment">%删除a的第2~4列元素</span><br>a(:,[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>])=[]      <span class="hljs-comment">%删除a的第2列和第4列元素</span><br></code></pre></td></tr></table></figure><h4 id="改变矩阵的形状"><a href="#改变矩阵的形状" class="headerlink" title="改变矩阵的形状"></a>改变矩阵的形状</h4><p>reshape(a,m,n)函数在矩阵总元素保持不变的前提下,将矩阵a重新排成m*n的二维矩阵</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab">x=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br>y=<span class="hljs-built_in">reshape</span>(a,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>);<br>y =<br><br>          <span class="hljs-number">1.00</span>          <span class="hljs-number">4.00</span>          <span class="hljs-number">7.00</span><br>          <span class="hljs-number">2.00</span>          <span class="hljs-number">5.00</span>          <span class="hljs-number">8.00</span><br>          <span class="hljs-number">3.00</span>          <span class="hljs-number">6.00</span>          <span class="hljs-number">9.00</span><br></code></pre></td></tr></table></figure><ol><li>在matlab中,矩阵元素<strong>按列存储</strong>,即首先存储矩阵第1列元素,然后存储第2列元素,…一直到矩阵的最后一列元素</li><li>reshape函数只是改变原矩阵的行数和列数,即改变其逻辑结构,但并不改变原矩阵元素的个数及其存储结构</li></ol><h3 id="特殊矩阵"><a href="#特殊矩阵" class="headerlink" title="特殊矩阵"></a>特殊矩阵</h3><h4 id="通用的特殊矩阵"><a href="#通用的特殊矩阵" class="headerlink" title="通用的特殊矩阵"></a>通用的特殊矩阵</h4><div class="table-container"><table><thead><tr><th style="text-align:center">函数名</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">zeros</td><td style="text-align:center">产生全0矩阵(零矩阵)</td></tr><tr><td style="text-align:center">ones</td><td style="text-align:center">产生全1矩阵(幺矩阵)</td></tr><tr><td style="text-align:center">eye</td><td style="text-align:center">产生单位矩阵</td></tr><tr><td style="text-align:center">rand</td><td style="text-align:center">产生(0,1)区间均匀分布的随机矩阵</td></tr><tr><td style="text-align:center">randn</td><td style="text-align:center">产生均值为0,方差为1的标准正态分布随机矩阵</td></tr></tbody></table></div><p><strong>调用方式</strong></p><ol><li><strong>zeros(m)</strong>:产生m×m零矩阵</li><li><strong>zeros(n,m)</strong>:产生n×m零矩阵</li><li><strong>zeros(size(a))</strong>:产生与矩阵a同样大小的零矩阵</li><li><strong>20+(50-20)*rand(4,5)</strong>:产生4行5列在区间[20,50]内均匀分布的随机矩阵</li><li><strong>0.6+sqrt(0.1)*randn(4,5)</strong>:产生4行5列均值为0.6,方差为0.1的正态分布随机矩阵</li></ol><h4 id="用于专门学科的特殊矩阵"><a href="#用于专门学科的特殊矩阵" class="headerlink" title="用于专门学科的特殊矩阵"></a>用于专门学科的特殊矩阵</h4><ol><li><p>魔方矩阵</p><ul><li>调用函数magic(n)</li><li>每行每列及两条对角线上的元素之和都相等</li><li>其元素由1,2,3,…,n^2^共n^2^个元素组成</li></ul></li><li><p>范德蒙矩阵</p><ul><li>调用函数vander(<strong>V</strong>)</li><li>范德蒙矩阵最后一列全为1,倒数第2列为一个指定的向量,其它各列是其后一列与倒数第2列对应元素的乘积</li><li><strong>V</strong>为一个指定的向量</li></ul></li><li><p>希尔伯特矩阵</p><ul><li>调用函数hilb(n)</li><li>求希尔伯特逆矩阵的函数 invhilb(n)</li><li>希尔伯特矩阵是一种数学变换矩阵,它的每个元素h~ij~=1/(i+j-1)</li><li>希尔伯特矩阵是一个高度病态的矩阵,即任何一个元素发生微小变动,整个矩阵的值和逆矩阵都会发生很大的变化,病态程度和阶数有关</li></ul></li><li><p>托普利兹矩阵</p><ul><li>调用函数toeplitz(x,y)</li><li>托普利兹矩阵除第1行和第1列外,其他每个元素都与左上角的元素相同</li><li>toeplitz(1:6)用向量[1:6]生成一个对称的托普利兹矩阵</li></ul></li><li><p>伴随矩阵</p><p>设多项式p(x)为:</p><script type="math/tex; mode=display">p\left( x\right) =a_{n}x^{n}+a_{n-1}x^{n-1}+...a_{1}x+a_{0}</script><ul><li>调用函数compan(p)</li><li>其中p是系数向量,高次幂系数排在前,低次幂排在后</li></ul></li><li><p>帕斯卡矩阵</p><ul><li>调用函数pascal(n)</li><li>杨辉三角形组成的矩阵称为帕斯卡矩阵</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab学习笔记(3)</title>
      <link href="/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3/"/>
      <url>/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3/</url>
      
        <content type="html"><![CDATA[<p><strong>matlab学习笔记(3)注意介绍了以下内容:</strong></p><ol><li>常用函数</li><li>常用数学函数</li><li>数据的输出格式</li><li>常用快捷键(mac系统)</li><li>预定义变量</li><li>注意点</li></ol><a id="more"></a><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><ol><li><p>画图函数</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-built_in">plot</span>(自变量,函数,自变量,函数)<br></code></pre></td></tr></table></figure></li><li><p>求根函数</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">roots(p)<br></code></pre></td></tr></table></figure></li></ol><ol><li>求积分<script type="math/tex; mode=display">\int ^{1}_{0}x\ln \left( 1+x\right) dx</script></li></ol><ul><li><p>方法一</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">f=@(x)x.*<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>+x);<br>integral(f,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></li><li><p>方法二</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">syms x<br>int(x*<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>+x),<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure></li></ul><ol><li>求解线性方程组</li></ol><script type="math/tex; mode=display">\begin{cases}2x-3y+z=4\\\8x+3y+2z=2\\\45x+y-9z=17\end{cases}</script><ul><li><p>方法一</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">2</span>,<span class="hljs-number">-3</span>,<span class="hljs-number">1</span>;<span class="hljs-number">8</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>;<span class="hljs-number">45</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-9</span>];<br>b=[<span class="hljs-number">4</span>;<span class="hljs-number">2</span>;<span class="hljs-number">17</span>];<br>x=inv(a)*b<br></code></pre></td></tr></table></figure></li><li><p>方法二</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">syms x y z<br>[x,y,z]=solve(<span class="hljs-number">2</span>*x<span class="hljs-number">-3</span>*y+z<span class="hljs-number">-4</span>,<span class="hljs-number">8</span>*x+<span class="hljs-number">3</span>*y+<span class="hljs-number">2</span>*z<span class="hljs-number">-2</span>,<span class="hljs-number">45</span>*x+y<span class="hljs-number">-9</span>*z<span class="hljs-number">-17</span>)<br></code></pre></td></tr></table></figure></li></ul><h2 id="常用数学函数"><a href="#常用数学函数" class="headerlink" title="常用数学函数"></a>常用数学函数</h2><div class="table-container"><table><thead><tr><th style="text-align:center">函数名</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">sin/sind</td><td style="text-align:center">正弦函数,输入值为弧度/角度</td></tr><tr><td style="text-align:center">cos/cosd</td><td style="text-align:center">余弦函数,输入值为弧度/角度</td></tr><tr><td style="text-align:center">tan/tand</td><td style="text-align:center">正切函数,输入值为弧度/角度</td></tr><tr><td style="text-align:center">asin/asind</td><td style="text-align:center">反正弦函数,输入值为弧度/角度</td></tr><tr><td style="text-align:center">acos/acosd</td><td style="text-align:center">反余弦函数,输入值为弧度/角度</td></tr><tr><td style="text-align:center">atan/atand</td><td style="text-align:center">反正切函数,输入值为弧度/角度</td></tr><tr><td style="text-align:center">sinh/asinh</td><td style="text-align:center">双曲正弦函数/反双曲正弦函数</td></tr><tr><td style="text-align:center">cosh/acosh</td><td style="text-align:center">双曲余弦函数/反双曲余弦函数</td></tr><tr><td style="text-align:center">tanh/atanh</td><td style="text-align:center">双曲正切函数/反双曲正切函数</td></tr><tr><td style="text-align:center">sqrt</td><td style="text-align:center">平方根函数</td></tr><tr><td style="text-align:center">log</td><td style="text-align:center">自然对数函数</td></tr><tr><td style="text-align:center">log10</td><td style="text-align:center">以10为底的对数函数</td></tr><tr><td style="text-align:center">log2</td><td style="text-align:center">以2为底的对数函数</td></tr><tr><td style="text-align:center">exp</td><td style="text-align:center">自然指数函数</td></tr><tr><td style="text-align:center">pow2</td><td style="text-align:center">2的幂</td></tr><tr><td style="text-align:center">abs</td><td style="text-align:center">绝对值函数</td></tr><tr><td style="text-align:center">rem</td><td style="text-align:center">求余</td></tr><tr><td style="text-align:center">mod</td><td style="text-align:center">求模</td></tr><tr><td style="text-align:center">fix</td><td style="text-align:center">向零方向取整</td></tr><tr><td style="text-align:center">floor</td><td style="text-align:center">向下取整</td></tr><tr><td style="text-align:center">ceil</td><td style="text-align:center">向上取整</td></tr><tr><td style="text-align:center">round</td><td style="text-align:center">四舍五入到最邻近的整数</td></tr><tr><td style="text-align:center">sign</td><td style="text-align:center">符号函数</td></tr><tr><td style="text-align:center">gcd</td><td style="text-align:center">最大公约数</td></tr><tr><td style="text-align:center">lcm</td><td style="text-align:center">最小公倍数</td></tr><tr><td style="text-align:center">factorial</td><td style="text-align:center">阶乘</td></tr><tr><td style="text-align:center">isprime</td><td style="text-align:center">判断是否为素数</td></tr><tr><td style="text-align:center">primes</td><td style="text-align:center">生成素数序列</td></tr><tr><td style="text-align:center">perms</td><td style="text-align:center">生成所有排列</td></tr><tr><td style="text-align:center">randperm</td><td style="text-align:center">生成任意排列</td></tr></tbody></table></div><h2 id="数据的输出格式"><a href="#数据的输出格式" class="headerlink" title="数据的输出格式"></a>数据的输出格式</h2><p><strong>format命令只影响数据输出格式,而不影响数据的计算和存储</strong></p><p>format命令格式为:</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">format 格式符<br></code></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center">格式符</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">short</td><td style="text-align:center">输出小数点后4位,最多不超过7位有效数字<br>对于大于1000的实数,用5位有效数字的科学记数形式输出</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">15位有效数字形式输出</td></tr><tr><td style="text-align:center">short e</td><td style="text-align:center">5位有效数字的科学记数形式输出</td></tr><tr><td style="text-align:center">long e</td><td style="text-align:center">15位有效数字的科学记数形式输出</td></tr><tr><td style="text-align:center">short g</td><td style="text-align:center">从short到short e中自动选择最佳输出方式</td></tr><tr><td style="text-align:center">long g</td><td style="text-align:center">从long到long e中自动选择最佳输出方式</td></tr><tr><td style="text-align:center">rat</td><td style="text-align:center">近似有理数表示</td></tr><tr><td style="text-align:center">hex</td><td style="text-align:center">十六进制表示</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">正数,负数,零分别用+,-,空格表示</td></tr><tr><td style="text-align:center">bank</td><td style="text-align:center">银行格式,用元角分表示</td></tr><tr><td style="text-align:center">compact</td><td style="text-align:center">输出变量之间没有空行</td></tr><tr><td style="text-align:center">loose</td><td style="text-align:center">输出变量之间有空行</td></tr></tbody></table></div><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><div class="table-container"><table><thead><tr><th style="text-align:center">组合键</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">⌘ +k</td><td style="text-align:center">清除命令行窗口</td></tr><tr><td style="text-align:center">esc</td><td style="text-align:center">删除当前行命令</td></tr><tr><td style="text-align:center">control+c</td><td style="text-align:center">中断当前任务</td></tr><tr><td style="text-align:center">tab</td><td style="text-align:center">代码补全</td></tr></tbody></table></div><h2 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h2><div class="table-container"><table><thead><tr><th style="text-align:center">预定义变量</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">ans</td><td style="text-align:center">计算结果的默认赋值变量</td></tr><tr><td style="text-align:center">eps</td><td style="text-align:center">机器零阈值</td></tr><tr><td style="text-align:center">pi</td><td style="text-align:center">圆周率π的近似值</td></tr><tr><td style="text-align:center">i,j</td><td style="text-align:center">虚数单位</td></tr><tr><td style="text-align:center">inf,Inf</td><td style="text-align:center">无穷大</td></tr><tr><td style="text-align:center">NaN,nan</td><td style="text-align:center">非数</td></tr><tr><td style="text-align:center">nargin</td><td style="text-align:center">函数输入参数个数</td></tr><tr><td style="text-align:center">nargout</td><td style="text-align:center">函数输出参数个数</td></tr><tr><td style="text-align:center">realmax</td><td style="text-align:center">最大正实数</td></tr><tr><td style="text-align:center">realmin</td><td style="text-align:center">最小正实数</td></tr><tr><td style="text-align:center">lasterr</td><td style="text-align:center">存放最新的错误信息</td></tr><tr><td style="text-align:center">lastwarn</td><td style="text-align:center">存放最新的警告信息</td></tr></tbody></table></div><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ol><li><p>matlab变量名</p><p>变量名<strong>只能以字母开头</strong>,后接字母,数字或下划线,变量名区分大小写</p></li><li><p>注释</p><p>使用<strong>%</strong>进行注释</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab学习笔记(2)</title>
      <link href="/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/"/>
      <url>/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/</url>
      
        <content type="html"><![CDATA[<p><strong>matlab学习笔记(2)主要介绍了以下内容:</strong></p><ol><li>数值类型<ul><li>整数类型</li><li>浮点数类型</li><li>复数</li><li>无穷量和非数值量</li></ul></li><li>逻辑类型</li><li>字符和字符串</li><li>函数句柄</li><li>结构体</li><li>数组类型</li><li>单元数组类型</li></ol><a id="more"></a><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><div class="table-container"><table><thead><tr><th style="text-align:center">数据格式</th><th style="text-align:center">示例</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">int8,uint8<br>int16,uint16<br>int32,uint32<br>int64,uint64</td><td style="text-align:center">int8(20)</td><td style="text-align:left">有符号和无符号的整数类型<br>相同数值的整数类型比浮点数占更少内存<br>除了int64和uint64类型外的所有整数类型,都可以进行数学运算</td></tr><tr><td style="text-align:center">single</td><td style="text-align:center">single(128.1)</td><td style="text-align:left">单精度浮点数<br>相同数值的单精度浮点数比双精度浮点数占更少内存<br>单精度浮点数类型能够表示的范围和精度都比双精度浮点数少</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">333.77<br>1.000-1.000i</td><td style="text-align:left">双精度浮点数<br>matlab中默认的数值类型</td></tr></tbody></table></div><p><strong>说明</strong></p><ol><li>matlab中数值类型的数据包括<strong>有符号</strong>和<strong>无符号</strong>整数,<strong>单精度浮点数</strong>和<strong>双精度浮点数</strong></li><li>在未加说明与特殊定义时,<strong>matlab对所有数值按照双精度浮点数类型进行存储和操作</strong></li><li>相对于双精度浮点数,整数和单精度浮点数的优点在于节省变量占用的内存空间</li><li>matlab会自动进行记忆体的使用和回收,而不像c语言那样,必须由使用者一一指定</li></ol><h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><div class="table-container"><table><thead><tr><th style="text-align:center">转换函数</th><th style="text-align:center">数值范围</th></tr></thead><tbody><tr><td style="text-align:center">int8</td><td style="text-align:center">-2^7^~2^7^-1</td></tr><tr><td style="text-align:center">uint8</td><td style="text-align:center">0~2^8^-1</td></tr><tr><td style="text-align:center">int16</td><td style="text-align:center">-2^15^~2^15^-1</td></tr><tr><td style="text-align:center">uint16</td><td style="text-align:center">0~2^16^-1</td></tr><tr><td style="text-align:center">int32</td><td style="text-align:center">-2^31^~2^31^-1</td></tr><tr><td style="text-align:center">uint32</td><td style="text-align:center">0~2^32^-1</td></tr><tr><td style="text-align:center">int64</td><td style="text-align:center">-2^63^~2^63^-1</td></tr><tr><td style="text-align:center">uint64</td><td style="text-align:center">0~2^64^-1</td></tr></tbody></table></div><p><strong>注意</strong></p><ol><li>由于<strong>matlab默认是double类型</strong>,将数值转化为整数时,遵循四舍六入,当小数部分为0.5时,则会转化为绝对值较大的那个整数</li><li>这些转换函数也可以将其他数据类型转换为指定的整数类型</li><li>在不超过数值范围的情况下,任意两个整数类型之间也可以通过转换函数进行互相转换</li><li>由于不同的整数类型能够表示的数值范围不同,因此当结果超出相应的整数类型能够表示的范围时,就会出现一处错误,运算结果被置为该整数能够表示的最大值或最小值</li></ol><h5 id="取整函数"><a href="#取整函数" class="headerlink" title="取整函数"></a>取整函数</h5><div class="table-container"><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">运算法则</th><th style="text-align:center">示例</th></tr></thead><tbody><tr><td style="text-align:center">floor(x)</td><td style="text-align:center">向下取整</td><td style="text-align:center">floor(1.2)=1<br>floor(-1.2)=-2</td></tr><tr><td style="text-align:center">ceil(x)</td><td style="text-align:center">向上取整</td><td style="text-align:center">ceil(1.2)=2<br>ceil(-1.2)=-1</td></tr><tr><td style="text-align:center">round(x)</td><td style="text-align:center">取最接近的整数<br>如果小数部分是0.5,则向绝对值大的方向取整</td><td style="text-align:center">round(1.2)=1<br>round(1.6)=2<br>round(-1.2)=-1<br>round(-1.6)=-2<br>round(-1.5)=-2</td></tr><tr><td style="text-align:center">fix(x)</td><td style="text-align:center">向0取整</td><td style="text-align:center">fix(1.2)=1<br>fix(1.6)=1<br>fix(-1.2)=-1<br>fix(-1.6)=-1</td></tr></tbody></table></div><h4 id="浮点数类型"><a href="#浮点数类型" class="headerlink" title="浮点数类型"></a>浮点数类型</h4><div class="table-container"><table><thead><tr><th style="text-align:center">浮点类型</th><th style="text-align:center">存储位宽</th><th style="text-align:center">各数位的含义</th><th style="text-align:center">数值范围</th><th style="text-align:center">转换函数</th></tr></thead><tbody><tr><td style="text-align:center">单精度</td><td style="text-align:center">32</td><td style="text-align:center">0~22位表示小数部分 <br>23~30位表示指数部分<br>31位表示符号(0正1负)</td><td style="text-align:center">-3.40282e+038 ~ -1.17549e-038<br>1.17549e-038 ~ 3.40282e+038</td><td style="text-align:center">single</td></tr><tr><td style="text-align:center">双精度</td><td style="text-align:center">64</td><td style="text-align:center">0~51位表示小数部分 <br>52~62位表示指数部分<br>63位表示符号(0正1负)</td><td style="text-align:center">-1.79769e+308 ~ -2.22507e-308<br>2.22507e-308 ~ 1.79769+308</td><td style="text-align:center">Double</td></tr></tbody></table></div><p><strong>注意</strong></p><ol><li>matlab中默认数值类型为双精度浮点类型,因此与创建整数类型数值一样,也可以通过转换函数来实现创建单精度浮点类型</li><li>双精度浮点数参与运算时,返回值得类型依赖于参与运算的其他数据类型<ul><li>参与运算的其他数据为<strong>逻辑型</strong>,<strong>字符型</strong>时,返回<strong>双精度浮点型</strong></li><li>参与运算的其他数据为<strong>整数型</strong>时,返回相应的<strong>整数类型</strong></li><li>参与运算的其他数据为<strong>单精度浮点型</strong>时,返回相应的<strong>单精度浮点型</strong></li></ul></li><li><strong>matlab中,单精度浮点型不能与整数进行算数运算</strong></li><li>由于浮点数只占用一定的存储位宽,其中只有有限位分别用来存储指数部分和小数部分,因此,浮点类型能够表示的实际数值是有限且离散的,任何两个最近相邻的浮点数之间都有微小间隙,而处在间隙中的数值都只能用这两个相邻的浮点数之中的一个来表示(matlab中提供eps函数:可以获得一个数值和最接近该数值的浮点数之间的间隙)</li></ol><h4 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h4><p>复数包括<strong>实部和虚部</strong>两部分,matlab中<strong>默认使用字符i或j作为虚部标志</strong>,创建复数时,可以直接按照复数形式进行输入或者利用complex函数</p><div class="table-container"><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">real(z)</td><td style="text-align:center">返回复数z的实部</td></tr><tr><td style="text-align:center">imag(z)</td><td style="text-align:center">返回复数z的虚部</td></tr><tr><td style="text-align:center">abs(z)</td><td style="text-align:center">返回复数z的模</td></tr><tr><td style="text-align:center">angle(z)</td><td style="text-align:center">返回复数z的辐角</td></tr><tr><td style="text-align:center">conj(z)</td><td style="text-align:center">返回复数z的共轭复数</td></tr><tr><td style="text-align:center">complex(a,b)</td><td style="text-align:center">以a为实部,b为虚部创建复数</td></tr></tbody></table></div><h4 id="无穷量-Inf-和非数值量-NaN"><a href="#无穷量-Inf-和非数值量-NaN" class="headerlink" title="无穷量(Inf)和非数值量(NaN)"></a>无穷量(Inf)和非数值量(NaN)</h4><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">Inf</td><td style="text-align:center">正无穷量</td></tr><tr><td style="text-align:center">-Inf</td><td style="text-align:center">负无穷量</td></tr><tr><td style="text-align:center">NaN</td><td style="text-align:center">非数值量</td></tr></tbody></table></div><p><strong>注意</strong></p><ol><li>正负无穷量一般都是由于运算溢出,产生了超出双精度浮点数数值范围的结果</li><li>非数值量一般都是由于0/0,Inf/Inf或者Inf-Inf造成的,这三个NaN彼此不相等</li><li>除了异常运算结果外,matlab还提供了特定函数Inf和NaN来创建指定数值类型的无穷量和非数值量,生成结果默认为双精度浮点类型中还有一种特殊的指数类型的数据叫做非数,通常表示运算得到的数值结果超出了运算范围,非数的实部用NaN表示,虚部用Inf表示</li></ol><h3 id="逻辑类型"><a href="#逻辑类型" class="headerlink" title="逻辑类型"></a>逻辑类型</h3><p>matlab把任何非零数值当做真,把零当做假.</p><p>所有关系和逻辑表达式的输出:对于真,输出1;对于假,输出0</p><div class="table-container"><table><thead><tr><th style="text-align:center">关系操作符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">&lt;</td><td style="text-align:center">小于</td></tr><tr><td style="text-align:center">&lt;=</td><td style="text-align:center">小于等于</td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:center">大于</td></tr><tr><td style="text-align:center">&gt;=</td><td style="text-align:center">大于等于</td></tr><tr><td style="text-align:center">==</td><td style="text-align:center">等于</td></tr><tr><td style="text-align:center">~=</td><td style="text-align:center">不等于</td></tr></tbody></table></div><p>matlab关系操作符能用来比较两个同样大小的数组,或用来比较一个数组和一个标量,在后一种情况中,标量和数组中的每一个元素相比较,结果与数组大小一样</p><div class="table-container"><table><thead><tr><th style="text-align:center">逻辑运算符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">&amp;</td><td style="text-align:center">与</td></tr><tr><td style="text-align:center">丨</td><td style="text-align:center">或</td></tr><tr><td style="text-align:center">~</td><td style="text-align:center">非</td></tr><tr><td style="text-align:center">xor(x,y)</td><td style="text-align:center">异或</td></tr><tr><td style="text-align:center">any(x)</td><td style="text-align:center">判断是否为零向量或者零矩阵</td></tr></tbody></table></div><h3 id="字符和字符串"><a href="#字符和字符串" class="headerlink" title="字符和字符串"></a>字符和字符串</h3><ol><li>在matlab中,<strong>文本</strong>当做特征字符串或简单地当做字符串</li><li>字符串能够<strong>显示在屏幕上</strong>,也可以<strong>用来构成一些命令</strong>,这些命令在其他的命令中用于求值或者被执行</li><li>一个字符串是存储在一个行向量中的文本,这个行向量中的每一个元素代表一个字符,实际上,元素中存放的是字符的ASCII码</li><li>在屏幕上显示字符变量的值时,显示出来的是文本,而不是ASCII数字</li><li>由于字符串是以向量的形式来存储的,因此可以通过它的下标对字符串中的任何一个元素进行访问,字符矩阵也可以通过下标索引进行访问,但是矩阵的每行字符数必须相同</li><li>一个字符串是由<strong>单引号</strong>括起来的简单文本</li><li>在字符串里的每个字符是数组里的一个元素,字符串的存储要求<strong>每个字符占8个字节</strong></li><li>字符串基本操作(以s=‘123456789’ 为例)</li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:left">输出</th></tr></thead><tbody><tr><td style="text-align:center">u=abs(s)</td><td style="text-align:left">u =[49,50,51,52,53,54,55,56,57]</td></tr><tr><td style="text-align:center">s=s+0</td><td style="text-align:left">s =[49,50,51,52,53,54,55,56,57]</td></tr><tr><td style="text-align:center">u=s(4:9)</td><td style="text-align:left">u=‘456789’</td></tr><tr><td style="text-align:center">u=s(9:-2:3)</td><td style="text-align:left">u=‘9753’</td></tr><tr><td style="text-align:center">输入s=I’’am Bob.</td><td style="text-align:left">s=I’m Bob</td></tr><tr><td style="text-align:center">u=[s ‘87654321’]</td><td style="text-align:left">u=‘12345678987654321’</td></tr></tbody></table></div><h3 id="函数句柄"><a href="#函数句柄" class="headerlink" title="函数句柄"></a>函数句柄</h3><p>在matlab中调用函数分为直接调用和间接调用</p><ul><li><p>直接调用</p><ul><li>被调函数被称为子函数</li><li>子函数只能被与其M文件同名的主函数或在M文件中的其他函数所调用</li><li>在一个文件中只能有一个主函数</li></ul></li><li><p>间接调用(函数句柄)</p><ul><li>避免了直接调用的限制(第二条)</li><li>创建函数句柄时需要用到操作符@</li><li>对任意函数都可以创造函数句柄</li><li>创建函数句柄的一般语法格式<ul><li>Function_Handle = @Function_Filename</li><li>Function_Filename是函数所对应的M文件的名称或matlab内部函数的名称</li><li>@是句柄创建操作符</li><li>Function_Handle变量保存了这一函数句柄,并在后续的运算中作为数据流进行传递</li><li>例:F_Handle=@cos 就创建了matlab内部函数cos的句柄,并将其保存在F_Handle变量中,后续的运算过程中就可以通过F_Handle(x)来实现cos(x)的功能</li><li>通过函数句柄调用函数时,也需要指定函数的输入参数(跟原来的那个函数调用一致)</li></ul></li></ul></li><li>函数句柄的操作函数</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">函数名称</th><th style="text-align:left">函数功能</th></tr></thead><tbody><tr><td style="text-align:center">functions(funhandle)</td><td style="text-align:left">返回一个结构体<br>包含函数的名称(function),函数类型(type),以及函数M文件的位置(file)</td></tr><tr><td style="text-align:center">func2str(funhandle)</td><td style="text-align:left">将函数句柄转换为函数名称的字符串</td></tr><tr><td style="text-align:center">str2func(str)</td><td style="text-align:left">将字符串代表的函数转换为函数句柄</td></tr><tr><td style="text-align:center">save filename.mat funhandle</td><td style="text-align:left">将函数句柄保存在*.mat文件中</td></tr><tr><td style="text-align:center">load filename.mat funhandle</td><td style="text-align:left">把*.mat文件中存储的函数句柄加载到工作区</td></tr><tr><td style="text-align:center">isa(var,’function_handle’)</td><td style="text-align:left">检测变量var是否是函数句柄</td></tr><tr><td style="text-align:center">isequal(funhandle1,funhandle2)</td><td style="text-align:left">检测两个函数句柄是否对应于同一个函数</td></tr></tbody></table></div><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><ul><li><p>创建结构体</p><ul><li><p>直接通过赋值语句给结构体的字段赋值</p><figure class="hljs highlight Matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Matlab">student.name=<span class="hljs-string">'sam'</span>;<br>student.grade=<span class="hljs-number">6</span>;<br>student.subject=&#123;<span class="hljs-string">'Chinese'</span>,<span class="hljs-string">'Math'</span>,<span class="hljs-string">'English'</span>&#125;;<br>student.result=&#123;<span class="hljs-number">99</span>,<span class="hljs-number">99</span>,<span class="hljs-number">99</span>&#125;;<br></code></pre></td></tr></table></figure><p><strong>注意</strong></p></li></ul><ol><li>在进行字段赋值时,没有明确赋值的字段,matlab默认赋值为空数组</li><li>通过圆括号索引进行字段赋值,还可以创建任意尺寸的结构体数组</li><li>同一个结构体数组中所有结构体对象具有相同的字段组合</li></ol><ul><li>利用struct函数创建结构体<ul><li>node = struct(‘field1’,var1,’field2’,var2,…,’fieldn’,varn)</li><li>数组  node(2) =struct(‘field1’,var1,’field2’,var2,…,’fieldn’,varn)</li><li>重复写入node = repmat(struct(‘day’,’thursday’,’time’),==1,2==)</li></ul></li></ul></li></ul><h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><p>matlab中进行运算的所有数据类型,都是按照数组及矩阵的形式进行存储和运算的,而二者在matlab中的基本运算性质不同,陈列强调元素对元素的运算,而矩阵则采用线性代数的运算方式</p><ul><li>数组定义 a=[1 2 3 4 5]</li><li>冒号定义<ul><li>a=1:10<br>a=[1 2 3 4 5 6 7 8 9 10]</li><li>a=1:2:10<br>a=[1 3 5 7 9]</li><li>a=linspace(a,b,100)<br>在区间[a,b]上创建一个有100个元素的向量,这100个数把整个区间线性分隔</li></ul></li></ul><h3 id="单元数组类型"><a href="#单元数组类型" class="headerlink" title="单元数组类型"></a>单元数组类型</h3><p>单元(cell)数组是一种无所不包的广义矩阵,组成单元数组的每一个元素称为一个单元,每一个单元可以包括一个任意数组,如数值数组,字符串数组,结构体数组或另外一个单元数组,因而每一个单元可以具有不同的尺寸和内存占用空间.</p><p><strong>注意</strong>:<strong>和一般的数值数组一样,单元数组的维数不受限制,可以是一维,二维或多维</strong></p><h4 id="单元数组的创建"><a href="#单元数组的创建" class="headerlink" title="单元数组的创建"></a>单元数组的创建</h4><ol><li><p>使用赋值语句创建单元数组</p><p>单元数组使用花括号”{}”来创建,使用逗号”,”或空格来分隔每一个单元,使用”;”来分行</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">c=&#123;<span class="hljs-string">'haha'</span>,[<span class="hljs-number">1</span>;<span class="hljs-number">2</span>;<span class="hljs-number">3</span>];<span class="hljs-number">10</span>,<span class="hljs-built_in">pi</span>&#125;<br></code></pre></td></tr></table></figure></li><li><p>利用cell函数创建空单元数组</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">cellname=cell(m,n)<br></code></pre></td></tr></table></figure><p>该函数创建一个m*n的空单元数组,其每一个单元均为空矩阵</p></li></ol><h4 id="单元数组的寻访"><a href="#单元数组的寻访" class="headerlink" title="单元数组的寻访"></a>单元数组的寻访</h4><p>在单元数组中,单元和单元中的内容是两个不同范畴的东西,因此,寻访单元和单元中的内容是两个不同的操作,matlab为上述两种操作设计了相对应的操作对象:单元外标识(Cell Indexing)和单元内编址(Content Addressing)</p><p>对于单元数组c,c(m,n)指的是单元数组中第m行第n列的单元,而c{m,n}指的是单元数组中第m行第n列单元中的内容</p><h4 id="单元数组的操作"><a href="#单元数组的操作" class="headerlink" title="单元数组的操作"></a>单元数组的操作</h4><ol><li><p>单元数组的合并</p><p><code>c={a b}</code></p></li><li><p>单元数组的删除</p><p>如果要删除单元数组中指定的某个单元,只需把空矩阵赋给该单元即可</p><p><code>c{m,n}=[]</code></p></li><li><p>使用reshape函数改变单元数组的形状</p><p><code>trimc = reshape(c,M,N)</code></p><p>该函数将单元数组c改变成一个具有M行N列的新单元数组</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab学习笔记(1)</title>
      <link href="/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/"/>
      <url>/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</url>
      
        <content type="html"><![CDATA[<p><strong>matlab学习笔记(1)主要介绍了以下内容</strong></p><ol><li>matlab的命令行通用命令</li><li>如何设置matlab调用文件的搜索路径</li><li>matlab的帮助系统</li></ol><a id="more"></a><h2 id="命令行通用命令"><a href="#命令行通用命令" class="headerlink" title="命令行通用命令"></a>命令行通用命令</h2><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">命令说明</th></tr></thead><tbody><tr><td style="text-align:center">cd</td><td style="text-align:center">显示或改变当前文件夹的地址</td></tr><tr><td style="text-align:center">dir</td><td style="text-align:center">显示当前文件夹或指定目录下的文件</td></tr><tr><td style="text-align:center">clc</td><td style="text-align:center">清除命令行中命令</td></tr><tr><td style="text-align:center">home</td><td style="text-align:center">将当前输入放到最上面</td></tr><tr><td style="text-align:center">clf</td><td style="text-align:center">清除图形窗口</td></tr><tr><td style="text-align:center">type</td><td style="text-align:center">显示文件内容</td></tr><tr><td style="text-align:center">clear</td><td style="text-align:center">清理工作区变量</td></tr><tr><td style="text-align:center">load</td><td style="text-align:center">加载指定文件的变量</td></tr><tr><td style="text-align:center">diary</td><td style="text-align:center">日志文件命令</td></tr><tr><td style="text-align:center">!</td><td style="text-align:center">调用dos命令</td></tr><tr><td style="text-align:center">exit</td><td style="text-align:center">退出matlab</td></tr><tr><td style="text-align:center">pack</td><td style="text-align:center">收集内存碎片</td></tr><tr><td style="text-align:center">hold</td><td style="text-align:center">图形保持开关</td></tr><tr><td style="text-align:center">path</td><td style="text-align:center">显示搜索目录</td></tr><tr><td style="text-align:center">save</td><td style="text-align:center">保存工作区变量到指定文件</td></tr></tbody></table></div><h3 id="标点"><a href="#标点" class="headerlink" title="标点"></a>标点</h3><div class="table-container"><table><thead><tr><th style="text-align:center">标点</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">:</td><td style="text-align:center">冒号,具有多种应用功能</td></tr><tr><td style="text-align:center">;</td><td style="text-align:center">分号,区分行及取消运行结果显示</td></tr><tr><td style="text-align:center">,</td><td style="text-align:center">逗号,区分列及函数参数分隔符</td></tr><tr><td style="text-align:center">()</td><td style="text-align:center">括号,指定运算的优先级</td></tr><tr><td style="text-align:center">[]</td><td style="text-align:center">方括号,定义矩阵</td></tr><tr><td style="text-align:center">{}</td><td style="text-align:center">大括号,构造单元数组</td></tr><tr><td style="text-align:center">%</td><td style="text-align:center">百分号,注释</td></tr><tr><td style="text-align:center">!</td><td style="text-align:center">感叹号,赋值标记</td></tr><tr><td style="text-align:center">=</td><td style="text-align:center">等号,赋值标记</td></tr><tr><td style="text-align:center">‘</td><td style="text-align:center">单引号,字符串的标识符</td></tr><tr><td style="text-align:center">.</td><td style="text-align:center">小数点及对象域访问</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">续行符号</td></tr></tbody></table></div><h2 id="设置matlab调用文件的搜索路径"><a href="#设置matlab调用文件的搜索路径" class="headerlink" title="设置matlab调用文件的搜索路径"></a>设置matlab调用文件的搜索路径</h2><ol><li><p>为什么要设置</p><p>一般情况下,matlab系统的函数,包括工具箱函数,都是在系统默认的搜索路径之中的,但是用户设计的函数有可能没有保存到搜索路径下,很多情况容易造成matlab误认为该函数不存在,因此需要把程序所在的目录扩展成matlab的搜索路径即可.</p></li><li><p>如何设置</p><p>点击主页窗口的<code>设置路径</code>,点击<code>添加文件夹</code>,然后选择你的函数文件夹即可,建议建立一个大的文件夹,把所有的函数都放进去.</p><p><strong>注意:只有在matlab搜索路径中的函数才能被识别(可以调用path命令来查看搜索路径).并且当某一文件夹的父文件夹在搜索路径中而其本身不在搜索路径中时,则此文件夹不会被搜索到.</strong></p></li></ol><h2 id="帮助系统"><a href="#帮助系统" class="headerlink" title="帮助系统"></a>帮助系统</h2><ol><li><p>help命令</p><p>调用格式(以sin函数作为例子)</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">help <span class="hljs-built_in">sin</span><br></code></pre></td></tr></table></figure><p>调用后会显示简洁用法,以及详细的参考页,可以调用的不单单只是函数,还可以调用<code>pi</code>等常数</p></li><li><p>demos帮助</p><p>直接在命令行中输入<code>demo</code>,用户可以更加直观,快速地学习matlab实用知识.</p></li><li><p>帮助导航浏览器</p><p>帮助导航浏览器是matlab专门提供的一个独立的帮助子系统,该系统包含的所有帮助文件都存储在matlab安装目录下的help子目录下</p><p>打开方式:命令行中直接输入<code>doc</code></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
