<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>向量</title>
      <link href="/2020/05/11/%E5%90%91%E9%87%8F/"/>
      <url>/2020/05/11/%E5%90%91%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 数学之美 </category>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 向量 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenMP并行编程指南</title>
      <link href="/2020/04/20/OpenMP%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/"/>
      <url>/2020/04/20/OpenMP%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p>OpenMP主要用于C/C++的CPU并行计算。</p><a id="more"></a><h3 id="并行计算"><a href="#并行计算" class="headerlink" title="并行计算"></a>并行计算</h3><p>对于CPU密集型的程序来说，可以使用OpenMP加快程序的计算速度。</p><p>OpenMP是跨平台的，大部分现代的C/C++编译器都支持OpenMP。</p><p>程序员可以简单地通过编译器指令<code>pragma omp</code>去控制程序的行为。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp <span class="hljs-meta-string">&lt;directive&gt; [clause[[,] clause] ...]</span></span><br></code></pre></td></tr></table></figure><p>最常见的指令应该是<code>parallel</code>指令，紧接在<code>parallel</code>指令后面的那个代码块将会并行执行：</p><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp parallel&#123;</span><br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Hello World!"</span>&lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序会启用N个线程去执行<code>parallel</code>指令后面的那个代码块（N为CPU的核心数），执行完这个代码块后，程序又会变回单线程。</p><p>编译时只需提供<code>-fopenmp</code>参数，就可以让编译器启用OpenMP。</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ g++ -std=c++11 -fopenmp -o main main.cpp<br>$ ./main<br>Hello, World!<br>Hello, World!<br></code></pre></td></tr></table></figure><p>OpenMP还提供<code>parallel for</code>指令，它的作用是<strong>将for循环分为N个线程去执行</strong>。</p><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdint&gt;</span></span><br><span class="hljs-keyword">using</span> Int = <span class="hljs-keyword">uint64_t</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;<br>    <span class="hljs-keyword">constexpr</span> Int size = <span class="hljs-number">10</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Int&gt; squares(size, <span class="hljs-number">0</span>);<br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp parallel for</span><br>    <span class="hljs-keyword">for</span> (Int i = <span class="hljs-number">0</span>; i &lt; size; ++i)<br>    &#123;<br>        squares[i] = i * i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该代码等同于：</p><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;omp.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdint&gt;</span></span><br><span class="hljs-keyword">using</span> Int = <span class="hljs-keyword">uint64_t</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;<br>    <span class="hljs-keyword">constexpr</span> Int size = <span class="hljs-number">10</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Int&gt; squares(size, <span class="hljs-number">0</span>);<br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> omp parallel</span><br>    &#123;<br>        Int thread_id = omp_get_thread_num();     <span class="hljs-comment">// 线程 ID, 范围从 0 到 N - 1</span><br>        Int thread_nums = omp_get_num_threads();  <span class="hljs-comment">// 线程的数量</span><br>        Int first = thread_id * size / thread_nums;<br>        Int last = (thread_id + <span class="hljs-number">1</span>) * size / thread_nums;<br>        <span class="hljs-keyword">for</span> (Int i = first; i &lt; last; ++i)<br>        &#123;<br>            squares[i] = i * i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>unity学习</title>
      <link href="/2020/03/22/unity%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/03/22/unity%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
          <category> unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机图形学 </tag>
            
            <tag> unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LearnOpenGL</title>
      <link href="/2020/02/27/LearnOpenGL/"/>
      <url>/2020/02/27/LearnOpenGL/</url>
      
        <content type="html"><![CDATA[<p>本文主要总结了我在《LearnOpenGL》中学习的过程</p><a id="more"></a><h1 id="文档说明"><a href="#文档说明" class="headerlink" title="文档说明"></a>文档说明</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>LearnOpenGL被分解成许多大的主题。每个<strong>主题</strong>包括一些<strong>小节</strong>，每个小节中会对不同的概念进行详细的解释。</p><p>本文采用了<strong>方框</strong>和<strong>代码</strong>。</p><h3 id="方框"><a href="#方框" class="headerlink" title="方框"></a>方框</h3><table><tr><td bgcolor="Chartreuse">绿色方框是一些注释或者对于OpenGL或讨论主题有用的特性/提示</td></tr></table><table><tr><td bgcolor="LightCoral">红色方框是一些警告或者一些你需要特别注意的特性</td></tr></table><table><tr><td bgcolor="LightSkyBlue">蓝色方框是帮助读者理解附加的一些信息</td></tr></table><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>代码会放在代码框中</p><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 这个方框是代码</span><br></code></pre></td></tr></table></figure><p>这样只提供了代码片段，当需要的时候会提供<strong>链接</strong>到当前工程的源代码中。</p><h3 id="颜色标记"><a href="#颜色标记" class="headerlink" title="颜色标记"></a>颜色标记</h3><p>有一些词语会以不同的颜色显示出来，用来表示这些词语有不同的意义</p><ul><li><font color="Green">定义</font>：绿色的字是定义，即一个重要的概念或名称，这些词语常能看到。</li><li><font color="Red">程序逻辑</font>：红色的字是函数的名称或者是类名。</li><li><font color="blue">变量</font>：蓝色的字是变量，包括所有的OpenGL常量。</li></ul><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>OpenGL是一个<strong>图形API（Application Programming Interface, 应用程序编程接口）</strong>，包含了一系列可以操作图形、图像的函数，由<a href="https://www.khronos.org/" target="_blank" rel="noopener">khronos</a>组织制定并维护的规范(Specification)。</p><p>OpenGL规范严格规定了<strong>每个函数该如何执行，以及它的输出值</strong>。内部函数具体如何实现(Implement)的，由OpenGL库的开发者自行决定，因此具体的OpenGL库允许使用不同的实现，只要其功能和结果与规范相匹配即可。</p><p>实际的OpenGL库的开发者通常是显卡的生产商。购买的显卡所支持的OpenGL版本都为这个系列的显卡专门开发的。当你使用Apple系统的时候，OpenGL库是由Apple自身维护的。在Linux下，有显卡生产商提供的OpenGL库，也有一些爱好者改编的版本。这也意味着<strong>任何时候OpenGL库表现的行为与规范规定的不一致时，基本都是库的开发者留下的bug</strong>。</p><table><tr><td bgcolor="Chartreuse">由于OpenGL的大多数实现都是由显卡厂商编写的，当产生一个bug时通常可以通过升级显卡驱动来解决。这些驱动会包括你的显卡能支持的最新版本的OpenGL，这也是为什么总是建议你偶尔更新一下显卡驱动</td></tr></table><p>所有版本的OpenGL规范文档都被公开寄存在Khronos那里。例如：<a href="https://www.opengl.org/registry/doc/glspec33.core.20100311.withchanges.pdf" target="_blank" rel="noopener">OpenGL3.3</a></p><ol><li>c++语言（如果对c++不是很熟悉，可以<a href="www.learncpp.com">learncpp</a>上学习）。</li><li>数学知识（线性代数、几何、三角学）。</li></ol><h2 id="核心模式与立即渲染模式"><a href="#核心模式与立即渲染模式" class="headerlink" title="核心模式与立即渲染模式"></a>核心模式与立即渲染模式</h2><p>早期的OpenGL使用<font color="green">立即渲染模式</font>(Immediate mode, 也就是<font color="green">固定渲染模式</font>&gt;)，这个模式下绘制图形很方便。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
            <tag> 计算机图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICthroughVR: Illuminating Cataracts through Virtual Reality</title>
      <link href="/2019/12/21/ICthroughVR-Illuminating-Cataracts-through-Virtual-Reality/"/>
      <url>/2019/12/21/ICthroughVR-Illuminating-Cataracts-through-Virtual-Reality/</url>
      
        <content type="html"><![CDATA[<p><strong>ICthroughVR: Illuminating(照亮) Cataracts(白内障) through Virtual Reality</strong></p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/ICthroughVR%3A%20Illuminating%20Cataracts%20through%20Virtual%20Reality/Figure%201.png"></p><p>Vision impairments, such as cataracts, affect the way many people interact with their environment, yet are rarely considered by <strong>architects and lighting designers</strong> because of a lack of design tools.</p><p>we present a method to <strong>simulate vision impairments</strong>, in particular cataracts, graphically in virtual reality (VR), using eye tracking for gaze-dependent(注视) effects. </p><p>We also conduct(进行) a VR user study to <strong>investigate the effects of lighting on visual perception(感知) for users with cataracts</strong>.</p><p>In contrast to existing approaches, <strong>which mostly provide only simplified simulations and are primarily targeted at educational or demonstrative(示范) purposes</strong>, we account for the user’s vision and the hardware constraints(限制) of the VR headset.</p><p>This makes it possible to calibrate(矫正) our cataract simulation to the same level of degraded(降低) vision for all participants. </p><p>Our study results show that we are able to calibrate(矫正) the vision of all our participants to a similar level of impairment, that maximum recognition distances for escape route signs with simulated cataracts are significantly smaller than without, and that luminaires(灯具) visible in the field of view are perceived as especially disturbing due to the glare effects they create.</p><p>In addition, the results show that our realistic simulation increases the understanding of how people with cataracts see and could therefore also be informative for health care personnel or relatives of cataract patients.</p><a id="more"></a><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Vision impairments affect 1.3 billion people worldwide, according to the <em>World Health Organization</em> (WHO), with cataracts being one of the leading causes.</p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
          <category> 虚拟现实 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟现实 </tag>
            
            <tag> 医疗康复 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>彻底理解红黑树</title>
      <link href="/2019/09/20/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
      <url>/2019/09/20/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p><strong>当在10亿数据中只需要进行10几次比较就能查找到目标时，不禁感叹编程之魅力！人类之伟大呀！ —— 学红黑树有感。</strong></p><p>红黑树是一种比较难的数据结构，要完全搞懂非常耗时耗力，红黑树怎么自平衡？什么时候需要左旋或右旋？插入和删除破坏了树的平衡后怎么处理？等等问题。</p><p>本文将通过图文的方式讲解红黑树的知识点，并且不会涉及到任何代码，相信我，在懂得红黑树实现原理前，看代码会一头雾水的，当原理懂了，代码也就按部就班写而已，没任何难度。</p><p>阅读本文需要具备知识点：</p><ul><li>二叉查找树</li><li>完美平衡二叉树</li></ul><a id="more"></a><p>红黑树也是二叉查找树，我们知道，二叉查找树这一数据结构并不难，而红黑树之所以难是难在它是自平衡的二叉查找树，在进行插入和删除等可能会破坏树的平衡的操作时，需要重新自处理达到平衡状态。</p><h2 id="红黑树的定义和性质"><a href="#红黑树的定义和性质" class="headerlink" title="红黑树的定义和性质"></a>红黑树的定义和性质</h2><p>红黑树是一种含有红黑结点并能自平衡的二叉查找树。它必须满足下面性质：</p><ul><li>性质1：每个结点要么是黑色的，要么是红色的。</li><li>性质2：根结点是黑色的。</li><li>性质3：每个叶子结点（NIL）是黑色的。</li><li>性质4：每个红色结点的两个子结点一定都是黑色的。</li><li><strong>性质5：任意一结点到其每个叶子结点的路径都包含数量相同的黑结点。</strong></li></ul><p>从性质5可以推出：</p><ul><li>性质5.1：如果一个结点存在黑子结点，那么该结点肯定有两个子结点。</li></ul><p>下图就是一颗简单的红黑树。其中Nil为叶子结点，并且它是黑色的。(值得提醒注意的是，在Java中，叶子结点是为null的结点。)</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%80%E6%A3%B5%E7%AE%80%E5%8D%95%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91.png" width="70%"></p><p>红黑树并不是一个<strong>完美</strong>平衡二叉查找树，从上图可以看到，根结点P的左子树显然比右子树高，但左子树和右子树的黑结点的层数是相等的，也即任意一个结点到到每个叶子结点的路径都包含数量相同的黑结点(性质5)。所以我们叫红黑树这种平衡为<strong>黑色完美平衡</strong>。</p><p>介绍到此，为了后面讲解不至于混淆，我们还需要来约定下红黑树一些结点的叫法，如下图所示。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BB%93%E7%82%B9%E5%8F%AB%E6%B3%95%E7%BA%A6%E5%AE%9A.png" width="70%"></p><p>我们把正在处理(遍历)的结点叫做当前结点，如上图中的D，它的父亲叫做父结点，它的父亲的另外一个子结点叫做兄弟结点，父亲的父亲叫做祖父结点。</p><p>红黑树自平衡靠三种操作：左旋、右旋和变色。</p><ul><li><strong>左旋</strong>：以某个结点作为支点(旋转结点P)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。如下图所示。</li></ul><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E6%97%8B.png" width="70%"></p><ul><li><strong>右旋</strong>：以某个结点作为支点(旋转结点P)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。如下图所示。</li></ul><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8F%B3%E6%97%8B.png" width="70%"></p><ul><li><strong>变色</strong>：结点的颜色由红变黑或由黑变红。</li></ul><p>我们先忽略颜色，可以看到旋转操作不会影响旋转结点的父结点，父结点以上的结构还是保持不变的。<br><strong>左旋</strong>只影响旋转结点和其<strong>右子树</strong>的结构，把右子树的结点往左子树挪了。<br><strong>右旋</strong>只影响旋转结点和其<strong>左子树</strong>的结构，把左子树的结点往右子树挪了。</p><p>所以旋转操作是<strong>局部</strong>的。另外可以看出旋转能保持红黑树平衡的一些端详了：当一边子树的结点少了，那么向另外一边子树“借”一些结点；当一边子树的结点多了，那么向另外一边子树“租”一些结点。</p><p>但要保持红黑树的性质，结点不能乱挪，还得靠变色了。怎么变？具体情景又不同变法，后面会具体讲到，现在只需要记住<strong>红黑树总是通过旋转和变色达到自平衡</strong>。</p><blockquote><p><strong>思考题1：黑结点可以同时包含一个红子结点和一个黑子结点吗？</strong></p><p>答：可以。如下图的F结点：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%80%9D%E8%80%83%E9%A2%981.png"></p></blockquote><h2 id="红黑树查找"><a href="#红黑树查找" class="headerlink" title="红黑树查找"></a>红黑树查找</h2><p>因为红黑树是一颗二叉平衡树，并且查找不会破坏树的平衡，所以查找跟二叉平衡树的查找无异：</p><ol><li>从根结点开始查找，把根结点设置为当前结点；</li><li>若当前结点为空，返回null；</li><li>若当前结点不为空，用当前结点的key跟查找key作比较；</li><li>若当前结点key等于查找key，那么该key就是查找目标，返回当前结点；</li><li>若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤2；</li><li>若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤2；</li></ol><p>流程图：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%9F%A5%E6%89%BE.png" width="80%"></p><p>非常简单，但简单不代表它效率不好。正由于红黑树总保持黑色完美平衡，所以它的查找最坏时间复杂度为$O(2logN)$，也即整颗树刚好红黑相隔的时候。能有这么好的查找效率得益于红黑树自平衡的特性，而这背后的付出，红黑树的插入操作功不可没～</p><h2 id="红黑树插入"><a href="#红黑树插入" class="headerlink" title="红黑树插入"></a>红黑树插入</h2><p>插入操作包括两部分工作：一查找插入的位置；二插入后自平衡。查找插入的父结点很简单，跟查找操作区别不大：</p><ol><li>从根结点开始查找；</li><li>若根结点为空，那么插入结点作为根结点，结束。</li><li>若根结点不为空，那么把根结点作为当前结点；</li><li>若当前结点为null，返回当前结点的父结点，结束。</li><li>若当前结点key等于查找key，那么该key所在结点就是插入结点，更新结点的值，结束。</li><li>若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤4；</li><li>若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤4；</li></ol><p>流程图：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A5.png" width="80%"></p><p>ok，插入位置已经找到，把插入结点放到正确的位置就可以啦，但插入结点是应该是什么颜色呢？答案是<strong>红色</strong>。理由很简单，红色在父结点（如果存在）为黑色结点时，红黑树的黑色平衡没被破坏，不需要做自平衡操作。但如果插入结点是黑色，那么插入位置所在的子树黑色结点总是多1，必须做自平衡。</p><p>所有插入情景如下：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A5%E6%83%85%E6%99%AF.png"></p><p>一共有8种插入情景，但情景1、2和3的处理很简单，而情景4.2和情景4.3只是方向反转而已，懂得了一种情景就能推出另外一种情景，所以总体来看，并不复杂，后续我们将一个一个情景来看，把它彻底搞懂。</p><p>根据二叉树的性质，<strong>除了情景2，所有插入操作都是在叶子结点进行的</strong>。这点应该不难理解，因为查找插入位置时，我们就是在找子结点为空的父结点的。</p><p>在开始每个情景的讲解前，我们还是先来约定下，如下图所示。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8F%92%E5%85%A5%E7%BB%93%E7%82%B9%E7%9A%84%E5%8F%AB%E6%B3%95%E7%BA%A6%E5%AE%9A.png" width="80%"></p><p>图中的字母并不代表结点Key的大小。I表示插入结点，P表示插入结点的父结点，S表示插入结点的叔叔结点，PP表示插入结点的祖父结点。</p><p>接下来，我们一个一个分析每个插入情景以及处理。</p><h3 id="插入情景1：红黑树为空树"><a href="#插入情景1：红黑树为空树" class="headerlink" title="插入情景1：红黑树为空树"></a>插入情景1：红黑树为空树</h3><p>最简单的一种情景，直接把插入结点作为根结点就行，但注意，<strong>根据红黑树性质2：根节点是黑色</strong>。还需要把插入结点设为<strong>黑色</strong>。</p><p><strong>处理：把插入结点作为根结点，并把结点设置为黑色</strong>。</p><h3 id="插入情景2：插入结点的Key已存在"><a href="#插入情景2：插入结点的Key已存在" class="headerlink" title="插入情景2：插入结点的Key已存在"></a>插入情景2：插入结点的Key已存在</h3><p>插入结点的Key已存在，既然红黑树总保持平衡，在插入前红黑树已经是平衡的，那么把插入结点设置为将要替代结点的颜色，再把结点的值更新就完成插入。</p><p><strong>处理：</strong></p><ul><li><strong>把I设为当前结点的颜色</strong></li><li><strong>更新当前结点的值为插入结点的值</strong></li></ul><h3 id="插入情景3：插入结点的父结点为黑结点"><a href="#插入情景3：插入结点的父结点为黑结点" class="headerlink" title="插入情景3：插入结点的父结点为黑结点"></a>插入情景3：插入结点的父结点为黑结点</h3><p>由于插入的结点是红色的，当插入结点的父结点为黑色时，并不会影响红黑树的平衡，直接插入即可，无需做自平衡。</p><p><strong>处理：直接插入</strong>。</p><h3 id="插入情景4：插入结点的父结点为红结点"><a href="#插入情景4：插入结点的父结点为红结点" class="headerlink" title="插入情景4：插入结点的父结点为红结点"></a>插入情景4：插入结点的父结点为红结点</h3><p>再次回想下红黑树的性质2：根结点是黑色。<strong>如果插入的父结点为红结点，那么该父结点不可能为根结点，所以插入结点总是存在祖父结点</strong>。这点很重要，因为后续的旋转操作肯定需要祖父结点的参与。</p><p>情景4又分为很多子情景，下面将进入重点部分，各位看官请留神了。</p><h4 id="插入情景4-1：叔叔结点存在并且为红结点"><a href="#插入情景4-1：叔叔结点存在并且为红结点" class="headerlink" title="插入情景4.1：叔叔结点存在并且为红结点"></a>插入情景4.1：叔叔结点存在并且为红结点</h4><p>从红黑树性质4可以，祖父结点肯定为黑结点，因为不可以同时存在两个相连的红结点。那么此时该插入子树的红黑层数的情况是：黑红红。显然最简单的处理方式是把其改为：红黑红。</p><p><strong>处理：</strong></p><ul><li><strong>将P和S设置为黑色</strong></li><li><strong>将PP设置为红色</strong></li><li><strong>把PP设置为当前插入结点</strong></li></ul><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.1.1.png" width="80%"></p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.1.2.png" width="80%"></p><p>可以看到，我们把PP结点设为红色了，如果PP的父结点是黑色，那么无需再做任何处理；但如果PP的父结点是红色，根据性质4，此时红黑树已不平衡了，所以还需要把PP当作新的插入结点，继续做插入操作自平衡处理，直到平衡为止。</p><p>试想下PP刚好为根结点时，那么根据性质2，我们必须把PP重新设为黑色，那么树的红黑结构变为：黑黑红。换句话说，从根结点到叶子结点的路径中，黑色结点增加了。<strong>这也是唯一一种会增加红黑树黑色结点层数的插入情景</strong>。</p><p>我们还可以总结出另外一个经验：<strong>红黑树的生长是自底向上的</strong>。这点不同于普通的二叉查找树，普通的二叉查找树的生长是自顶向下的。</p><h4 id="插入情景4-2：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的左子结点"><a href="#插入情景4-2：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的左子结点" class="headerlink" title="插入情景4.2：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的左子结点"></a>插入情景4.2：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的左子结点</h4><p>单纯从插入前来看，也即不算情景4.1自底向上处理时的情况，叔叔结点非红即为叶子结点(Nil)。因为如果叔叔结点为黑结点，而父结点为红结点，那么叔叔结点所在的子树的黑色结点就比父结点所在子树的多了，这不满足红黑树的性质5。后续情景同样如此，不再多做说明了。</p><p>前文说了，需要旋转操作时，肯定一边子树的结点多了或少了，需要租或借给另一边。插入显然是多的情况，那么把多的结点租给另一边子树就可以了。</p><h5 id="插入情景4-2-1：插入结点是其父结点的左子节点"><a href="#插入情景4-2-1：插入结点是其父结点的左子节点" class="headerlink" title="插入情景4.2.1：插入结点是其父结点的左子节点"></a>插入情景4.2.1：插入结点是其父结点的左子节点</h5><p><strong>处理：</strong></p><ul><li><strong>将P设为黑色</strong></li><li><strong>将PP设为红色</strong></li><li><strong>对PP进行右旋</strong></li></ul><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.2.1.png" width="80%"></p><p>由上图可得，左边两个红结点，右边不存在，那么一边一个刚刚好，并且因为为红色，肯定不会破坏树的平衡。</p><p>咦，可以把PP设为红色，I和P设为黑色吗？答案是可以！看过《算法：第4版》的同学可能知道，书中讲解的就是把PP设为红色，I和P设为黑色。但把PP设为红色，显然又会出现情景4.1的情况，需要自底向上处理，做多了无谓的操作，既然能自己消化就不要麻烦祖辈们啦～</p><h5 id="插入情景4-2-2：插入结点是其父结点的右子结点"><a href="#插入情景4-2-2：插入结点是其父结点的右子结点" class="headerlink" title="插入情景4.2.2：插入结点是其父结点的右子结点"></a>插入情景4.2.2：插入结点是其父结点的右子结点</h5><p>这种情景显然可以转换为情景4.2.1，如下图所示，不做过多说明了。</p><p><strong>处理：</strong></p><ul><li><strong>对P进行左旋</strong></li><li><strong>把P设置为插入结点，得到情景4.2.1</strong></li><li><strong>进行情景4.2.1的处理</strong></li></ul><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.2.2.png" width="80%"></p><h4 id="插入情景4-3：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的右子结点"><a href="#插入情景4-3：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的右子结点" class="headerlink" title="插入情景4.3：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的右子结点"></a>插入情景4.3：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的右子结点</h4><p>该情景对应情景4.2，只是方向反转，不做过多说明了，直接看图。</p><h5 id="插入情景4-3-1：插入结点是其父结点的右子结点"><a href="#插入情景4-3-1：插入结点是其父结点的右子结点" class="headerlink" title="插入情景4.3.1：插入结点是其父结点的右子结点"></a>插入情景4.3.1：插入结点是其父结点的右子结点</h5><p><strong>处理：</strong></p><ul><li><strong>将P设为黑色</strong></li><li><strong>将PP设为红色</strong></li><li><strong>对PP进行左旋</strong></li></ul><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.3.1.png" width="80%"></p><h5 id="插入情景4-3-2：插入结点是其父结点的右子结点"><a href="#插入情景4-3-2：插入结点是其父结点的右子结点" class="headerlink" title="插入情景4.3.2：插入结点是其父结点的右子结点"></a>插入情景4.3.2：插入结点是其父结点的右子结点</h5><p><strong>处理：</strong></p><ul><li><strong>对P进行右旋</strong></li><li><strong>把P设置为插入结点，得到情景4.3.1</strong></li><li><strong>进行情景4.3.1的处理</strong></li></ul><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.3.2.png" width="80%"></p><p>好了，讲完插入的所有情景了。可能又同学会想：上面的情景举例的都是第一次插入而不包含自底向上处理的情况，那么上面所说的情景都适合自底向上的情况吗？答案是肯定的。理由很简单，但每棵子树都能自平衡，那么整棵树最终总是平衡的。</p><blockquote><p>好吧，在出个习题，请大家拿出笔和纸画下试试（请务必动手画下，加深印象）：</p><p><strong>习题1：请画出下图的插入自平衡处理过程。</strong></p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B9%A0%E9%A2%981.png" width="80%"></p><p>答：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B9%A0%E9%A2%981%E8%A7%A3%E7%AD%94.png" width="80%"></p></blockquote><h2 id="红黑树删除"><a href="#红黑树删除" class="headerlink" title="红黑树删除"></a>红黑树删除</h2><p>红黑树插入已经够复杂了，但删除更复杂，也是红黑树最复杂的操作了。但稳住，胜利的曙光就在前面了！</p><p>红黑树的删除操作也包括两部分工作：一查找目标结点；而删除后自平衡。查找目标结点显然可以复用查找操作，当不存在目标结点时，忽略本次操作；当存在目标结点时，删除后就得做自平衡处理了。删除了结点后我们还需要找结点来替代删除结点的位置，不然子树跟父辈结点断开了，除非删除结点刚好没子结点，那么就不需要替代。</p><p>二叉树删除结点找替代结点有3种情情景：</p><ul><li>情景1：若删除结点无子结点，直接删除</li><li>情景2：若删除结点只有一个子结点，用子结点替换删除结点</li><li>情景3：若删除结点有两个子结点，用后继结点（大于删除结点的最小结点）替换删除结点</li></ul><p>补充说明下，<strong>情景3的后继结点是大于删除结点的最小结点</strong>，也是<strong>删除结点的右子树的最左结点</strong>。那么可以拿前继结点（删除结点的左子树最右结点）替代吗？可以的。但习惯上大多都是拿后继结点来替代，后文的讲解也是用后继结点来替代。</p><p>另外告诉大家一种找前继和后继结点的直观的方法（不知为何没人提过，大家都知道？）：<strong>把二叉树所有结点投射在X轴上，所有结点都是从左到右排好序的，所有目标结点的前后结点就是对应前继和后继结点</strong>。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8A%95%E5%B0%84x%E8%BD%B4%E5%90%8E%E6%9C%89%E5%BA%8F.png" width="80%"></p><p>接下来，讲一个重要的思路：<strong>删除结点被替代后，在不考虑结点的键值的情况下，对于树来说，可以认为删除的是替代结点！</strong></p><p>话很苍白，我们看下图。在不看键值对的情况下，图中的红黑树最终结果是删除了Q所在位置的结点！这种思路非常重要，大大简化了后文讲解红黑树删除的情景！</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9%E6%8D%A2%E4%BD%8D%E6%80%9D%E8%B7%AF.png" width="80%"></p><p>基于此，上面所说的3种二叉树的删除情景可以相互转换并且最终都是转换为情景1！</p><ul><li>情景2：删除结点用其唯一的子结点替换，子结点替换为删除结点后，可以认为删除的是子结点，若子结点又有两个子结点，那么相当于转换为情景3，一直自顶向下转换，总是能转换为情景1。（对于红黑树来说，根据性质5.1，只存在一个子结点的结点肯定在树末了）</li><li>情景3：删除结点用后继结点（肯定不存在左结点），如果后继结点有右子结点，那么相当于转换为情景2，否则转为为情景1。</li></ul><p>二叉树删除结点情景关系图如图所示。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E6%99%AF%E8%BD%AC%E6%8D%A2.png" width="80%"></p><p>综上所述，<strong>删除操作删除的结点可以看作删除替代结点，而替代结点最后总是在树末。</strong>有了这结论，我们讨论的删除红黑树的情景就少了很多，因为我们只考虑删除树末结点的情景了。</p><p>同样的，我们也是先来总体看下删除操作的所有情景，如下图所示。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4%E6%83%85%E6%99%AF.png"></p><p>即使简化了还是有9种情景！但跟插入操作一样，存在左右对称的情景，只是方向变了，没有本质区别。</p><p>同样的，我们还是来约定下，如图所示。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E7%BB%93%E7%82%B9%E7%9A%84%E5%8F%AB%E6%B3%95%E7%BA%A6%E5%AE%9A.png" width="80%"></p><p>图中的字母并不代表结点Key的大小。R表示替代结点，P表示替代结点的父结点，S表示替代结点的兄弟结点，SL表示兄弟结点的左子结点，SR表示兄弟结点的右子结点。灰色结点表示它可以是红色也可以是黑色。</p><p>值得特别提醒的是，<strong>R是即将被替换到删除结点的位置的替代结点，在删除前，它还在原来所在位置参与树的子平衡，平衡后再替换到删除结点的位置，才算删除完成。</strong></p><p>万事具备，我们进入最后的也是最难的讲解。</p><h4 id="删除情景1：替换结点是红色结点"><a href="#删除情景1：替换结点是红色结点" class="headerlink" title="删除情景1：替换结点是红色结点"></a>删除情景1：替换结点是红色结点</h4><p>我们把替换结点换到了删除结点的位置时，由于替换结点时红色，删除也了不会影响红黑树的平衡，只要把替换结点的颜色设为删除的结点的颜色即可重新平衡。</p><p><strong>处理：颜色变为删除结点的颜色</strong></p><h4 id="删除情景2：替换结点是黑结点"><a href="#删除情景2：替换结点是黑结点" class="headerlink" title="删除情景2：替换结点是黑结点"></a>删除情景2：替换结点是黑结点</h4><p>当替换结点是黑色时，我们就不得不进行自平衡处理了。我们必须还得考虑替换结点是其父结点的左子结点还是右子结点，来做不同的旋转操作，使树重新平衡。</p><h5 id="删除情景2-1：替换结点是其父结点的左子结点"><a href="#删除情景2-1：替换结点是其父结点的左子结点" class="headerlink" title="删除情景2.1：替换结点是其父结点的左子结点"></a>删除情景2.1：替换结点是其父结点的左子结点</h5><p><strong>删除情景2.1.1：替换结点的兄弟结点是红结点</strong><br>若兄弟结点是红结点，那么根据性质4，兄弟结点的父结点和子结点肯定为黑色，不会有其他子情景，我们按图21处理，得到删除情景2.1.2.3（后续讲解，这里先记住，此时R仍然是替代结点，它的新的兄弟结点SL和兄弟结点的子结点都是黑色）。</p><p><strong>处理：</strong></p><ul><li><strong>将S设为黑色</strong></li><li><strong>将P设为红色</strong></li><li><strong>对P进行左旋，得到情景2.1.2.3</strong></li><li><strong>进行情景2.1.2.3的处理</strong></li></ul><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%88%A0%E9%99%A4%E6%83%85%E6%99%AF2.1.1.png" width="80%"></p><p><strong>删除情景2.1.2：替换结点的兄弟结点是黑结点</strong></p><p>当兄弟结点为黑时，其父结点和子结点的具体颜色也无法确定（如果也不考虑自底向上的情况，子结点非红即为叶子结点Nil，Nil结点为黑结点），此时又得考虑多种子情景。</p><p><strong>删除情景2.1.2.1：替换结点的兄弟结点的右子结点是红结点，左子结点任意颜色</strong><br>即将删除的左子树的一个黑色结点，显然左子树的黑色结点少1了，然而右子树又又红色结点，那么我们直接向右子树“借”个红结点来补充黑结点就好啦，此时肯定需要用旋转处理了。如下图所示。</p><p><strong>处理：</strong></p><ul><li><strong>将S的颜色设为P的颜色</strong></li><li><strong>将P设为黑色</strong></li><li><strong>将SR设为黑色</strong></li><li><strong>对P进行左旋</strong></li></ul><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%88%A0%E9%99%A4%E6%83%85%E6%99%AF2.1.2.1.png" width="80%"></p><p>平衡后的图怎么不满足红黑树的性质？前文提醒过，R是即将替换的，它还参与树的自平衡，平衡后再替换到删除结点的位置，所以R最终可以看作是删除的。另外上图是考虑到第一次替换和自底向上处理的情况，如果只考虑第一次替换的情况，根据红黑树性质，SL肯定是红色或为Nil，所以最终结果树是平衡的。如果是自底向上处理的情况，同样，每棵子树都保持平衡状态，最终整棵树肯定是平衡的。后续的情景同理，不做过多说明了。</p><p><strong>删除情景2.1.2.2：替换结点的兄弟结点的右子结点为黑结点，左子结点为红结点</strong><br>兄弟结点所在的子树有红结点，我们总是可以向兄弟子树借个红结点过来，显然该情景可以转换为情景2.1.2.1。如下图所示。</p><p><strong>处理：</strong></p><ul><li><strong>将S设为红色</strong></li><li><p><strong>将SL设为黑色</strong></p></li><li><p><strong>对S进行右旋，得到情景2.1.2.1</strong></p></li><li><strong>进行情景2.1.2.1的处理</strong></li></ul><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%88%A0%E9%99%A4%E6%83%85%E6%99%AF2.1.2.2.png" width="80%"></p><p><strong>删除情景2.1.2.3：替换结点的兄弟结点的子结点都为黑结点</strong><br>好了，此次兄弟子树都没红结点“借”了，兄弟帮忙不了，找父母呗，这种情景我们把兄弟结点设为红色，再把父结点当作替代结点，自底向上处理，去找父结点的兄弟结点去“借”。但为什么需要把兄弟结点设为红色呢？显然是为了在P所在的子树中保证平衡（R即将删除，少了一个黑色结点，子树也需要少一个），后续的平衡工作交给父辈们考虑了，还是那句，当每棵子树都保持平衡时，最终整棵总是平衡的。</p><p><strong>处理：</strong></p><ul><li><strong>将S设为红色</strong></li><li><strong>把P作为新的替换结点</strong></li><li><strong>重新进行删除结点情景处理</strong></li></ul><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%83%85%E6%99%AF2.1.2.3.png" width="80%"></p><h5 id="删除情景2-2：替换结点是其父结点的右子结点"><a href="#删除情景2-2：替换结点是其父结点的右子结点" class="headerlink" title="删除情景2.2：替换结点是其父结点的右子结点"></a>删除情景2.2：替换结点是其父结点的右子结点</h5><p>好啦，右边的操作也是方向相反，不做过多说明了，相信理解了删除情景2.1后，肯定可以理解2.2。</p><p><strong>删除情景2.2.1：替换结点的兄弟结点是红结点</strong><br>处理：</p><ul><li><strong>将S设为黑色</strong></li><li><strong>将P设为红色</strong></li><li><strong>对P进行右旋，得到情景2.2.2.3</strong></li><li><strong>进行情景2.2.2.3的处理</strong></li></ul><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%88%A0%E9%99%A4%E6%83%85%E6%99%AF2.2.1.png" width="80%"></p><p><strong>删除情景2.2.2：替换结点的兄弟结点是黑结点</strong><br><strong>删除情景2.2.2.1：替换结点的兄弟结点的左子结点是红结点，右子结点任意颜色</strong><br><strong>处理：</strong></p><ul><li><strong>将S的颜色设为P的颜色</strong></li><li><strong>将P设为黑色</strong></li><li><strong>将SL设为黑色</strong></li><li><strong>对P进行右旋</strong></li></ul><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%88%A0%E9%99%A4%E6%83%85%E6%99%AF2.2.2.1.png" width="80%"></p><p><strong>删除情景2.2.2.2：替换结点的兄弟结点的左子结点为黑结点，右子结点为红结点</strong><br><strong>处理：</strong></p><ul><li><strong>将S设为红色</strong></li><li><strong>将SR设为黑色</strong></li><li><strong>对S进行左旋，得到情景2.2.2.1</strong></li><li><strong>进行情景2.2.2.1的处理</strong></li></ul><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%88%A0%E9%99%A4%E6%83%85%E6%99%AF2.2.2.2.png" width="80%"></p><p><strong>删除情景2.2.2.3：替换结点的兄弟结点的子结点都为黑结点</strong><br><strong>处理：</strong></p><ul><li><strong>将S设为红色</strong></li><li><strong>把P作为新的替换结点</strong></li><li><strong>重新进行删除结点情景处理</strong></li></ul><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%88%A0%E9%99%A4%E6%83%85%E6%99%AF2.2.2.3.png" width="80%"></p><p>综上，红黑树删除后自平衡的处理可以总结为：</p><ol><li>自己能搞定的自消化（情景1）</li><li>自己不能搞定的叫兄弟帮忙（除了情景1、情景2.1.2.3和情景2.2.2.3）</li><li>兄弟都帮忙不了的，通过父母，找远方亲戚（情景2.1.2.3和情景2.2.2.3）</li></ol><p>哈哈，是不是跟现实中很像，当我们有困难时，首先先自己解决，自己无力了总兄弟姐妹帮忙，如果连兄弟姐妹都帮不上，再去找远方的亲戚了。这里记忆应该会好记点～</p><blockquote><p>最后再做个习题加深理解（请不熟悉的同学务必动手画下）：</p><p>习题2：请画出下图的删除自平衡处理过程。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B9%A0%E9%A2%982.png" width="80%"></p><p>答：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B9%A0%E9%A2%982%E8%A7%A3%E7%AD%94.png"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红黑树 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性代数公式</title>
      <link href="/2019/09/10/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%85%AC%E5%BC%8F/"/>
      <url>/2019/09/10/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%85%AC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<ul><li>矩阵的秩</li></ul><a id="more"></a><h2 id="矩阵的秩"><a href="#矩阵的秩" class="headerlink" title="矩阵的秩"></a>矩阵的秩</h2><p>设$A$是$m\times n$矩阵，$B$是满足有关矩阵运算要求的矩阵，则</p><ol><li>$0\le r(a)\le \min\{m,n\}$</li><li><p>$r(kA)=r(A),(k\ne 0)$</p></li><li><p>设$A$是$m\times n$矩阵，$P,Q$分别是$m$阶、$n$阶可逆矩阵，则$r(A)=r(PA)=r(AQ)=r(PAQ)$</p></li><li><p>$r(AB)\le \min\{r(A),r(B)\}$，注：若$r(AB)\le r(A)$，$B$为$n$阶矩阵，则$r(B)&lt;n$</p></li><li>$r(A+B)\le r(A)+r(B)$</li><li><p>$r\left(\begin{bmatrix}A &amp;O\\O&amp;B\end{bmatrix}\right)=r(A)+r(B)$</p></li><li><p>$r(A)+r(B)\le r\left(\begin{bmatrix}A &amp;O\\C&amp;B\end{bmatrix}\right)\le r(A)+r(B)+r(C)$</p></li><li>$r(AB)\ge r(A)+r(B)-n$，注：当$AB=0$时，$r(A)+r(B)\le n$，$n$是$A$的列数（或$B$的行数）</li><li>$r(A)=r(A^T)=r(AA^T)=r(A^TA)$</li><li>$r(A^*)=\begin{cases}<br>\ n,r(A)=n \\<br>\ 1,r(A)=n-1,其中A为n阶方阵 \\<br>\ 0,r(A)&lt;n-1<br>\end{cases}$</li><li>若$A$是$n$阶方阵，$A^2=A$，则$r(A)+r(E-A)=n$</li><li>若$A$是$n$阶方阵，$A^2=E$，则$r(A+E)=r(A-E)=n$</li><li>$Ax=0$，基础解系所含向量的个数$S=n-r(A)$</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数学之美 </category>
          
          <category> 数学公式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 高数 </tag>
            
            <tag> 数学公式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高数公式</title>
      <link href="/2019/09/09/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/"/>
      <url>/2019/09/09/%E9%AB%98%E6%95%B0%E5%85%AC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<ul><li>不定积分的基本积分公式</li><li>定积分的性质</li><li>常见泰勒展开式</li><li>和差化积公式</li><li>积化和差公式</li><li>微分中值定理</li></ul><a id="more"></a><h2 id="不定积分的基本积分公式"><a href="#不定积分的基本积分公式" class="headerlink" title="不定积分的基本积分公式"></a>不定积分的基本积分公式</h2><p>$\int x^\alpha dx=\frac{1}{1+\alpha}x^{1+\alpha}+C,(\alpha \ne -1)$</p><p>$\int \frac{1}{x} dx=\ln|x|+C$</p><p>$\int a^x dx=\frac{a^x}{\ln a}+C,\int e^x dx=e^x+C$</p><p>$\int\cos xdx=\sin x+C$</p><p>$\int\sin xdx=-\cos x+C$</p><p>$\int \sec^2xdx=\int\frac{1}{\cos^2x}dx=\tan{x}+C$</p><p>$\int \csc^2xdx=\int\frac{1}{\sin^2x}dx=-\cot{x}+C$</p><p>$\int\sec xdx=\ln|\sec x+\tan x|+C$</p><p>$\int\csc xdx=\ln|\csc x-\cot x|+C$</p><p>$\int\frac{1}{a^2+x^2}dx=\frac{1}{a}\arctan\frac{x}{a}+C,\int\frac{1}{1+x^2}dx=\arctan x+C$</p><p>$\int\frac{1}{\sqrt{a^2-x^2}}dx=\arcsin\frac{x}{a}+C,(a&gt;0),\int\frac{1}{\sqrt{1-x^2}}dx=\arcsin x+C,(a&gt;0)$</p><p>$\int\frac{1}{a^2-x^2}dx=\frac{1}{2a}\ln|\frac{a+x}{a-x}|+C$</p><p>$\int\frac{1}{\sqrt{x^2\pm a^2}}dx=\ln|x+\sqrt{x^2\pm a^2}|+C$</p><h2 id="定积分性质"><a href="#定积分性质" class="headerlink" title="定积分性质"></a>定积分性质</h2><p>设$f(x)$，$g(x)$在区间$[a,b]$上可积，则</p><ol><li><p>$\int_{a}^bkf(x)dx=k\int_{a}^bf(x)dx$</p></li><li><p>$\int_a^b[f(x)\pm g(x)]dx=\int_a^bf(x)dx\pm \int_a^bg(x)dx$</p></li><li>$\int_a^b1\cdot dx=\int_a^bdx=b-a$</li><li><p>若$f(x)$在由$a, b,c$构成的最大的区间上可积，则$\int_a^bf(x)dx=\int_a^cf(x)dx+\int_c^bf(x)dx$</p></li><li><p>若在区间$[a,b]$上$f(x)\le g(x)$，则$\int_a^bf(x)dx\le\int_a^bg(x)dx$</p></li><li><p><strong>定积分的估值定理：</strong>如果$f(x)$在q㢟$[a,b]$上的最大值与最小值分别为$M,m$，则$m(b-a)\le\int_a^bf(x)dx\le M(b-a)$</p></li><li><p><strong>积分中值定理：</strong>如果$f(x)$在区间$[a,b]$上连续，则$[a,b]$上至少存在一点$\xi$，使$\int_a^bf(x)dx=f(\xi)(b-a)$，称$\frac{1}{b-a}\int_a^bf(x)dx$为函数$y=f(x)$在区间$[a,b]$上的平均值</p></li></ol><h2 id="常见泰勒展开式"><a href="#常见泰勒展开式" class="headerlink" title="常见泰勒展开式"></a>常见泰勒展开式</h2><p>$e^x=\sum\limits_{n=0}^{\infty}\frac{x^n}{n!}=1+x+\frac{x^2}{2!}+…+\frac{x^n}{n!}+…,-\infty&lt;x&lt;+\infty$</p><p>$\frac{1}{1+x}=\sum\limits_{n=0}^{\infty}(-1)^nx^n=1-x+x^2-x^3+…+(-1)^nx^n+…,-1&lt;x&lt;1$</p><p>$\frac{1}{1-x}=\sum\limits_{n=0}^{\infty}x^n=1+x+x^2+x^3+…+x^n+…,-1&lt;x&lt;1$</p><p>$\ln(1+x)=\sum\limits_{n=1}^{\infty}(-1)^{n-1}\frac{x^n}{n}=x-\frac{x^2}{2}+\frac{x^3}{3}-\frac{x^4}{4}+…+(-1)^{n-1}\frac{x^n}{n}+…,-1\le{x}\le{1}$</p><p>$\sin{x}=\sum\limits_{n=0}^{\infty}(-1)^n\frac{x^{2n+1}}{(2n+1)!}=x-\frac{x^3}{3!}+\frac{x^5}{5!}-\frac{x^7}{7!}+…+(-1)^n\frac{x^{2n+1}}{(2n+1)!}+…,-\infty&lt;x&lt;+\infty$</p><p>$\cos{x}=\sum\limits_{n=0}^{\infty}(-1)^n\frac{x^{2n}}{(2n)!}=1-\frac{x^2}{2!}+\frac{x^4}{4!}-\frac{x^6}{6!}+…+(-1)^n\frac{x^{2n}}{(2n)!}+…,-\infty&lt;x&lt;+\infty$</p><p>$(1+x)^{\alpha}=1+\alpha{x}+\frac{\alpha(\alpha-1)}{2!}x^2+…+\frac{\alpha(\alpha-1)…(\alpha-n+1)}{n!}x^n+…,$$\begin{cases}<br> \ x\in(-1,1),\alpha\le-1\\<br> \ x\in(-1,1],-1&lt;\alpha<0\\ \ x\in[-1,1],\alpha>0<br>\end{cases}$</0\\></p><p>$\tan{x}=x+\frac{1}{3}x^3+o(x^3)$</p><p>$\arcsin{x}=x+\frac{1}{6}x^3+o(x^3)$</p><p>$\arctan{x}=x-\frac{1}{3}x^3+o(x^3)$</p><h2 id="和差化积公式"><a href="#和差化积公式" class="headerlink" title="和差化积公式"></a>和差化积公式</h2><p>$\sin\alpha+\sin\beta=2\sin\frac{\alpha+\beta}{2}\cos\frac{\alpha-\beta}{2}$</p><p>$\sin\alpha-\sin\beta=2\sin\frac{\alpha-\beta}{2}\cos\frac{\alpha+\beta}{2}$</p><p>$\cos\alpha+\cos\beta=2\cos\frac{\alpha+\beta}{2}\cos\frac{\alpha-\beta}{2}$</p><p>$\cos\alpha-\cos\beta=-2\sin\frac{\alpha+\beta}{2}\sin\frac{\alpha-\beta}{2}$</p><h2 id="积化和差公式"><a href="#积化和差公式" class="headerlink" title="积化和差公式"></a>积化和差公式</h2><p>$\sin\alpha\sin\beta=\frac{1}{2}[\cos(\alpha-\beta)-\cos(\alpha+\beta)]$</p><p>$\cos\alpha\cos\beta=\frac{1}{2}[\cos(\alpha+\beta)+\cos(\alpha-\beta)]$</p><p>$\sin\alpha\cos\beta=\frac{1}{2}[\sin(\alpha+\beta)+\sin(\alpha-\beta)]$</p><p>$\cos\alpha\sin\beta=\frac{1}{2}[\sin(\alpha+\beta)-\sin(\alpha-\beta)]$</p><h2 id="微分中值定理"><a href="#微分中值定理" class="headerlink" title="微分中值定理"></a>微分中值定理</h2><h3 id="罗尔定理"><a href="#罗尔定理" class="headerlink" title="罗尔定理"></a>罗尔定理</h3><p>设$f(x)$在闭区间$[a,b]$上连续，在开区间$(a,b)$内可导，若$f(a)=f(b)$，则至少存在一点$\xi\in(a,b)$，使得$f’(\xi)=0$。</p><h3 id="拉格朗日中值定理"><a href="#拉格朗日中值定理" class="headerlink" title="拉格朗日中值定理"></a>拉格朗日中值定理</h3><p>设$f(x)$在闭区间$[a,b]$上连续，在开区间$(a,b)$内可导，则至少存在一点$\xi\in(a,b)$，使得$f(b)-f(a)=f’(\xi)(b-a)$。</p><h3 id="柯西中值定理"><a href="#柯西中值定理" class="headerlink" title="柯西中值定理"></a>柯西中值定理</h3><p>设$f(x)$，$g(x)$在闭区间$[a,b]$上连续，在开区间$(a,b)$内可导，且$g’(x)\ne 0$，$x\in(a,b)$，则至少存在一点$\xi\in(a,b)$，使得$\frac{f(b)-f(a)}{g(b)-g(a)}=\frac{f’(\xi)}{g’(\xi)}$。</p><h3 id="泰勒定理"><a href="#泰勒定理" class="headerlink" title="泰勒定理"></a>泰勒定理</h3><h4 id="带拉格朗日余项的泰勒定理"><a href="#带拉格朗日余项的泰勒定理" class="headerlink" title="带拉格朗日余项的泰勒定理"></a>带拉格朗日余项的泰勒定理</h4><p>设$f(x)$在点$x_0$的某一领域内有直到$n+1$阶的导数，则对该领域内的任意点$x$，都有</p><script type="math/tex; mode=display">f(x)=f(x_0)+\frac{f'(x_0)}{1!}(x-x_0)+\frac{f''(x_0)}{2!}(x-x_0)^2+...+\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n+\frac{f^{(n+1)}(\xi)}{(n+1)!}(x-x_0)^{n+1} \nonumber</script><p>其中，$\xi$ 介于$x$，$x_0$之间。</p><h4 id="带皮亚诺余项的泰勒定理"><a href="#带皮亚诺余项的泰勒定理" class="headerlink" title="带皮亚诺余项的泰勒定理"></a>带皮亚诺余项的泰勒定理</h4><p>设$f(x)$在点$x_0$的某一领域内有直到 $n$ 阶的导数，则对该领域内的任意点$x$，都有</p><script type="math/tex; mode=display">f(x)=f(x_0)+\frac{f'(x_0)}{1!}(x-x_0)+\frac{f''(x_0)}{2!}(x-x_0)^2+...+\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n+o(x-x_0)^{n} \nonumber</script><h4 id="几个常用函数的带皮亚诺余项的麦克劳林展开式"><a href="#几个常用函数的带皮亚诺余项的麦克劳林展开式" class="headerlink" title="几个常用函数的带皮亚诺余项的麦克劳林展开式"></a>几个常用函数的带皮亚诺余项的麦克劳林展开式</h4><p>$e^x=1+x+\frac{x^2}{2!}+…+\frac{x^n}{n!}+o(x^n)$</p><p>$\sin{x}=x-\frac{x^3}{3!}+\frac{x^5}{5!}-\frac{x^7}{7!}+…+(-1)^n\frac{x^{2n+1}}{(2n+1)!}+o(x^{2n+1})$</p><p>$\cos{x}=1-\frac{x^2}{2!}+\frac{x^4}{4!}-\frac{x^6}{6!}+…+(-1)^n\frac{x^{2n}}{(2n)!}+o(x^{2n})$</p><p>$\ln(1+x)=x-\frac{x^2}{2}+\frac{x^3}{3}-\frac{x^4}{4}+…+(-1)^{n-1}\frac{x^n}{n}+o(x^n)$</p><p>$(1+x)^{\alpha}=1+\alpha{x}+\frac{\alpha(\alpha-1)}{2!}x^2+…+\frac{\alpha(\alpha-1)…(\alpha-n+1)}{n!}x^n+o(x^n)$</p>]]></content>
      
      
      <categories>
          
          <category> 数学之美 </category>
          
          <category> 数学公式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 高数 </tag>
            
            <tag> 数学公式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卷积神经网络（CNN）模型结构可视化工具</title>
      <link href="/2019/09/01/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88CNN%EF%BC%89%E6%A8%A1%E5%9E%8B%E7%BB%93%E6%9E%84%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7/"/>
      <url>/2019/09/01/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88CNN%EF%BC%89%E6%A8%A1%E5%9E%8B%E7%BB%93%E6%9E%84%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>深度学习中，CNN模型可视化有助于我们学习、分析网络模型。目前接触到的可视化有：特征图可视化、网络模型结构可视化。本文为大家介绍的就是网络模型结构可视化的两款小工具。</p><h2 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h2><p>本文主要介绍Netscope和ConvNetDraw。</p><a id="more"></a><h2 id="Netscope"><a href="#Netscope" class="headerlink" title="Netscope"></a>Netscope</h2><p>Netscope是一个在线编辑，用于可视化卷积神经网络模型结构的小工具。目前，支持Caffe的prototxt文件可视化。</p><p>支持自定义网络结构，可视化输出结构，只要按照prototxt的格式写即可。</p><p>可视化效果：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B7%A5%E5%85%B7/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E7%BB%93%E6%9E%84%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7/trick-8-1.png" width="50%"></p><p>体验地址：<a href="https://cuijiahua.com/netscope/quickstart.html" target="_blank" rel="noopener">https://cuijiahua.com/netscope/quickstart.html</a></p><h2 id="ConvNetDraw"><a href="#ConvNetDraw" class="headerlink" title="ConvNetDraw"></a>ConvNetDraw</h2><p>ConvNetDraw也是一个用于可视化卷积神经网络模型结构的小工具。与Netscope不同的是，ConvNetDraw是使用可视化命令进行可视化的，而且命令很简单比如：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B7%A5%E5%85%B7/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E7%BB%93%E6%9E%84%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7/trick-8-2.png" width="50%"></p><p>可视化效果：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B7%A5%E5%85%B7/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E7%BB%93%E6%9E%84%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7/trick-8-3.png" width="50%"></p><p>体验地址：<a href="https://cuijiahua.com/convdraw/" target="_blank" rel="noopener">https://cuijiahua.com/convdraw/</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>两个工具都有些bug，对于前端可视化卷积神经网络感兴趣的朋友，可以去他们的Github开源项目看看，帮助完善就更赞了。</p><p>Netscope开源项目地址：<a href="https://cuijiahua.com/wp-content/themes/begin/inc/go.php?url=https://github.com/ethereon/netscope" target="_blank" rel="noopener">https://github.com/ethereon/netscope</a></p><p>ConvNetDraw开源项目地址：<a href="https://cuijiahua.com/wp-content/themes/begin/inc/go.php?url=https://github.com/cbovar/ConvNetDraw" target="_blank" rel="noopener">https://github.com/cbovar/ConvNetDraw</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机工具 </category>
          
          <category> 网络模型结构可视化工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CNN </tag>
            
            <tag> 模型结构 </tag>
            
            <tag> 可视化工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How a Kalman filter works, in pictures</title>
      <link href="/2019/08/30/How-a-Kalman-filter-works-in-pictures/"/>
      <url>/2019/08/30/How-a-Kalman-filter-works-in-pictures/</url>
      
        <content type="html"><![CDATA[<p>I have to tell you about the Kalman filter, because what it does is pretty damn amazing.</p><p>Surprisingly few software engineers and scientists seem to know about it, and that makes me sad because it is such a general and powerful tool for <strong>combining information</strong> in the presence of uncertainty. At times its ability to extract accurate information seems almost magical— and if it sounds like I’m talking this up too much, then take a look at <a href="https://www.bzarg.com/p/improving-imu-attitude-estimates-with-velocity-data" target="_blank" rel="noopener">this previously posted video</a> where I demonstrate a Kalman filter figuring out the <em>orientation</em> of a free-floating body by looking at its <em>velocity</em>. Totally neat!</p><a id="more"></a><h2 id="What-is-it"><a href="#What-is-it" class="headerlink" title="What is it?"></a>What is it?</h2><p>You can use a Kalman filter in any place where you have <strong>uncertain information</strong> about some dynamic system, and you can make an <strong>educated guess</strong> about what the system is going to do next. Even if messy reality comes along and interferes with the clean motion you guessed about, the Kalman filter will often do a very good job of figuring out what actually happened. And it can take advantage of correlations between crazy phenomena that you maybe wouldn’t have thought to exploit!</p><p>Kalman filters are ideal for systems which are <strong>continuously changing</strong>. They have the advantage that they are light on memory (they don’t need to keep any history other than the previous state), and they are very fast, making them well suited for real time problems and embedded systems.</p><p>The math for implementing the Kalman filter appears pretty scary and opaque in most places you find on Google. That’s a bad state of affairs, because the Kalman filter is actually super simple and easy to understand if you look at it in the right way. Thus it makes a great article topic, and I will attempt to illuminate it with lots of clear, pretty pictures and colors. The prerequisites are simple; all you need is a basic understanding of probability and matrices.</p><p>I’ll start with a loose example of the kind of thing a Kalman filter can solve, but if you want to get right to the shiny pictures and math, feel free to <a href="http://www.bzarg.com/p/how-a-kalman-filter-works-in-pictures/#mathybits" target="_blank" rel="noopener">jump ahead</a>.</p><h2 id="What-can-we-do-with-a-Kalman-filter"><a href="#What-can-we-do-with-a-Kalman-filter" class="headerlink" title="What can we do with a Kalman filter?"></a>What can we do with a Kalman filter?</h2><p>Let’s make a toy example: You’ve built a little robot that can wander around in the woods, and the robot needs to know exactly where it is so that it can navigate.</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/robot_forest.png" width="30%"></p><p>We’ll say our robot has a state $\vec{x_k}$ , which is just a position and a velocity :</p><script type="math/tex; mode=display">\nonumber\vec{x_k} = (\vec{p}, \vec{v})</script><p>Note that the state is just a list of numbers about the underlying configuration of your system; it could be anything. In our example it’s position and velocity, but it could be data about the amount of fluid in a tank, the temperature of a car engine, the position of a user’s finger on a touchpad, or any number of things you need to keep track of.</p><p>Our robot also has a GPS sensor, which is accurate to about 10 meters, which is good, but it needs to know its location more precisely than 10 meters. There are lots of gullies and cliffs in these woods, and if the robot is wrong by more than a few feet, it could fall off a cliff. So GPS by itself is not good enough.</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/robot_ohnoes.png" width="30%"></p><p>We might also know something about how the robot moves: It knows the commands sent to the wheel motors, and its knows that if it’s headed in one direction and nothing interferes, at the next instant it will likely be further along that same direction. But of course it doesn’t know everything about its motion: It might be buffeted by the wind, the wheels might slip a little bit, or roll over bumpy terrain; so the amount the wheels have turned might not exactly represent how far the robot has actually traveled, and the prediction won’t be perfect.</p><p>The GPS <strong>sensor</strong> tells us something about the state, but only indirectly, and with some uncertainty or inaccuracy. Our <strong>prediction</strong> tells us something about how the robot is moving, but only indirectly, and with some uncertainty or inaccuracy.</p><p>But if we use all the information available to us, can we get a better answer than <strong>either estimate would give us by itself</strong>? Of course the answer is yes, and that’s what a Kalman filter is for.</p><h2 id="How-a-Kalman-filter-sees-your-problem"><a href="#How-a-Kalman-filter-sees-your-problem" class="headerlink" title="How a Kalman filter sees your problem"></a>How a Kalman filter sees your problem</h2><p>Let’s look at the landscape we’re trying to interpret. We’ll continue with a simple state having only position and velocity.</p><script type="math/tex; mode=display">\nonumber\vec{x} = \begin{bmatrix}p\\v\end{bmatrix}</script><p>We don’t know what the <em>actual</em> position and velocity are; there are a whole range of possible combinations of position and velocity that might be true, but some of them are more likely than others:</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/gauss_0.png" width="30%"></p><p>The Kalman filter assumes that both variables (postion and velocity, in our case) are random and <em>Gaussian distributed.</em> Each variable has a <strong>mean</strong> value $\mu$), which is the center of the random distribution (and its most likely state), and a <strong>variance </strong>$\sigma^2$, which is the uncertainty:</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/gauss_1.png" width="30%"></p><p>In the above picture, position and velocity are <strong>uncorrelated</strong>, which means that the state of one variable tells you nothing about what the other might be.</p><p>The example below shows something more interesting: Position and velocity are <strong>correlated</strong>. The likelihood of observing a particular position depends on what velocity you have:</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/gauss_3.png" width="30%"></p><p>This kind of situation might arise if, for example, we are estimating a new position based on an old one. If our velocity was high, we probably moved farther, so our position will be more distant. If we’re moving slowly, we didn’t get as far.</p><p>This kind of relationship is really important to keep track of, because it gives us <strong>more information:</strong> One measurement tells us something about what the others could be. And that’s the goal of the Kalman filter, we want to squeeze as much information from our uncertain measurements as we possibly can!</p><p>This correlation is captured by something called a <a href="https://en.wikipedia.org/wiki/Covariance_matrix" target="_blank" rel="noopener">covariance matrix</a>. In short, each element of the matrix $\Sigma_{ij}$ is the degree of correlation between the <em>ith</em> state variable and the <em>jth</em> state variable. (You might be able to guess that the covariance matrix is <a href="https://en.wikipedia.org/wiki/Symmetric_matrix" target="_blank" rel="noopener">symmetric</a>, which means that it doesn’t matter if you swap <em>i</em> and <em>j</em>). Covariance matrices are oftimg en labelled “$\mathbf{\Sigma}$”, so we call their elements “$\Sigma_{ij}$”.</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/gauss_2.png" width="30%"></p><h2 id="Describing-the-problem-with-matrices"><a href="#Describing-the-problem-with-matrices" class="headerlink" title="Describing the problem with matrices"></a>Describing the problem with matrices</h2><p>We’re modeling our knowledge about the state as a Gaussian blob, so we need two pieces of information at time (k): We’ll call our best estimate $\mathbf{\hat{x}_k}$ (the mean, elsewhere named $\mu$, and its covariance matrix $\mathbf{P_k}$. </p><script type="math/tex; mode=display">\begin{equation} \label{eq:statevars}\begin{aligned}\mathbf{\hat{x}}_k &= \begin{bmatrix}\text{position}\\\text{velocity}\end{bmatrix}\\\mathbf{P}_k &=\begin{bmatrix}\Sigma_{pp} & \Sigma_{pv} \\\Sigma_{vp} & \Sigma_{vv} \\\end{bmatrix}\end{aligned}\end{equation}</script><p>(Of course we are using only position and velocity here, but it’s useful to remember that the state can contain any number of variables, and represent anything you want).</p><p>Next, we need some way to look at the <strong>current state</strong> (at time <strong>k-1</strong>) and <strong>predict the next state</strong> at time <strong>k</strong>. Remember, we don’t know which state is the “real” one, but our prediction function doesn’t care. It just works on <em>all of them</em>, and gives us a new distribution:</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/gauss_7.jpg" width="30%"></p><p>We can represent this prediction step with a matrix, $\mathbf{F_k}$:</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/gauss_8.jpg" width="30%"></p><p>It takes <em>every point</em> in our original estimate and moves it to a new predicted location, which is where the system would move if that original estimate was the right one.</p><p>Let’s apply this. How would we use a matrix to predict the position and velocity at the next moment in the future? We’ll use a really basic kinematic formula:</p><script type="math/tex; mode=display">\nonumber\begin{split}\color{deeppink}{p_k} &= \color{royalblue}{p_{k-1}} + \Delta t &\color{royalblue}{v_{k-1}} \\\color{deeppink}{v_k} &= &\color{royalblue}{v_{k-1}}\end{split}</script><p>In other words : </p><script type="math/tex; mode=display">\begin{align}\color{deeppink}{\mathbf{\hat{x}}_k} &= \begin{bmatrix}1 & \Delta t \\0 & 1\end{bmatrix} \color{royalblue}{\mathbf{\hat{x}}_{k-1}} \\&= \mathbf{F}_k \color{royalblue}{\mathbf{\hat{x}}_{k-1}} \label{statevars}\end{align}</script><p>We now have a <strong>prediction matrix</strong> which gives us our next state, but we still don’t know how to update the covariance matrix.</p><p>This is where we need another formula. If we multiply every point in a distribution by a matrix $\color{firebrick}{\mathbf{A}}$, then what happens to its covariance matrix $\Sigma$ ?</p><p>Well, it’s easy. I’ll just give you the identity:</p><script type="math/tex; mode=display">\begin{equation}\begin{split}Cov(x) &= \Sigma\\Cov(\color{firebrick}{\mathbf{A}}x) &= \color{firebrick}{\mathbf{A}} \Sigma \color{firebrick}{\mathbf{A}}^T\end{split} \label{covident}\end{equation}</script><p>So combining $\eqref{covident}$ with equation $\eqref{statevars}$:</p><script type="math/tex; mode=display">\begin{equation}\begin{split}\color{deeppink}{\mathbf{\hat{x}}_k} &= \mathbf{F}_k \color{royalblue}{\mathbf{\hat{x}}_{k-1}} \\\color{deeppink}{\mathbf{P}_k} &= \mathbf{F_k} \color{royalblue}{\mathbf{P}_{k-1}} \mathbf{F}_k^T\end{split}\end{equation}</script><h2 id="External-influence"><a href="#External-influence" class="headerlink" title="External influence"></a>External influence</h2><p>We haven’t captured everything, though. There might be some changes that <strong>aren’t related to the state</strong> itself— the outside world could be affecting the system.</p><p>For example, if the state models the motion of a train, the train operator might push on the throttle, causing the train to accelerate. Similarly, in our robot example, the navigation software might issue a command to turn the wheels or stop. If we know this additional information about what’s going on in the world, we could stuff it into a vector called $\color{darkorange}{\vec{\mathbf{u}_k}}$, do something with it, and add it to our prediction as a correction.</p><p>Let’s say we know the expected acceleration $\color{darkorange}{a}$ due to the throttle setting or control commands. From basic kinematics we get :</p><script type="math/tex; mode=display">\nonumber\begin{split}\color{deeppink}{p_k} &= \color{royalblue}{p_{k-1}} + {\Delta t} &\color{royalblue}{v_{k-1}} + &\frac{1}{2} \color{darkorange}{a} {\Delta t}^2 \\\color{deeppink}{v_k} &= &\color{royalblue}{v_{k-1}} + & \color{darkorange}{a} {\Delta t}\end{split}</script><p>In matrix form: </p><script type="math/tex; mode=display">\begin{equation}\begin{split}\color{deeppink}{\mathbf{\hat{x}}_k} &= \mathbf{F}_k \color{royalblue}{\mathbf{\hat{x}}_{k-1}} + \begin{bmatrix}\frac{\Delta t^2}{2} \\\Delta t\end{bmatrix} \color{darkorange}{a} \\&= \mathbf{F}_k \color{royalblue}{\mathbf{\hat{x}}_{k-1}} + \mathbf{B}_k \color{darkorange}{\vec{\mathbf{u}_k}}\end{split}\end{equation}</script><p>$\mathbf{B}_k$ is called the <strong>control matrix</strong> and $\color{darkorange}{\vec{\mathbf{u}_k}}$ the <strong>control vector.</strong></p><p>(For very simple systems with no external influence, you could omit these).</p><p>Let’s add one more detail. What happens if our prediction is not a 100% accurate model of what’s actually going on?</p><h2 id="External-uncertainty"><a href="#External-uncertainty" class="headerlink" title="External uncertainty"></a>External uncertainty</h2><p>Everything is fine if the state evolves based on its own properties. Everything is <em>still</em> fine if the state evolves based on external forces, so long as we know what those external forces are.</p><p>But what about forces that we <em>don’t</em> know about? If we’re tracking a quadcopter, for example, it could be buffeted around by wind. If we’re tracking a wheeled robot, the wheels could slip, or bumps on the ground could slow it down. We can’t keep track of these things, and if any of this happens, our prediction could be off because we didn’t account for those extra forces.</p><p>We can model the uncertainty associated with the “world” (i.e. things we aren’t keeping track of) by adding some new uncertainty after every prediction step:</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/gauss_9.jpg" width="30%"></p><p>Every state in our original estimate could have moved to a <em>range</em> of states. Because we like Gaussian blobs so much, we’ll say that each point in $\color{royalblue}{\mathbf{\hat{x}}_{k-1}}$ is moved to somewhere inside a Gaussian blob with covariance $\color{mediumaquamarine}{\mathbf{Q}_k}$. Another way to say this is that we are treating the untracked influences as <strong>noise</strong> with covariance $\color{mediumaquamarine}{\mathbf{Q}_k}$.</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/gauss_10a.jpg" width="30%"></p><p>This produces a new Gaussian blob, with a different covariance (but the same mean):</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/gauss_10b.jpg" width="30%"></p><p>We get the expanded covariance by simply <strong>adding</strong> ${\color{mediumaquamarine}{\mathbf{Q}_k}}$, giving our complete expression for the <strong>prediction step</strong>: </p><script type="math/tex; mode=display">\begin{equation}\begin{split}\color{deeppink}{\mathbf{\hat{x}}_k} &= \mathbf{F}_k \color{royalblue}{\mathbf{\hat{x}}_{k-1}} + \mathbf{B}_k \color{darkorange}{\vec{\mathbf{u}_k}} \\\color{deeppink}{\mathbf{P}_k} &= \mathbf{F_k} \color{royalblue}{\mathbf{P}_{k-1}} \mathbf{F}_k^T + \color{mediumaquamarine}{\mathbf{Q}_k}\end{split}\label{kalpredictfull}\end{equation}</script><p>In other words, the <strong>new best estimate</strong> is a <strong>prediction</strong> made from <strong>previous best estimate</strong>, plus a <strong>correction</strong> for <strong>known external influences</strong>.</p><p>And the <strong>new uncertainty</strong> is <strong>predicted</strong> from the <strong>old uncertainty</strong>, with some <strong>additional uncertainty from the environment</strong>.</p><p>All right, so that’s easy enough. We have a fuzzy estimate of where our system might be, given by $\color{deeppink}{\mathbf{\hat{x}}_k}$ and $\color{deeppink}{\mathbf{P}_k}$. What happens when we get some data from our sensors?</p><h2 id="Refining-the-estimate-with-measurements"><a href="#Refining-the-estimate-with-measurements" class="headerlink" title="Refining the estimate with measurements"></a>Refining the estimate with measurements</h2><p>We might have several sensors which give us information about the state of our system. For the time being it doesn’t matter what they measure; perhaps one reads position and the other reads velocity. Each sensor tells us something <strong>indirect</strong> about the state— in other words, the sensors operate on a state and produce a set of <strong>readings</strong>.</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/gauss_12.jpg" width="30%"></p><p>Notice that the units and scale of the reading might not be the same as the units and scale of the state we’re keeping track of. You might be able to guess where this is going: We’ll model the sensors with a matrix, $\mathbf{H}_k$.</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/gauss_13.jpg" width="30%"></p><p>We can figure out the distribution of sensor readings we’d expect to see in the usual way:</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}\vec{\mu}_{\text{expected}} &= \mathbf{H}_k \color{deeppink}{\mathbf{\hat{x}}_k} \\\mathbf{\Sigma}_{\text{expected}} &= \mathbf{H}_k \color{deeppink}{\mathbf{P}_k} \mathbf{H}_k^T\end{aligned}\end{equation}</script><p>One thing that Kalman filters are great for is dealing with <em>sensor noise</em>. In other words, our sensors are at least somewhat unreliable, and every state in our original estimate might result in a <em>range</em> of sensor readings.</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/gauss_14.jpg" width="30%"></p><p>From each reading we observe, we might guess that our system was in a particular state. But because there is uncertainty, <strong>some states are more likely than others</strong> to have have produced the reading we saw:</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/gauss_11.jpg" width="30%"></p><p>We’ll call the <strong>covariance</strong> of this uncertainty (i.e. of the sensor noise) $\color{mediumaquamarine}{\mathbf{R}_k}$. The distribution has a <strong>mean</strong> equal to the reading we observed, which we’ll call $\color{yellowgreen}{\vec{\mathbf{z}_k}}$.</p><p>So now we have two Gaussian blobs: One surrounding the mean of our transformed prediction, and one surrounding the actual sensor reading we got.</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/gauss_4.jpg" width="30%"></p><p>We must try to reconcile our guess about the readings we’d see based on the <strong>predicted state</strong> (<strong>pink</strong>) with a <em>different</em> guess based on our <strong>sensor readings</strong> (<strong>green</strong>) that we actually observed.</p><p>So what’s our new most likely state? For any possible reading $(z_1,z_2)$, we have two associated probabilities: (1) The probability that our sensor reading $\color{yellowgreen}{\vec{\mathbf{z}_k}}$ is a (mis-)measurement of $(z_1,z_2)$, and (2) the probability that our previous estimate thinks $(z_1,z_2)$ is the reading we should see.</p><p>If we have two probabilities and we want to know the chance that <em>both</em> are true, we just multiply them together. So, we take the two Gaussian blobs and multiply them:</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/gauss_6a.png" width="30%"></p><p>What we’re left with is the <strong>overlap</strong>, the region where <em>both</em> blobs are bright/likely. And it’s a lot more precise than either of our previous estimates. The mean of this distribution is the configuration for which <strong>both estimates are most likely</strong>, and is therefore the <strong>best guess</strong>of the true configuration given all the information we have.</p><p>Hmm. This looks like another Gaussian blob.</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/gauss_6.png" width="30%"></p><p>As it turns out, when you multiply two Gaussian blobs with separate means and covariance matrices, you get a <em>new</em> Gaussian blob with its <strong>own</strong> mean and covariance matrix! Maybe you can see where this is going: There’s got to be a formula to get those new parameters from the old ones!</p><h2 id="Combining-Gaussians"><a href="#Combining-Gaussians" class="headerlink" title="Combining Gaussians"></a>Combining Gaussians</h2><p>Let’s find that formula. It’s easiest to look at this first in <strong>one dimension</strong>. A 1D Gaussian bell curve with variance $\sigma^2$ and mean (\mu) is defined as: </p><script type="math/tex; mode=display">\begin{equation} \label{gaussformula}\mathcal{N}(x, \mu,\sigma) = \frac{1}{ \sigma \sqrt{ 2\pi } } e^{ -\frac{ (x – \mu)^2 }{ 2\sigma^2 } }\end{equation}</script><p>We want to know what happens when you multiply two Gaussian curves together. The blue curve below represents the (unnormalized) intersection of the two Gaussian populations:</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/gauss_joint.png" width="30%"></p><script type="math/tex; mode=display">\begin{equation} \label{gaussequiv}\mathcal{N}(x, \color{fuchsia}{\mu_0}, \color{deeppink}{\sigma_0}) \cdot \mathcal{N}(x, \color{yellowgreen}{\mu_1}, \color{mediumaquamarine}{\sigma_1}) \stackrel{?}{=} \mathcal{N}(x, \color{royalblue}{\mu’}, \color{mediumblue}{\sigma’})\end{equation}</script><p>You can substitute equation $\eqref{gaussformula}$ into equation $\eqref{gaussequiv}$ and do some algebra (being careful to renormalize, so that the total probability is 1) to obtain: </p><script type="math/tex; mode=display">\begin{equation} \label{fusionformula}\begin{aligned}\color{royalblue}{\mu’} &= \mu_0 + \frac{\sigma_0^2 (\mu_1 – \mu_0)} {\sigma_0^2 + \sigma_1^2}\\\color{mediumblue}{\sigma’}^2 &= \sigma_0^2 – \frac{\sigma_0^4} {\sigma_0^2 + \sigma_1^2}\end{aligned}\end{equation}</script><p>We can simplify by factoring out a little piece and calling it $\color{purple}{\mathbf{k}}$: </p><script type="math/tex; mode=display">\begin{equation} \label{gainformula}\color{purple}{\mathbf{k}} = \frac{\sigma_0^2}{\sigma_0^2 + \sigma_1^2}\end{equation}</script><script type="math/tex; mode=display">\begin{equation}\begin{split}\color{royalblue}{\mu’} &= \mu_0 + &\color{purple}{\mathbf{k}} (\mu_1 – \mu_0)\\\color{mediumblue}{\sigma’}^2 &= \sigma_0^2 – &\color{purple}{\mathbf{k}} \sigma_0^2\end{split} \label{update}\end{equation}</script><p>Take note of how you can take your previous estimate and <strong>add something</strong> to make a new estimate. And look at how simple that formula is!</p><p>But what about a matrix version? Well, let’s just re-write equations $\eqref{gainformula}$ and $\eqref{update}$ in matrix form. If $\Sigma$ is the covariance matrix of a Gaussian blob, and $\vec{\mu}$ its mean along each axis, then: </p><script type="math/tex; mode=display">\begin{equation} \label{matrixgain}\color{purple}{\mathbf{K}} = \Sigma_0 (\Sigma_0 + \Sigma_1)^{-1}\end{equation}</script><script type="math/tex; mode=display">\begin{equation}\begin{split}\color{royalblue}{\vec{\mu}’} &= \vec{\mu_0} + &\color{purple}{\mathbf{K}} (\vec{\mu_1} – \vec{\mu_0})\\\color{mediumblue}{\Sigma’} &= \Sigma_0 – &\color{purple}{\mathbf{K}} \Sigma_0\end{split} \label{matrixupdate}\end{equation}</script><p>$\color{purple}{\mathbf{K}}$ is a matrix called the <strong>Kalman gain</strong>, and we’ll use it in just a moment.</p><p>Easy! We’re almost finished!</p><h2 id="Putting-it-all-together"><a href="#Putting-it-all-together" class="headerlink" title="Putting it all together"></a>Putting it all together</h2><p>We have two distributions: The predicted measurement with $(\color{fuchsia}{\mu_0}, \color{deeppink}{\Sigma_0}) = (\color{fuchsia}{\mathbf{H}_k \mathbf{\hat{x}}_k}, \color{deeppink}{\mathbf{H}_k \mathbf{P}_k \mathbf{H}_k^T}) $, and the observed measurement with $(\color{yellowgreen}{\mu_1}, \color{mediumaquamarine}{\Sigma_1}) = (\color{yellowgreen}{\vec{\mathbf{z}_k}}, \color{mediumaquamarine}{\mathbf{R}_k})$. We can just plug these into equation $\eqref{matrixupdate}$ to find their overlap:</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}\mathbf{H}_k \color{royalblue}{\mathbf{\hat{x}}_k’} &= \color{fuchsia}{\mathbf{H}_k \mathbf{\hat{x}}_k} & + & \color{purple}{\mathbf{K}} ( \color{yellowgreen}{\vec{\mathbf{z}_k}} – \color{fuchsia}{\mathbf{H}_k \mathbf{\hat{x}}_k} ) \\\mathbf{H}_k \color{royalblue}{\mathbf{P}_k’} \mathbf{H}_k^T &= \color{deeppink}{\mathbf{H}_k \mathbf{P}_k \mathbf{H}_k^T} & – & \color{purple}{\mathbf{K}} \color{deeppink}{\mathbf{H}_k \mathbf{P}_k \mathbf{H}_k^T}\end{aligned} \label {kalunsimplified}\end{equation}</script><p> And from $\eqref{matrixgain}$, the Kalman gain is:</p><script type="math/tex; mode=display">\begin{equation} \label{eq:kalgainunsimplified}\color{purple}{\mathbf{K}} = \color{deeppink}{\mathbf{H}_k \mathbf{P}_k \mathbf{H}_k^T} ( \color{deeppink}{\mathbf{H}_k \mathbf{P}_k \mathbf{H}_k^T} + \color{mediumaquamarine}{\mathbf{R}_k})^{-1}\end{equation}</script><p> We can knock an $\mathbf{H}_k$ off the front of every term in $\eqref{kalunsimplified}$ and $\eqref{eq:kalgainunsimplified}$ (note that one is hiding inside $\color{purple}{\mathbf{K}}$ ), and an $\mathbf{H}_k^T$ off the end of all terms in the equation for $\color{royalblue}{\mathbf{P}_k’}$. </p><script type="math/tex; mode=display">\begin{equation}\begin{split}\color{royalblue}{\mathbf{\hat{x}}_k’} &= \color{fuchsia}{\mathbf{\hat{x}}_k} & + & \color{purple}{\mathbf{K}’} ( \color{yellowgreen}{\vec{\mathbf{z}_k}} – \color{fuchsia}{\mathbf{H}_k \mathbf{\hat{x}}_k} ) \\\color{royalblue}{\mathbf{P}_k’} &= \color{deeppink}{\mathbf{P}_k} & – & \color{purple}{\mathbf{K}’} \color{deeppink}{\mathbf{H}_k \mathbf{P}_k}\end{split}\label{kalupdatefull}\end{equation}</script><script type="math/tex; mode=display">\begin{equation}\color{purple}{\mathbf{K}’} = \color{deeppink}{\mathbf{P}_k \mathbf{H}_k^T} ( \color{deeppink}{\mathbf{H}_k \mathbf{P}_k \mathbf{H}_k^T} + \color{mediumaquamarine}{\mathbf{R}_k})^{-1}\label{kalgainfull}\end{equation}</script><p> …giving us the complete equations for the <strong>update step.</strong></p><p>And that’s it! $\color{royalblue}{\mathbf{\hat{x}}_k’}$ is our new best estimate, and we can go on and feed it (along with  $\color{royalblue}{\mathbf{P}_k’} $ ) back into another round of <strong>predict</strong> or <strong>update</strong> as many times as we like.</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/kalflow.png" width="80%"></p><h2 id="Wrapping-up"><a href="#Wrapping-up" class="headerlink" title="Wrapping up"></a>Wrapping up</h2><p>Of all the math above, all you need to implement are equations $\eqref{kalpredictfull}, \eqref{kalupdatefull}$, and $\eqref{kalgainfull}$. (Or if you forget those, you could re-derive everything from equations $\eqref{covident}$ and $\eqref{matrixupdate}$.)</p><p>This will allow you to model any linear system accurately. For nonlinear systems, we use the <strong>extended Kalman filter</strong>, which works by simply linearizing the predictions and measurements about their mean. (I may do a second write-up on the EKF in the future).</p><p>If I’ve done my job well, hopefully someone else out there will realize how cool these things are and come up with an unexpected new place to put them into action.</p><p>Some credit and referral should be given to <a href="http://www.cl.cam.ac.uk/~rmf25/papers/Understanding the Basis of the Kalman Filter.pdf" target="_blank" rel="noopener">this fine document</a>, which uses a similar approach involving overlapping Gaussians. More in-depth derivations can be found there, for the curious.</p>]]></content>
      
      
      <categories>
          
          <category> 常见模型 </category>
          
          <category> 卡尔曼滤波 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 卡尔曼滤波 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-101-对称二叉树</title>
      <link href="/2019/08/28/leetcode-101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/08/28/leetcode-101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p><p>示例1：</p><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">    <span class="hljs-number">1</span><br>   / \<br>  <span class="hljs-number">2</span>   <span class="hljs-number">2</span><br> / \ / \<br><span class="hljs-number">3</span>  <span class="hljs-number">4</span> <span class="hljs-number">4</span>  <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>但是下面这个 <code>[1,2,2,null,3,null,3]</code>则不是镜像对称的:</p><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">  <span class="hljs-number">1</span><br> / \<br><span class="hljs-number">2</span>   <span class="hljs-number">2</span><br> \   \<br> <span class="hljs-number">3</span>    <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><a id="more"></a><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol><li><strong>递归</strong></li><li><strong>迭代</strong></li></ol><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>数组完成排序后，我们可以放置两个指针 $i$ 和 $j$，其中 $i$ 是慢指针，而 $j$ 是快指针。只要 $nums[i] = nums[j]$，我们就增加 $j$ 以跳过重复项。</p><p>当我们遇到 $nums[j] \neq nums[i]$ 时，跳过重复项的运行已经结束，因此我们必须把它（$nums[j]$）的值复制到 $nums[i + 1]$。然后递增 $i$，接着我们将再次重复相同的过程，直到 $j$ 到达数组的末尾为止。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.size()==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=i+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(j&lt;nums.size())&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]==nums[j])&#123;<br>                j++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                i++;<br>                nums[i]=nums[j];<br>                j++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：$O(n)$，假设数组的长度是 $n$，那么 $i$ 和 $j$ 分别最多遍历 $n$ 步。</li><li>空间复杂度：$O(1)$。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法与数据结构 </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 对称 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反向传播算法</title>
      <link href="/2019/08/26/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95/"/>
      <url>/2019/08/26/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>卷积神经网络是一种特殊的前馈神经网络，通常也是一种深度神经网络。</p><p>深度学习是在克服反向传播算法对深度神经网络的训练困难过程中逐步发展和建立起来的。而深度神经网络的基本学习训练方法是反向传播算法。</p><p>作为一种有监督学习的算法，反向传播算法在本质上是一种具有递归结构的梯度下降算法，往往需要给定足够多的训练样本，才能获得满意的效果。</p><p>下面先给出任意前馈神经网络的<strong>通用反向传播算法</strong>，再讨论深层神经网络的<strong>逐层反向传播算法</strong>。</p><a id="more"></a><h2 id="通用反向传播算法"><a href="#通用反向传播算法" class="headerlink" title="通用反向传播算法"></a>通用反向传播算法</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>设前馈神经网络共有$N$个节点$\{u_1,u_2,…,u_N\}$，只有从编号较小的神经元才能连接到编号较大的神经元，没有反馈连接。</p><p>下图给出了前馈神经网络的一种可能的连接结构，共包含10个节点，其中两个为输入。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%89%8D%E9%A6%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" width="50%"></p><p>一般地，用$x_{n,l}$表示第$n$个节点对第$l$个输入样本的输出，其中$1\le{n}\le{N}$且$1\le{l}\le{L}$。</p><p>如果$u_n$是输入节点，那么它对第$l$个输入样本的输入为$net_{n,l}=x_{n,l}$；否则，$u_n$是隐含节点或输出节点，相应的输入为$net_{n,l}=\sum_{k}w_{k\to{n}}x_{k,l}$，输出为$x_{n,l}=f_n(net_{n,l})$。</p><p>其中，$w_{k\to{n}}(k&lt;n)$表示从第$k$个节点到第$n$个节点的有向连接$k\to{n}$的权值，$f_n$表示第$n$个节点的激活函数，比如sigmoid函数。</p><p>此外，若令$x_{0,l}=1$，则可用$w_{0\to{n}}$表示非输入节点$u_n$的偏置值。</p><p>最后，用OUT表示所有输出神经元的集合，且对任意$n\in{OUT}$，用$y_{n,l}$表示$x_{n,l}$的期望值，用$e_{n,l}$表示编号为$n$的输出神经元对第$l$个输入样本产生的输出误差。</p><p>因此，关于样本$l$的输出误差可以表示为：</p><script type="math/tex; mode=display">E_l=\sum\limits_{n\in{OUT}}e_{n,l}</script><p>总的输出误差为：</p><script type="math/tex; mode=display">E=\sum\limits^L_{l=1}E_l=\sum\limits^L_{l=1}\sum\limits_{n\in{OUT}}e_{n,l}</script><p>如果定义第$n$个神经网络关于第$l$个样本的反传误差信号（backpropagated error signal）或灵敏度（sensitivity）如下：</p><script type="math/tex; mode=display">\delta_{n,l}=\frac{\partial{E}}{\partial{net_{n,l}}}=\frac{\partial{E_l}}{\partial{net_{n,l}}}</script><p> 那么用链式法则可以得到：</p><script type="math/tex; mode=display">\forall{n}\in{OUT}，\frac{\partial{E}}{\partial{w_{k\to{n}}}}=\sum\limits^{L}_{l=1}\frac{\partial{E_l}}{\partial{net_{n,l}}}\frac{\partial{net_{n,l}}}{\partial{w_{k\to{n}}}}=\sum\limits^{L}_{l=1}\frac{\partial{E_l}}{\partial{x_{n,l}}}f'_{n}(net_{n,l})\frac{\partial{net_{n,l}}}{\partial{w_{k\to{n}}}}\\=\sum\limits^{L}_{l=1}\delta_{n,l}\frac{\partial{net_{n,l}}}{\partial{w_{k\to{n}}}}=\sum\limits^{L}_{n=1}\delta_{n,l}x_{k,l}</script><script type="math/tex; mode=display">\forall{k}\notin{OUT}，\frac{\partial{E}}{\partial{w_{j\to{k}}}}=\sum\limits^{L}_{l=1}\frac{\partial{E_l}}{\partial{net_{k,l}}}\frac{\partial{net_{k,l}}}{\partial{w_{j\to{k}}}}=\sum\limits^{L}_{l=1}(\sum\limits_{k\to{n}}\frac{\partial{E_l}}{\partial{net_{n,l}}}\frac{\partial{net_{n,l}}}{\partial{net_{k,l}}})\frac{\partial{net_{k,l}}}{\partial{w_{j\to{k}}}}\\=\sum\limits^{L}_{l=1}(\sum\limits_{k\to{n}}w_{k\to{n}}\delta_{n,l})f'_{k}(net_{k,l})\frac{\partial{net_{k,l}}}{\partial{w_{j\to{k}}}}=\sum\limits^{L}_{l=1}\delta_{k,l}\frac{\partial{net_{k,l}}}{\partial{w_{j\to{k}}}}=\sum\limits^{L}_{n=1}\delta_{k,l}x_{j,l}</script><p>如果对输出节点选择平方误差$e_{n,l}=\frac{1}{2}(x_{n,l}-y_{n,l})^2$，那么</p><script type="math/tex; mode=display">\forall{n}\in{OUT}，\delta_{n,l}=\frac{\partial{e_{n,l}}}{\partial{net_{n,l}}}=(x_{n,l}-y_{n,l})f'_{n}(net_{n,l})</script><script type="math/tex; mode=display">\forall{n}\notin{OUT}，\delta_{k,l}=(\sum\limits_{k\to{n}}w_{k\to{n}}\delta_{n,l})f'_{k}(net_{k,l})</script><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><strong>输入：</strong>训练集$\{(\pmb{x}^l,\pmb{y}^l), 1\le{l}\le{L}\}$，学习率$\eta$，前馈网络结构，迭代次数epoch</p><p><strong>输出：</strong>所有前馈连接权值$w_{k\to{n}}$</p><ol><li><p>选择学习率$\eta&gt;0$，迭代次数epoch，随机初始化$w_{k\to{n}}$</p></li><li><p><strong>for</strong> $i = 1$ to epoch <strong>do</strong></p></li><li>$\quad$<strong>for</strong> $l = 1$ to $L$ <strong>do</strong></li><li>$\qquad$如果$n$是输出节点，则计算其反传误差信号$\delta_{n,l}=(x_{n,l}-y_{n,l})f’_{n}(net_{n,l})$</li><li>$\qquad$否则递归计算其反传误差信号$\delta_{n,l}=\Big (\sum\limits_{k\to{n}}w_{k\to{n}}\delta_{n,l}\Big)f’_{k}(net_{k,l})$</li><li>$\quad$<strong>end for</strong></li><li><p>$\quad$计算关于连接权的偏导$\Delta{w_{k\to{n}}}=\frac{\partial{E}}{\partial{w_{k\to{n}}}}=\sum\limits^{L}_{l=1}\delta_{n,l}x_{k,l}$</p></li><li><p>$\quad$如果所有这些偏导产生的总梯度足够小，则停止</p></li><li>$\quad$否则，更新连接权值$w_{k\to{n}}=w_{k\to{n}}-\eta\Delta{w_{k\to{n}}}$</li><li><strong>end for</strong></li></ol><p><strong>注意：</strong>epoch表示迭代次数，在实际应用中可能需要几十次、几百次，甚至成千上万次迭代，才能获得令人满意的学习训练效果。</p><h2 id="逐层反向传播算法"><a href="#逐层反向传播算法" class="headerlink" title="逐层反向传播算法"></a>逐层反向传播算法</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>对于多层感知器来说，可以设计出更加简洁实用的<strong>逐层反向传播算法</strong>。</p><p>多层感知器由一个输出层、若干隐含层和一个输出层组成，如下图所示：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E5%99%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png" width="50%"></p><p>设输入层的维数为$m$，输入向量表示为$x=(x_1,x_2,…,x_m)^T\in{\pmb{R}}$。第$k$个隐含层包含$n_k$个神经元$(k=1,2,…,R)$，相应的隐含层向量表示为$\pmb{h}_k=(h_{k,1},h_{k,2},…,h_{k,n_k})^T\in{\pmb{R}}^{n_k}$。输出层包含$c$个神经元，输出向量表示为$\pmb{o}=(o_1,o_2,…,o_c)^T\in{\pmb{R}^c}$。输入层与第$1$个隐含层之间的权值矩阵用$\pmb{W}^1=(w^1_{ij})_{n_1\times{m}}$表示，第$k-1$个隐含层与第$k$个隐含层之间的权值矩阵用$\pmb{W}^k=(w^k_{ij})_{n_k\times n_{k-1}}(1&lt;k\le R)$表示，第$R$个隐含层与输出层之间的权值矩阵用$\pmb{W}^{R+1}=(w^{R+1}_{ij})_{c\times{n_R}}$表示。那么，这个多层感知器的各层神经元激活输出可以计算如下：</p><script type="math/tex; mode=display">\begin{cases} \pmb{h}_1=\sigma_{\pmb{h}_1}(\pmb{W}^1\pmb{x}+\pmb{b}^1) \\ \pmb{h}_k=\sigma_{\pmb{h}_k}(\pmb{W}^k\pmb{h}_{k-1}+\pmb{b}^k),2\le{k}\le{R} \\ \pmb{o}=\sigma_{\pmb{o}}(\pmb{W}^{R+1}\pmb{h}_{R}+\pmb{b}^{R+1}) \end{cases}</script><p>其中，$\pmb{b}^1$、$\pmb{b}^k$和$\pmb{b}^{R+1}$是各层的偏置，$\sigma_{\pmb{h}_1}$、$\sigma_{\pmb{h}_k}$和$\sigma_{\pmb{o}}$是各层的逐元向量函数，一般都取为逐元sigmoid函数。</p><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p><strong>输入：</strong>训练集$\{(\pmb{x}^l,\pmb{y}^l), 1\le{l}\le{L}\}$，学习率$\eta$，分层网络结构，隐含层数$\pmb{R}$、迭代次数epoch</p><p><strong>输出：</strong>所有权值和偏置$(\pmb{W}^k,\pmb{b}^k)(1\le{k}\le{R})$</p><ol><li>随机初始化$\pmb{W}^k\approx{0}$，$\pmb{b}^k\approx0$，$k=1$，…，$R$</li><li>令$\pmb{h}_0^l=\pmb{x}^l$</li><li><strong>for</strong> $i = 1$ to epoch <strong>do</strong></li><li>$\quad$<strong>for</strong> $l = 1$ to $L$ <strong>do</strong></li><li>$\qquad$计算$\pmb{u}_k^l=\pmb{W}^k\pmb{h}_{k-1}^l+\pmb{b}^k$，$\pmb{h}^l_k=\sigma(\pmb{u}^l_k)$，$1\le{k}\le{R+1}$</li><li>$\qquad$计算$\pmb{\delta}_{R+1}^l=(\pmb{o}^l-\pmb{y}^l)$，$\sigma’{\pmb{u}_{R+1}^l}$</li><li>$\qquad$计算$\delta_k^l=[(\pmb{W}^{k+1})^T\delta^l_{k+1}]$，$\sigma’{\pmb{u}_{k}^l}$，$1\le{k}\le{R}$</li><li>$\quad$<strong>end for</strong></li><li>$\quad$计算$\frac{\partial{E}}{\partial{\pmb{W}^k}}=\sum\limits^{L}_{l=1}\pmb{\delta}^l_k(\pmb{h}^l_{k-1})^T$，$\frac{\partial{E}}{\partial{\pmb{b}^k}}=\sum\limits^{L}_{l=1}\pmb{\delta}^l_k$，$1\le{k}\le {R+1}$</li><li>$\quad$如果所有这些偏导产生的总梯度足够小，则停止</li><li>$\quad$否则，更新权值和偏置：$\pmb{W}^k\gets\pmb{W}^k-\eta\frac{\partial \pmb{L}_N}{\partial\pmb{W}^k}$，$\pmb{b}^k\gets\pmb{b}^k-\eta\frac{\partial \pmb{L}_N}{\partial \pmb{b}^k}$，$1\le k\le R+1$</li><li><strong>end for</strong></li></ol><p><strong>注意：</strong>epoch表示迭代次数，在实际应用中可能需要几十次、几百次，甚至成千上万次迭代，才能获得令人满意的学习训练效果。</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>为了对多层感知器中的权值和偏置进行学习，需要给定一组训练样本。</p><p>假定共有$L$个训练样本$(\pmb{x}^l,\pmb{y}^l)(1\le l\le L)$，输入是$\pmb{x}^l=(\pmb{x}^l_1,\pmb{x}^l_2,…,\pmb{x}^l_m)^T$，期望输出是$\pmb{y}^l=(y^l_1,y^l_2,…,y^l_c)^T$，实际输出是$\pmb{o}^l=(o^l_1,o^l_2,…,o^l_c)^T$。</p><p>优化函数选取平方误差：</p><script type="math/tex; mode=display">E=\frac{1}{2}\sum\limits^L_{l=1}\|\pmb{o}^l-\pmb{y}^l \|^2=\frac{1}{2}\sum\limits^L_{l=1}\sum\limits^c_{j=1}(o^l-y^l )^2</script><p>令$\pmb{h}^l_0=\pmb{x}^l$，$\pmb{u}_k^l=\pmb{W}^k\pmb{h}^l_{k-1}+\pmb{b}^k$，$\pmb{h}^l_k=\sigma(\pmb{u}^l_k)(1\le k \le R+1)$，$\pmb{o}^l=\pmb{h}^l_{R+1}=\sigma(\pmb{u}^l_{R+1})$</p><p>如果定义网络各层关于第$l$个样本的反传误差信号或灵敏度为：$\pmb{\delta}_k^l=\frac{\partial \pmb{E}}{\partial \pmb{u}^l_k}$</p><p>那么这些反传误差信号可以递归计算如下：</p><script type="math/tex; mode=display">\pmb{\delta}^l_{R+1}=\frac{\partial \pmb{E}}{\partial\pmb{u}^l_{R+1}}=\frac{\partial \pmb{E}}{\partial\pmb{o}^l}\frac{\partial\pmb{o}^l}{\partial\pmb{u}^l_{R+1}}=(\pmb{o}^l-\pmb{y}^l)\circ\sigma'(\pmb{u}^l_{R+1})=(\pmb{o}^l-\pmb{y}^l)\circ\pmb{o}^l\circ(1-\pmb{o}^l)</script><script type="math/tex; mode=display">\delta_k^l=\frac{\partial \pmb E}{\partial \pmb u^l_k}=\frac{\partial \pmb E}{\partial \pmb{u}^l_{k+1}}\frac{\partial \pmb{u}^l_{k+1}}{\partial \pmb u^l_k}=[(\pmb{W}^{k+1})^T\delta^l_{k+1}]\circ\sigma'(\pmb{u}^l_k),1\le k \le R</script><p>如果采用<strong>受限玻尔兹曼</strong>对多层感知器的权值和偏置进行预训练代理随机初始化，还可以进一步提高逐层反向传播算法的学习训练效果。</p><p>此外，学习训练过程优化的目标函数不一定是平方误差，还可以是其他函数，比如交叉熵：</p><script type="math/tex; mode=display">E=-\sum\limits^L_{l=1}\sum\limits^c_{j=1}(y^l_j\times log(o^l_j)+(1-y^l_j)\times log(1-o^l_j))</script><p>这时，相应的逐层反向传播算法只需把$\pmb{\delta}^l_{R+1}$的计算公式修改为：</p><script type="math/tex; mode=display">\pmb{\delta}^l_{R+1}=\pmb{o}^l-\pmb{y}^l</script><p>多层感知器在训练完之后，常常再被用softmax函数转换成伪概率输出。</p><p>虽然很多文献和代码都把这种softmax函数转换称为软最大输出，但从理论上严格地说，软最大输出应该是把输出层的计算定义为：</p><script type="math/tex; mode=display">\pmb{o}=softmax(\pmb{W}^{R+1}\pmb{h}_R+\pmb{b}^{R+1})</script><p>如果保持其他部分不变，但采用式$(14)$计算网络的输出，那么在采用平方误差$(9)$作为目标函数时，$\pmb{\delta}^l_{R+1}$的计算公式应改为：</p><script type="math/tex; mode=display">\pmb{\delta}^l_{R+1}=\frac{\partial \pmb{E}}{\partial\pmb{u}^l_{R+1}}=\frac{\partial \pmb{E}}{\partial\pmb{o}^l}\frac{\partial\pmb{o}^l}{\partial\pmb{u}^l_{R+1}}=[diag(\pmb{o}^l)-\pmb{o}^l(\pmb{o}^l)^T](\pmb{o}^l-\pmb{y}^l)</script><p>而在采用交叉熵作为目标函数时，$\pmb{\delta}^l_{R+1}$的计算公式应改为：</p><script type="math/tex; mode=display">\pmb{\delta}^l_{R+1}=\left(\begin{array}{cccc}     1 &  \frac{o^l_1}{o^l_2-1} & ... & \frac{o^l_1}{o^l_c-1} \\     \frac{o^l_2}{o^l_1-1} & 1  & ... & \frac{o^l_2}{o^l_c-1}\\     ... & ... & ... &...\\      \frac{o^l_c}{o^l_1-1} & \frac{o^l_c}{o^l_2-1} & ...& 1\end{array}\right)(\pmb{o}^l-\pmb{y}^l)\\=(diag(\pmb{1}./(\pmb{1}-\pmb{o}^l))-(\pmb{o}^l)^T(\pmb{1}./(\pmb{1}-\pmb{o}^l)))(\pmb{o}^l-\pmb{y}^l)</script><p>其中，$<code>\pmb{1}&quot;$表示一个分量全是1的向量，$</code>./“$表示向量的对应分量相除。</p><p>如果每个样本的期望输出$\pmb{y}^l$仅有一个分量，为$\pmb{y}^l_{jl}=1$，那么还可以选用退化交叉熵作为目标函数，即：</p><script type="math/tex; mode=display">E=-\sum\limits^{L}_{l=1}log(\pmb{o}^l_{jl})</script><p>同时，$\pmb{\delta}^l_{R+1}$的计算公式修正为：</p><script type="math/tex; mode=display">\pmb{\delta}^l_{R+1}=\pmb{o}^l-\pmb{y}^l</script>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
          <category> 深度学习 </category>
          
          <category> 预备知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反向传播 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>梯度下降算法</title>
      <link href="/2019/08/25/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E7%AE%97%E6%B3%95/"/>
      <url>/2019/08/25/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>梯度下降算法，又称为最速下降算法，是在无约束条件下计算连续可微函数极小值的基本方法。</p><p>这种方法的核心思想是用负梯度方向作为下降方向，在1874年由法国科学家Cauchy提出。</p><a id="more"></a><h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>设$f(\pmb{x})$在$\pmb{x_k}$附近连续可微，令$\pmb{x}=\pmb{x}_k+\alpha{\pmb{d}}$，其中$\pmb{d}$为单位方向( $|\pmb{d}|=1$ )。</p><p>如果$\pmb{g}_k=\bigtriangledown{f(\pmb{x}_k)}\ne0$，则由Taylor展开式得：</p><script type="math/tex; mode=display">f(\pmb{x})=f(\pmb{x}_k)+(\bigtriangledown{f(\pmb{x}_k)})^{T}(\pmb{x}-\pmb{x}_k)+o(\|\pmb{x}-\pmb{x}_k\|)</script><p>或改写为：</p><script type="math/tex; mode=display">f(\pmb{x}_k+\alpha{\pmb{d}})=f(\pmb{x}_k)+\alpha{\pmb{g}_k}^T\pmb{d}+o(\alpha),\alpha>0</script><p>设$\theta$为$d$与$-g_k$之间的夹角，则有：</p><script type="math/tex; mode=display">\pmb{g}_k^T\pmb{d}=-\pmb{g}_k\cos{\theta}</script><p>不难看出，当$\theta=0$时，$\cos{\theta}=1$，$\pmb{g}_k^T\pmb{d}$取最小值，从而$f(\pmb{x})$下降最快，此时$\pmb{d}=-\pmb{g}_k$。</p><p>因此，负梯度方向$-\pmb{g}_k$就是函数$f(\pmb{x})$在$\pmb{x}_k$附近下降最快的方向。</p><p>梯度下降算法一般都是线性收敛的，速度通常较慢。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p><strong>输入：</strong>$f(\pmb{x})$的表达式</p><p><strong>输出：</strong>极小值点$\pmb{x}^*$</p><ol><li>选初始点$\pmb{x}_0$，收敛误差$\epsilon&gt;0$，迭代次数为$N$，令$k=0$</li><li>若$|\pmb{g}_k|\le{\epsilon}$，则$\pmb{x}^*=\pmb{x}_k$，停止迭代；否则计算$\pmb{d}_k=-\pmb{g}_k$</li><li>选择和计算步长因子$\alpha_k$</li><li>计算$\pmb{x}_{k+1}=\pmb{x}_k+\alpha_k\pmb{d}_k$</li><li>令$k=k+1$，若$k\ge{N}$，则$\pmb{x}^*=\pmb{x}_k$，停止迭代；否则转步到2</li></ol><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>如果$f(\pmb{x})=\frac{1}{2}\pmb{x}^T\pmb{Gx}$，其中$\pmb{G}$是$n\times{n}$对称正定矩阵，最大和最小特征值分别是$\lambda_1$和$\lambda_n$，那么梯度下降算法的收敛速度至少是线性的，且产生的点列${\pmb{x}_k}$对所有k满足</p><script type="math/tex; mode=display">\frac{f(\pmb{x}_{k+1})-f(\pmb{x}^*)}{f(\pmb{x}_{k})-f(\pmb{x}^*)}\le\frac{(\lambda_1-\lambda_n)^2}{(\lambda_1+\lambda_n)^2}</script><script type="math/tex; mode=display">\frac{\|\pmb{x}_{k+1}-\pmb{x}^*\|}{\|\pmb{x}_{k}-\pmb{x}^*\|}\le\sqrt{\frac{\lambda_n}{\lambda_1}}\frac{(\lambda_1-\lambda_n)^2}{(\lambda_1+\lambda_n)^2}</script><p>其中，$\pmb{x}^*$是问题的唯一极小值点。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
          <category> 深度学习 </category>
          
          <category> 预备知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 梯度下降 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>激活函数</title>
      <link href="/2019/08/24/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"/>
      <url>/2019/08/24/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>一些常见的激活函数</p><a id="more"></a><p><strong>恒等函数：</strong>$f(x)=x$</p><p><strong>sigmoid函数：</strong>$\sigma(x)=sigm(x)=\frac{1}{1+e^{-x}}$ ，<strong>导数：</strong> $\sigma’(x)=(sigm(x))’=\sigma(x)(1-\sigma(x))=-\frac{e^{-x}}{(1+e^{-x})^{2}}$</p><p><strong>双曲正切函数tanh：</strong>$\tanh(x)=\frac{e^x-x^{-x}}{e^x+e^{-x}}$ ，<strong>导数：</strong>$(\tanh(x))’=1-(\tanh(x))^{2}=\frac{(e^x+x^{-x})^2-(e^x-e^{-x})^2}{(e^x+e^{-x})^2}$</p><p><strong>硬限幅函数：</strong>$\begin{equation}<br>\text{hardlim}(x)=\left\{\begin{array}{lr}1,x\ge{0} \\ 0,x&lt;0\end{array}\right.<br>\end{equation}$</p><p><strong>斜面函数：</strong>$\begin{equation}<br>\text{ramp}(x)=\left\{\begin{array}{lr}1,x\ge{1} \\ x,-1&lt;x&lt;1 \\ -1,x\le{-1}\end{array}\right.<br>\end{equation}$</p><p><strong>修正线性单元ReLU：</strong>$\text{ReLU}(x)=max(0,x)$ ， <strong>导数：</strong>$\begin{equation}<br>(\text{ReLU}(x))’=\left\{\begin{array}{lr}1,x\ge{0} \\ 0,x&lt;0\end{array}\right.<br>\end{equation}$</p><p><strong>渗漏修正线性单元LReLU：</strong>$\begin{equation}<br>\text{LReLU}(x)=\left\{\begin{array}{lr}1,x\ge{0} \\ax,x&lt;0\end{array}\right.<br>\end{equation}$ ，其中，$a\in{(0,1)}$是一个固定值。</p><p>如果按照某个均匀分布取随机值，则称为RReLU ( Ramdomized LReLU )。</p><p><strong>参数修正线性单元PReLU：</strong>$\begin{equation}<br>\text{PReLU}(x)=\left\{\begin{array}{lr}1,x\ge{0} \\ax,x&lt;0\end{array}\right.<br>\end{equation}$ ，其中，$a\le{1}$是一个可调参数，具体值需要通过学习得到。</p><p><strong>指数线性单元ELU：</strong>$\begin{equation}<br>\text{ELU}(x)=\left\{\begin{array}{lr}1,x\ge{0} \\a(e^{x}-1),x&lt;0\end{array}\right.<br>\end{equation}$  ，其中，$a\ge{0}$ 是一个可调参数。</p><p><strong>软加函数softplus：</strong>$f(x)=\ln(1+e^{x})$</p><p><strong>最大输出函数maxout：</strong>$maxout(x)=max(x_{1},x_{2},…,x_{n})$</p><p><strong>软最大输出函数softmax：</strong>$softmax(x_{1},x_{2},…,x_{n})=\frac{e^{x_i}}{\sum{_{i=1}^{n}}e^{x_i}}$</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
          <category> 深度学习 </category>
          
          <category> 预备知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 激活函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-26-删除排序数组中的重复项</title>
      <link href="/2019/08/24/leetcode-26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
      <url>/2019/08/24/leetcode-26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><p>示例1：</p><blockquote><p>给定数组 nums = [1,1,2], </p><p>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </p><p>你不需要考虑数组中超出新长度后面的元素。</p></blockquote><p>示例2：</p><blockquote><p>给定 nums = [0,0,1,1,1,2,2,3,3,4],</p><p>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</p><p>你不需要考虑数组中超出新长度后面的元素。</p></blockquote><p>说明：</p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><blockquote><p>// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝<br>int len = removeDuplicates(nums);</p><p>// 在函数里修改输入数组对于调用者是可见的。<br>// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。<br>for (int i = 0; i &lt; len; i++) {<br>   print(nums[i]);<br>}</p></blockquote><a id="more"></a><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>双指针法</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>数组完成排序后，我们可以放置两个指针 $i$ 和 $j$，其中 $i$ 是慢指针，而 $j$ 是快指针。只要 $nums[i] = nums[j]$，我们就增加 $j$ 以跳过重复项。</p><p>当我们遇到 $nums[j] \neq nums[i]$ 时，跳过重复项的运行已经结束，因此我们必须把它（$nums[j]$）的值复制到 $nums[i + 1]$。然后递增 $i$，接着我们将再次重复相同的过程，直到 $j$ 到达数组的末尾为止。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.size()==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=i+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(j&lt;nums.size())&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]==nums[j])&#123;<br>                j++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                i++;<br>                nums[i]=nums[j];<br>                j++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：$O(n)$，假设数组的长度是 $n$，那么 $i$ 和 $j$ 分别最多遍历 $n$ 步。</li><li>空间复杂度：$O(1)$。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法与数据结构 </tag>
            
            <tag> 删除重复 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-7-整数反转</title>
      <link href="/2019/08/23/leetcode-7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
      <url>/2019/08/23/leetcode-7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<p>给出一个32位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p><p>示例1：</p><blockquote><p>输入：123</p><p>输出：321</p></blockquote><p>示例2：</p><blockquote><p>输入：-123</p><p>输出：-321</p></blockquote><p>示例3：</p><blockquote><p>输入：120</p><p>输出：21</p></blockquote><p>注意：</p><p>假设我们的环境只能存储得下32位的有符号整数，则其数值范围为$[-2^{31}, 2^{31}-1]$。请根据这个假设，如果反转后整数溢出那么就返回0</p><a id="more"></a><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>弹出和推入数字 &amp; 溢出前进行检查</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我们可以一次构建反转整数的一位数字。在这样做的时候，我们可以预先检查向原整数附加另一位数字是否会导致溢出。</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>反转整数的方法可以与反转字符串进行类比。</p><p>我们想重复“弹出” $x$ 的最后一位数字，并将它“推入”到 $\text{rev}$ 的后面。最后，$\text{rev}$ 将与 $x$ 相反。</p><p>要在没有辅助堆栈 / 数组的帮助下 “弹出” 和 “推入” 数字，我们可以使用数学方法。</p><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//pop operation:</span><br>pop = x % <span class="hljs-number">10</span>;<br>x /= <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">//push operation:</span><br>temp = rev * <span class="hljs-number">10</span> + pop;<br>rev = temp;<br></code></pre></td></tr></table></figure><p>但是，这种方法很危险，因为当 $\text{temp} = \text{rev} \cdot 10 + \text{pop}$ 时会导致溢出。</p><p>幸运的是，事先检查这个语句是否会导致溢出很容易。</p><p>为了便于解释，我们假设 $\text{rev}$ 是正数。</p><ol><li>如果 $temp = \text{rev} \cdot 10 + \text{pop}$ 导致溢出，那么一定有$ \text{rev} \geq \frac{INTMAX}{10}$ 。</li><li>如果 $\text{rev} &gt; \frac{INTMAX}{10}$ ，那么 $temp = \text{rev} \cdot 10 + \text{pop}$ 一定会溢出。</li><li>如果 $\text{rev} == \frac{INTMAX}{10}$ ，那么只要 $\text{pop} &gt; 7$ ，$temp = \text{rev} \cdot 10 + \text{pop}$ 就会溢出。</li></ol><p>当 $\text{rev}$ 为负时可以应用类似的逻辑。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> rev = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">do</span>&#123;<br>            <span class="hljs-keyword">int</span> pop = x % <span class="hljs-number">10</span>;<br>            x /= <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">if</span> (rev &gt; INT_MAX/<span class="hljs-number">10</span> || (rev == INT_MAX / <span class="hljs-number">10</span> &amp;&amp; pop &gt; <span class="hljs-number">7</span>)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (rev &lt; INT_MIN/<span class="hljs-number">10</span> || (rev == INT_MIN / <span class="hljs-number">10</span> &amp;&amp; pop &lt; <span class="hljs-number">-8</span>)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            rev = rev * <span class="hljs-number">10</span> + pop;<br>        &#125;<span class="hljs-keyword">while</span> (x) ;<br>        <span class="hljs-keyword">return</span> rev;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：$O(\log(x))$，$x$ 中大约有 $\log_{10}(x)$ 位数字。</li><li>空间复杂度：$O(1)$。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法与数据结构 </tag>
            
            <tag> 溢出边界 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程挑战任务：车道检测</title>
      <link href="/2019/08/16/Python-OpenCV%E6%95%99%E7%A8%8B%E6%8C%91%E6%88%98%E4%BB%BB%E5%8A%A1%EF%BC%9A%E8%BD%A6%E9%81%93%E6%A3%80%E6%B5%8B/"/>
      <url>/2019/08/16/Python-OpenCV%E6%95%99%E7%A8%8B%E6%8C%91%E6%88%98%E4%BB%BB%E5%8A%A1%EF%BC%9A%E8%BD%A6%E9%81%93%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<p>挑战任务：实际公路的车道线检测。</p><a id="more"></a><h2 id="挑战内容"><a href="#挑战内容" class="headerlink" title="挑战内容"></a>挑战内容</h2><ol><li>在所提供的公路图片上检测出车道线并标记</li></ol><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_lane_detection_result_sample.jpg"></p><ol><li>在所提供的公路视频上检测出车道线并标记</li></ol><p>本次挑战内容来自Udacity自动驾驶纳米学位课程，素材中车道保持不变，车道线清晰明确，易于检测，是车道检测的基础版本，网上也有很多针对复杂场景的高级实现，感兴趣的童鞋可以自行了解。</p><h2 id="挑战解答"><a href="#挑战解答" class="headerlink" title="挑战解答"></a>挑战解答</h2><h3 id="挑战方案"><a href="#挑战方案" class="headerlink" title="挑战方案"></a>挑战方案</h3><p>要检测出当前车道，就是要检测出左右两条车道直线。</p><p>由于无人车一直保持在当前车道，那么无人车上的相机拍摄的视频中，车道线的位置应该基本固定在某一个范围内：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_lane_detection_roi_sample.jpg"></p><p>如果我们手动把这部分ROI区域抠出来，就会排除掉大部分干扰。接下来检测直线肯定是用霍夫变换，但ROI区域内的边缘直线信息还是很多，考虑到只有左右两条车道线，一条斜率为正，一条为负，可将所有的线分为两组，每组再通过均值或最小二乘法拟合的方式确定唯一一条线就可以完成检测。</p><p>总体步骤如下：</p><ol><li>灰度化</li><li>高斯模糊</li><li>Canny边缘检测</li><li>不规则ROI区域截取</li><li>霍夫直线检测</li><li>车道计算</li></ol><p>对于视频来说，只要一幅图能检查出来，合成下就可以了，问题不大。</p><h3 id="图像预处理"><a href="#图像预处理" class="headerlink" title="图像预处理"></a>图像预处理</h3><p>灰度化和滤波操作是大部分图像处理的必要步骤。灰度化不必多说，因为不是基于色彩信息识别的任务，所以没有必要用彩色图，<strong>可以大大减少计算量</strong>。而滤波会削弱图像噪点，排除干扰信息。另外，根据前面学习的知识，边缘提取是基于图像梯度的，<strong>梯度对噪声很敏感，所以平滑滤波操作必不可少</strong>。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_lane_detection_gray_blur_result.jpg"></p><p>这次的代码我们分模块来写，规范一点。其中<code>process_an_image()</code>是主要的图像处理流程：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 高斯滤波核大小</span><br>blur_ksize = <span class="hljs-number">5</span><br><span class="hljs-comment"># Canny边缘检测高低阈值</span><br>canny_lth = <span class="hljs-number">50</span><br>canny_hth = <span class="hljs-number">150</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process_an_image</span><span class="hljs-params">(img)</span>:</span><br>    <span class="hljs-comment"># 1. 灰度化、滤波和Canny</span><br>    gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)<br>    blur_gray = cv2.GaussianBlur(gray, (blur_ksize, blur_ksize), <span class="hljs-number">1</span>)<br>    edges = cv2.Canny(blur_gray, canny_lth, canny_hth)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:<br>    img = cv2.imread(<span class="hljs-string">'test_pictures/lane.jpg'</span>)<br>    result = process_an_image(img)<br>    cv2.imshow(<span class="hljs-string">"lane"</span>, np.hstack((img, result)))<br>    cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_lane_detection_canny_result.jpg"></p><h3 id="ROI截取"><a href="#ROI截取" class="headerlink" title="ROI截取"></a>ROI截取</h3><p>按照前面描述的方案，只需保留边缘图中红线部分区域用于后续的霍夫直线检测，其余都是无用的信息：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_lane_detection_canny_roi_reserve.jpg"></p><p>如何实现呢？还记得图像混合中的这张图吗？</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_understand_mask.jpg"></p><p>我们可以创建一个梯形的mask掩膜，然后与边缘检测结果图混合运算，掩膜中白色的部分保留，黑色的部分舍弃。梯形的四个坐标需要手动标记：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_lane_detection_mask_sample.jpg"></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process_an_image</span><span class="hljs-params">(img)</span>:</span><br>    <span class="hljs-comment"># 1. 灰度化、滤波和Canny</span><br>gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)<br>    blur_gray = cv2.GaussianBlur(gray, (blur_ksize, blur_ksize), <span class="hljs-number">1</span>)<br>    edges = cv2.Canny(blur_gray, canny_lth, canny_hth)<br>    <span class="hljs-comment"># 2. 标记四个坐标点用于ROI截取</span><br>    rows, cols = edges.shape<br>    points = np.array([[(<span class="hljs-number">0</span>, rows), (<span class="hljs-number">460</span>, <span class="hljs-number">325</span>), (<span class="hljs-number">520</span>, <span class="hljs-number">325</span>), (cols, rows)]])<br>    <span class="hljs-comment"># [[[0 540], [460 325], [520 325], [960 540]]]</span><br>    roi_edges = roi_mask(edges, points)<br>    <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">roi_mask</span><span class="hljs-params">(img, corner_points)</span>:</span><br>    <span class="hljs-comment"># 创建掩膜</span><br>    mask = np.zeros_like(img)<br>    cv2.fillPoly(mask, corner_points, <span class="hljs-number">255</span>)<br><br>    masked_img = cv2.bitwise_and(img, mask)<br>    <span class="hljs-keyword">return</span> masked_img<br></code></pre></td></tr></table></figure><p>这样，结果图”roi_edges”应该是：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_lane_detection_masked_roi_edges.jpg"></p><h3 id="霍夫直线提取"><a href="#霍夫直线提取" class="headerlink" title="霍夫直线提取"></a>霍夫直线提取</h3><p>为了方便后续计算直线的斜率，我们使用统计概率霍夫直线变换（因为它能直接得到直线的起点和终点坐标）。霍夫变换的参数比较多，可以放在代码开头，便于修改：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 霍夫变换参数</span><br>rho = <span class="hljs-number">1</span><br>theta = np.pi / <span class="hljs-number">180</span><br>threshold = <span class="hljs-number">15</span><br>min_line_len = <span class="hljs-number">40</span><br>max_line_gap = <span class="hljs-number">20</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process_an_image</span><span class="hljs-params">(img)</span>:</span><br>    <span class="hljs-comment"># 1. 灰度化、滤波和Canny</span><br>gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)<br>    blur_gray = cv2.GaussianBlur(gray, (blur_ksize, blur_ksize), <span class="hljs-number">1</span>)<br>    edges = cv2.Canny(blur_gray, canny_lth, canny_hth)<br>    <br>    <span class="hljs-comment"># 2. 标记四个坐标点用于ROI截取</span><br>    rows, cols = edges.shape<br>    points = np.array([[(<span class="hljs-number">0</span>, rows), (<span class="hljs-number">460</span>, <span class="hljs-number">325</span>), (<span class="hljs-number">520</span>, <span class="hljs-number">325</span>), (cols, rows)]])<br>    <span class="hljs-comment"># [[[0 540], [460 325], [520 325], [960 540]]]</span><br>    roi_edges = roi_mask(edges, points)<br>    <br>    <span class="hljs-comment"># 3. 霍夫直线提取</span><br>    drawing, lines = hough_lines(roi_edges, rho, theta, threshold, min_line_len, max_line_gap)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hough_lines</span><span class="hljs-params">(img, rho, theta, threshold, min_line_len, max_line_gap)</span>:</span><br>    <span class="hljs-comment"># 统计概率霍夫直线变换</span><br>    lines = cv2.HoughLinesP(img, rho, theta, threshold, minLineLength=min_line_len, maxLineGap=max_line_gap)<br><br>    <span class="hljs-comment"># 新建一副空白画布</span><br>    drawing = np.zeros((img.shape[<span class="hljs-number">0</span>], img.shape[<span class="hljs-number">1</span>], <span class="hljs-number">3</span>), dtype=np.uint8)<br>    <span class="hljs-comment"># draw_lines(drawing, lines)     # 画出直线检测结果</span><br><br>    <span class="hljs-keyword">return</span> drawing, lines<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draw_lines</span><span class="hljs-params">(img, lines, color=[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>], thickness=<span class="hljs-number">1</span>)</span>:</span><br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines:<br>        <span class="hljs-keyword">for</span> x1, y1, x2, y2 <span class="hljs-keyword">in</span> line:<br>            cv2.line(img, (x1, y1), (x2, y2), color, thickness)<br></code></pre></td></tr></table></figure><p><code>draw_lines()</code>是用来画直线检测的结果，后面我们会接着处理直线，所以这里注释掉了，可以取消注释看下效果：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_lane_detection_hough_lines_direct_result.jpg"></p><p>对本例的这张测试图来说，如果打印出直线的条数<code>print(len(lines))</code>，应该是有16条。</p><h3 id="车道计算"><a href="#车道计算" class="headerlink" title="车道计算"></a>车道计算</h3><p>这部分应该算是本次挑战任务的核心内容了：前面通过霍夫变换得到了多条直线的起点和终点，我们的目的是通过某种算法只得到左右两条车道线。</p><p><strong>第一步、根据斜率正负划分某条线是左车道还是右车道。</strong></p><script type="math/tex; mode=display">斜率=\frac{y_2-y_1}{x_2-x_1}(\le0:左，>0:右)</script><blockquote><p>经验之谈：再次强调，斜率计算是在图像坐标系下，所以斜率正负/左右跟平面坐标有区别。</p></blockquote><p><strong>第二步、迭代计算各直线斜率与斜率均值的差，排除掉差值过大的异常数据。</strong></p><p>注意这里迭代的含义，意思是第一次计算完斜率均值并排除掉异常值后，再在剩余的斜率中取均值，继续排除……这样迭代下去。</p><p><strong>第三步、最小二乘法拟合左右车道线。</strong></p><p>经过第二步的筛选，就只剩下可能的左右车道线了，这样只需从多条直线中拟合出一条就行。拟合方法有很多种，最常用的便是最小二乘法，它通过最小化误差的平方和来寻找数据的最佳匹配函数。</p><p>具体来说，假设目前可能的左车道线有6条，也就是12个坐标点，包括12个x和12个y，我们的目的是拟合出这样一条直线：</p><script type="math/tex; mode=display">f(x_i)=ax_i+b</script><p>使得误差平方和最小：</p><script type="math/tex; mode=display">E=\sum[f(x_i)-y_i]^2</script><p>Python中可以直接使用<code>np.polyfit()</code>进行最小二乘法拟合。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process_an_image</span><span class="hljs-params">(img)</span>:</span><br>    <span class="hljs-comment"># 1. 灰度化、滤波和Canny</span><br><br>    <span class="hljs-comment"># 2. 标记四个坐标点用于ROI截取</span><br><br>    <span class="hljs-comment"># 3. 霍夫直线提取</span><br><br>    <span class="hljs-comment"># 4. 车道拟合计算</span><br>    draw_lanes(drawing, lines)<br><br>    <span class="hljs-comment"># 5. 最终将结果合在原图上</span><br>    result = cv2.addWeighted(img, <span class="hljs-number">0.9</span>, drawing, <span class="hljs-number">0.2</span>, <span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">return</span> result<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draw_lanes</span><span class="hljs-params">(img, lines, color=[<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], thickness=<span class="hljs-number">8</span>)</span>:</span><br>    <span class="hljs-comment"># a. 划分左右车道</span><br>    left_lines, right_lines = [], []<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines:<br>        <span class="hljs-keyword">for</span> x1, y1, x2, y2 <span class="hljs-keyword">in</span> line:<br>            k = (y2 - y1) / (x2 - x1)<br>            <span class="hljs-keyword">if</span> k &lt; <span class="hljs-number">0</span>:<br>                left_lines.append(line)<br>            <span class="hljs-keyword">else</span>:<br>                right_lines.append(line)<br><br>    <span class="hljs-keyword">if</span> (len(left_lines) &lt;= <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> len(right_lines) &lt;= <span class="hljs-number">0</span>):<br>        <span class="hljs-keyword">return</span><br><br>    <span class="hljs-comment"># b. 清理异常数据</span><br>    clean_lines(left_lines, <span class="hljs-number">0.1</span>)<br>    clean_lines(right_lines, <span class="hljs-number">0.1</span>)<br><br>    <span class="hljs-comment"># c. 得到左右车道线点的集合，拟合直线</span><br>    left_points = [(x1, y1) <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> left_lines <span class="hljs-keyword">for</span> x1, y1, x2, y2 <span class="hljs-keyword">in</span> line]<br>    left_points = left_points + [(x2, y2) <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> left_lines <span class="hljs-keyword">for</span> x1, y1, x2, y2 <span class="hljs-keyword">in</span> line]<br>    right_points = [(x1, y1) <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> right_lines <span class="hljs-keyword">for</span> x1, y1, x2, y2 <span class="hljs-keyword">in</span> line]<br>    right_points = right_points + [(x2, y2) <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> right_lines <span class="hljs-keyword">for</span> x1, y1, x2, y2 <span class="hljs-keyword">in</span> line]<br><br>    left_results = least_squares_fit(left_points, <span class="hljs-number">325</span>, img.shape[<span class="hljs-number">0</span>])<br>    right_results = least_squares_fit(right_points, <span class="hljs-number">325</span>, img.shape[<span class="hljs-number">0</span>])<br><br>    <span class="hljs-comment"># 注意这里点的顺序</span><br>    vtxs = np.array([[left_results[<span class="hljs-number">1</span>], left_results[<span class="hljs-number">0</span>], right_results[<span class="hljs-number">0</span>], right_results[<span class="hljs-number">1</span>]]])<br>    <span class="hljs-comment"># d. 填充车道区域</span><br>    cv2.fillPoly(img, vtxs, (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>))<br><br>    <span class="hljs-comment"># 或者只画车道线</span><br>    <span class="hljs-comment"># cv2.line(img, left_results[0], left_results[1], (0, 255, 0), thickness)</span><br>    <span class="hljs-comment"># cv2.line(img, right_results[0], right_results[1], (0, 255, 0), thickness)</span><br>    <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">clean_lines</span><span class="hljs-params">(lines, threshold)</span>:</span><br>    <span class="hljs-comment"># 迭代计算斜率均值，排除掉与差值差异较大的数据</span><br>    slope = [(y2 - y1) / (x2 - x1) <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines <span class="hljs-keyword">for</span> x1, y1, x2, y2 <span class="hljs-keyword">in</span> line]<br>    <span class="hljs-keyword">while</span> len(lines) &gt; <span class="hljs-number">0</span>:<br>        mean = np.mean(slope)<br>        diff = [abs(s - mean) <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> slope]<br>        idx = np.argmax(diff)<br>        <span class="hljs-keyword">if</span> diff[idx] &gt; threshold:<br>            slope.pop(idx)<br>            lines.pop(idx)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">break</span><br>            <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">least_squares_fit</span><span class="hljs-params">(point_list, ymin, ymax)</span>:</span><br>    <span class="hljs-comment"># 最小二乘法拟合</span><br>    x = [p[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> point_list]<br>    y = [p[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> point_list]<br><br>    <span class="hljs-comment"># polyfit第三个参数为拟合多项式的阶数，所以1代表线性</span><br>    fit = np.polyfit(y, x, <span class="hljs-number">1</span>)<br>    fit_fn = np.poly1d(fit)  <span class="hljs-comment"># 获取拟合的结果</span><br><br>    xmin = int(fit_fn(ymin))<br>    xmax = int(fit_fn(ymax))<br><br>    <span class="hljs-keyword">return</span> [(xmin, ymin), (xmax, ymax)]<br></code></pre></td></tr></table></figure><p>这段代码比较多，请每个步骤单独来看。最后得到的是左右两条车道线的起点和终点坐标，可以选择画出车道线，这里我直接填充了整个区域：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_lane_detection_result_sample.jpg"></p><h3 id="视频处理"><a href="#视频处理" class="headerlink" title="视频处理"></a>视频处理</h3><p>搞定了一张图，视频也就没什么问题了，关键就是视频帧的提取和合成，为此，我们要用到Python的视频编辑包<a href="https://pypi.org/project/moviepy/#files" target="_blank" rel="noopener">moviepy</a>：</p><p>另外还需要ffmpeg，首次运行moviepy时会自动下载，也可<a href="https://github.com/imageio/imageio-binaries/tree/master/ffmpeg" target="_blank" rel="noopener">手动</a>下载。</p><p>只需在开头导入moviepy，然后将主函数改掉就可以了，其余代码不需要更改：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 开头导入moviepy</span><br><span class="hljs-keyword">from</span> moviepy.editor <span class="hljs-keyword">import</span> VideoFileClip<br><br><span class="hljs-comment"># 主函数更改为：</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:<br>    output = <span class="hljs-string">'test_videos/output.mp4'</span><br>    clip = VideoFileClip(<span class="hljs-string">"test_videos/cv2_white_lane.mp4"</span>)<br>    out_clip = clip.fl_image(process_an_image)<br>    out_clip.write_videofile(output, audio=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><p>本文实现了车道检测的基础版本，如果你感兴趣的话，可以自行搜索或参考引用部分了解更多。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="http://pic.ex2tron.top/cv2_lane_detection_material.zip" target="_blank" rel="noopener">图片和视频素材</a></li><li><a href="https://zhuanlan.zhihu.com/p/25354571" target="_blank" rel="noopener">从零开始学习无人驾驶技术 — 车道检测</a></li><li><a href="https://blog.csdn.net/u010665216/article/details/80152458" target="_blank" rel="noopener">无人驾驶之高级车道线检测</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 车道检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>目标检测背景</title>
      <link href="/2019/08/16/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E8%83%8C%E6%99%AF/"/>
      <url>/2019/08/16/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E8%83%8C%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<p><strong>图像分类，检测及分割是计算机视觉领域的三大任务。</strong></p><p>图像分类模型是将图像划分为单个类别，通常对应于图像中最突出的物体。但在现实世界的很多图片通常包含不只一个物体，此时如果使用图像分类模型为图像分配一个单一标签其实是非常粗糙的，并不准确。</p><p>对于这样的情况，就需要目标检测模型，目标检测模型可以识别一张图片的多个物体，并可以定位出不同物体（给出边界框）。</p><p>目标检测在很多场景有用，如无人驾驶和安防系统。</p><p>以下是图像分类，目标检测与实例分割的对比。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB%EF%BC%8C%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%88%86%E5%89%B2%E7%9A%84%E5%AF%B9%E6%AF%94.png"></p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>目前主流的目标检测算法主要是基于深度学习模型，其可以分成两大类：</p><ul><li><p>two-stage检测算法</p><p>  two-stage检测算法将检测问题划分为两个阶段，首先产生候选区域（region proposals），然后对候选区域分类（一般还需要对位置精修），这类算法的典型代表是基于region proposal的R-CNN系算法，如R-CNN、Fast R-CNN、Faster R-CNN等。</p></li><li><p>one-stage检测算法</p><p>  one-stage检测不需要region proposal阶段，直接产生物体的类别概率和位置坐标值，比较典型的算法如YOLO和SSD。</p></li></ul><p>目标检测模型的主要性能指标是检测<strong>准确度</strong>和<strong>速度</strong>。</p><p>一般情况下，two-stage算法在准确度上有优势，而one-stage算法在速度上有优势。</p><p>在这篇长文中，我们将对最新的目标检测算法做一个综述。在介绍目标检测算法之前，先简单介绍目标检测领域常用的数据集以及性能指标。</p><h2 id="数据集合性能指标"><a href="#数据集合性能指标" class="headerlink" title="数据集合性能指标"></a>数据集合性能指标</h2><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p>PASCAL VOC（<a href="http://host.robots.ox.ac.uk/pascal/VOC/" target="_blank" rel="noopener">The PASCAL Visual Object Classification</a>）是目标检测，分类，分割等领域。从2005到2012年，共举办了8个不同的挑战赛。PASCAL VOC包含约10,000张带有边界框的图片用于训练和验证。但是，PASCAL VOC数据集仅包含20个类别，因此其被看成目标检测问题的一个基准数据集。</p><p><a href="http://www.image-net.org/" target="_blank" rel="noopener">ImageNet</a>在2013年放出了包含边界框的目标检测数据集。训练数据集包含500,000张图片，属于200类物体。由于数据集太大，训练所需计算量很大，因而很少使用。同时，由于类别数也比较多，目标检测的难度也相当大。</p><p>MS COCO（<a href="http://cocodataset.org/#home" target="_blank" rel="noopener">Common Objects in COntext</a>）数据集。这个数据集用于多种竞赛：图像标题生成，目标检测，关键点检测和物体分割。对于目标检测任务，COCO共包含80个类别，每年大赛的训练和验证数据集包含超过120,000个图片，超过40,000个测试图片。测试集最近被划分为两类，一类是test-dev数据集用于研究者，一类是test-challenge数据集用于竞赛者。测试集的标签数据没有公开，以避免在测试集上过拟合。</p><h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><p>目标检测问题同时是一个回归和分类问题。</p><p>首先，为了评估定位精度，需要计算IoU（Intersection over Union，介于0到1之间），其表示预测框与真实框（ground-truth box）之间的重叠程度。IoU越高，预测框的位置越准确。因而，在评估预测框时，通常会设置一个IoU阈值（如0.5），只有当预测框与正式框的IoU值大于这个阈值的时候，该预测框才被认定为真阳性（True Positive，TP），反之就是假阳性（False Positive，FP）。</p><p>对于二分类，AP（Average Precision）是一个重要的指标，这是信息检索中的一个概念，基于precision-recall曲线计算出来，可以参考<a href="https://en.wikipedia.org/w/index.php?title=Information_retrieval&amp;oldid=793358396#Average_precision" target="_blank" rel="noopener">这里</a>。对于目标检测，首先要单独计算各个类别的AP值，这是评估检测效果的重要指标。取各个类别的AP的平均值，就得到一个综合指标mAP（Mean Average Precision），mAP指标可以避免某些类别比较极端化而弱化其他类别的性能这个问题。</p><p>对于目标检测，mAP一般在某个固定的IoU上计算，但是不同的IoU值会改变TP和FP的比例，从而造成mAP的差异。COCO数据集提供了<a href="https://github.com/cocodataset/cocoapi" target="_blank" rel="noopener">官方的评估指标</a>，它的AP是计算一系列IoU下（0.5 : 0.05 : 0.9, 见<a href="http://cocodataset.org/#detection-eval" target="_blank" rel="noopener">说明</a>）AP的平均值，这样可以消除IoU导致的AP波动。其实对于PASCAL VOC数据集也是这样，Facebook的Detectron上的有比较清晰的<a href="https://github.com/facebookresearch/Detectron/blob/05d04d3a024f0991339de45872d02f2f50669b3d/lib/datasets/voc_eval.py#L54" target="_blank" rel="noopener">实现</a>。</p><p>除了检测准确度，目标检测算法的另外一个重要性能指标是速度，只有速度快，才能实现实时检测，这对一些应用场景极其重要。评估速度的常用指标是每秒帧率（Frame Per Second，FPS），即每秒内可以处理的图片数量。当然要对比FPS，你需要在同一硬件上进行。另外也可以使用处理一张图片所需时间来评估检测速度，时间越短，速度越快。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> 目标检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 目标检测 </tag>
            
            <tag> 背景 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YOLO原理与实现</title>
      <link href="/2019/08/16/YOLO%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/08/16/YOLO%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍了YOLO算法</p><p>其全称是：You Only Look Once: Unified, Real-Time Object Detection</p><p>该名称基本上把Yolo算法的特点都概括全了：</p><ul><li>You Only Look Once：只需要一次CNN运算</li><li>Unified：一个统一的框架，提供end-to-end的预测</li><li>Real-Time：Yolo算法速度快</li></ul><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> 基本模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 基本模型 </tag>
            
            <tag> YOLO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程17：霍夫变换</title>
      <link href="/2019/08/15/Python-OpenCV%E6%95%99%E7%A8%8B17%EF%BC%9A%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2/"/>
      <url>/2019/08/15/Python-OpenCV%E6%95%99%E7%A8%8B17%EF%BC%9A%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>学习使用霍夫变换识别出图像中的直线和圆等几何形状。</p><p>目标：</p><ul><li>理解霍夫变换的实现</li><li>分别使用霍夫线变换和圆变换检测图像中的直线和圆</li><li>OpenCV函数：<ul><li><code>cv2.HoughLines()</code>：霍夫直线变换（整条直线）</li><li><code>cv2.HoughLinesP()</code>：统计概率霍夫直线变换</li><li><code>cv2.HoughCircles()</code>：霍夫圆变换</li></ul></li></ul><a id="more"></a><h2 id="霍夫变换"><a href="#霍夫变换" class="headerlink" title="霍夫变换"></a>霍夫变换</h2><p>霍夫变换常用来在图像中提取直线和圆等几何形状，我来做个简易的解释：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_understand_hough_transform.jpg"></p><p>学过几何的都知道，直线可以分别用直角坐标系和极坐标系来表示：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_line_expression_in_coordinate.jpg"></p><p>那么经过某个点(x0,y0)的所有直线都可以用这个式子来表示：</p><script type="math/tex; mode=display">r_\theta=x_0\cdot\cos{\theta}+y_0\cdot\sin{\theta}</script><p>也就是说每一个(r,θ)都表示一条经过(x0,y0)直线，那么同一条直线上的点必然会有同样的(r,θ)。如果将某个点所有的(r,θ)绘制成下面的曲线，那么同一条直线上的点的(r,θ)曲线会相交于一点：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_curve_of_r_theta.jpg"></p><p>OpenCV中首先计算(r,θ) 累加数，累加数超过一定值后就认为在同一直线上。</p><h2 id="霍夫直线变换"><a href="#霍夫直线变换" class="headerlink" title="霍夫直线变换"></a>霍夫直线变换</h2><p>OpenCV中用<code>cv2.HoughLines()</code>在二值图上实现霍夫变换，函数返回的是一组直线的(r,θ)数据：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 1.加载图片，转为二值图</span><br>img = cv2.imread(<span class="hljs-string">'shapes.jpg'</span>)<br>drawing = np.zeros(img.shape[:], dtype=np.uint8)<br>gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br>edges = cv2.Canny(gray, <span class="hljs-number">50</span>, <span class="hljs-number">150</span>)<br><br><span class="hljs-comment"># 2.霍夫直线变换</span><br>lines = cv2.HoughLines(edges, <span class="hljs-number">0.8</span>, np.pi / <span class="hljs-number">180</span>, <span class="hljs-number">90</span>)<br></code></pre></td></tr></table></figure><p>函数中：</p><ul><li>参数1：要检测的二值图（一般是阈值分割或边缘检测后的图）</li><li>参数2：距离r的精度，值越大，考虑越多的线</li><li>参数3：角度θ的精度，值越小，考虑越多的线</li><li>参数4：累加数阈值，值越小，考虑越多的线</li></ul><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 3.将检测的线画出来（注意是极坐标噢）</span><br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines:<br>    rho, theta = line[<span class="hljs-number">0</span>]<br>    a = np.cos(theta)<br>    b = np.sin(theta)<br>    x0 = a * rho<br>    y0 = b * rho<br>    x1 = int(x0 + <span class="hljs-number">1000</span> * (-b))<br>    y1 = int(y0 + <span class="hljs-number">1000</span> * (a))<br>    x2 = int(x0 - <span class="hljs-number">1000</span> * (-b))<br>    y2 = int(y0 - <span class="hljs-number">1000</span> * (a))<br>    <br>    cv2.line(drawing, (x1, y1), (x2, y2), (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>))<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_hough_line_function.jpg"></p><h2 id="统计概率霍夫直线变换"><a href="#统计概率霍夫直线变换" class="headerlink" title="统计概率霍夫直线变换"></a>统计概率霍夫直线变换</h2><p>前面的方法又称为标准霍夫变换，它会计算图像中的每一个点，计算量比较大，另外它得到的是整一条线（r和θ），并不知道原图中直线的端点。所以提出了统计概率霍夫直线变换(Probabilistic Hough Transform)，是一种改进的霍夫变换：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">drawing = np.zeros(img.shape[:], dtype=np.uint8)<br><span class="hljs-comment"># 统计概率霍夫线变换</span><br>lines = cv2.HoughLinesP(edges, <span class="hljs-number">0.8</span>, np.pi / <span class="hljs-number">180</span>, <span class="hljs-number">90</span>,<br>                        minLineLength=<span class="hljs-number">50</span>, maxLineGap=<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><p>前面几个参数跟之前的一样，有两个可选参数：</p><ul><li><code>minLineLength</code>：最短长度阈值，比这个长度短的线会被排除</li><li><code>maxLineGap</code>：同一直线两点之间的最大距离</li></ul><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将检测的线画出来</span><br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines:<br>    x1, y1, x2, y2 = line[<span class="hljs-number">0</span>]<br>    cv2.line(drawing, (x1, y1), (x2, y2), (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>), <span class="hljs-number">1</span>, lineType=cv2.LINE_AA)<br></code></pre></td></tr></table></figure><p><code>cv2.LINE_AA</code>在之前绘图功能中讲解过，表示抗锯齿线型。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_hough_lines_p_function.jpg"></p><h2 id="霍夫圆变换"><a href="#霍夫圆变换" class="headerlink" title="霍夫圆变换"></a>霍夫圆变换</h2><p>霍夫圆变换跟直线变换类似，只不过线是用(r,θ)表示，圆是用(x_center,y_center,r)来表示，从二维变成了三维，数据量变大了很多；所以一般使用霍夫梯度法减少计算量，对该算法感兴趣的同学可参考：<a href="https://en.wikipedia.org/wiki/Circle_Hough_Transform" target="_blank" rel="noopener">Circle Hough Transform</a></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">drawing = np.zeros(img.shape[:], dtype=np.uint8)<br><span class="hljs-comment"># 霍夫圆变换</span><br>circles = cv2.HoughCircles(edges, cv2.HOUGH_GRADIENT, <span class="hljs-number">1</span>, <span class="hljs-number">20</span>, param2=<span class="hljs-number">30</span>)<br>circles = np.int0(np.around(circles))<br></code></pre></td></tr></table></figure><p>其中，</p><ul><li>参数2：变换方法，一般使用霍夫梯度法，详情：<a href="https://docs.opencv.org/3.3.1/d7/dbd/group__imgproc.html#ga073687a5b96ac7a3ab5802eb5510fe65" target="_blank" rel="noopener">HoughModes</a></li><li>参数3 dp=1：表示霍夫梯度法中累加器图像的分辨率与原图一致</li><li>参数4：两个不同圆圆心的最短距离</li><li>参数5：param2跟霍夫直线变换中的累加数阈值一样</li></ul><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将检测的圆画出来</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> circles[<span class="hljs-number">0</span>, :]:<br>    cv2.circle(drawing, (i[<span class="hljs-number">0</span>], i[<span class="hljs-number">1</span>]), i[<span class="hljs-number">2</span>], (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>), <span class="hljs-number">2</span>)  <span class="hljs-comment"># 画出外圆</span><br>    cv2.circle(drawing, (i[<span class="hljs-number">0</span>], i[<span class="hljs-number">1</span>]), <span class="hljs-number">2</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">3</span>)  <span class="hljs-comment"># 画出圆心</span><br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_hough_circles_function.jpg"></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_houghlines/py_houghlines.html" target="_blank" rel="noopener">Hough Line Transform</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_houghcircles/py_houghcircles.html" target="_blank" rel="noopener">Hough Circle Transform</a></li><li><a href="https://en.wikipedia.org/wiki/Hough_transform" target="_blank" rel="noopener">Hough transform</a></li><li><a href="https://blog.csdn.net/YuYunTan/article/details/80141392" target="_blank" rel="noopener">经典霍夫变换（Hough Transform）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 霍夫变换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程16：模板匹配</title>
      <link href="/2019/08/15/Python-OpenCV%E6%95%99%E7%A8%8B16%EF%BC%9A%E6%A8%A1%E6%9D%BF%E5%8C%B9%E9%85%8D/"/>
      <url>/2019/08/15/Python-OpenCV%E6%95%99%E7%A8%8B16%EF%BC%9A%E6%A8%A1%E6%9D%BF%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<p>学习使用模板匹配在图像中寻找物体。</p><p>目标：</p><ul><li>使用模板匹配在图像中寻找物体，在大图中找小图</li><li>OpenCV函数<ul><li><code>cv2.matchTemplate()</code>：进行模板匹配</li><li><code>cv2.minMaxLoc()</code>：得到最大匹配值的坐标，以这个点为左上角角点。</li></ul></li></ul><a id="more"></a><h2 id="模板匹配"><a href="#模板匹配" class="headerlink" title="模板匹配"></a>模板匹配</h2><p><a href="https://baike.baidu.com/item/模板匹配" target="_blank" rel="noopener">模板匹配</a>就是用来在大图中找小图，也就是说在一副图像中寻找另外一张模板图像的位置：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_understand_template_matching.jpg"></p><p>用<code>cv2.matchTemplate()</code>实现模板匹配。首先我们来读入图片和模板：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><br>img = cv2.imread(<span class="hljs-string">'lena.jpg'</span>, <span class="hljs-number">0</span>)<br>template = cv2.imread(<span class="hljs-string">'face.jpg'</span>, <span class="hljs-number">0</span>)<br>h, w = template.shape[:<span class="hljs-number">2</span>]  <span class="hljs-comment"># rows-&gt;h, cols-&gt;w</span><br></code></pre></td></tr></table></figure><p>匹配函数返回的是一副灰度图，最白的地方表示最大的匹配。</p><p>使用<code>cv2.minMaxLoc()</code>函数可以得到最大匹配值的坐标，以这个点为左上角角点。</p><p>模板的宽和高画矩形就是匹配的位置了：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 相关系数匹配方法：cv2.TM_CCOEFF</span><br>res = cv2.matchTemplate(img, template, cv2.TM_CCOEFF)<br>min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)<br><br>left_top = max_loc  <span class="hljs-comment"># 左上角</span><br>right_bottom = (left_top[<span class="hljs-number">0</span>] + w, left_top[<span class="hljs-number">1</span>] + h)  <span class="hljs-comment"># 右下角</span><br>cv2.rectangle(img, left_top, right_bottom, <span class="hljs-number">255</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment"># 画出矩形位置</span><br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_ccoeff_matching_template.jpg"></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>模板匹配的原理其实很简单，就是不断地在原图中移动模板图像去比较，有6种不同的比较方法，详情可参考：<a href="https://docs.opencv.org/3.3.1/df/dfb/group__imgproc__object.html#ga3a7850640f1fe1f58fe91a2d7583695d" target="_blank" rel="noopener">TemplateMatchModes</a></p><ul><li>平方差匹配CV_TM_SQDIFF：用两者的平方差来匹配，最好的匹配值为0</li><li>归一化平方差匹配CV_TM_SQDIFF_NORMED</li><li>相关匹配CV_TM_CCORR：用两者的乘积匹配，数值越大表明匹配程度越好</li><li>归一化相关匹配CV_TM_CCORR_NORMED</li><li>相关系数匹配CV_TM_CCOEFF：用两者的相关系数匹配，1表示完美的匹配，-1表示最差的匹配</li><li>归一化相关系数匹配CV_TM_CCOEFF_NORMED</li></ul><p>归一化的意思就是将值统一到0~1，这些方法的对比代码可到源码处查看。</p><p>模板匹配也是应用卷积来实现的：假设原图大小为W×H，模板图大小为w×h，那么生成图大小是(W-w+1)×(H-h+1)，生成图中的每个像素值表示原图与模板的匹配程度。</p><h2 id="匹配多个物体"><a href="#匹配多个物体" class="headerlink" title="匹配多个物体"></a>匹配多个物体</h2><p>前面我们是找最大匹配的点，所以只能匹配一次。我们可以设定一个匹配阈值来匹配多次：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1.读入原图和模板</span><br>img_rgb = cv2.imread(<span class="hljs-string">'mario.jpg'</span>)<br>img_gray = cv2.cvtColor(img_rgb, cv2.COLOR_BGR2GRAY)<br>template = cv2.imread(<span class="hljs-string">'mario_coin.jpg'</span>, <span class="hljs-number">0</span>)<br>h, w = template.shape[:<span class="hljs-number">2</span>]<br><br><span class="hljs-comment"># 2.标准相关模板匹配</span><br>res = cv2.matchTemplate(img_gray, template, cv2.TM_CCOEFF_NORMED)<br>threshold = <span class="hljs-number">0.8</span> <br><br><span class="hljs-comment"># 3.这边是Python/Numpy的知识，后面解释</span><br>loc = np.where(res &gt;= threshold)  <span class="hljs-comment"># 匹配程度大于%80的坐标y,x</span><br><span class="hljs-keyword">for</span> pt <span class="hljs-keyword">in</span> zip(*loc[::<span class="hljs-number">-1</span>]):  <span class="hljs-comment"># *号表示可选参数</span><br>    right_bottom = (pt[<span class="hljs-number">0</span>] + w, pt[<span class="hljs-number">1</span>] + h)<br>    cv2.rectangle(img_rgb, pt, right_bottom, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_template_matching_multi.jpg"></p><p>第3步有几个Python/Numpy的重要知识，来大致看下：</p><ul><li><a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.where.html" target="_blank" rel="noopener">np.where()</a>在这里返回res中值大于0.8的所有坐标，如：</li></ul><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">x = np.arange(<span class="hljs-number">9.</span>).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)<br>print(np.where(x &gt; <span class="hljs-number">5</span>))<br><span class="hljs-comment"># 结果(先y坐标，再x坐标)：(array([2, 2, 2]), array([0, 1, 2]))</span><br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_np_where_function.jpg"></p><ul><li><a href="https://docs.python.org/3/library/functions.html#zip" target="_blank" rel="noopener">zip()</a>函数，功能强大到难以解释，举个简单例子就知道了：</li></ul><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">x = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>y = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br>print(list(zip(x, y)))  <span class="hljs-comment"># [(1, 4), (2, 5), (3, 6)]</span><br></code></pre></td></tr></table></figure><p>这样大家就能理解前面代码的用法了吧：因为loc是先y坐标再x坐标，所以用loc[::-1]翻转一下，然后再用zip函数拼接在一起。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_template_matching/py_template_matching.html" target="_blank" rel="noopener">Template Matching</a></li><li><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/histograms/template_matching/template_matching.html#template-matching" target="_blank" rel="noopener">模板匹配</a></li><li><a href="https://docs.opencv.org/3.3.1/df/dfb/group__imgproc__object.html#ga3a7850640f1fe1f58fe91a2d7583695d" target="_blank" rel="noopener">TemplateMatchModes</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 模板匹配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程15：直方图</title>
      <link href="/2019/08/15/Python-OpenCV%E6%95%99%E7%A8%8B15%EF%BC%9A%E7%9B%B4%E6%96%B9%E5%9B%BE/"/>
      <url>/2019/08/15/Python-OpenCV%E6%95%99%E7%A8%8B15%EF%BC%9A%E7%9B%B4%E6%96%B9%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>学习计算并绘制直方图，直方图均衡化等。</p><p>目标：</p><ul><li>计算并绘制直方图</li><li>（自适应）直方图均衡化</li><li>OpenCV函数：<ul><li><code>cv2.calcHist()</code>：计算直方图</li><li><code>cv2.equalizeHist()</code>：均衡化直方图</li></ul></li></ul><p>均衡化用来使图像的直方图分布更加均匀，提升亮度和对比度。</p><a id="more"></a><h2 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h2><p>直方图是一种分析图像的手段，简单来说就是图像中每个像素值的个数统计，比如说一副灰度图中像素值为0的有多少个，1的有多少个……直方图是一种分析图片的手段：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_understand_histogram.jpg"></p><p>在计算直方图之前，有几个术语先来了解一下：</p><ul><li>dims：要计算的通道数，对于灰度图dims=1，普通彩色图dims=3</li><li>range：要计算的像素值范围，一般为[0,256)</li><li>bins：子区段数目，如果我们统计0~255每个像素值，bins=256；如果划分区间，比如0~15, 16~31…240~255这样16个区间，bins=16</li></ul><h2 id="计算直方图"><a href="#计算直方图" class="headerlink" title="计算直方图"></a>计算直方图</h2><p>OpenCV和Numpy中都提供了计算直方图的函数，我们对比下它们的性能。</p><h3 id="OpenCV中直方图计算"><a href="#OpenCV中直方图计算" class="headerlink" title="OpenCV中直方图计算"></a>OpenCV中直方图计算</h3><p>使用<code>cv2.calcHist(images, channels, mask, histSize, ranges)</code>计算，其中：</p><ul><li>参数1：要计算的原图，以方括号的传入，如：[img]</li><li>参数2：类似前面提到的dims，灰度图写[0]就行，彩色图B/G/R分别传入[0]/[1]/[2]</li><li>参数3：要计算的区域，计算整幅图的话，写None</li><li>参数4：前面提到的bins</li><li>参数5：前面提到的range</li></ul><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>img = cv2.imread(<span class="hljs-string">'hist.jpg'</span>, <span class="hljs-number">0</span>)<br>hist = cv2.calcHist([img], [<span class="hljs-number">0</span>], <span class="hljs-literal">None</span>, [<span class="hljs-number">256</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">256</span>])  <span class="hljs-comment"># 性能：0.025288 s</span><br></code></pre></td></tr></table></figure><h3 id="Numpy中直方图计算"><a href="#Numpy中直方图计算" class="headerlink" title="Numpy中直方图计算"></a>Numpy中直方图计算</h3><p>也可用Numpy的函数计算，其中<a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ravel.html" target="_blank" rel="noopener">ravel()</a>函数将二维矩阵展平变成一维数组，之前有提到过：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">hist, bins = np.histogram(img.ravel(), <span class="hljs-number">256</span>, [<span class="hljs-number">0</span>, <span class="hljs-number">256</span>])  <span class="hljs-comment"># 性能：0.020628 s</span><br></code></pre></td></tr></table></figure><blockquote><p>经验之谈：Numpy中还有一种更高效的方式：（还记得怎么评估性能吗：<a href="[http://huris.xyz/2019/08/13/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%871%EF%BC%9A%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/](http://huris.xyz/2019/08/13/Python-OpenCV教程番外篇1：代码性能优化/">番外篇：代码性能优化</a>)）</p></blockquote><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">hist = np.bincount(img.ravel(), minlength=<span class="hljs-number">256</span>)  <span class="hljs-comment"># 性能：0.003163 s</span><br></code></pre></td></tr></table></figure><h2 id="绘制直方图"><a href="#绘制直方图" class="headerlink" title="绘制直方图"></a>绘制直方图</h2><p>其实Matplotlib自带了一个计算并绘制直方图的功能，不需要用到上面的函数：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.hist(img.ravel(), <span class="hljs-number">256</span>, [<span class="hljs-number">0</span>, <span class="hljs-number">256</span>])<br>plt.show()<br></code></pre></td></tr></table></figure><p>当然，也可以用前面计算出来的结果绘制：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.plot(hist)<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_calc_draw_histogram.jpg"></p><p>从直方图上可以看到图片的大部分区域集中在150偏白的附近，这其实并不是很好的效果，下面我们来看看如何改善它。</p><blockquote><p>使用OpenCV的画线功能也可以画直方图，不过太麻烦了，有兴趣的可以看下官方示例：<a href="https://github.com/opencv/opencv/blob/master/samples/python/hist.py" target="_blank" rel="noopener">hist.py</a>。</p></blockquote><h2 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h2><p>一副效果好的图像通常在直方图上的分布比较均匀，直方图均衡化就是用来改善图像的全局亮度和对比度。其实从观感上就可以发现，前面那幅图对比度不高，偏灰白。对均衡化算法感兴趣的同学可参考：<a href="https://zh.wikipedia.org/wiki/直方图均衡化" target="_blank" rel="noopener">维基百科：直方图均衡化</a></p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_understand_histogram_equalization.jpg"></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">equ = cv2.equalizeHist(img)<br></code></pre></td></tr></table></figure><p>OpenCV中用<code>cv2.equalizeHist()</code>实现均衡化。我们把两张图片并排显示，对比一下：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">cv2.imshow(<span class="hljs-string">'equalization'</span>, np.hstack((img, equ)))  <span class="hljs-comment"># 并排显示</span><br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_before_after_equalization.jpg"></p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_before_after_equalization_histogram.jpg"></p><p>可以看到均衡化后图片的亮度和对比度效果明显好于原图。</p><h2 id="自适应均衡化"><a href="#自适应均衡化" class="headerlink" title="自适应均衡化"></a>自适应均衡化</h2><p>不难看出来，直方图均衡化是应用于整幅图片的，会有什么问题呢？看下图：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_understand_adaptive_histogram.jpg"></p><p>很明显，因为全局调整亮度和对比度的原因，脸部太亮，大部分细节都丢失了。</p><p>自适应均衡化就是用来解决这一问题的：它在每一个小区域内（默认8×8）进行直方图均衡化。</p><p>当然，如果有噪点的话，噪点会被放大，需要对小区域内的对比度进行了限制，所以这个算法全称叫：<strong>对比度受限的自适应直方图均衡化</strong>CLAHE(<a href="https://en.wikipedia.org/wiki/Adaptive_histogram_equalization" target="_blank" rel="noopener">Contrast Limited Adaptive Histogram Equalization</a>)。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 自适应均衡化，参数可选</span><br>clahe = cv2.createCLAHE(clipLimit=<span class="hljs-number">2.0</span>, tileGridSize=(<span class="hljs-number">8</span>, <span class="hljs-number">8</span>))<br>cl1 = clahe.apply(img)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_adaptive_histogram.jpg"></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p><code>cv2.calcHist()</code>函数中的参数3是指要计算的区域(mask：目标区域白色，其余黑色)，编写一个只计算图片左上角200×200区域直方图的程序。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_histogram_mask.jpg"></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>img = cv2.imread(<span class="hljs-string">'hist.jpg'</span>, <span class="hljs-number">0</span>)<br><span class="hljs-comment"># 只计算左上角200*200的区域</span><br>mask = np.zeros(img.shape, dtype=np.uint8)<br>mask[:<span class="hljs-number">200</span>, :<span class="hljs-number">200</span>] = <span class="hljs-number">255</span><br><br>hist_mask = cv2.calcHist([img], [<span class="hljs-number">0</span>], mask, [<span class="hljs-number">256</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">256</span>])<br><br>plt.plot(hist_mask)<br>plt.show()<br></code></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_histograms/py_histogram_begins/py_histogram_begins.html#histograms-getting-started" target="_blank" rel="noopener">Histograms - 1 : Find, Plot, Analyze !!!</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_histograms/py_histogram_equalization/py_histogram_equalization.html#histogram-equalization" target="_blank" rel="noopener">Histograms - 2: Histogram Equalization</a></li><li><a href="https://zh.wikipedia.org/wiki/直方图均衡化" target="_blank" rel="noopener">维基百科：直方图均衡化</a></li><li><a href="https://en.wikipedia.org/wiki/Adaptive_histogram_equalization" target="_blank" rel="noopener">维基百科：自适应直方图均衡化</a></li><li><a href="http://www.cambridgeincolour.com/tutorials/histograms1.htm" target="_blank" rel="noopener">Cambridge in Color website</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 直方图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程14：轮廓特征</title>
      <link href="/2019/08/15/Python-OpenCV%E6%95%99%E7%A8%8B14%EF%BC%9A%E8%BD%AE%E5%BB%93%E7%89%B9%E5%BE%81/"/>
      <url>/2019/08/15/Python-OpenCV%E6%95%99%E7%A8%8B14%EF%BC%9A%E8%BD%AE%E5%BB%93%E7%89%B9%E5%BE%81/</url>
      
        <content type="html"><![CDATA[<p>学习计算轮廓特征，如面积、周长、最小外接矩形等。</p><p>目标：</p><ul><li>计算物体的周长、面积、质心、最小外接矩形等</li><li>OpenCV函数：<ul><li><code>cv2.contourArea()</code>：面积</li><li><code>cv2.arcLength()</code>：周长</li><li><code>cv2.boundingRect()</code>：外接矩</li><li><code>cv2.minAreaRect()</code>：最小外接矩</li><li><code>cv2.minEnclosingCircle()</code>：最小外接圆</li><li><code>cv2.matchShapes()</code>：进行形状匹配</li></ul></li></ul><a id="more"></a><h2 id="轮廓特征"><a href="#轮廓特征" class="headerlink" title="轮廓特征"></a>轮廓特征</h2><p>在计算轮廓特征之前，我们先用上一节的代码把轮廓找到：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_31_handwriting_sample.jpg"></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>img = cv2.imread(<span class="hljs-string">'handwriting.jpg'</span>, <span class="hljs-number">0</span>)<br>_, thresh = cv2.threshold(img, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)<br>image, contours, hierarchy = cv2.findContours(thresh, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 以数字3的轮廓为例</span><br>cnt = contours[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>为了便于绘制，我们创建出两幅彩色图，并把轮廓画在第一幅图上：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">img_color1 = cv2.cvtColor(image, cv2.COLOR_GRAY2BGR)<br>img_color2 = np.copy(img_color1)<br>cv2.drawContours(img_color1, [cnt], <span class="hljs-number">0</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h3 id="轮廓面积"><a href="#轮廓面积" class="headerlink" title="轮廓面积"></a>轮廓面积</h3><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">area = cv2.contourArea(cnt)  <span class="hljs-comment"># 4386.5</span><br></code></pre></td></tr></table></figure><p>注意轮廓特征计算的结果并不等同于像素点的个数，而是根据几何方法算出来的，所以有小数。</p><blockquote><p>如果统计二值图中像素点个数，应尽量避免循环，<strong>可以使用<code>cv2.countNonZero()</code></strong>，更加高效。</p></blockquote><h3 id="轮廓周长"><a href="#轮廓周长" class="headerlink" title="轮廓周长"></a>轮廓周长</h3><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">perimeter = cv2.arcLength(cnt, <span class="hljs-literal">True</span>)  <span class="hljs-comment"># 585.7</span><br></code></pre></td></tr></table></figure><p>参数2表示轮廓是否封闭，显然我们的轮廓是封闭的，所以是True。</p><h3 id="图像矩"><a href="#图像矩" class="headerlink" title="图像矩"></a>图像矩</h3><p>矩可以理解为图像的各类几何特征，详情请参考：[<a href="http://en.wikipedia.org/wiki/Image_moment" target="_blank" rel="noopener">Image Moments</a>]</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">M = cv2.moments(cnt)<br></code></pre></td></tr></table></figure><p>M中包含了很多轮廓的特征信息，比如M[‘m00’]表示轮廓面积，与前面<code>cv2.contourArea()</code>计算结果是一样的。</p><p>质心也可以用它来算：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">cx, cy = M[<span class="hljs-string">'m10'</span>] / M[<span class="hljs-string">'m00'</span>], M[<span class="hljs-string">'m01'</span>] / M[<span class="hljs-string">'m00'</span>]  <span class="hljs-comment"># (205, 281)</span><br></code></pre></td></tr></table></figure><h3 id="外接矩形"><a href="#外接矩形" class="headerlink" title="外接矩形"></a>外接矩形</h3><p>形状的外接矩形有两种，如下图，绿色的叫外接矩形，表示不考虑旋转并且能包含整个轮廓的矩形。蓝色的叫最小外接矩，考虑了旋转：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_min_rect_rect_bounding.jpg"></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">x, y, w, h = cv2.boundingRect(cnt)  <span class="hljs-comment"># 外接矩形</span><br>cv2.rectangle(img_color1, (x, y), (x + w, y + h), (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>), <span class="hljs-number">2</span>)<br><br>rect = cv2.minAreaRect(cnt)  <span class="hljs-comment"># 最小外接矩形</span><br>box = np.int0(cv2.boxPoints(rect))  <span class="hljs-comment"># 矩形的四个角点取整</span><br>cv2.drawContours(img_color1, [box], <span class="hljs-number">0</span>, (<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>其中<code>np.int0(x)</code>是把x取整的操作，比如377.93就会变成377，也可以用<code>x.astype(np.int)</code>。</p><h3 id="最小外接圆"><a href="#最小外接圆" class="headerlink" title="最小外接圆"></a>最小外接圆</h3><p>外接圆跟外接矩形一样，找到一个能包围物体的最小圆：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">`(x, y), radius = cv2.minEnclosingCircle(cnt)(x, y, radius) = np.int0((x, y, radius))  <span class="hljs-comment"># 圆心和半径取整cv2.circle(img_color2, (x, y), radius, (0, 0, 255), 2)`</span><br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_min_enclosing_circle.jpg"></p><h3 id="拟合椭圆"><a href="#拟合椭圆" class="headerlink" title="拟合椭圆"></a>拟合椭圆</h3><p>我们可以用得到的轮廓拟合出一个椭圆：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ellipse = cv2.fitEllipse(cnt)<br>cv2.ellipse(img_color2, ellipse, (<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>), <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_fitting_ellipse.jpg"></p><h3 id="形状匹配"><a href="#形状匹配" class="headerlink" title="形状匹配"></a>形状匹配</h3><p><code>cv2.matchShapes()</code>可以检测两个形状之间的相似度，返回<strong>值越小，越相似</strong>。先读入下面这张图片：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_match_shape_shapes.jpg"></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">img = cv2.imread(<span class="hljs-string">'shapes.jpg'</span>, <span class="hljs-number">0</span>)<br>_, thresh = cv2.threshold(img, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)<br>contours, hierarchy = cv2.findContours(thresh, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>)<br>img_color = cv2.cvtColor(thresh, cv2.COLOR_GRAY2BGR)  <span class="hljs-comment"># 用于绘制的彩色图</span><br></code></pre></td></tr></table></figure><p>图中有3条轮廓，我们用A/B/C表示：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">cnt_a, cnt_b, cnt_c = contours[<span class="hljs-number">0</span>], contours[<span class="hljs-number">1</span>], contours[<span class="hljs-number">2</span>]<br>print(cv2.matchShapes(cnt_b, cnt_b, <span class="hljs-number">1</span>, <span class="hljs-number">0.0</span>))  <span class="hljs-comment"># 0.0</span><br>print(cv2.matchShapes(cnt_b, cnt_c, <span class="hljs-number">1</span>, <span class="hljs-number">0.0</span>))  <span class="hljs-comment"># 2.17e-05</span><br>print(cv2.matchShapes(cnt_b, cnt_a, <span class="hljs-number">1</span>, <span class="hljs-number">0.0</span>))  <span class="hljs-comment"># 0.418</span><br></code></pre></td></tr></table></figure><p>可以看到BC相似程度比AB高很多，并且图形的旋转或缩放并没有影响。其中，参数3是匹配方法，详情可参考：<a href="https://docs.opencv.org/4.0.0/d3/dc0/group__imgproc__shape.html#gaf2b97a230b51856d09a2d934b78c015f" target="_blank" rel="noopener">ShapeMatchModes</a>，参数4是OpenCV的预留参数，暂时没有实现，可以不用理会。</p><p>形状匹配是通过图像的Hu矩来实现的(<code>cv2.HuMoments()</code>)，大家如果感兴趣，可以参考：<a href="http://en.wikipedia.org/wiki/Image_moment#Rotation_invariant_moments" target="_blank" rel="noopener">Hu-Moments</a></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol><li>前面我们是对图片中的数字3进行轮廓特征计算的，大家换成数字1看看。</li></ol><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 载入手写数字图片</span><br>img = cv2.imread(<span class="hljs-string">'handwriting.jpg'</span>, <span class="hljs-number">0</span>)<br>_, thresh = cv2.threshold(img, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)<br>contours, hierarchy = cv2.findContours(thresh, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 创建出两幅彩色图用于绘制</span><br>img_color1 = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)<br>img_color2 = np.copy(img_color1)<br><br><span class="hljs-comment"># 计算数字1的轮廓特征</span><br>cnt = contours[<span class="hljs-number">1</span>]<br>cv2.drawContours(img_color1, [cnt], <span class="hljs-number">0</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 1.轮廓面积</span><br>area = cv2.contourArea(cnt)  <span class="hljs-comment"># 6289.5</span><br>print(area)<br><br><br><span class="hljs-comment"># 2.轮廓周长</span><br>perimeter = cv2.arcLength(cnt, <span class="hljs-literal">True</span>)  <span class="hljs-comment"># 527.4041</span><br>print(perimeter)<br><br><br><span class="hljs-comment"># 3.图像矩</span><br>M = cv2.moments(cnt)<br>print(M)<br>print(M[<span class="hljs-string">'m00'</span>])  <span class="hljs-comment"># 同前面的面积：6289.5</span><br>cx, cy = M[<span class="hljs-string">'m10'</span>] / M[<span class="hljs-string">'m00'</span>], M[<span class="hljs-string">'m01'</span>] / M[<span class="hljs-string">'m00'</span>]  <span class="hljs-comment"># 质心</span><br>print(cx, cy)<br><br><span class="hljs-comment"># 4.图像外接矩形和最小外接矩形</span><br>x, y, w, h = cv2.boundingRect(cnt)  <span class="hljs-comment"># 外接矩形</span><br>cv2.rectangle(img_color1, (x, y), (x + w, y + h), (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>), <span class="hljs-number">2</span>)<br><br>rect = cv2.minAreaRect(cnt)  <span class="hljs-comment"># 最小外接矩形</span><br>box = np.int0(cv2.boxPoints(rect))  <span class="hljs-comment"># 矩形的四个角点并取整</span><br>cv2.drawContours(img_color1, [box], <span class="hljs-number">0</span>, (<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">2</span>)<br><br>cv2.imshow(<span class="hljs-string">'contours'</span>, img_color1)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br><br><br><span class="hljs-comment"># 5.最小外接圆</span><br>(x, y), radius = cv2.minEnclosingCircle(cnt)<br>(x, y, radius) = map(int, (x, y, radius))  <span class="hljs-comment"># 这也是取整的一种方式噢</span><br>cv2.circle(img_color2, (x, y), radius, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">2</span>)<br><br><br><span class="hljs-comment"># 6.拟合椭圆</span><br>ellipse = cv2.fitEllipse(cnt)<br>cv2.ellipse(img_color2, ellipse, (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>), <span class="hljs-number">2</span>)<br><br>cv2.imshow(<span class="hljs-string">'contours2'</span>, img_color2)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><ol><li>用形状匹配比较两个字母或数字（这相当于很简单的一个<a href="https://baike.baidu.com/item/光学字符识别/4162921?fr=aladdin&amp;fromid=25995&amp;fromtitle=OCR" target="_blank" rel="noopener">OCR</a>噢）。</li></ol><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br><span class="hljs-comment"># 载入原图</span><br>img = cv2.imread(<span class="hljs-string">'abc.jpg'</span>, <span class="hljs-number">0</span>)<br>_, thresh = cv2.threshold(img, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)<br>contours, hierarchy = cv2.findContours(thresh, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>)<br><span class="hljs-comment"># 找到ABC的轮廓</span><br>b, c, a = contours[<span class="hljs-number">0</span>], contours[<span class="hljs-number">3</span>], contours[<span class="hljs-number">4</span>]<br><br><span class="hljs-comment"># 载入标准模板图</span><br>img_a = cv2.imread(<span class="hljs-string">'template_a.jpg'</span>, <span class="hljs-number">0</span>)<br>_, th = cv2.threshold(img_a, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)<br>contours, hierarchy = cv2.findContours(th, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>)<br><span class="hljs-comment"># 字母A的轮廓</span><br>template_a = contours[<span class="hljs-number">0</span>]<br><br>print(cv2.matchShapes(a, template_a, <span class="hljs-number">1</span>, <span class="hljs-number">0.0</span>))  <span class="hljs-comment"># 0.02557(最相似)</span><br>print(cv2.matchShapes(b, template_a, <span class="hljs-number">1</span>, <span class="hljs-number">0.0</span>))  <span class="hljs-comment"># 0.80585</span><br>print(cv2.matchShapes(c, template_a, <span class="hljs-number">1</span>, <span class="hljs-number">0.0</span>))  <span class="hljs-comment"># 3.26050</span><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><ul><li><a href="https://docs.opencv.org/4.0.0/d3/dc0/group__imgproc__shape.html#ga2c759ed9f497d4a618048a2f56dc97f1" target="_blank" rel="noopener">cv2.contourArea()</a></li><li><a href="https://docs.opencv.org/4.0.0/d3/dc0/group__imgproc__shape.html#ga8d26483c636be6b35c3ec6335798a47c" target="_blank" rel="noopener">cv2.arcLength()</a></li><li><a href="https://docs.opencv.org/4.0.0/d3/dc0/group__imgproc__shape.html#ga556a180f43cab22649c23ada36a8a139" target="_blank" rel="noopener">cv2.moments()</a></li><li><a href="https://docs.opencv.org/4.0.0/d3/dc0/group__imgproc__shape.html#ga103fcbda2f540f3ef1c042d6a9b35ac7" target="_blank" rel="noopener">cv2.boundingRect()</a></li><li><a href="https://docs.opencv.org/4.0.0/d3/dc0/group__imgproc__shape.html#ga3d476a3417130ae5154aea421ca7ead9" target="_blank" rel="noopener">cv2.minAreaRect()</a></li><li><a href="https://docs.opencv.org/4.0.0/d3/dc0/group__imgproc__shape.html#ga8ce13c24081bbc7151e9326f412190f1" target="_blank" rel="noopener">cv2.minEnclosingCircle()</a></li><li><a href="https://docs.opencv.org/4.0.0/d3/dc0/group__imgproc__shape.html#gaf259efaad93098103d6c27b9e4900ffa" target="_blank" rel="noopener">cv2.fitEllipse()</a></li><li><a href="https://docs.opencv.org/4.0.0/d3/dc0/group__imgproc__shape.html#gaadc90cb16e2362c9bd6e7363e6e4c317" target="_blank" rel="noopener">cv2.matchShapes()</a></li><li><a href="https://docs.opencv.org/4.0.0/d3/dc0/group__imgproc__shape.html#gaf2b97a230b51856d09a2d934b78c015f" target="_blank" rel="noopener">cv2.ShapeMatchModes</a></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contour_features/py_contour_features.html" target="_blank" rel="noopener">Contour Features</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contours_more_functions/py_contours_more_functions.html" target="_blank" rel="noopener">Contours : More Functions</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 轮廓 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程番外篇11：凸包及更多轮廓特征</title>
      <link href="/2019/08/15/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%8711%EF%BC%9A%E5%87%B8%E5%8C%85%E5%8F%8A%E6%9B%B4%E5%A4%9A%E8%BD%AE%E5%BB%93%E7%89%B9%E5%BE%81/"/>
      <url>/2019/08/15/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%8711%EF%BC%9A%E5%87%B8%E5%8C%85%E5%8F%8A%E6%9B%B4%E5%A4%9A%E8%BD%AE%E5%BB%93%E7%89%B9%E5%BE%81/</url>
      
        <content type="html"><![CDATA[<p>计算凸包及更多轮廓特征。</p><a id="more"></a><h2 id="多边形逼近"><a href="#多边形逼近" class="headerlink" title="多边形逼近"></a>多边形逼近</h2><p>前面我们学习过最小外接矩和最小外接圆，那么可以用一个最小的多边形包围物体吗？当然可以：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 多边形逼近</span><br><span class="hljs-comment"># 1.先找到轮廓</span><br>img = cv2.imread(<span class="hljs-string">'unregular.jpg'</span>, <span class="hljs-number">0</span>)<br>_, thresh = cv2.threshold(img, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)<br>contours, hierarchy = cv2.findContours(thresh, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>)<br>cnt = contours[<span class="hljs-number">0</span>]<br><br><span class="hljs-comment"># 2.进行多边形逼近，得到多边形的角点</span><br>approx = cv2.approxPolyDP(cnt, <span class="hljs-number">3</span>, <span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 3.画出多边形</span><br>image = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)<br>cv2.polylines(image, [approx], <span class="hljs-literal">True</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>), <span class="hljs-number">2</span>)<br>print(len(approx))  <span class="hljs-comment"># 角点的个数</span><br>cv2.imshow(<span class="hljs-string">'approxPloyDP'</span>, image)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>其中<code>cv2.approxPolyDP()</code>的参数2(epsilon)是一个距离值，表示多边形的轮廓接近实际轮廓的程度，值越小，越精确；参数3表示是否闭合。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_understand_approxpoly.jpg"></p><h2 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h2><p><a href="https://baike.baidu.com/item/凸包/179150?fr=aladdin" target="_blank" rel="noopener">凸包</a>跟多边形逼近很像，只不过它是物体最外层的”凸”多边形：集合A内连接任意两个点的直线都在A的内部，则称集合A是凸形的。</p><p>如下图，红色的部分为手掌的凸包，双箭头部分表示凸缺陷(Convexity Defects)，凸缺陷常用来进行手势识别等：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_understand_convex.jpg"></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 凸包</span><br><span class="hljs-comment"># 1.先找到轮廓</span><br>img = cv2.imread(<span class="hljs-string">'convex.jpg'</span>, <span class="hljs-number">0</span>)<br>_, thresh = cv2.threshold(img, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)<br>contours, hierarchy = cv2.findContours(thresh, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>)<br>cnt = contours[<span class="hljs-number">0</span>]<br><br><span class="hljs-comment"># 2.寻找凸包，得到凸包的角点</span><br>hull = cv2.convexHull(cnt)<br><br><span class="hljs-comment"># 3.绘制凸包</span><br>image = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)<br>cv2.polylines(image, [hull], <span class="hljs-literal">True</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>), <span class="hljs-number">2</span>)<br>cv2.imshow(<span class="hljs-string">'convex hull'</span>, image)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_convex_hull.jpg"></p><p>其中函数<code>cv2.convexHull()</code>有个可选参数returnPoints，默认是True，代表返回角点的x/y坐标；如果为False的话，表示返回轮廓中是凸包角点的索引，比如说：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">print(hull[<span class="hljs-number">0</span>])  <span class="hljs-comment"># [[362 184]]（坐标）</span><br>hull2 = cv2.convexHull(cnt, returnPoints=<span class="hljs-literal">False</span>)<br>print(hull2[<span class="hljs-number">0</span>])  <span class="hljs-comment"># [510]（cnt中的索引）</span><br>print(cnt[<span class="hljs-number">510</span>])  <span class="hljs-comment"># [[362 184]]</span><br></code></pre></td></tr></table></figure><p>当使用<code>cv2.convexityDefects()</code>计算凸包缺陷时，returnPoints需为False，详情可参考：<a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contours_more_functions/py_contours_more_functions.html#contours-more-functions" target="_blank" rel="noopener">Convexity Defects</a></p><p>另外可以用下面的语句来判断轮廓是否是凸形的：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">print(cv2.isContourConvex(hull))  <span class="hljs-comment"># True</span><br></code></pre></td></tr></table></figure><h2 id="点到轮廓的"><a href="#点到轮廓的" class="headerlink" title="点到轮廓的"></a>点到轮廓的</h2><p><code>cv2.pointPolygonTest()</code>函数计算点到轮廓的最短距离（也就是垂线），又称多边形测试：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">dist = cv2.pointPolygonTest(cnt, (<span class="hljs-number">100</span>, <span class="hljs-number">100</span>), <span class="hljs-literal">True</span>)  <span class="hljs-comment"># -3.53</span><br></code></pre></td></tr></table></figure><p>其中参数3为True时表示计算距离值：点在轮廓外面值为负，点在轮廓上值为0，点在轮廓里面值为正；参数3为False时，只返回-1/0/1表示点相对轮廓的位置，不计算距离。</p><p>更多轮廓特征，如当量直径、平均强度等，我目前也没用到过，以后用到再写吧，感兴趣的可以参看：<a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contour_properties/py_contour_properties.html" target="_blank" rel="noopener">Contour Properties</a>、<a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contours_hierarchy/py_contours_hierarchy.html" target="_blank" rel="noopener">Contours Hierarchy</a></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contours_more_functions/py_contours_more_functions.html#contours-more-functions" target="_blank" rel="noopener">Convexity Defects</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contour_properties/py_contour_properties.html" target="_blank" rel="noopener">Contour Properties</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contours_hierarchy/py_contours_hierarchy.html" target="_blank" rel="noopener">Contours Hierarchy</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程番外篇10：轮廓层级</title>
      <link href="/2019/08/15/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%8710%EF%BC%9A%E8%BD%AE%E5%BB%93%E5%B1%82%E7%BA%A7/"/>
      <url>/2019/08/15/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%8710%EF%BC%9A%E8%BD%AE%E5%BB%93%E5%B1%82%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<p>了解轮廓间的层级关系。</p><p>前面我们使用<code>cv2.findContours()</code>寻找轮廓时，参数3表示轮廓的寻找方式(RetrievalModes)，当时我们传入的是cv2.RETR_TREE，它表示什么意思呢？另外，函数返回值hierarchy有什么用途呢？</p><p>下面我们就来研究下这两个问题。</p><a id="more"></a><h2 id="理解轮廓层级"><a href="#理解轮廓层级" class="headerlink" title="理解轮廓层级"></a>理解轮廓层级</h2><p>很多情况下，图像中的形状之间是有关联的，比如说下图：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_understand_hierarchy.jpg"></p><p>图中总共有8条轮廓，2和2a分别表示外层和里层的轮廓，3和3a也是一样。从图中看得出来：</p><ul><li>轮廓0/1/2是最外层的轮廓，我们可以说它们处于同一轮廓等级：0级</li><li>轮廓2a是轮廓2的子轮廓，反过来说2是2a的父轮廓，轮廓2a算一个等级：1级</li><li>同样3是2a的子轮廓，轮廓3处于一个等级：2级</li><li>类似的，3a是3的子轮廓，等等…………</li></ul><p>这里面OpenCV关注的就是两个概念：同一轮廓等级和轮廓间的子属关系。</p><h2 id="OpenCV中轮廓等级的表示"><a href="#OpenCV中轮廓等级的表示" class="headerlink" title="OpenCV中轮廓等级的表示"></a>OpenCV中轮廓等级的表示</h2><p>如果我们打印出<code>cv2.findContours()</code>函数的返回值hierarchy，会发现它是一个包含4个值的数组：<strong>[Next, Previous, First Child, Parent]</strong></p><ul><li><em>Next：与当前轮廓处于同一层级的下一条轮廓</em></li></ul><p>举例来说，前面图中跟0处于同一层级的下一条轮廓是1，所以Next=1；同理，对轮廓1来说，Next=2；那么对于轮廓2呢？没有与它同一层级的下一条轮廓了，此时Next=-1。</p><ul><li><em>Previous：与当前轮廓处于同一层级的上一条轮廓</em></li></ul><p>跟前面一样，对于轮廓1来说，Previous=0；对于轮廓2，Previous=1；对于轮廓1，没有上一条轮廓了，所以Previous=-1。</p><ul><li><em>First Child：当前轮廓的第一条子轮廓</em></li></ul><p>比如对于轮廓2，第一条子轮廓就是轮廓2a，所以First Child=2a；对轮廓3a，First Child=4。</p><ul><li><em>Parent：当前轮廓的父轮廓</em></li></ul><p>比如2a的父轮廓是2，Parent=2；轮廓2没有父轮廓，所以Parent=-1。</p><p>下面我们通过代码验证一下：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br><span class="hljs-comment"># 1.读入图片</span><br>img = cv2.imread(<span class="hljs-string">'hierarchy.jpg'</span>)<br>img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br>_, thresh = cv2.threshold(img_gray, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)<br><br><span class="hljs-comment"># 2.寻找轮廓</span><br>contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, <span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 3.绘制轮廓</span><br>print(len(contours),hierarchy)  <span class="hljs-comment"># 8条</span><br>cv2.drawContours(img, contours, <span class="hljs-number">-1</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><blockquote><p>经验之谈：OpenCV中找到的轮廓序号跟前面讲的不同噢，如下图：</p></blockquote><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_hierarchy_RETR_TREE.jpg"></p><p>现在既然我们了解了层级的概念，那么类似cv2.RETR_TREE的轮廓寻找方式又是啥意思呢？</p><h2 id="轮廓寻找方式"><a href="#轮廓寻找方式" class="headerlink" title="轮廓寻找方式"></a>轮廓寻找方式</h2><p>OpenCV中有四种轮廓寻找方式<a href="https://docs.opencv.org/3.3.1/d3/dc0/group__imgproc__shape.html#ga819779b9857cc2f8601e6526a3a5bc71" target="_blank" rel="noopener">RetrievalModes</a>，下面分别来看下：</p><h3 id="RETR-LIST"><a href="#RETR-LIST" class="headerlink" title="RETR_LIST"></a>RETR_LIST</h3><p>这是最简单的一种寻找方式，它不建立轮廓间的子属关系，也就是所有轮廓都属于同一层级。</p><p>这样，hierarchy中的后两个值[First Child, Parent]都为-1。</p><p>比如同样的图，我们使用cv2.RETR_LIST来寻找轮廓：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">_, hierarchy = cv2.findContours(thresh, cv2.RETR_LIST, <span class="hljs-number">2</span>)<br>print(hierarchy)<br><span class="hljs-comment"># 结果如下</span><br>[[[ <span class="hljs-number">1</span> <span class="hljs-number">-1</span> <span class="hljs-number">-1</span> <span class="hljs-number">-1</span>]<br>  [ <span class="hljs-number">2</span>  <span class="hljs-number">0</span> <span class="hljs-number">-1</span> <span class="hljs-number">-1</span>]<br>  [ <span class="hljs-number">3</span>  <span class="hljs-number">1</span> <span class="hljs-number">-1</span> <span class="hljs-number">-1</span>]<br>  [ <span class="hljs-number">4</span>  <span class="hljs-number">2</span> <span class="hljs-number">-1</span> <span class="hljs-number">-1</span>]<br>  [ <span class="hljs-number">5</span>  <span class="hljs-number">3</span> <span class="hljs-number">-1</span> <span class="hljs-number">-1</span>]<br>  [ <span class="hljs-number">6</span>  <span class="hljs-number">4</span> <span class="hljs-number">-1</span> <span class="hljs-number">-1</span>]<br>  [ <span class="hljs-number">7</span>  <span class="hljs-number">5</span> <span class="hljs-number">-1</span> <span class="hljs-number">-1</span>]<br>  [<span class="hljs-number">-1</span>  <span class="hljs-number">6</span> <span class="hljs-number">-1</span> <span class="hljs-number">-1</span>]]]<br></code></pre></td></tr></table></figure><p>因为没有从属关系，所以轮廓0的下一条是1，1的下一条是2……</p><blockquote><p>经验之谈：如果你不需要轮廓层级信息的话，cv2.RETR_LIST更推荐使用，因为性能更好。</p></blockquote><h3 id="RETR-TREE"><a href="#RETR-TREE" class="headerlink" title="RETR_TREE"></a>RETR_TREE</h3><blockquote><p>注意：使用这个参数找到的轮廓序号与之前不同。</p></blockquote><p>图中括号里面1代表外层轮廓，2代表里层轮廓。比如说对于轮廓2，Next就是4，Previous是1，它有里层的轮廓3，所以First Child=3，但因为只有两个层级，它本身就是外层轮廓，所以Parent=-1。大家可以针对其他的轮廓自己验证一下。</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>如下图，找到3个圆环的内环，然后填充成(180,215,215)这种颜色：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_hierarchy_fill_holes.jpg"></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 1.读入圆环</span><br>img = cv2.imread(<span class="hljs-string">'circle_ring.jpg'</span>)<br>img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br>_, thresh = cv2.threshold(<br>    img_gray, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)<br><br><span class="hljs-comment"># 2.使用cv2.RETR_CCOMP寻找轮廓</span><br>contours, hierarchy = cv2.findContours(thresh, cv2.RETR_CCOMP, <span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 3.找到内层轮廓并填充</span><br><span class="hljs-comment"># hierarchy的形状为(1,6,4)，使用np.squeeze压缩一维数据，变成(6,4)</span><br>hierarchy = np.squeeze(hierarchy)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(contours)):<br>    <span class="hljs-comment"># 存在父轮廓，说明是里层</span><br>    <span class="hljs-keyword">if</span>(hierarchy[i][<span class="hljs-number">3</span>] != <span class="hljs-number">-1</span>):<br>        cv2.drawContours(img, contours, i, (<span class="hljs-number">180</span>, <span class="hljs-number">215</span>, <span class="hljs-number">215</span>), <span class="hljs-number">-1</span>)<br><br><span class="hljs-comment"># 4.显示结果</span><br>cv2.imshow(<span class="hljs-string">'fill'</span>, img)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contours_hierarchy/py_contours_hierarchy.html#contours-hierarchy" target="_blank" rel="noopener">Contours Hierarchy</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 轮廓层级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程13：轮廓</title>
      <link href="/2019/08/15/Python-OpenCV%E6%95%99%E7%A8%8B13%EF%BC%9A%E8%BD%AE%E5%BB%93/"/>
      <url>/2019/08/15/Python-OpenCV%E6%95%99%E7%A8%8B13%EF%BC%9A%E8%BD%AE%E5%BB%93/</url>
      
        <content type="html"><![CDATA[<p>学习如何寻找并绘制轮廓。</p><p>目标：</p><ul><li>了解轮廓的概念</li><li>寻找并绘制轮廓</li><li>OpenCV函数：<ul><li><code>cv2.findContours()</code>：寻找轮廓</li><li><code>cv2.drawContours()</code>：绘制轮廓</li></ul></li></ul><a id="more"></a><h2 id="轮廓"><a href="#轮廓" class="headerlink" title="轮廓"></a>轮廓</h2><p>轮廓是一系列相连的点组成的曲线，代表了物体的基本外形。</p><p>谈起轮廓不免想到边缘，它们确实很像。简单的说，<strong>轮廓是连续的，边缘并不全都连续</strong>（下图）。其实边缘主要是作为图像的特征使用，比如可以用边缘特征可以区分脸和手，而轮廓主要用来分析物体的形态，比如物体的周长和面积等，可以说边缘包括轮廓。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_understand_contours.jpg"></p><p>寻找轮廓的操作一般用于二值化图，所以通常会使用阈值分割或Canny边缘检测先得到二值图。</p><blockquote><p>经验之谈：<strong>寻找轮廓是针对白色物体的</strong>，一定要保证物体是白色，而背景是黑色，<strong>不然很多人在寻找轮廓时会找到图片最外面的一个框</strong>。</p></blockquote><h2 id="寻找轮廓"><a href="#寻找轮廓" class="headerlink" title="寻找轮廓"></a>寻找轮廓</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><ul><li><a href="https://docs.opencv.org/4.0.0/d3/dc0/group__imgproc__shape.html#gadf1ad6a0b82947fa1fe3c3d497f260e0" target="_blank" rel="noopener">cv2.findContours()</a></li><li><a href="https://docs.opencv.org/4.0.0/d3/dc0/group__imgproc__shape.html#ga819779b9857cc2f8601e6526a3a5bc71" target="_blank" rel="noopener">cv2.RetrievalModes</a></li><li><a href="https://docs.opencv.org/4.0.0/d3/dc0/group__imgproc__shape.html#ga4303f45752694956374734a03c54d5ff" target="_blank" rel="noopener">cv2.ContourApproximationModes</a></li><li><a href="https://docs.opencv.org/4.0.0/d6/d6e/group__imgproc__draw.html#ga746c0625f1781f1ffc9056259103edbc" target="_blank" rel="noopener">cv2.drawContours()</a></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contours_begin/py_contours_begin.html" target="_blank" rel="noopener">Contours : Getting Started</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 轮廓 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程12：腐蚀与膨胀</title>
      <link href="/2019/08/15/Python-OpenCV%E6%95%99%E7%A8%8B12%EF%BC%9A%E8%85%90%E8%9A%80%E4%B8%8E%E8%86%A8%E8%83%80/"/>
      <url>/2019/08/15/Python-OpenCV%E6%95%99%E7%A8%8B12%EF%BC%9A%E8%85%90%E8%9A%80%E4%B8%8E%E8%86%A8%E8%83%80/</url>
      
        <content type="html"><![CDATA[<p>学习常用形态学操作：腐蚀膨胀，开运算和闭运算。</p><p>目标：</p><ul><li>了解形态学操作的概念</li><li>学习膨胀、腐蚀、开运算和闭运算等形态学操作</li><li>OpenCV：<ul><li><code>cv2.erode()</code>：腐蚀函数</li><li><code>cv2.dilate()</code>：膨胀函数</li><li><code>cv2.morphologyEx()</code>：开闭运算函数</li></ul></li></ul><p>形态学操作就是改变物体的形状，如腐蚀使物体”变瘦”，膨胀使物体”变胖”</p><p>先腐蚀后膨胀会分离物体，所以叫开运算，常用来<strong>去除小区域物体</strong>。</p><p>先膨胀后腐蚀会<strong>消除物体内的小洞</strong>，所以叫闭运算。</p><p>开/闭理解了之后很容易记忆噢(⊙o⊙)。</p><a id="more"></a><h2 id="形态学操作"><a href="#形态学操作" class="headerlink" title="形态学操作"></a>形态学操作</h2><p>形态学操作其实就是<strong>改变物体的形状</strong>，比如腐蚀就是”变瘦”，膨胀就是”变胖”，看下图就明白了：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_understand_morphological.jpg"></p><blockquote><p>经验之谈：形态学操作一般作用于二值化图，来连接相邻的元素或分离成独立的元素。<strong>腐蚀和膨胀是针对图片中的白色部分！</strong></p></blockquote><h2 id="腐蚀"><a href="#腐蚀" class="headerlink" title="腐蚀"></a>腐蚀</h2><p>腐蚀的效果是把图片”变瘦”，其原理是在原图的小区域内取局部最小值。因为是二值化图，只有0和255，所以小区域内有一个是0该像素点就为0：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_understand_erosion.jpg"></p><p>这样原图中边缘地方就会变成0，达到了瘦身目的（小胖福利(●ˇ∀ˇ●)）</p><p>OpenCV中用<code>cv2.erode()</code>函数进行腐蚀，只需要指定核的大小就行：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>img = cv2.imread(<span class="hljs-string">'j.bmp'</span>, <span class="hljs-number">0</span>)<br>kernel = np.ones((<span class="hljs-number">5</span>, <span class="hljs-number">5</span>), np.uint8)<br>erosion = cv2.erode(img, kernel)  <span class="hljs-comment"># 腐蚀</span><br></code></pre></td></tr></table></figure><blockquote><p>这个核也叫结构元素，因为形态学操作其实也是应用卷积来实现的。结构元素可以是矩形/椭圆/十字形，可以用<code>cv2.getStructuringElement()</code>来生成不同形状的结构元素，比如：</p></blockquote><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (<span class="hljs-number">5</span>, <span class="hljs-number">5</span>))  <span class="hljs-comment"># 矩形结构</span><br>kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (<span class="hljs-number">5</span>, <span class="hljs-number">5</span>))  <span class="hljs-comment"># 椭圆结构</span><br>kernel = cv2.getStructuringElement(cv2.MORPH_CROSS, (<span class="hljs-number">5</span>, <span class="hljs-number">5</span>))  <span class="hljs-comment"># 十字形结构</span><br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_morphological_struct_element.jpg"></p><h2 id="膨胀"><a href="#膨胀" class="headerlink" title="膨胀"></a>膨胀</h2><p>膨胀与腐蚀相反，取的是局部最大值，效果是把图片“<strong>变胖</strong>”。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">dilation = cv2.dilate(img, kernel)  <span class="hljs-comment"># 膨胀</span><br></code></pre></td></tr></table></figure><h2 id="开闭运算"><a href="#开闭运算" class="headerlink" title="开闭运算"></a>开闭运算</h2><p>先腐蚀后膨胀叫开运算（因为先腐蚀会分开物体，这样容易记住）。</p><p>其作用是：分离物体，消除小区域。</p><p>这类形态学操作用<code>cv2.morphologyEx()</code>函数实现：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (<span class="hljs-number">5</span>, <span class="hljs-number">5</span>))  <span class="hljs-comment"># 定义结构元素</span><br>img = cv2.imread(<span class="hljs-string">'j_noise_out.bmp'</span>, <span class="hljs-number">0</span>)<br>opening = cv2.morphologyEx(img, cv2.MORPH_OPEN, kernel)  <span class="hljs-comment"># 开运算</span><br></code></pre></td></tr></table></figure><p>闭运算则相反：先膨胀后腐蚀（先膨胀会使白色的部分扩张，以至于消除/“闭合”物体里面的小黑洞，所以叫闭运算）</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">img = cv2.imread(<span class="hljs-string">'j_noise_in.bmp'</span>, <span class="hljs-number">0</span>)<br>closing = cv2.morphologyEx(img, cv2.MORPH_CLOSE, kernel)  <span class="hljs-comment"># 闭运算</span><br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_morphological_opening_closing.jpg"></p><blockquote><p>经验之谈：很多人对开闭运算的作用不是很清楚（好吧，其实是比较容易混◑﹏◐），但看上图↑，不用怕：如果我们的目标物体外面有很多无关的小区域，就用开运算去除掉；如果物体内部有很多小黑洞，就用闭运算填充掉。</p></blockquote><p>接下来的3种形态学操作并不常用，大家有兴趣可以看看（因为较短，没有做成番外篇）：</p><h2 id="其他形态学操作"><a href="#其他形态学操作" class="headerlink" title="其他形态学操作"></a>其他形态学操作</h2><h3 id="形态学梯度"><a href="#形态学梯度" class="headerlink" title="形态学梯度"></a>形态学梯度</h3><p>膨胀图减去腐蚀图，<code>dilation - erosion</code>，这样会得到物体的轮廓：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">img = cv2.imread(<span class="hljs-string">'school.bmp'</span>, <span class="hljs-number">0</span>)<br>gradient = cv2.morphologyEx(img, cv2.MORPH_GRADIENT, kernel)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_morphological_gradient.jpg"></p><h3 id="顶帽"><a href="#顶帽" class="headerlink" title="顶帽"></a>顶帽</h3><p>原图减去开运算后的图：<code>src - opening</code></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">tophat = cv2.morphologyEx(img, cv2.MORPH_TOPHAT, kernel)<br></code></pre></td></tr></table></figure><h3 id="黑帽"><a href="#黑帽" class="headerlink" title="黑帽"></a>黑帽</h3><p>闭运算后的图减去原图：<code>closing - src</code></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">blackhat = cv2.morphologyEx(img, cv2.MORPH_BLACKHAT, kernel)<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><ul><li><a href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#gaeb1e0c1033e3f6b891a25d0511362aeb" target="_blank" rel="noopener">cv2.erode()</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#gac342a1bb6eabf6f55c803b09268e36dc" target="_blank" rel="noopener">cv2.getStructuringElement()</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#ga4ff0f3318642c4f469d0e11f242f3b6c" target="_blank" rel="noopener">cv2.dilate()</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#gac2db39b56866583a95a5680313c314ad" target="_blank" rel="noopener">cv2.MorphShapes</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#ga67493776e3ad1a3df63883829375201f" target="_blank" rel="noopener">cv2.morphologyEx()</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#ga7be549266bad7b2e6a04db49827f9f32" target="_blank" rel="noopener">cv2.MorphTypes</a></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="http://homepages.inf.ed.ac.uk/rbf/HIPR2/morops.htm" target="_blank" rel="noopener">Morphological Operations</a></li><li><a href="http://szeliski.org/Book/" target="_blank" rel="noopener">Computer Vision: Algorithms and Applications</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 形态学 </tag>
            
            <tag> 腐蚀 </tag>
            
            <tag> 膨胀 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程11：边缘检测</title>
      <link href="/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B11%EF%BC%9A%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/"/>
      <url>/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B11%EF%BC%9A%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<p>学习使用Canny获取图像的边缘。</p><blockquote><p><a href="https://www.computer.org/cms/Computer.org/Transactions Home Pages/TPAMI/PDFs/top_ten_6.pdf" target="_blank" rel="noopener">Canny J . A Computational Approach To Edge Detection[J\]. IEEE Transactions on Pattern Analysis and Machine Intelligence, 1986, PAMI-8(6):679-698.</a></p></blockquote><p>目标：</p><ul><li>Canny边缘检测的简单概念</li><li>OpenCV函数：<code>cv2.Canny()</code>：进行Canny边缘检测</li></ul><a id="more"></a><h2 id="Canny边缘检测"><a href="#Canny边缘检测" class="headerlink" title="Canny边缘检测"></a>Canny边缘检测</h2><p>Canny边缘检测方法常被誉为边缘检测的最优方法，废话不多说，先看个例子：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># Canny边缘检测</span><br>img = cv2.imread(<span class="hljs-string">'handwriting.jpg'</span>, <span class="hljs-number">0</span>)<br>edges = cv2.Canny(img, <span class="hljs-number">30</span>, <span class="hljs-number">70</span>)<br><br>cv2.imshow(<span class="hljs-string">'canny'</span>, np.hstack((img, edges)))<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_canny_edge_detection.jpg"></p><p><code>cv2.Canny()</code>进行边缘检测，参数2、3表示最低、高阈值，下面来解释下具体原理。</p><blockquote><p>经验之谈：之前我们用低通滤波的方式模糊了图片，那反过来，想得到物体的边缘，就需要用到高通滤波。推荐先阅读：<a href="[http://huris.xyz/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%879%EF%BC%9A%E5%9B%BE%E5%83%8F%E6%A2%AF%E5%BA%A6/](http://huris.xyz/2019/08/14/Python-OpenCV教程番外篇9：图像梯度/">番外篇：图像梯度</a>)。</p></blockquote><p><strong>Canny边缘提取</strong>的具体步骤如下：</p><ol><li>使用5×5高斯滤波消除噪声：</li></ol><p>边缘检测本身属于锐化操作，对噪点比较敏感，所以需要进行平滑处理。</p><p>高斯滤波的具体内容参考前一篇：<a href="[http://huris.xyz/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B10%EF%BC%9A%E5%B9%B3%E6%BB%91%E5%9B%BE%E5%83%8F/](http://huris.xyz/2019/08/14/Python-OpenCV教程10：平滑图像/">平滑图像</a>)</p><script type="math/tex; mode=display">K=\frac{1}{256}\begin{bmatrix}1&4&6&4&1\\4&16&24&16&4\\6&24&36&24&6\\4&16&24&16&4\\1&4&6&4&1\end{bmatrix}</script><ol><li>计算图像梯度的方向</li></ol><p>首先使用<strong>Sobel算子</strong>计算两个方向上的梯度$G_x$和$G_y$，然后算出梯度的方向：</p><script type="math/tex; mode=display">\theta=\arctan(\frac{G_y}{G_x})</script><p>保留这四个方向的梯度：$0^{\circ}/45^{\circ}/90^{\circ}/135^{\circ}$，有什么用呢？我们接着看。</p><ol><li>取局部极大值</li></ol><p>梯度其实已经表示了轮廓，但为了进一步筛选，可以在上面的四个角度方向上再取局部极大值：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_understand_canny_direction.jpg"></p><p>比如，A点在45°方向上大于B/C点，那就保留它，把B/C设置为0。</p><ol><li>滞后阈值</li></ol><p>经过前面三步，就只剩下0和可能的边缘梯度值了，为了最终确定下来，需要设定高低阈值：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_understand_canny_max_min_val.jpg"></p><ul><li>像素点的值大于最高阈值，那肯定是边缘（上图A）</li><li>同理像素值小于最低阈值，那肯定不是边缘</li><li>像素值介于两者之间，如果与高于最高阈值的点连接，也算边缘，所以上图中C算，B不算</li></ul><p>Canny推荐的高低阈值比在2:1到3:1之间。</p><h2 id="先阈值分割后检测"><a href="#先阈值分割后检测" class="headerlink" title="先阈值分割后检测"></a>先阈值分割后检测</h2><p>其实很多情况下，阈值分割后再检测边缘，效果会更好：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 先阈值，后边缘检测</span><br><span class="hljs-comment"># 阈值分割（使用到了番外篇讲到的Otsu自动阈值）</span><br>_, thresh = cv2.threshold(img, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)<br>edges = cv2.Canny(thresh, <span class="hljs-number">30</span>, <span class="hljs-number">70</span>)<br><br>cv2.imshow(<span class="hljs-string">'canny'</span>, np.hstack((img, thresh, edges)))<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>代码中我用了<a href="[http://huris.xyz/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%874%EF%BC%9AOtsu%E9%98%88%E5%80%BC%E6%B3%95/](http://huris.xyz/2019/08/14/Python-OpenCV教程番外篇4：Otsu阈值法/">番外篇：Otsu阈值法</a>)中的自动阈值分割，如果你不太了解，大可以使用传统的方法，不过如果是下面这种图片，推荐用Otsu阈值法。</p><p>另外Python中某个值不用的话，就写个下划线’_’。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_canny_edge_detection_threshold.jpg"></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>如果你不太理解高低阈值的效果，创建两个滑动条来调节它们的值看看：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_trackbar_maxval_minval_canny.gif"></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">track_back</span><span class="hljs-params">(x)</span>:</span><br>    <span class="hljs-keyword">pass</span><br><br><br>img = cv2.imread(<span class="hljs-string">'sudoku.jpg'</span>, <span class="hljs-number">0</span>)<br>cv2.namedWindow(<span class="hljs-string">'window'</span>)<br><br><span class="hljs-comment"># 创建滑动条</span><br>cv2.createTrackbar(<span class="hljs-string">'maxVal'</span>, <span class="hljs-string">'window'</span>, <span class="hljs-number">100</span>, <span class="hljs-number">255</span>, track_back)<br>cv2.createTrackbar(<span class="hljs-string">'minVal'</span>, <span class="hljs-string">'window'</span>, <span class="hljs-number">200</span>, <span class="hljs-number">255</span>, track_back)<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment"># 获取滑动条的值</span><br>    max_val = cv2.getTrackbarPos(<span class="hljs-string">'maxVal'</span>, <span class="hljs-string">'window'</span>)<br>    min_val = cv2.getTrackbarPos(<span class="hljs-string">'minVal'</span>, <span class="hljs-string">'window'</span>)<br><br>    edges = cv2.Canny(img, min_val, max_val)<br>    cv2.imshow(<span class="hljs-string">'window'</span>, edges)<br><br>    <span class="hljs-comment"># 按下ESC键退出</span><br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">30</span>) == <span class="hljs-number">27</span>:<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><ul><li><a href="https://docs.opencv.org/4.0.0/dd/d1a/group__imgproc__feature.html#ga04723e007ed888ddf11d9ba04e2232de" target="_blank" rel="noopener">cv2.Canny()</a></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_canny/py_canny.html" target="_blank" rel="noopener">Canny Edge Detection</a></li><li><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/imgtrans/canny_detector/canny_detector.html" target="_blank" rel="noopener">Canny 边缘检测</a></li><li><a href="https://www.computer.org/cms/Computer.org/Transactions Home Pages/TPAMI/PDFs/top_ten_6.pdf" target="_blank" rel="noopener">Canny J . A Computational Approach To Edge Detection[J\]. IEEE Transactions on Pattern Analysis and Machine Intelligence, 1986, PAMI-8(6):679-698.</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 边缘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程番外篇9：图像梯度</title>
      <link href="/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%879%EF%BC%9A%E5%9B%BE%E5%83%8F%E6%A2%AF%E5%BA%A6/"/>
      <url>/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%879%EF%BC%9A%E5%9B%BE%E5%83%8F%E6%A2%AF%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>了解图像梯度和边缘检测的相关概念。</p><p>还记得前面<a href="http://ex2tron.wang/opencv-python-smoothing-images/" target="_blank" rel="noopener">平滑图像</a>中提到的滤波与模糊的区别吗？我们说低通滤波器是模糊，高通滤波器是锐化，这节我们就来看看高通滤波器。</p><a id="more"></a><h2 id="图像梯度"><a href="#图像梯度" class="headerlink" title="图像梯度"></a>图像梯度</h2><blockquote><p>如果你还记得高数中用一阶导数来求极值的话，就很容易理解了：</p><p>把图片想象成连续函数，因为边缘部分的像素值是与旁边像素明显有区别的，所以对图片局部求极值，就可以得到整幅图片的边缘信息了。不过图片是二维的离散函数，导数就变成了差分，这个差分就称为图像的梯度。</p></blockquote><p>当然，大部分人应该是早忘记高数了(￣▽￣)”，所以看不懂的话，就把上面的解释划掉，我们重新从卷积的角度来看看。</p><h3 id="垂直边缘提取"><a href="#垂直边缘提取" class="headerlink" title="垂直边缘提取"></a>垂直边缘提取</h3><p>滤波是应用卷积来实现的，卷积的关键就是卷积核，我们来考察下面这个卷积核：</p><script type="math/tex; mode=display">k1=\begin{bmatrix}-1&0&1\\-2&0&2\\-1&0&1\end{bmatrix}</script><p>这个核是用来提取图片中的垂直边缘的，怎么做到的呢？看下图：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_understand_sobel_edge_detection.jpg"></p><p>当前列左右两侧的元素进行差分，由于边缘的值明显小于（或大于）周边像素，所以边缘的差分结果会明显不同，这样就提取出了垂直边缘。</p><p>同理，把上面那个矩阵转置一下，就是提取水平边缘。</p><p>这种差分操作就称为图像的梯度计算：</p><script type="math/tex; mode=display">k2=\begin{bmatrix}-1&-2&-1\\0&0&0\\1&2&1\end{bmatrix}</script><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_horizen_vertical_edge_detection.jpg"></p><blockquote><p>还记得滤波函数<code>cv2.filter2D()</code>吗？（<a href="[http://huris.xyz/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%878%EF%BC%9A%E5%8D%B7%E7%A7%AF%E5%9F%BA%E7%A1%80-%E5%9B%BE%E7%89%87%E8%BE%B9%E6%A1%86/](http://huris.xyz/2019/08/14/Python-OpenCV教程番外篇8：卷积基础-图片边框/">番外篇：卷积基础</a>)）我们来手动实现上面的功能：</p></blockquote><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">img = cv2.imread(<span class="hljs-string">'sudoku.jpg'</span>, <span class="hljs-number">0</span>)<br><span class="hljs-comment"># 自己进行垂直边缘提取</span><br>kernel = np.array([[<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],<br>                   [<span class="hljs-number">-2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>],<br>                   [<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]], dtype=np.float32)<br>dst_v = cv2.filter2D(img, <span class="hljs-number">-1</span>, kernel)<span class="hljs-comment"># -1表示与原通道数相同</span><br><span class="hljs-comment"># 自己进行水平边缘提取</span><br>dst_h = cv2.filter2D(img, <span class="hljs-number">-1</span>, kernel.T)  <span class="hljs-comment"># -1表示与原通道数相同</span><br><span class="hljs-comment"># 横向并排对比显示</span><br>cv2.imshow(<span class="hljs-string">'edge'</span>, np.hstack((img, dst_v, dst_h)))<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h3 id="Sobel算子"><a href="#Sobel算子" class="headerlink" title="Sobel算子"></a>Sobel算子</h3><p>上面的这种差分方法就叫<a href="https://baike.baidu.com/item/Sobel算子/11000092?fr=aladdin" target="_blank" rel="noopener">Sobel算子</a>：</p><ol><li>先在<strong>垂直方向</strong>计算梯度$G_x=k_1×src$</li><li>再在<strong>水平方向</strong>计算梯度$G_y=k_2×src$</li><li>最后求出<strong>总梯度</strong>：$G=\sqrt{G_{x}^2+G_{y}^2}$</li></ol><p>我们可以把前面的代码用Sobel算子更简单地实现：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">sobelx = cv2.Sobel(img, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, ksize=<span class="hljs-number">3</span>)  <span class="hljs-comment"># 只计算x方向</span><br>sobely = cv2.Sobel(img, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, ksize=<span class="hljs-number">3</span>)  <span class="hljs-comment"># 只计算y方向</span><br></code></pre></td></tr></table></figure><blockquote><p>经验之谈：很多人疑问，Sobel算子的卷积核这几个值是怎么来的呢？事实上，并没有规定，你可以用你自己的。</p></blockquote><p>比如，最初只利用领域间的原始差值来检测边缘的<a href="https://baike.baidu.com/item/Prewitt算子/8415245?fr=aladdin" target="_blank" rel="noopener">Prewitt算子</a>：</p><script type="math/tex; mode=display">k=\begin{bmatrix}-1&0&1\\-1&0&1\\-1&0&1\end{bmatrix}</script><p>还有比Sobel更好用的<strong>Scharr算子</strong>，大家可以了解下：</p><script type="math/tex; mode=display">k=\begin{bmatrix}-3&0&3\\-10&0&10\\-3&0&3\end{bmatrix}</script><p>这些算法都是一阶边缘检测的代表，网上也有算子之间的对比资料，有兴趣的可参考引用。</p><h3 id="Laplacian算子"><a href="#Laplacian算子" class="headerlink" title="Laplacian算子"></a>Laplacian算子</h3><p>高数中用一阶导数求极值，在这些极值的地方，二阶导数为0，所以也可以通过求二阶导计算梯度：$dst=\frac{\partial^{2}{f}}{\partial{x^2}}+\frac{\partial^{2}{f}}{\partial{y^2}}$</p><p>一维的一阶和二阶差分公式分别为：</p><script type="math/tex; mode=display">\frac{\partial{f}}{\partial{x}}=f(x+1)-f(x)</script><script type="math/tex; mode=display">\frac{\partial^{2}{f}}{\partial{x}^{2}}=f(x+1)+f(x-1)-2f(x)</script><p>提取前面的系数，那么一维的Laplacian滤波核是：</p><script type="math/tex; mode=display">K=\begin{bmatrix}1&2&1\end{bmatrix}</script><p>而对于二维函数f(x,y)，两个方向的二阶差分分别是：</p><script type="math/tex; mode=display">\frac{\partial^{2}{f}}{\partial{x}^{2}}=f(x+1,y)+f(x-1,y)-2f(x,y)</script><script type="math/tex; mode=display">\frac{\partial^{2}{f}}{\partial{y}^{2}}=f(x,y+1)+f(x,y-1)-2f(x,y)</script><p>合在一起就是：</p><script type="math/tex; mode=display">\nabla^{2}f(x,y)=f(x+1,y)+f(x-1,y)+f(x,y+1)+f(x,y-1)-4f(x,y)</script><p>同样提取前面的系数，那么二维的Laplacian滤波核就是：</p><script type="math/tex; mode=display">K=\begin{bmatrix}0&1&0\\1&-4&1\\0&1&0\end{bmatrix}</script><p>这就是Laplacian算子的图像卷积模板，有些资料中在此基础上考虑斜对角情况，将卷积核拓展为：</p><script type="math/tex; mode=display">K=\begin{bmatrix}1&1&1\\1&-8&1\\1&1&1\end{bmatrix}</script><p>OpenCV中直接使用<code>cv2.Laplacian()</code>函数：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">laplacian = cv2.Laplacian(img, <span class="hljs-number">-1</span>)  <span class="hljs-comment"># 使用Laplacian算子</span><br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_laplacian.jpg"></p><p>Laplacian算子是二阶边缘检测的典型代表，一/二阶边缘检测各有优缺点，大家可自行了解。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_gradients/py_gradients.html" target="_blank" rel="noopener">Image Gradients</a></li><li><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/imgtrans/sobel_derivatives/sobel_derivatives.html#sobel-derivatives" target="_blank" rel="noopener">Sobel导数</a></li><li><a href="https://zh.wikipedia.org/wiki/边缘检测" target="_blank" rel="noopener">维基百科：边缘检测</a></li><li><a href="https://www.jianshu.com/p/2334bee37de5" target="_blank" rel="noopener">数字图像 - 边缘检测原理 - Sobel, Laplace, Canny算子</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 梯度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程10：平滑图像</title>
      <link href="/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B10%EF%BC%9A%E5%B9%B3%E6%BB%91%E5%9B%BE%E5%83%8F/"/>
      <url>/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B10%EF%BC%9A%E5%B9%B3%E6%BB%91%E5%9B%BE%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<p>学习模糊/平滑图像，消除噪点。</p><p>目标：</p><ul><li>模糊/平滑图片来消除图片噪声</li><li>OpenCV函数<ul><li><code>cv2.blur()</code>：均值滤波</li><li><code>cv2.GaussianBlur()</code>：高斯滤波</li><li><code>cv2.medianBlur()</code>：中值滤波</li><li><code>cv2.bilateralFilter()</code>：双边滤波</li></ul></li></ul><p>小结：</p><ul><li>在不知道用什么滤波器好的时候，优先高斯滤波<code>cv2.GaussianBlur()</code>，然后均值滤波<code>cv2.blur()</code>。</li><li>斑点和椒盐噪声优先使用中值滤波<code>cv2.medianBlur()</code>。</li><li>要去除噪点的同时尽可能保留更多的边缘信息，使用双边滤波<code>cv2.bilateralFilter()</code>。</li><li>线性滤波方式：均值滤波、方框滤波、高斯滤波（速度相对快）。</li><li>非线性滤波方式：中值滤波、双边滤波（速度相对慢）。</li></ul><a id="more"></a><h2 id="滤波与模糊"><a href="#滤波与模糊" class="headerlink" title="滤波与模糊"></a>滤波与模糊</h2><p>关于滤波和模糊，很多人分不清，我来给大家理理（虽说如此，我后面也会混着用,,ԾㅂԾ,,）：</p><ul><li>它们<strong>都属于卷积</strong>，<strong>不同滤波方法之间只是卷积核不同</strong>（对线性滤波而言）</li><li>低通滤波器是模糊，高通滤波器是锐化</li></ul><p><strong>低通滤波器</strong>就是允许低频信号通过，在图像中边缘和噪点都相当于高频部分，所以低通滤波器用于去除噪点、平滑和模糊图像。</p><p><strong>高通滤波器</strong>则反之，用来增强图像边缘，进行锐化处理。</p><blockquote><p>常见噪声有<a href="https://baike.baidu.com/item/椒盐噪声/3455958?fr=aladdin" target="_blank" rel="noopener">椒盐噪声</a>和<a href="https://baike.baidu.com/item/高斯噪声" target="_blank" rel="noopener">高斯噪声</a>：</p><p><strong>椒盐噪声：</strong>可以理解为斑点，随机出现在图像中的黑点或白点；</p><p><strong>高斯噪声：</strong>可以理解为拍摄图片时由于光照等原因造成的噪声。</p></blockquote><h3 id="均值滤波"><a href="#均值滤波" class="headerlink" title="均值滤波"></a>均值滤波</h3><p>均值滤波是一种最简单的滤波处理，它取的是卷积核区域内元素的均值，用<code>cv2.blur()</code>实现，如3×3的卷积核：</p><script type="math/tex; mode=display">kernel=\frac{1}{9}\begin{bmatrix}1&1&1\\1&1&1\\1&1&1\end{bmatrix}</script><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>img = cv2.imread(<span class="hljs-string">'lena.jpg'</span>)<br><span class="hljs-comment"># 均值滤波</span><br>blur = cv2.blur(img, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>))<br><br><span class="hljs-comment"># 上面的均值滤波也可以用方框滤波实现：normalize=True</span><br><span class="hljs-comment"># blur = cv2.boxFilter(img, -1, (3, 3), normalize=True)</span><br></code></pre></td></tr></table></figure><blockquote><p>所有的滤波函数都有一个可选参数borderType，这个参数就是<a href="[http://huris.xyz/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%878%EF%BC%9A%E5%8D%B7%E7%A7%AF%E5%9F%BA%E7%A1%80-%E5%9B%BE%E7%89%87%E8%BE%B9%E6%A1%86/](http://huris.xyz/2019/08/14/Python-OpenCV教程番外篇8：卷积基础-图片边框/">番外篇：卷积基础(图片边框)</a>)中所说的边框填充方式。</p></blockquote><h3 id="方框滤波"><a href="#方框滤波" class="headerlink" title="方框滤波"></a>方框滤波</h3><p>方框滤波跟均值滤波很像，如3×3的滤波核如下：</p><script type="math/tex; mode=display">kernel=a\begin{bmatrix}1&1&1\\1&1&1\\1&1&1\end{bmatrix}</script><p>用<code>cv2.boxFilter()</code>函数实现，</p><p><strong>当可选参数normalize为True的时候，方框滤波就是均值滤波，上式中的a就等于1/9；</strong></p><p><strong>当normalize为False的时候，a=1，相当于求区域内的像素和。</strong></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 前面的均值滤波也可以用方框滤波实现：normalize=True</span><br>blur = cv2.boxFilter(img, <span class="hljs-number">-1</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), normalize=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><h3 id="高斯滤波"><a href="#高斯滤波" class="headerlink" title="高斯滤波"></a>高斯滤波</h3><p>前面两种滤波方式，卷积核内的每个值都一样，也就是说图像区域中每个像素的权重也就一样。高斯滤波的卷积核权重并不相同：中间像素点权重最高，越远离中心的像素权重越小，来，数学时间( ╯□╰ )，还记得标准正态分布的曲线吗？</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_gaussian_kernel_function_theory.jpg"></p><p>显然这种处理元素间权值的方式更加合理一些。</p><p>图像是2维的，所以我们需要使用<a href="https://en.wikipedia.org/wiki/Gaussian_filter" target="_blank" rel="noopener">2维的高斯函数</a>，比如OpenCV中默认的3×3的高斯卷积核（具体原理和卷积核生成方式请参考文末的番外小篇：</p><script type="math/tex; mode=display">kernel=\begin{bmatrix}0.0625&0.125&0.0625\\0.125&0.25&0.125\\0.0625&0.125&0.0625\end{bmatrix}</script><p>OpenCV中对应函数为<code>cv2.GaussianBlur(src,ksize,sigmaX)</code>：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">img = cv2.imread(<span class="hljs-string">'gaussian_noise.bmp'</span>)<br><span class="hljs-comment"># 均值滤波vs高斯滤波</span><br>blur = cv2.blur(img, (<span class="hljs-number">5</span>, <span class="hljs-number">5</span>))  <span class="hljs-comment"># 均值滤波</span><br>gaussian = cv2.GaussianBlur(img, (<span class="hljs-number">5</span>, <span class="hljs-number">5</span>), <span class="hljs-number">1</span>)  <span class="hljs-comment"># 高斯滤波</span><br></code></pre></td></tr></table></figure><p>参数3 σx值越大，模糊效果越明显。</p><p>高斯滤波相比均值滤波效率要慢，但可以有效消除高斯噪声，能保留更多的图像细节，所以经常被称为最有用的滤波器。</p><p>均值滤波与高斯滤波的对比结果如下（均值滤波丢失的细节更多）：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_gaussian_vs_average.jpg"></p><h3 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h3><p><a href="https://baike.baidu.com/item/中值" target="_blank" rel="noopener">中值</a>又叫中位数，是所有数排序后取中间的值。中值滤波就是用区域内的中值来代替本像素值，所以那种孤立的斑点，如0或255很容易消除掉，<strong>适用于去除椒盐噪声和斑点噪声</strong>。</p><p>中值是一种非线性操作，效率相比前面几种线性滤波要慢。</p><p>比如下面这张斑点噪声图，用中值滤波显然更好：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">img = cv2.imread(<span class="hljs-string">'salt_noise.bmp'</span>, <span class="hljs-number">0</span>)<br><span class="hljs-comment"># 均值滤波vs中值滤波</span><br>blur = cv2.blur(img, (<span class="hljs-number">5</span>, <span class="hljs-number">5</span>))  <span class="hljs-comment"># 均值滤波</span><br>median = cv2.medianBlur(img, <span class="hljs-number">5</span>)  <span class="hljs-comment"># 中值滤波</span><br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_median_vs_average.jpg"></p><h3 id="双边滤波"><a href="#双边滤波" class="headerlink" title="双边滤波"></a>双边滤波</h3><p>模糊操作基本都会损失掉图像细节信息，尤其前面介绍的线性滤波器，图像的边缘信息很难保留下来。</p><p>然而，边缘（edge）信息是图像中很重要的一个特征，所以这才有了<a href="https://baike.baidu.com/item/双边滤波" target="_blank" rel="noopener">双边滤波</a>。</p><p>用<code>cv2.bilateralFilter()</code>函数实现：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">img = cv2.imread(<span class="hljs-string">'lena.jpg'</span>)<br><span class="hljs-comment"># 双边滤波vs高斯滤波</span><br>gau = cv2.GaussianBlur(img, (<span class="hljs-number">5</span>, <span class="hljs-number">5</span>), <span class="hljs-number">0</span>)  <span class="hljs-comment"># 高斯滤波</span><br>blur = cv2.bilateralFilter(img, <span class="hljs-number">9</span>, <span class="hljs-number">75</span>, <span class="hljs-number">75</span>)  <span class="hljs-comment"># 双边滤波</span><br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_bilateral_vs_gaussian.jpg" width="80%"></p><p>可以看到，双边滤波明显保留了更多边缘信息。</p><h2 id="番外小篇：高斯滤波卷积核"><a href="#番外小篇：高斯滤波卷积核" class="headerlink" title="番外小篇：高斯滤波卷积核"></a>番外小篇：高斯滤波卷积核</h2><p>要解释高斯滤波卷积核是如何生成的，需要先复习下概率论的知识（What？？又是数学( ╯□╰ )）</p><p>一维的高斯函数/正态分布$X\sim{N(\mu,\sigma^{2})}$：</p><script type="math/tex; mode=display">G(x)=\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^{2}}{2\sigma^{2}}}</script><p>当$\mu=0$，$\sigma^{2}=1$时，称为标准正态分布$X\sim{N(0,1)}$：</p><script type="math/tex; mode=display">G(x)=\frac{1}{\sqrt{2\pi}}e^{-\frac{x^{2}}{2}}</script><p>二维X/Y相互独立的高斯函数：</p><script type="math/tex; mode=display">G(x,y)=\frac{1}{2\pi\sigma_x\sigma_y}e^{-\frac{(x-\mu_x)^2+(y-\mu_y)^2}{2\sigma_{x}\sigma_{y}}}=G(x)G(y)</script><p>由上可知，<strong>二维高斯函数具有可分离性</strong>。</p><p>所以OpenCV分两步计算二维高斯卷积：先水平再垂直，每个方向上都是一维的卷积。</p><p>OpenCV中这个一维卷积的计算公式类似于上面的一维高斯函数：</p><script type="math/tex; mode=display">G(i)=\alpha*e^{-\frac{(i-\frac{ksize-1}{2})^{2}}{2\sigma^{2}}}</script><p>其中i=0,…,ksize-1，$\alpha$是一个常数，也称为放缩因子，它使得$\sum{G(i)}=1$</p><p>比如我们可以用<code>cv2.getGaussianKernel(ksize,sigma)</code>来生成一维卷积核：</p><ul><li>sigma&lt;=0时，sigma=0.3<em>((ksize-1)</em>0.5 - 1) + 0.8</li><li>sigma&gt;0时，sigma=sigma</li></ul><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">print(cv2.getGaussianKernel(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>))<br><span class="hljs-comment"># 结果：[[0.25][0.5][0.25]]</span><br></code></pre></td></tr></table></figure><p>生成之后，先进行三次的水平卷积：</p><script type="math/tex; mode=display">I\times{\begin{bmatrix}0.25&0.5&0.25\\0.25&0.5&0.25\\0.25&0.5&0.25\end{bmatrix}}</script><p>然后再进行垂直的三次卷积：</p><script type="math/tex; mode=display">I\times{\begin{bmatrix}0.25&0.5&0.25\\0.25&0.5&0.25\\0.25&0.5&0.25\end{bmatrix}}\times{\begin{bmatrix}0.25&0.5&0.25\\0.25&0.5&0.25\\0.25&0.5&0.25\end{bmatrix}}=I\times{\begin{bmatrix}0.0625&0.125&0.0625\\0.125&0.25&0.125\\0.0625&0.125&0.0625\end{bmatrix}}</script><p>这就是OpenCV中高斯卷积核的生成方式。其实，OpenCV源码中对小于7×7的核是直接计算好放在数组里面的，这样计算速度会快一点，感兴趣的可以看下源码：<a href="https://github.com/ex2tron/OpenCV-Python-Tutorial/blob/master/10. 平滑图像/cv2_source_code_getGaussianKernel.cpp" target="_blank" rel="noopener">getGaussianKernel()</a></p><p>上面矩阵也可以写成：</p><script type="math/tex; mode=display">\frac{1}{16}\begin{bmatrix}1&2&1\\2&4&2\\1&2&1\end{bmatrix}</script><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><ul><li><a href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#ga8c45db9afe636703801b0b2e440fce37" target="_blank" rel="noopener">cv2.blur()</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#gad533230ebf2d42509547d514f7d3fbc3" target="_blank" rel="noopener">cv2.boxFilter()</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#gaabe8c836e97159a9193fb0b11ac52cf1" target="_blank" rel="noopener">cv2.GaussianBlur()</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#gac05a120c1ae92a6060dd0db190a61afa" target="_blank" rel="noopener">cv2.getGaussianKernel()</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#ga564869aa33e58769b4469101aac458f9" target="_blank" rel="noopener">cv2.medianBlur()</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#ga9d7064d478c95d60003cf839430737ed" target="_blank" rel="noopener">cv2.bilateralFilter()</a></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_filtering/py_filtering.html" target="_blank" rel="noopener">Smoothing Images</a></li><li><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/gausian_median_blur_bilateral_filter/gausian_median_blur_bilateral_filter.html" target="_blank" rel="noopener">图像平滑处理</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 模糊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程番外篇8：卷积基础(图片边框)</title>
      <link href="/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%878%EF%BC%9A%E5%8D%B7%E7%A7%AF%E5%9F%BA%E7%A1%80-%E5%9B%BE%E7%89%87%E8%BE%B9%E6%A1%86/"/>
      <url>/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%878%EF%BC%9A%E5%8D%B7%E7%A7%AF%E5%9F%BA%E7%A1%80-%E5%9B%BE%E7%89%87%E8%BE%B9%E6%A1%86/</url>
      
        <content type="html"><![CDATA[<p>了解卷积/滤波的基础知识，给图片添加边框。如果你已了解相关理论，请直接跳到部分。</p><p>卷积的概念其实很好理解，下面我就给大家做个最简单的解释，绝对轻松加愉快的辣o(<em>￣▽￣</em>)o</p><a id="more"></a><h2 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h2><p>可以看下面这张图片了解二维卷积：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_understand_convolution.jpg" width="70%"></p><p>卷积就是<strong>循环对图像跟一个核逐个元素相乘再求和得到另外一副图像的操作</strong>，比如结果图中第一个元素5是怎么算的呢？原图中3×3的区域与3×3的核逐个元素相乘再相加：</p><script type="math/tex; mode=display">5=1\times{1}+2\times{0}+1\times{0}+0\times{0}+1\times{0}+3\times{0}+0\times{0}+2\times{2}</script><p>算完之后，整个框再往右移一步继续计算，横向计算完后，再往下移一步继续计算……网上有一副很经典的动态图，方便我们理解卷积：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_understand_cnn.gif" width="70%"></p><h2 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h2><p>不难发现，前面我们用3×3的核对一副6×6的图像进行卷积，得到的是4×4的图，图片缩小了！那怎么办呢？我们可以<strong>把原图扩充一圈，再卷积，这个操作叫填充padding</strong>。</p><blockquote><p>事实上，原图为n×n，卷积核为f×f，最终结果图大小为(n-f+1) × (n-f+1)。</p></blockquote><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_understand_padding.jpg" width="70%"></p><p>那么扩展的这一层应该填充什么值呢？OpenCV中有好几种填充方式，都使用<code>cv2.copyMakeBorder()</code>函数实现，一起来看看。</p><h2 id="添加边框"><a href="#添加边框" class="headerlink" title="添加边框"></a>添加边框</h2><p><code>cv2.copyMakeBorder()</code>用来给图片添加边框，它有下面几个参数：</p><ul><li>src：要处理的原图</li><li>top, bottom, left, right：上下左右要扩展的像素数</li><li><strong>borderType</strong>：边框类型，这个就是需要关注的填充方式，详情请参考：<a href="https://docs.opencv.org/3.3.1/d2/de8/group__core__array.html#ga209f2f4869e304c82d07739337eae7c5" target="_blank" rel="noopener">BorderTypes</a></li></ul><p>其中默认方式和固定值方式最常用，我们详细说明一下：</p><h3 id="固定值填充"><a href="#固定值填充" class="headerlink" title="固定值填充"></a>固定值填充</h3><p>顾名思义，<code>cv2.BORDER_CONSTANT</code>这种方式就是边框都填充成一个固定的值，比如下面的程序都填充0：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>img = cv2.imread(<span class="hljs-string">'6_by_6.bmp'</span>, <span class="hljs-number">0</span>)<br>print(img)<br><span class="hljs-comment"># 结果应该如下：</span><br><span class="hljs-comment"># [[213 166 237 240 196 243]</span><br><span class="hljs-comment">#  [166  81 213 181  34 197]</span><br><span class="hljs-comment">#  [237 217 247 240 196 243]</span><br><span class="hljs-comment">#  [245 200 241 241 199 240]</span><br><span class="hljs-comment">#  [200  38 190 189  35 197]</span><br><span class="hljs-comment">#  [241 185 237 240 189 241]]</span><br><br><span class="hljs-comment"># 固定值边框：zero padding</span><br>cons = cv2.copyMakeBorder(img, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, cv2.BORDER_CONSTANT, value=<span class="hljs-number">0</span>)<br>print(cons)<br><span class="hljs-comment"># 结果应该如下：</span><br><span class="hljs-comment"># [[0   0   0   0   0   0   0   0]</span><br><span class="hljs-comment">#  [0 213 166 237 240 196 243   0]</span><br><span class="hljs-comment">#  [0 166  81 213 181  34 197   0]</span><br><span class="hljs-comment">#  [0 237 217 247 240 196 243   0]</span><br><span class="hljs-comment">#  [0 245 200 241 241 199 240   0]</span><br><span class="hljs-comment">#  [0 200  38 190 189  35 197   0]</span><br><span class="hljs-comment">#  [0 241 185 237 240 189 241   0]</span><br><span class="hljs-comment">#  [0   0   0   0   0   0   0   0]]</span><br></code></pre></td></tr></table></figure><h3 id="默认边框类型"><a href="#默认边框类型" class="headerlink" title="默认边框类型"></a>默认边框类型</h3><p>默认边框<code>cv2.BORDER_DEFAULT</code>其实是取镜像对称的像素填充，比较拗口，一步步解释：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>img = cv2.imread(<span class="hljs-string">'6_by_6.bmp'</span>, <span class="hljs-number">0</span>)<br>print(img)<br><span class="hljs-comment"># 结果应该如下：</span><br><span class="hljs-comment"># [[213 166 237 240 196 243]</span><br><span class="hljs-comment">#  [166  81 213 181  34 197]</span><br><span class="hljs-comment">#  [237 217 247 240 196 243]</span><br><span class="hljs-comment">#  [245 200 241 241 199 240]</span><br><span class="hljs-comment">#  [200  38 190 189  35 197]</span><br><span class="hljs-comment">#  [241 185 237 240 189 241]]</span><br><br><span class="hljs-comment"># 默认边框类型</span><br>default = cv2.copyMakeBorder(img, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, cv2.BORDER_DEFAULT)<br>print(default)<br><span class="hljs-comment"># 结果应该如下：</span><br><span class="hljs-comment"># [[ 81 166  81 213 181  34 197  34]</span><br><span class="hljs-comment">#  [166 213 166 237 240 196 243 196]</span><br><span class="hljs-comment">#  [ 81 166  81 213 181  34 197  34]</span><br><span class="hljs-comment">#  [217 237 217 247 240 196 243 196]</span><br><span class="hljs-comment">#  [200 245 200 241 241 199 240 199]</span><br><span class="hljs-comment">#  [ 38 200  38 190 189  35 197  35]</span><br><span class="hljs-comment">#  [185 241 185 237 240 189 241 189]</span><br><span class="hljs-comment">#  [ 38 200  38 190 189  35 197  35]]</span><br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_up_down_padding_first.jpg"></p><p>同理再进行左右两边的填充，最后把四个顶点补充上就好了：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_right_left_padding_second2.jpg"></p><blockquote><p>经验之谈：一般情况下默认方式更加合理，因为边界的像素值更加接近。具体应视场合而定。</p></blockquote><h2 id="OpenCV进行卷积"><a href="#OpenCV进行卷积" class="headerlink" title="OpenCV进行卷积"></a>OpenCV进行卷积</h2><p>OpenCV中用<code>cv2.filter2D()</code>实现卷积操作，比如我们的核是下面这样（3×3区域像素的和除以10）：</p><script type="math/tex; mode=display">M=\frac{1}{10}\begin{bmatrix}1&1&1\\1&1&1\\1&1&1\end{bmatrix}</script><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">img = cv2.imread(<span class="hljs-string">'lena.jpg'</span>)<br><span class="hljs-comment"># 定义卷积核</span><br>kernel = np.ones((<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), np.float32) / <span class="hljs-number">10</span><br><span class="hljs-comment"># 卷积操作，-1表示通道数与原图相同</span><br>dst = cv2.filter2D(img, <span class="hljs-number">-1</span>, kernel)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_convolution_kernel_3_3.jpg"></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_core/py_basic_ops/py_basic_ops.html" target="_blank" rel="noopener">Basic Operations on Images</a></li><li><a href="http://blog.csdn.net/zouxy09/article/details/49080029" target="_blank" rel="noopener">图像卷积与滤波的一些知识点</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 卷积 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程9：图像混合</title>
      <link href="/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B9%EF%BC%9A%E5%9B%BE%E5%83%8F%E6%B7%B7%E5%90%88/"/>
      <url>/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B9%EF%BC%9A%E5%9B%BE%E5%83%8F%E6%B7%B7%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p>学习图片间的数学运算，图像混合。</p><p>目标：</p><ul><li>学习图片间的数学运算，如相加、按位运算等。</li><li>OpenCV函数：<ul><li><code>cv2.add()</code>：叠加两幅图片。</li><li><code>cv2.addWeighted()</code>：叠加两幅图片，可自定义两幅图片的权重。</li><li><code>cv2.bitwise_and()</code>：执行按位与运算。</li><li><code>cv2.bitwise_not()</code>：执行按位非运算。</li><li><code>cv2.bitwise_or()</code>：执行按位或运算。</li><li><code>cv2.bitwise_xor()</code>：执行按位异或运算。</li></ul></li><li>掩膜就是用来对图片进行全局或局部的遮挡。</li></ul><a id="more"></a><h2 id="图片相加"><a href="#图片相加" class="headerlink" title="图片相加"></a>图片相加</h2><p>要叠加两张图片，可以用<code>cv2.add()</code>函数，相加两幅图片的形状（高度/宽度/通道数）必须相同。</p><p>numpy中可以直接用res = img + img1相加，但这两者的结果并不相同：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">x = np.uint8([<span class="hljs-number">250</span>])<br>y = np.uint8([<span class="hljs-number">10</span>])<br>print(cv2.add(x, y))  <span class="hljs-comment"># 250+10 = 260 =&gt; 255</span><br>print(x + y)  <span class="hljs-comment"># 250+10 = 260 % 256 = 4</span><br></code></pre></td></tr></table></figure><p>如果是二值化图片（只有0和255两种值），两者结果是一样的（用numpy的方式更简便一些）。</p><h2 id="图像混合"><a href="#图像混合" class="headerlink" title="图像混合"></a>图像混合</h2><p>图像混合<code>cv2.addWeighted()</code>也是一种图片相加的操作，只不过两幅图片的权重不一样，γ相当于一个修正值：</p><script type="math/tex; mode=display">dst=\alpha\times{img1}+\beta\times{img2}+\gamma</script><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">img1 = cv2.imread(<span class="hljs-string">'lena_small.jpg'</span>)<br>img2 = cv2.imread(<span class="hljs-string">'opencv-logo-white.png'</span>)<br>res = cv2.addWeighted(img1, <span class="hljs-number">0.6</span>, img2, <span class="hljs-number">0.4</span>, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_image_blending_6_4.jpg" width="80%"></p><blockquote><p>经验之谈：$\alpha$和$\beta$都等于1时，就相当于图片相加。</p></blockquote><h2 id="按位操作"><a href="#按位操作" class="headerlink" title="按位操作"></a>按位操作</h2><p>按位操作包括按位与/或/非/异或操作，有什么用途呢？比如说我们要实现下图的效果：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_bitwise_operations_demo.jpg"></p><p>如果将两幅图片直接相加会改变图片的颜色，如果用图像混合，则会改变图片的透明度，所以我们需要用<strong>按位操作</strong>。</p><p>首先来了解一下<a href="https://baike.baidu.com/item/掩膜/8544392?fr=aladdin" target="_blank" rel="noopener">掩膜</a>（mask）的概念：</p><blockquote><p>掩膜是用一副二值化图片对另外一幅图片进行局部的遮挡</p></blockquote><p>看下图就一目了然了：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_understand_mask.jpg"></p><p>所以我们的思路就是把原图中要放logo的区域抠出来，再把logo放进去就行了：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br><span class="hljs-comment"># 按位操作</span><br>img1 = cv2.imread(<span class="hljs-string">'lena.jpg'</span>)<br>img2 = cv2.imread(<span class="hljs-string">'opencv-logo-white.png'</span>)<br><br><span class="hljs-comment"># 把logo放在左上角，所以我们只关心这一块区域</span><br>rows, cols = img2.shape[:<span class="hljs-number">2</span>]  <span class="hljs-comment"># img2.shape为(172,172,3)</span><br>roi = img1[:rows, :cols]  <span class="hljs-comment"># 获取指定区域</span><br><br><br><span class="hljs-comment"># 创建掩膜</span><br>img2gray = cv2.cvtColor(img2, cv2.COLOR_BGR2GRAY)  <span class="hljs-comment"># 颜色空间转换</span><br><span class="hljs-comment"># 设置阈值, mask为结果</span><br>ret, mask = cv2.threshold(img2gray, <span class="hljs-number">10</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY)<br>mask_inv = cv2.bitwise_not(mask)    <span class="hljs-comment"># 做取反操作</span><br><br><span class="hljs-comment"># 保留除logo外的背景</span><br>img1_bg = cv2.bitwise_and(roi, roi, mask=mask_inv)<br>dst = cv2.add(img1_bg, img2)  <span class="hljs-comment"># 进行融合</span><br>img1[:rows, :cols] = dst  <span class="hljs-comment"># 融合后放在原图上</span><br><br>cv2.imshow(<span class="hljs-string">'result'</span>, img1)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><blockquote><p>经验之谈：掩膜的概念在图像混合/叠加的场景下使用较多，可以多多练习噢！</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><ul><li><a href="https://docs.opencv.org/4.0.0/d2/de8/group__core__array.html#ga10ac1bfb180e2cfda1701d06c24fdbd6" target="_blank" rel="noopener">cv2.add()</a></li><li><a href="https://docs.opencv.org/4.0.0/d2/de8/group__core__array.html#gafafb2513349db3bcff51f54ee5592a19" target="_blank" rel="noopener">cv2.addWeighted()</a></li><li><a href="https://docs.opencv.org/4.0.0/d2/de8/group__core__array.html#ga60b4d04b251ba5eb1392c34425497e14" target="_blank" rel="noopener">cv2.bitwise_and()</a></li><li><a href="https://docs.opencv.org/4.0.0/d2/de8/group__core__array.html#ga0002cf8b418479f4cb49a75442baee2f" target="_blank" rel="noopener">cv2.bitwise_not()</a></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="https://baike.baidu.com/item/掩膜/8544392?fr=aladdin" target="_blank" rel="noopener">掩膜</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_core/py_image_arithmetics/py_image_arithmetics.html" target="_blank" rel="noopener">Arithmetic Operations on Images</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 图像混合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程番外篇7：亮度与对比度</title>
      <link href="/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%877%EF%BC%9A%E4%BA%AE%E5%BA%A6%E4%B8%8E%E5%AF%B9%E6%AF%94%E5%BA%A6/"/>
      <url>/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%877%EF%BC%9A%E4%BA%AE%E5%BA%A6%E4%B8%8E%E5%AF%B9%E6%AF%94%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>学习如何调整图片的亮度和对比度。</p><a id="more"></a><h2 id="亮度与对比度"><a href="#亮度与对比度" class="headerlink" title="亮度与对比度"></a>亮度与对比度</h2><ul><li>亮度调整是将图像像素的强度整体变大/变小。</li><li>对比度调整指的是图像暗处的像素强度变低，亮处的变高，从而拓宽某个区域内的显示精度。</li></ul><p>OpenCV中亮度和对比度应用这个公式来计算：</p><script type="math/tex; mode=display">g(x)=\alpha f(x)+\beta</script><p>其中：$\alpha(&gt;0)$、$\beta$常称为增益与偏置值，分别控制图片的对比度和亮度。</p><blockquote><p>经验之谈：此处对α/β控制对比度和亮度有争议，具体请参考：<a href="http://blog.csdn.net/abc20002929/article/details/40474807" target="_blank" rel="noopener">OpenCV关于对比度和亮度的误解</a>。</p></blockquote><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>img = cv2.imread(<span class="hljs-string">'lena.jpg'</span>)<br><span class="hljs-comment"># numpy默认是取模运算，250+10 = 260%256 = 4</span><br><span class="hljs-comment"># 所以此处需要用np.clip进行范围限定，</span><br><span class="hljs-comment"># a&lt;0 =&gt; a=0, a&gt;255 =&gt; a=255</span><br>res = np.uint8(np.clip((<span class="hljs-number">1.5</span> * img + <span class="hljs-number">10</span>), <span class="hljs-number">0</span>, <span class="hljs-number">255</span>))<br><br><span class="hljs-comment"># 两张图片横向合并（便于对比显示）</span><br>tmp = np.hstack((img, res))<br>cv2.imshow(<span class="hljs-string">'image'</span>, tmp)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>还记得图像混合那一节中numpy对数据溢出的取模处理吗？<code>250+10 = 260 =&gt; 260%256=4</code>，它并不适用于我们的图像处理，所以用<a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.clip.html#numpy.clip" target="_blank" rel="noopener">np.clip()</a>函数将数据限定：<code>a&lt;0 =&gt; a=0, a&gt;255 =&gt; a=255</code>。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_contrast_brightness.jpg"></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>创建两个滑动条分别调整对比度和亮度（对比度范围：0~0.3，亮度：0~100）。提示：因为滑动条没有小数，所以可以设置为0~300，然后乘以0.01。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nothing</span><span class="hljs-params">(x)</span>:</span><br>    <span class="hljs-string">'''<br>    ### 回调函数，暂时无用<br>    '''</span><br>    <span class="hljs-keyword">pass</span><br><br><br>img = cv2.imread(<span class="hljs-string">'lena.jpg'</span>)<br>cv2.namedWindow(<span class="hljs-string">'image'</span>)<br><br><span class="hljs-comment"># 创建两个滑块</span><br>cv2.createTrackbar(<span class="hljs-string">'brightness'</span>, <span class="hljs-string">'image'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, nothing)<br>cv2.createTrackbar(<span class="hljs-string">'contrast'</span>, <span class="hljs-string">'image'</span>, <span class="hljs-number">100</span>, <span class="hljs-number">300</span>, nothing)<br><br>temp = img.copy()<br>rows, cols = img.shape[:<span class="hljs-number">2</span>]<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    cv2.imshow(<span class="hljs-string">'image'</span>, temp)<br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">1</span>) == <span class="hljs-number">27</span>:<br>        <span class="hljs-keyword">break</span><br><br>    <span class="hljs-comment"># 得到两个滑块的值</span><br>    brightness = cv2.getTrackbarPos(<span class="hljs-string">'brightness'</span>, <span class="hljs-string">'image'</span>)<br>    contrast = cv2.getTrackbarPos(<span class="hljs-string">'contrast'</span>, <span class="hljs-string">'image'</span>) * <span class="hljs-number">0.01</span><br>    <span class="hljs-comment"># 进行对比度和亮度调整</span><br>    temp = np.uint8(np.clip(contrast * img + brightness, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>))<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_liangdu_duibidu.png" width="70%"></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.clip.html#numpy.clip" target="_blank" rel="noopener">numpy.clip()</a></li><li><a href="http://blog.csdn.net/abc20002929/article/details/40474807" target="_blank" rel="noopener">OpenCV关于对比度和亮度的误解</a></li><li><a href="http://blog.csdn.net/u013139259/article/details/52145377" target="_blank" rel="noopener">OpenCV改变图像亮度和对比度以及优化</a></li><li><a href="https://docs.opencv.org/3.1.0/d3/d63/classcv_1_1Mat.html#a3f356665bb0ca452e7d7723ccac9a810" target="_blank" rel="noopener">Mat::convertTo</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 亮度 </tag>
            
            <tag> 对比度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程挑战任务：画动态时钟</title>
      <link href="/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E6%8C%91%E6%88%98%E4%BB%BB%E5%8A%A1%EF%BC%9A%E7%94%BB%E5%8A%A8%E6%80%81%E6%97%B6%E9%92%9F/"/>
      <url>/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E6%8C%91%E6%88%98%E4%BB%BB%E5%8A%A1%EF%BC%9A%E7%94%BB%E5%8A%A8%E6%80%81%E6%97%B6%E9%92%9F/</url>
      
        <content type="html"><![CDATA[<p>挑战任务：使用OpenCV绘制一个随系统时间动态变化的时钟，<strong>中间显示当前日期</strong>。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_draw_clock_dynamic_sample.gif" width="50%"></p><a id="more"></a><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>本次挑战任务旨在提升大家的动手实践能力，解决实际问题，所以我们得先有个解题思路和方案。观察下常见的时钟表盘：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_draw_clock_actual_clock_sample.jpg"></p><p>整个表盘其实只有3根表针在动，所以可以先画出静态表盘，然后获取系统当前时间，根据时间实时动态绘制3根表针就解决了。</p><h2 id="绘制表盘"><a href="#绘制表盘" class="headerlink" title="绘制表盘"></a>绘制表盘</h2><p>表盘上只有60条分/秒刻线和12条小时刻线，当然还有表盘的外部轮廓圆，也就是重点在如何画72根线。先把简单的圆画出来：</p><p>前面我们使用OpenCV画直线的时候，需知道直线的起点和终点坐标，那么画72根线就变成了获取72组坐标。</p><p>在平面坐标系下，已知半径和角度的话，A点的坐标可以表示为：</p><script type="math/tex; mode=display">x=r\times{\cos{\alpha}}\\y=r\times{\sin{\alpha}}</script><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_draw_clock_center_shift.jpg"></p><p>先只考虑将坐标系原点移动到左上角，角度依然是平面坐标系中的逆时针计算，那么新坐标是：</p><script type="math/tex; mode=display">x=r+r\times{\cos{\alpha}}\\y=r+r\times{\sin{\alpha}}</script><p>对于60条分/秒刻线，刻线间的夹角是360°/60=6°，对于小时刻线，角度是360°/12=30°，这样就得到了72组起点坐标，那怎么得到终点坐标呢？</p><p>其实同样的原理，用一个同心的小圆来计算得到B点：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_draw_clock_a_b_position.jpg"></p><p>通过A/B两点就可以画出直线：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python">pt1 = []<br><br><span class="hljs-comment"># 画出60条秒和分钟的刻线</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">60</span>):<br>    <span class="hljs-comment"># 最外部圆，计算A点</span><br>    x1 = center_x+(radius-margin)*math.cos(i*<span class="hljs-number">6</span>*np.pi/<span class="hljs-number">180.0</span>)<br>    y1 = center_y+(radius-margin)*math.sin(i*<span class="hljs-number">6</span>*np.pi/<span class="hljs-number">180.0</span>)<br>    pt1.append((int(x1), int(y1)))<br><br>    <span class="hljs-comment"># 同心小圆，计算B点</span><br>    x2 = center_x+(radius<span class="hljs-number">-15</span>)*math.cos(i*<span class="hljs-number">6</span>*np.pi/<span class="hljs-number">180.0</span>)<br>    y2 = center_y+(radius<span class="hljs-number">-15</span>)*math.sin(i*<span class="hljs-number">6</span>*np.pi/<span class="hljs-number">180.0</span>)<br><br>    cv2.line(img, pt1[i], (int(x2), int(y2)), (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), thickness=<span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 4. 画出12条小时的刻线</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">12</span>):<br>    <span class="hljs-comment"># 12条小时刻线应该更长一点</span><br>    x = center_x+(radius<span class="hljs-number">-25</span>)*math.cos(i*<span class="hljs-number">30</span>*np.pi/<span class="hljs-number">180.0</span>)<br>    y = center_y+(radius<span class="hljs-number">-25</span>)*math.sin(i*<span class="hljs-number">30</span>*np.pi/<span class="hljs-number">180.0</span>)<br>    <span class="hljs-comment"># 这里用到了前面的pt1</span><br>    cv2.line(img, pt1[i*<span class="hljs-number">5</span>], (int(x), int(y)), (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), thickness=<span class="hljs-number">5</span>)<br><br><span class="hljs-comment"># 到这里基本的表盘图就已经画出来了</span><br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_draw_clock_blank_clock.jpg"></p><h2 id="角度换算"><a href="#角度换算" class="headerlink" title="角度换算"></a>角度换算</h2><p>接下来算是一个小难点，首先<strong>时钟的起始坐标在正常二维坐标系的90°方向，其次时钟跟图像一样，都是顺时针计算角度的</strong>，所以三者需要统一下：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_draw_clock_different_clock_contrast.jpg"></p><p>因为角度是完全对称的，顺逆时针没有影响，所以平面坐标系完全不用理会，放在这里只是便于大家理解。对于时钟坐标和图像坐标，时钟0的0°对应图像的270°，时钟15的90°对应图像的360°，时钟30的180°对应图像的450°（360°+90°）…</p><p>所以两者之间的关系便是：</p><blockquote><p>计算角度 = 时钟角度+270°</p><p>计算角度 = 计算角度 if 计算角度&lt;=360° else 计算角度-360°</p></blockquote><h2 id="同步时间"><a href="#同步时间" class="headerlink" title="同步时间"></a>同步时间</h2><p>Python中如何获取当前时间和添加日期文字都比较简单，看代码就行，我就不解释了。代码中角度计算我换了一种方式，其实是一样的，看你能不能看懂(●ˇ∀ˇ●)：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment"># 不断拷贝表盘图，才能更新绘制，不然会重叠在一起</span><br>    temp = np.copy(img)<br><br>    <span class="hljs-comment"># 获取系统时间，画出动态的时-分-秒三条刻线</span><br>    now_time = datetime.datetime.now()<br>    hour, minute, second = now_time.hour, now_time.minute, now_time.second<br><br>    <span class="hljs-comment"># 画秒刻线</span><br>    <span class="hljs-comment"># 参见博客，OpenCV中的角度是顺时针计算的，所以需要转换下</span><br>    sec_angle = second * <span class="hljs-number">6</span> + <span class="hljs-number">270</span> <span class="hljs-keyword">if</span> second &lt;= <span class="hljs-number">15</span> <span class="hljs-keyword">else</span> (second - <span class="hljs-number">15</span>) * <span class="hljs-number">6</span><br>    sec_x = center_x + (radius - margin) * math.cos(sec_angle * np.pi / <span class="hljs-number">180.0</span>)<br>    sec_y = center_y + (radius - margin) * math.sin(sec_angle * np.pi / <span class="hljs-number">180.0</span>)<br>    cv2.line(temp, center, (int(sec_x), int(sec_y)), (<span class="hljs-number">203</span>, <span class="hljs-number">222</span>, <span class="hljs-number">166</span>), <span class="hljs-number">2</span>)<br><br>    <span class="hljs-comment"># 画分刻线</span><br>    min_angle = minute * <span class="hljs-number">6</span> + <span class="hljs-number">270</span> <span class="hljs-keyword">if</span> minute &lt;= <span class="hljs-number">15</span> <span class="hljs-keyword">else</span> (minute - <span class="hljs-number">15</span>) * <span class="hljs-number">6</span><br>    min_x = center_x + (radius - <span class="hljs-number">35</span>) * math.cos(min_angle * np.pi / <span class="hljs-number">180.0</span>)<br>    min_y = center_y + (radius - <span class="hljs-number">35</span>) * math.sin(min_angle * np.pi / <span class="hljs-number">180.0</span>)<br>    cv2.line(temp, center, (int(min_x), int(min_y)), (<span class="hljs-number">186</span>, <span class="hljs-number">199</span>, <span class="hljs-number">137</span>), <span class="hljs-number">8</span>)<br><br>    <span class="hljs-comment"># 画时刻线</span><br>    hour_angle = hour * <span class="hljs-number">30</span> + <span class="hljs-number">270</span> <span class="hljs-keyword">if</span> hour &lt;= <span class="hljs-number">3</span> <span class="hljs-keyword">else</span> (hour - <span class="hljs-number">3</span>) * <span class="hljs-number">30</span><br>    hour_x = center_x + (radius - <span class="hljs-number">65</span>) * math.cos(hour_angle * np.pi / <span class="hljs-number">180.0</span>)<br>    hour_y = center_y + (radius - <span class="hljs-number">65</span>) * math.sin(hour_angle * np.pi / <span class="hljs-number">180.0</span>)<br>    cv2.line(temp, center, (int(hour_x), int(hour_y)), (<span class="hljs-number">169</span>, <span class="hljs-number">198</span>, <span class="hljs-number">26</span>), <span class="hljs-number">15</span>)<br><br>    <span class="hljs-comment"># 添加当前日期文字</span><br>    font = cv2.FONT_HERSHEY_SIMPLEX<br>    time_str = now_time.strftime(<span class="hljs-string">"%d/%m/%Y"</span>)<br>    cv2.putText(img, time_str, (<span class="hljs-number">135</span>, <span class="hljs-number">275</span>), font, <span class="hljs-number">1</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">2</span>)<br><br>    cv2.imshow(<span class="hljs-string">'clocking'</span>, temp)<br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">1</span>) == <span class="hljs-number">27</span>:  <span class="hljs-comment"># 按下ESC键退出</span><br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p>本此挑战旨在锻炼一步步解决实际问题的思路（虽然有点数学知识(￣▽￣)”），大家再接再厉噢！</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">import</span> datetime<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>margin = <span class="hljs-number">5</span>  <span class="hljs-comment"># 上下左右边距</span><br>radius = <span class="hljs-number">220</span>  <span class="hljs-comment"># 圆的半径</span><br>center = (center_x, center_y) = (<span class="hljs-number">225</span>, <span class="hljs-number">225</span>)  <span class="hljs-comment"># 圆心</span><br><br><span class="hljs-comment"># 1. 新建一个画板并填充成白色</span><br>img = np.zeros((<span class="hljs-number">450</span>, <span class="hljs-number">450</span>, <span class="hljs-number">3</span>), np.uint8)<br>img[:] = (<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>)<br><br><span class="hljs-comment"># 2. 画出圆盘</span><br>cv2.circle(img, center, radius, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), thickness=<span class="hljs-number">5</span>)<br><br>pt1 = []<br><br><span class="hljs-comment"># 3. 画出60条秒和分钟的刻线</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">60</span>):<br>    <span class="hljs-comment"># 最外部圆，计算A点</span><br>    x1 = center_x + (radius - margin) * math.cos(i * <span class="hljs-number">6</span> * np.pi / <span class="hljs-number">180.0</span>)<br>    y1 = center_y + (radius - margin) * math.sin(i * <span class="hljs-number">6</span> * np.pi / <span class="hljs-number">180.0</span>)<br>    pt1.append((int(x1), int(y1)))<br><br>    <span class="hljs-comment"># 同心小圆，计算B点</span><br>    x2 = center_x + (radius - <span class="hljs-number">15</span>) * math.cos(i * <span class="hljs-number">6</span> * np.pi / <span class="hljs-number">180.0</span>)<br>    y2 = center_y + (radius - <span class="hljs-number">15</span>) * math.sin(i * <span class="hljs-number">6</span> * np.pi / <span class="hljs-number">180.0</span>)<br><br>    cv2.line(img, pt1[i], (int(x2), int(y2)), (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), thickness=<span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 4. 画出12条小时的刻线</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">12</span>):<br>    <span class="hljs-comment"># 12条小时刻线应该更长一点</span><br>    x = center_x + (radius - <span class="hljs-number">25</span>) * math.cos(i * <span class="hljs-number">30</span> * np.pi / <span class="hljs-number">180.0</span>)<br>    y = center_y + (radius - <span class="hljs-number">25</span>) * math.sin(i * <span class="hljs-number">30</span> * np.pi / <span class="hljs-number">180.0</span>)<br>    <span class="hljs-comment"># 这里用到了前面的pt1</span><br>    cv2.line(img, pt1[i * <span class="hljs-number">5</span>], (int(x), int(y)), (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), thickness=<span class="hljs-number">5</span>)<br><br><span class="hljs-comment"># 到这里基本的表盘图就已经画出来了</span><br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment"># 不断拷贝表盘图，才能更新绘制，不然会重叠在一起</span><br>    temp = np.copy(img)<br><br>    <span class="hljs-comment"># 5. 获取系统时间，画出动态的时-分-秒三条刻线</span><br>    now_time = datetime.datetime.now()<br>    hour, minute, second = now_time.hour, now_time.minute, now_time.second<br><br>    <span class="hljs-comment"># 画秒刻线</span><br>    <span class="hljs-comment"># 参见博客，OpenCV中的角度是顺时针计算的，所以需要转换下</span><br>    sec_angle = second * <span class="hljs-number">6</span> + <span class="hljs-number">270</span> <span class="hljs-keyword">if</span> second &lt;= <span class="hljs-number">15</span> <span class="hljs-keyword">else</span> (second - <span class="hljs-number">15</span>) * <span class="hljs-number">6</span><br>    sec_x = center_x + (radius - margin) * math.cos(sec_angle * np.pi / <span class="hljs-number">180.0</span>)<br>    sec_y = center_y + (radius - margin) * math.sin(sec_angle * np.pi / <span class="hljs-number">180.0</span>)<br>    cv2.line(temp, center, (int(sec_x), int(sec_y)), (<span class="hljs-number">203</span>, <span class="hljs-number">222</span>, <span class="hljs-number">166</span>), <span class="hljs-number">2</span>)<br><br>    <span class="hljs-comment"># 画分刻线</span><br>    min_angle = minute * <span class="hljs-number">6</span> + <span class="hljs-number">270</span> <span class="hljs-keyword">if</span> minute &lt;= <span class="hljs-number">15</span> <span class="hljs-keyword">else</span> (minute - <span class="hljs-number">15</span>) * <span class="hljs-number">6</span><br>    min_x = center_x + (radius - <span class="hljs-number">35</span>) * math.cos(min_angle * np.pi / <span class="hljs-number">180.0</span>)<br>    min_y = center_y + (radius - <span class="hljs-number">35</span>) * math.sin(min_angle * np.pi / <span class="hljs-number">180.0</span>)<br>    cv2.line(temp, center, (int(min_x), int(min_y)), (<span class="hljs-number">186</span>, <span class="hljs-number">199</span>, <span class="hljs-number">137</span>), <span class="hljs-number">8</span>)<br><br>    <span class="hljs-comment"># 画时刻线</span><br>    hour_angle = hour * <span class="hljs-number">30</span> + <span class="hljs-number">270</span> <span class="hljs-keyword">if</span> hour &lt;= <span class="hljs-number">3</span> <span class="hljs-keyword">else</span> (hour - <span class="hljs-number">3</span>) * <span class="hljs-number">30</span><br>    hour_x = center_x + (radius - <span class="hljs-number">65</span>) * math.cos(hour_angle * np.pi / <span class="hljs-number">180.0</span>)<br>    hour_y = center_y + (radius - <span class="hljs-number">65</span>) * math.sin(hour_angle * np.pi / <span class="hljs-number">180.0</span>)<br>    cv2.line(temp, center, (int(hour_x), int(hour_y)), (<span class="hljs-number">169</span>, <span class="hljs-number">198</span>, <span class="hljs-number">26</span>), <span class="hljs-number">15</span>)<br><br>    <span class="hljs-comment"># 6. 添加当前日期文字</span><br>    font = cv2.FONT_HERSHEY_SIMPLEX<br>    time_str = now_time.strftime(<span class="hljs-string">"%d/%m/%Y"</span>)<br>    cv2.putText(img, time_str, (<span class="hljs-number">135</span>, <span class="hljs-number">275</span>), font, <span class="hljs-number">1</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">2</span>)<br><br>    cv2.imshow(<span class="hljs-string">'clocking'</span>, temp)<br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">1</span>) == <span class="hljs-number">27</span>:  <span class="hljs-comment"># 按下ESC键退出</span><br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 绘图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程番外篇6：鼠标绘图</title>
      <link href="/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%876%EF%BC%9A%E9%BC%A0%E6%A0%87%E7%BB%98%E5%9B%BE/"/>
      <url>/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%876%EF%BC%9A%E9%BC%A0%E6%A0%87%E7%BB%98%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>学习如何用鼠标实时绘图。</p><p>目标：</p><ul><li>捕获鼠标事件</li><li>OpenCV函数：<code>cv2.setMouseCallback()</code></li><li>要用鼠标绘图，需要用<code>cv2.setMouseCallback()</code>定义回调函数，然后在回调函数中根据不同的event事件，执行不同的功能。</li></ul><a id="more"></a><h2 id="确定鼠标位置"><a href="#确定鼠标位置" class="headerlink" title="确定鼠标位置"></a>确定鼠标位置</h2><p>OpenCV中，我们需要创建一个鼠标的回调函数来获取鼠标当前的位置、当前的事件如左键按下/左键释放或是右键单击等等，然后执行相应的功能。</p><p>使用<code>cv2.setMouseCallback()</code>来创建鼠标的回调函数，比如我们在左键单击的时候，打印出当前鼠标的位置：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mouse_event</span><span class="hljs-params">(event, x, y, flags, param)</span>:</span><br>    <span class="hljs-string">'''<br>    ### 鼠标的回调函数<br>    '''</span><br>    <span class="hljs-comment"># 通过event判断具体是什么事件，这里是左键按下</span><br>    <span class="hljs-keyword">if</span> event == cv2.EVENT_LBUTTONDOWN:<br>        print((x, y))<br><br>img = np.zeros((<span class="hljs-number">512</span>, <span class="hljs-number">512</span>, <span class="hljs-number">3</span>), np.uint8)<br>cv2.namedWindow(<span class="hljs-string">'image'</span>)<br><span class="hljs-comment"># 定义鼠标的回调函数</span><br>cv2.setMouseCallback(<span class="hljs-string">'image'</span>, mouse_event)<br><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">True</span>):<br>    cv2.imshow(<span class="hljs-string">'image'</span>, img)<br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">20</span>) == ord(<span class="hljs-string">'q'</span>):<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p>上面的代码先定义鼠标的回调函数<code>mouse_event()</code>，然后在回调函数中判断是否是左键单击事件 <code>EVENT_LBUTTONDOWN</code>，是的话就打印出坐标。需要注意的是，<strong>回调函数的参数格式是固定的</strong>，不要随意更改。</p><p>那除了左键单击之外，还有哪些事件呢？可以用下面的代码打印出来：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 获取所有的事件</span><br>events = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> dir(cv2) <span class="hljs-keyword">if</span> <span class="hljs-string">'EVENT'</span> <span class="hljs-keyword">in</span> i]<br>print(events)<br><br>**************************************************************<br><br>运行结果：<br>[<span class="hljs-string">'EVENT_FLAG_ALTKEY'</span>, <span class="hljs-string">'EVENT_FLAG_CTRLKEY'</span>, <span class="hljs-string">'EVENT_FLAG_LBUTTON'</span>, <span class="hljs-string">'EVENT_FLAG_MBUTTON'</span>, <span class="hljs-string">'EVENT_FLAG_RBUTTON'</span>, <span class="hljs-string">'EVENT_FLAG_SHIFTKEY'</span>, <span class="hljs-string">'EVENT_LBUTTONDBLCLK'</span>, <span class="hljs-string">'EVENT_LBUTTONDOWN'</span>, <span class="hljs-string">'EVENT_LBUTTONUP'</span>, <span class="hljs-string">'EVENT_MBUTTONDBLCLK'</span>, <span class="hljs-string">'EVENT_MBUTTONDOWN'</span>, <span class="hljs-string">'EVENT_MBUTTONUP'</span>, <span class="hljs-string">'EVENT_MOUSEHWHEEL'</span>, <span class="hljs-string">'EVENT_MOUSEMOVE'</span>, <span class="hljs-string">'EVENT_MOUSEWHEEL'</span>, <span class="hljs-string">'EVENT_RBUTTONDBLCLK'</span>, <span class="hljs-string">'EVENT_RBUTTONDOWN'</span>, <span class="hljs-string">'EVENT_RBUTTONUP'</span>]<br></code></pre></td></tr></table></figure><h2 id="综合实例"><a href="#综合实例" class="headerlink" title="综合实例"></a>综合实例</h2><p>现在我们来实现一个综合的例子，这个实例会帮助你理解图像交互的一些思想：</p><p>在图像上用鼠标画图，可以画圆或矩形，按m键在两种模式下切换。左键按下时开始画图，移动到哪儿画到哪儿，左键释放时结束画图。听上去很复杂，是吗？一步步来看：</p><ul><li>用鼠标画图：需要定义鼠标的回调函数mouse_event</li><li>画圆或矩形：需要定义一个画图的模式mode</li><li>左键单击、移动、释放：需要捕获三个不同的事件</li><li>开始画图，结束画图：需要定义一个画图的标记位drawing</li></ul><p>好，开始coding吧：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>drawing = <span class="hljs-literal">False</span>  <span class="hljs-comment"># 是否开始画图</span><br>mode = <span class="hljs-literal">True</span>  <span class="hljs-comment"># True：画矩形，False：画圆</span><br>start = (<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mouse_event</span><span class="hljs-params">(event, x, y, flags, param)</span>:</span><br>    <span class="hljs-keyword">global</span> start, drawing, mode<br><br>    <span class="hljs-comment"># 左键按下：开始画图</span><br>    <span class="hljs-keyword">if</span> event == cv2.EVENT_LBUTTONDOWN:<br>        drawing = <span class="hljs-literal">True</span><br>        start = (x, y)<br>    <span class="hljs-comment"># 鼠标移动，画图</span><br>    <span class="hljs-keyword">elif</span> event == cv2.EVENT_MOUSEMOVE:<br>        <span class="hljs-keyword">if</span> drawing:<br>            <span class="hljs-keyword">if</span> mode:<br>                cv2.rectangle(img, start, (x, y), (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>), <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">else</span>:<br>                cv2.circle(img, (x, y), <span class="hljs-number">5</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">-1</span>)<br>    <span class="hljs-comment"># 左键释放：结束画图</span><br>    <span class="hljs-keyword">elif</span> event == cv2.EVENT_LBUTTONUP:<br>        drawing = <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">if</span> mode:<br>            cv2.rectangle(img, start, (x, y), (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>), <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">else</span>:<br>            cv2.circle(img, (x, y), <span class="hljs-number">5</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">-1</span>)<br><br><br>img = np.zeros((<span class="hljs-number">512</span>, <span class="hljs-number">512</span>, <span class="hljs-number">3</span>), np.uint8)<br>cv2.namedWindow(<span class="hljs-string">'image'</span>)<br>cv2.setMouseCallback(<span class="hljs-string">'image'</span>, mouse_event)<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    cv2.imshow(<span class="hljs-string">'image'</span>, img)<br>    <span class="hljs-comment"># 按下m切换模式</span><br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">1</span>) == ord(<span class="hljs-string">'m'</span>):<br>        mode = <span class="hljs-keyword">not</span> mode<br>    <span class="hljs-comment"># 按下ESC退出</span><br>    <span class="hljs-keyword">elif</span> cv2.waitKey(<span class="hljs-number">1</span>) == <span class="hljs-number">27</span>:<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p>效果应该如下图所示：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_mouse_drawing_rectangle_circle.jpg"></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="练习1"><a href="#练习1" class="headerlink" title="练习1"></a>练习1</h3><p>实现用鼠标画矩形，跟实例差不多，但只实时画一个，类似于下面动画：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_live_draw_rectangle.gif"></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>start, end = (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>drawing = <span class="hljs-literal">False</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mouse_event</span><span class="hljs-params">(event, x, y, flags, param)</span>:</span><br>    <span class="hljs-keyword">global</span> start, drawing, end, temp<br><br>    <span class="hljs-comment"># 鼠标按下，开始画图：记录下起点</span><br>    <span class="hljs-keyword">if</span> event == cv2.EVENT_LBUTTONDOWN:<br>        drawing = <span class="hljs-literal">True</span><br>        start = (x, y)<br>    <span class="hljs-comment"># 实时移动的位置作为矩形终点（右下角点）</span><br>    <span class="hljs-keyword">elif</span> event == cv2.EVENT_MOUSEMOVE:<br>        <span class="hljs-keyword">if</span> drawing:<br>            end = (x, y)<br>    <span class="hljs-comment"># 鼠标释放后，停止绘图</span><br>    <span class="hljs-keyword">elif</span> event == cv2.EVENT_LBUTTONUP:<br>        drawing = <span class="hljs-literal">False</span><br>        cv2.rectangle(img, start, (x, y), (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>), <span class="hljs-number">2</span>)<br>        start = end = (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br><br><br>img = np.zeros((<span class="hljs-number">512</span>, <span class="hljs-number">512</span>, <span class="hljs-number">3</span>), np.uint8)<br>cv2.namedWindow(<span class="hljs-string">'image'</span>)<br>cv2.setMouseCallback(<span class="hljs-string">'image'</span>, mouse_event)<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment"># 下面这句话很关键，拷贝出原图，这样才可以实时画一个矩形</span><br>    temp = np.copy(img)<br>    <span class="hljs-keyword">if</span> drawing <span class="hljs-keyword">and</span> end != (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>):<br>        cv2.rectangle(temp, start, end, (<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">2</span>)<br><br>    cv2.imshow(<span class="hljs-string">'image'</span>, temp)<br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">20</span>) == <span class="hljs-number">27</span>:<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h3 id="练习2"><a href="#练习2" class="headerlink" title="练习2"></a>练习2</h3><p>做一个在白色面板上绘图的简单程序，可用滑动条调整颜色和笔刷大小。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nothing</span><span class="hljs-params">(x)</span>:</span><br>    <span class="hljs-string">'''<br>    ### 回调函数，x表示滑块的位置，本例暂不使用<br>    '''</span><br>    <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mouse_event</span><span class="hljs-params">(event, x, y, flags, param)</span>:</span><br>    <span class="hljs-string">'''<br>    ### 鼠标回调函数<br>    '''</span><br>    <span class="hljs-keyword">global</span> brush_size, brush_color, drawing<br><br>    <span class="hljs-keyword">if</span> event == cv2.EVENT_LBUTTONDOWN:<br>        drawing = <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">elif</span> event == cv2.EVENT_MOUSEMOVE:<br>        <span class="hljs-keyword">if</span> drawing:<br>            cv2.circle(img, (x, y), brush_size, brush_color, <span class="hljs-number">-1</span>)<br>    <span class="hljs-keyword">elif</span> event == cv2.EVENT_LBUTTONUP:<br>        drawing = <span class="hljs-literal">False</span><br>        cv2.circle(img, (x, y), brush_size, brush_color, <span class="hljs-number">-1</span>)<br><br><br>img = np.zeros((<span class="hljs-number">300</span>, <span class="hljs-number">512</span>, <span class="hljs-number">3</span>), np.uint8)<br>img[:] = (<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>)  <span class="hljs-comment"># 定义画板为白色</span><br>cv2.namedWindow(<span class="hljs-string">'painting'</span>)<br><br><span class="hljs-comment"># 定义默认的笔刷尺寸和颜色</span><br>brush_size, brush_color = <span class="hljs-number">8</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>drawing = <span class="hljs-literal">False</span><br><br><span class="hljs-comment"># 创建rgb三个滑动条</span><br>cv2.createTrackbar(<span class="hljs-string">'r'</span>, <span class="hljs-string">'painting'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, nothing)<br>cv2.createTrackbar(<span class="hljs-string">'g'</span>, <span class="hljs-string">'painting'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, nothing)<br>cv2.createTrackbar(<span class="hljs-string">'b'</span>, <span class="hljs-string">'painting'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, nothing)<br><span class="hljs-comment"># 创建笔刷大小滑动条</span><br>cv2.createTrackbar(<span class="hljs-string">'brush size'</span>, <span class="hljs-string">'painting'</span>, <span class="hljs-number">8</span>, <span class="hljs-number">15</span>, nothing)<br><span class="hljs-comment"># 定义鼠标回调函数</span><br>cv2.setMouseCallback(<span class="hljs-string">'painting'</span>, mouse_event)<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    cv2.imshow(<span class="hljs-string">'painting'</span>, img)<br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">1</span>) == <span class="hljs-number">27</span>:<br>        <span class="hljs-keyword">break</span><br><br>    r = cv2.getTrackbarPos(<span class="hljs-string">'r'</span>, <span class="hljs-string">'painting'</span>)<br>    g = cv2.getTrackbarPos(<span class="hljs-string">'g'</span>, <span class="hljs-string">'painting'</span>)<br>    b = cv2.getTrackbarPos(<span class="hljs-string">'b'</span>, <span class="hljs-string">'painting'</span>)<br>    brush_color = (b, g, r)<br>    brush_size = cv2.getTrackbarPos(<span class="hljs-string">'brush size'</span>, <span class="hljs-string">'painting'</span>)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_paint_ex2.png" width="70%"></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_mouse_handling/py_mouse_handling.html" target="_blank" rel="noopener">Mouse as a Paint-Brush</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 绘图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程8：绘图功能</title>
      <link href="/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B8%EF%BC%9A%E7%BB%98%E5%9B%BE%E5%8A%9F%E8%83%BD/"/>
      <url>/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B8%EF%BC%9A%E7%BB%98%E5%9B%BE%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>学习画线、圆和矩形等多种几何形状，给图片添加文字。</p><p>目标：</p><ul><li>绘制各种几何形状、添加文字</li><li>OpenCV函数<ul><li><code>cv2.line()</code>：直线</li><li><code>cv2.circle()</code>：圆</li><li><code>cv2.rectangle()</code>：矩形</li><li><code>cv2.ellipse()</code>：椭圆</li><li><code>cv2.polylines()</code>：多边形</li><li><code>cv2.putText()</code>：添加文字</li></ul></li></ul><p>画多条直线时，<code>cv2.polylines()</code>要比<code>cv2.line()</code>高效很多。</p><p><strong>所有绘图函数均会直接影响原图片，这点要注意。</strong></p><a id="more"></a><h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><p>绘制形状的函数有一些共同的参数，提前说明一下：</p><ul><li>img：要绘制形状的图片</li><li>color：绘制的颜色<ul><li>彩色图就传入BGR的一组值，如蓝色就是(255,0,0)</li><li>灰度图，传入一个灰度值就行</li></ul></li><li>thickness：线宽，默认为1；<strong>对于矩形/圆之类的封闭形状而言，传入-1表示填充形状</strong></li></ul><p>需要导入的模块和显示图片的通用代码：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>cv2.imshow(<span class="hljs-string">'img'</span>, img)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_drawing_functions.jpg"></p><p>上图就是本教程绘制的最终效果，下面一步步来看：</p><h3 id="画线"><a href="#画线" class="headerlink" title="画线"></a>画线</h3><p>画直线只需指定起点和终点的坐标就行：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 画一条线宽为5的蓝色直线</span><br><span class="hljs-comment"># 参数1：图片，参数2：起点，参数3：终点，参数4：BGR颜色，参数5：线宽</span><br>cv2.line(img, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">512</span>, <span class="hljs-number">512</span>), (<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><h3 id="画矩形"><a href="#画矩形" class="headerlink" title="画矩形"></a>画矩形</h3><p>画矩形需要知道左上角和右下角的坐标：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 画一个绿色边框的矩形</span><br><span class="hljs-comment"># 参数1：图片，参数2：左上角坐标，参数3：右下角坐标，参数4：BGR颜色，参数5：线宽（负数为填充）</span><br>cv2.rectangle(img, (<span class="hljs-number">384</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">510</span>, <span class="hljs-number">128</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>), <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><h3 id="画圆"><a href="#画圆" class="headerlink" title="画圆"></a>画圆</h3><p>画圆需要指定圆心和半径，注意下面的例子中线宽=-1代表填充：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 画一个填充红色的圆</span><br><span class="hljs-comment"># 参数1：图片，参数2：圆心坐标，参数3：半径，参数4：BGR颜色，参数5：线宽（负数为填充）</span><br>cv2.circle(img, (<span class="hljs-number">447</span>, <span class="hljs-number">63</span>), <span class="hljs-number">63</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">-1</span>)<br></code></pre></td></tr></table></figure><h3 id="画椭圆"><a href="#画椭圆" class="headerlink" title="画椭圆"></a>画椭圆</h3><p>画椭圆需要的参数比较多，请对照后面的代码理解这几个参数：</p><ul><li>参数2：椭圆中心(x,y)</li><li>参数3：x/y轴的长度</li><li>参数4：angle—椭圆的旋转角度（顺时针计算）</li><li>参数5：startAngle—椭圆的起始角度</li><li>参数6：endAngle—椭圆的结束角度</li></ul><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在图中心画一个填充的半圆</span><br><span class="hljs-comment"># 参数1：图片，参数2：椭圆中心，参数3：x/y轴长度，参数4：旋转角度</span><br><span class="hljs-comment"># 参数5：椭圆起始角度，参数6：椭圆结束角度，参数7：BGR颜色，参数8：线宽（负数为填充）</span><br>cv2.ellipse(img, (<span class="hljs-number">256</span>, <span class="hljs-number">256</span>), (<span class="hljs-number">100</span>, <span class="hljs-number">50</span>), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">180</span>, (<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">-1</span>)<br></code></pre></td></tr></table></figure><h3 id="画多边形"><a href="#画多边形" class="headerlink" title="画多边形"></a>画多边形</h3><p>画多边形需要指定一系列多边形的顶点坐标，相当于从第一个点到第二个点画直线，再从第二个点到第三个点画直线….</p><p>OpenCV中需要先将多边形的顶点坐标需要变成顶点数×1×2维的矩阵，再来绘制：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 画一个闭合的四边形</span><br><span class="hljs-comment"># 定义四个顶点坐标</span><br>pts = np.array([[<span class="hljs-number">10</span>, <span class="hljs-number">5</span>],  [<span class="hljs-number">50</span>, <span class="hljs-number">10</span>], [<span class="hljs-number">70</span>, <span class="hljs-number">20</span>], [<span class="hljs-number">20</span>, <span class="hljs-number">30</span>]], np.int32)<br><span class="hljs-comment"># 顶点个数：4，矩阵变成顶点数*1*2维（注意numpy中-1的用法）</span><br>pts = pts.reshape((<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br><span class="hljs-comment"># 参数1：图片，参数2：顶点集合，参数3：是否闭合，参数4：BGR颜色</span><br>cv2.polylines(img, [pts], <span class="hljs-literal">True</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>))<br></code></pre></td></tr></table></figure><p><code>cv2.polylines()</code>的参数3如果是False的话，多边形就不闭合，即<strong>最后一个点与第一个点不连</strong>。</p><blockquote><p>经验之谈：如果需要绘制多条直线，使用cv2.polylines()要比cv2.line()高效很多，例如：</p></blockquote><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用cv2.polylines()画多条直线</span><br>line1 = np.array([[<span class="hljs-number">100</span>, <span class="hljs-number">20</span>],  [<span class="hljs-number">300</span>, <span class="hljs-number">20</span>]], np.int32).reshape((<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br>line2 = np.array([[<span class="hljs-number">100</span>, <span class="hljs-number">60</span>],  [<span class="hljs-number">300</span>, <span class="hljs-number">60</span>]], np.int32).reshape((<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br>line3 = np.array([[<span class="hljs-number">100</span>, <span class="hljs-number">100</span>],  [<span class="hljs-number">300</span>, <span class="hljs-number">100</span>]], np.int32).reshape((<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br>cv2.polylines(img, [line1, line2, line3], <span class="hljs-literal">True</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>))<br></code></pre></td></tr></table></figure><h3 id="添加文字"><a href="#添加文字" class="headerlink" title="添加文字"></a>添加文字</h3><p>使用<code>cv2.putText()</code>添加文字，它的参数也比较多，同样请对照后面的代码理解这几个参数：</p><ul><li>参数2：要添加的文本</li><li>参数3：文字的起始坐标（左下角为起点）</li><li>参数4：字体</li><li>参数5：文字大小（缩放比例）</li></ul><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 添加文字</span><br>font = cv2.FONT_HERSHEY_SIMPLEX<br><span class="hljs-comment"># 参数1：图片，参数2：添加的文本内容，参数3：文字起始坐标，参数4：字体类型</span><br><span class="hljs-comment"># 参数5：字体大小，参数6：字体颜色，参数7：线宽，参数8：线型</span><br>cv2.putText(img, <span class="hljs-string">'ex2tron'</span>, (<span class="hljs-number">10</span>, <span class="hljs-number">500</span>), font,<br>            <span class="hljs-number">4</span>, (<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>), <span class="hljs-number">2</span>, lineType=cv2.LINE_AA)<br></code></pre></td></tr></table></figure><p>字体可参考：<a href="https://docs.opencv.org/4.0.0/d6/d6e/group__imgproc__draw.html#ga0f9314ea6e35f99bb23f29567fc16e11" target="_blank" rel="noopener">HersheyFonts</a>。另外，这里有个线型lineType参数，LINE_AA表示抗锯齿线型，具体可见<a href="https://docs.opencv.org/3.3.1/d0/de1/group__core.html#gaf076ef45de481ac96e0ab3dc2c29a777" target="_blank" rel="noopener">LineTypes</a>。</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>能用已学的绘图功能画出OpenCV的logo。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>img = np.zeros((<span class="hljs-number">200</span>, <span class="hljs-number">200</span>, <span class="hljs-number">3</span>), np.uint8)<br><br><span class="hljs-comment"># 画OpenCV的logo，其实很简单</span><br><span class="hljs-comment"># 1.先画一个0°到300°的圆</span><br><span class="hljs-comment"># 2.再在中心画一个跟背景颜色一样的小圆</span><br><span class="hljs-comment"># 3.重复前两部，并且旋转一定的角度即可</span><br><br><span class="hljs-comment"># 画绿色的部分</span><br>cv2.ellipse(img, (<span class="hljs-number">43</span>, <span class="hljs-number">125</span>), (<span class="hljs-number">45</span>, <span class="hljs-number">45</span>), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">300</span>,<br>            (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>), <span class="hljs-number">-1</span>, lineType=cv2.LINE_AA)<br>cv2.circle(img, (<span class="hljs-number">43</span>, <span class="hljs-number">125</span>), <span class="hljs-number">15</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">-1</span>, lineType=cv2.LINE_AA)<br><br><span class="hljs-comment"># 画红色的部分</span><br>cv2.ellipse(img, (<span class="hljs-number">90</span>, <span class="hljs-number">40</span>), (<span class="hljs-number">45</span>, <span class="hljs-number">45</span>), <span class="hljs-number">120</span>, <span class="hljs-number">0</span>, <span class="hljs-number">300</span>,<br>            (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">-1</span>, lineType=cv2.LINE_AA)<br>cv2.circle(img, (<span class="hljs-number">90</span>, <span class="hljs-number">40</span>), <span class="hljs-number">15</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">-1</span>, lineType=cv2.LINE_AA)<br><br><span class="hljs-comment"># 画蓝色的部分</span><br>cv2.ellipse(img, (<span class="hljs-number">137</span>, <span class="hljs-number">125</span>), (<span class="hljs-number">45</span>, <span class="hljs-number">45</span>), <span class="hljs-number">-60</span>, <span class="hljs-number">0</span>, <span class="hljs-number">300</span>,<br>            (<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">-1</span>, lineType=cv2.LINE_AA)<br>cv2.circle(img, (<span class="hljs-number">137</span>, <span class="hljs-number">125</span>), <span class="hljs-number">15</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">-1</span>, lineType=cv2.LINE_AA)<br><br>cv2.imshow(<span class="hljs-string">'img'</span>, img)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_draw_opencv_logo.jpg"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><ul><li><a href="https://docs.opencv.org/4.0.0/d6/d6e/group__imgproc__draw.html#ga7078a9fae8c7e7d13d24dac2520ae4a2" target="_blank" rel="noopener">cv2.line()</a></li><li><a href="https://docs.opencv.org/4.0.0/d6/d6e/group__imgproc__draw.html#gaf10604b069374903dbd0f0488cb43670" target="_blank" rel="noopener">cv2.circle()</a></li><li><a href="https://docs.opencv.org/4.0.0/d6/d6e/group__imgproc__draw.html#ga07d2f74cadcf8e305e810ce8eed13bc9" target="_blank" rel="noopener">cv2.rectangle()</a></li><li><a href="https://docs.opencv.org/4.0.0/d6/d6e/group__imgproc__draw.html#ga28b2267d35786f5f890ca167236cbc69" target="_blank" rel="noopener">cv2.ellipse()</a></li><li><a href="https://docs.opencv.org/4.0.0/d6/d6e/group__imgproc__draw.html#ga5126f47f883d730f633d74f07456c576" target="_blank" rel="noopener">cv2.putText()</a></li><li><a href="https://docs.opencv.org/4.0.0/d6/d6e/group__imgproc__draw.html#ga1ea127ffbbb7e0bfc4fd6fd2eb64263c" target="_blank" rel="noopener">cv2.polylines()</a></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="https://docs.opencv.org/3.3.1/d0/de1/group__core.html#gaf076ef45de481ac96e0ab3dc2c29a777" target="_blank" rel="noopener">LineTypes</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_drawing_functions/py_drawing_functions.html" target="_blank" rel="noopener">Drawing Functions in OpenCV</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 绘图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-OpenCV教程番外篇5：仿射变换与透视变换</title>
      <link href="/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%875%EF%BC%9A%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2%E4%B8%8E%E9%80%8F%E8%A7%86%E5%8F%98%E6%8D%A2/"/>
      <url>/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%875%EF%BC%9A%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2%E4%B8%8E%E9%80%8F%E8%A7%86%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>常见的2D图像变换从原理上讲主要包括基于2×3矩阵的<a href="https://baike.baidu.com/item/仿射变换" target="_blank" rel="noopener">仿射变换</a>和基于3×3矩阵<a href="https://baike.baidu.com/item/透视变换" target="_blank" rel="noopener">透视变换</a>。</p><a id="more"></a><h2 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h2><p>基本的图像变换就是二维坐标的变换：从一种二维坐标(x,y)到另一种二维坐标(u,v)的线性变换：</p><script type="math/tex; mode=display">u=a_1x+b_1y+c_1\\v=a_2x+b_2y+c_2</script><p>如果写成矩阵的形式，就是：</p><script type="math/tex; mode=display">\begin{bmatrix}u\\v\end{bmatrix}=\begin{bmatrix}a_1 & b_1\\a_2 & b_2\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}+\begin{bmatrix}c_1\\c_2\end{bmatrix}</script><p>作如下定义：</p><script type="math/tex; mode=display">R=\begin{bmatrix}a_1&b_1\\a_2&b_2\end{bmatrix},t=\begin{bmatrix}c_1\\c_2\end{bmatrix},T=\begin{bmatrix}R&t\end{bmatrix}</script><p>矩阵T(2×3)就称为<strong>仿射变换的变换矩阵</strong>，R为<strong>线性变换矩阵</strong>，t为<strong>平移矩阵</strong>。</p><p>简单来说，<strong>仿射变换就是线性变换+平移</strong>。变换后直线依然是直线，平行线依然是平行线，直线间的相对位置关系不变，因此<strong>非共线的三个对应点便可确定唯一的一个仿射变换</strong>，<em>线性变换4个自由度+平移2个自由度</em>→<strong>仿射变换自由度为6</strong>。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_warp_affine_image_sample_introduction2.jpg"></p><p>来看下OpenCV中如何实现仿射变换：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>img = cv2.imread(<span class="hljs-string">'drawing.jpg'</span>)<br>rows, cols = img.shape[:<span class="hljs-number">2</span>]<br><br><span class="hljs-comment"># 仿射变换</span><br><br><span class="hljs-comment"># 变换前的三个点</span><br>pts1 = np.float32([[<span class="hljs-number">50</span>, <span class="hljs-number">65</span>], [<span class="hljs-number">150</span>, <span class="hljs-number">65</span>], [<span class="hljs-number">210</span>, <span class="hljs-number">210</span>]])<br><span class="hljs-comment"># 变换后的三个点</span><br>pts2 = np.float32([[<span class="hljs-number">50</span>, <span class="hljs-number">100</span>], [<span class="hljs-number">150</span>, <span class="hljs-number">65</span>], [<span class="hljs-number">100</span>, <span class="hljs-number">250</span>]])<br><br><span class="hljs-comment"># 生成变换矩阵，维数：2*3</span><br>M = cv2.getAffineTransform(pts1, pts2)<br>dst = cv2.warpAffine(img, M, (cols, rows))<br><br>plt.subplot(<span class="hljs-number">121</span>), plt.imshow(img), plt.title(<span class="hljs-string">'input'</span>)<br>plt.subplot(<span class="hljs-number">122</span>), plt.imshow(dst), plt.title(<span class="hljs-string">'output'</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_affine_transformation_drawing.jpg"></p><p>其实平移、旋转、缩放和翻转等变换就是对应了不同的仿射变换矩阵，下面分别来看下。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_image_transformation_sample.jpg"></p><h3 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h3><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_warp_affine_shift_sample.jpg"></p><p>平移就是x和y方向上的直接移动，可以上下/左右移动，自由度为2，变换矩阵可以表示为：</p><script type="math/tex; mode=display">\begin{bmatrix}u\\v\end{bmatrix}=\begin{bmatrix}1&0\\0&1\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}+\begin{bmatrix}t_x\\t_y\end{bmatrix}</script><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_warp_affine_rotation_sample.jpg"></p><p>旋转是坐标轴方向饶原点旋转一定的角度$\theta$，自由度为1，不包含平移，如顺时针旋转可以表示为：</p><script type="math/tex; mode=display">\begin{bmatrix}u\\v\end{bmatrix}=\begin{bmatrix}\cos{\theta}&-\sin{\theta}\\\sin{\theta}&\cos{\theta}\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}+\begin{bmatrix}0\\0\end{bmatrix}</script><blockquote><p>思考：如果不是绕原点，而是可变点，自由度是多少呢？（请看下文刚体变换）</p></blockquote><h3 id="翻转"><a href="#翻转" class="headerlink" title="翻转"></a>翻转</h3><p>翻转是x或y某个方向或全部方向上取反，自由度为2，比如这里以垂直翻转为例：</p><script type="math/tex; mode=display">\begin{bmatrix}u\\v\end{bmatrix}=\begin{bmatrix}1&0\\0&-1\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}+\begin{bmatrix}0\\0\end{bmatrix}</script><h3 id="刚体变换"><a href="#刚体变换" class="headerlink" title="刚体变换"></a>刚体变换</h3><p>旋转+平移也称刚体变换（Rigid Transform），就是说如果<strong>图像变换前后两点间的距离仍然保持不变</strong>，那么这种变化就称为刚体变换。刚体变换包括了平移、旋转和翻转，自由度为3。变换矩阵可以表示为：</p><script type="math/tex; mode=display">\begin{bmatrix}u\\v\end{bmatrix}=\begin{bmatrix}\cos{\theta}&-\sin{\theta}\\\sin{\theta}&\cos{\theta}\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}+\begin{bmatrix}t_x\\t_y\end{bmatrix}</script><p>由于只是旋转和平移，刚体变换保持了直线间的长度不变，所以也称欧式变换（变化前后保持欧氏距离）。</p><h3 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h3><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_warp_affine_scale_sampel.jpg"></p><p>缩放是x和y方向的尺度（倍数）变换，在有些资料上非等比例的缩放也称为拉伸/挤压，等比例缩放自由度为1，非等比例缩放自由度为2，矩阵可以表示为：</p><script type="math/tex; mode=display">\begin{bmatrix}u\\v\end{bmatrix}=\begin{bmatrix}s_x&0\\0&s_y\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}+\begin{bmatrix}0\\0\end{bmatrix}</script><h3 id="相似变换"><a href="#相似变换" class="headerlink" title="相似变换"></a>相似变换</h3><p>相似变换又称缩放旋转，相似变换包含了旋转、等比例缩放和平移等变换，自由度为4。在OpenCV中，旋转就是用相似变换实现的：</p><p>若<strong>缩放比例为scale</strong>，<strong>旋转角度为$\theta$</strong>，<strong>旋转中心是$(center_x,center_y)$</strong>，则仿射变换可以表示为：</p><script type="math/tex; mode=display">\begin{bmatrix}u\\v\end{bmatrix}=\begin{bmatrix}\alpha&\beta\\-\beta&\alpha\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}+\begin{bmatrix}(1-\alpha)center_x-\beta center_y\\\beta center_x+(1-\alpha)center_y\end{bmatrix}</script><p>其中：</p><script type="math/tex; mode=display">\alpha=scale\cdot{\cos\theta},\beta=scale\cdot\sin{\theta}</script><p><strong>相似变换相比刚体变换加了缩放，所以并不会保持欧氏距离不变，但直线间的夹角依然不变。</strong></p><blockquote><p>经验之谈：OpenCV中默认按照逆时针旋转噢~</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_transformation_matrix_dof_summary.jpg" width="70%"></p><div class="table-container"><table><thead><tr><th style="text-align:center">变换</th><th style="text-align:center">矩阵</th><th style="text-align:center">自由度</th><th style="text-align:center">保持性质</th></tr></thead><tbody><tr><td style="text-align:center">平移</td><td style="text-align:center">[I, t]（2×3）</td><td style="text-align:center">2</td><td style="text-align:center">方向/长度/夹角/平行性/直线性</td></tr><tr><td style="text-align:center">刚体</td><td style="text-align:center">[R, t]（2×3）</td><td style="text-align:center">3</td><td style="text-align:center">长度/夹角/平行性/直线性</td></tr><tr><td style="text-align:center">相似</td><td style="text-align:center">[sR, t]（2×3）</td><td style="text-align:center">4</td><td style="text-align:center">夹角/平行性/直线性</td></tr><tr><td style="text-align:center">仿射</td><td style="text-align:center">[T]（2×3）</td><td style="text-align:center">6</td><td style="text-align:center">平行性/直线性</td></tr><tr><td style="text-align:center">透视</td><td style="text-align:center">[T]（3×3）</td><td style="text-align:center">8</td><td style="text-align:center">直线性</td></tr></tbody></table></div><h3 id="透视变换"><a href="#透视变换" class="headerlink" title="透视变换"></a>透视变换</h3><p>前面仿射变换后依然是平行四边形，并不能做到任意的变换。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_warp_perspective_image_sample4.jpg"></p><p><a href="https://baike.baidu.com/item/透视变换" target="_blank" rel="noopener">透视变换</a>（Perspective Transformation）是将二维的图片投影到一个三维视平面上，然后再转换到二维坐标下，所以也称为投影映射（Projective Mapping）。简单来说就是二维→三维→二维的一个过程。</p><script type="math/tex; mode=display">X=a_1x+b_1y+c_1\\Y=a_2x+b_2y+c_2\\Z=a_3x+b_3y+c_3</script><p>可以写成齐次矩阵的形式：</p><script type="math/tex; mode=display">\begin{bmatrix}X\\Y\\Z\end{bmatrix}=\begin{bmatrix}a_1&b_1&c_1\\a_2&b_2&c_2\\a_3&b_3&c_3\end{bmatrix}\begin{bmatrix}x\\y\\1\end{bmatrix}</script><p>其中，$\begin{bmatrix}a_1&amp;b_1\\a_2&amp;b_2\end{bmatrix}$表示线性变换，$\begin{bmatrix}a_3&amp;b_3\end{bmatrix}$产生透视变换，其余表示平移变换，因此<strong>仿射变换是透视变换的子集</strong>。接下来再通过除以Z轴转换成二维坐标：</p><script type="math/tex; mode=display">x'=\frac{X}{Z}=\frac{a_1x+b_1y+c_1}{a_3x+b_3y+c_3}\\y'=\frac{Y}{Z}=\frac{a_2x+b_2y+c_2}{a_3x+b_3y+c_3}</script><p>透视变换相比仿射变换更加灵活，变换后会产生一个新的四边形，但不一定是平行四边形，所以需要<strong>非共线的四个点才能唯一确定</strong>，原图中的直线变换后依然是直线。</p><p>因为四边形包括了所有的平行四边形，所以透视变换包括了所有的仿射变换。</p><p>OpenCV中首先根据变换前后的四个点用<code>cv2.getPerspectiveTransform()</code>生成3×3的变换矩阵，然后再用<code>cv2.warpPerspective()</code>进行透视变换。实战演练一下：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_perspective_transformations_inm.jpg"></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># 透视变换</span><br>img = cv2.imread(<span class="hljs-string">'card.jpg'</span>)<br><br><span class="hljs-comment"># 原图中卡片的四个角点</span><br>pts1 = np.float32([[<span class="hljs-number">148</span>, <span class="hljs-number">80</span>], [<span class="hljs-number">437</span>, <span class="hljs-number">114</span>], [<span class="hljs-number">94</span>, <span class="hljs-number">247</span>], [<span class="hljs-number">423</span>, <span class="hljs-number">288</span>]])<br><span class="hljs-comment"># 变换后分别在左上、右上、左下、右下四个点</span><br>pts2 = np.float32([[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">320</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">178</span>], [<span class="hljs-number">320</span>, <span class="hljs-number">178</span>]])<br><br><span class="hljs-comment"># 生成透视变换矩阵</span><br>M = cv2.getPerspectiveTransform(pts1, pts2)<br><span class="hljs-comment"># 进行透视变换，参数3是目标图像大小</span><br>dst = cv2.warpPerspective(img, M, (<span class="hljs-number">320</span>, <span class="hljs-number">178</span>))<br><br><span class="hljs-comment"># matplotlib默认以RGB通道显示，所以需要用[:, :, ::-1]翻转一下</span><br>plt.subplot(<span class="hljs-number">121</span>), plt.imshow(img[:, :, ::<span class="hljs-number">-1</span>]), plt.title(<span class="hljs-string">'input'</span>)<br>plt.subplot(<span class="hljs-number">122</span>), plt.imshow(dst[:, :, ::<span class="hljs-number">-1</span>]), plt.title(<span class="hljs-string">'output'</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p>当然，<strong>我们后面学习了特征提取之后，就可以自动识别角点了。</strong>透视变换是一项很酷的功能。比如我们经常会用手机去拍身份证和文件，无论你怎么拍，貌似都拍不正或者有边框。如果你使用过手机上面一些扫描类软件，比如”<a href="https://baike.baidu.com/item/扫描全能王" target="_blank" rel="noopener">扫描全能王</a>“，”<a href="https://baike.baidu.com/item/Office Lens" target="_blank" rel="noopener">Office Lens</a>“，它们能很好地矫正图片，这些软件就是应用透视变换实现的。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="http://pic.ex2tron.top/Computer Vision：Algorithms and Applications.pdf" target="_blank" rel="noopener">计算机视觉：算法与应用</a></li><li><a href="https://zh.wikipedia.org/wiki/仿射变换" target="_blank" rel="noopener">维基百科：仿射变换</a></li><li><a href="https://www.zhihu.com/question/20666664" target="_blank" rel="noopener">如何通俗地讲解「仿射变换」这个概念？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 几何变换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程7：图像几何变换</title>
      <link href="/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B7%EF%BC%9A%E5%9B%BE%E5%83%8F%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2/"/>
      <url>/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B7%EF%BC%9A%E5%9B%BE%E5%83%8F%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>学习如何旋转、平移、缩放和翻转图片。</p><p>目标：</p><ul><li>实现旋转、平移、缩放和翻转图片</li><li>OpenCV函数：<ul><li><code>cv2.resize()</code>：缩放图片，可以按指定大小缩放，也可以按比例缩放。</li><li><code>cv2.flip()</code>：翻转图片，可以指定水平、垂直、水平垂直翻转三种方式。</li><li><code>cv2.warpAffine()</code>：仿射变换，可以实现平移和旋转。</li></ul></li></ul><blockquote><p>图像的几何变换从原理上看主要包括两种：基于2×3矩阵的仿射变换（平移、缩放、旋转和翻转等）、基于3×3矩阵的透视变换，感兴趣的小伙伴可参考<a href="[http://huris.xyz/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%875%EF%BC%9A%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2%E4%B8%8E%E9%80%8F%E8%A7%86%E5%8F%98%E6%8D%A2/](http://huris.xyz/2019/08/14/Python-OpenCV教程番外篇5：仿射变换与透视变换/">番外篇：仿射变换与透视变换</a>)。</p></blockquote><a id="more"></a><h2 id="缩放图片"><a href="#缩放图片" class="headerlink" title="缩放图片"></a>缩放图片</h2><p>缩放就是调整图片的大小，使用<code>cv2.resize()</code>函数实现缩放。可以按照比例缩放，也可以按照指定的大小缩放：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br>img = cv2.imread(<span class="hljs-string">'drawing.jpg'</span>)<br><br><span class="hljs-comment"># 1.按照指定的宽度、高度缩放图片</span><br>res = cv2.resize(img, (<span class="hljs-number">132</span>, <span class="hljs-number">150</span>))<br><br><span class="hljs-comment"># 按照比例缩放，如x,y轴均放大一倍</span><br>res2 = cv2.resize(img, <span class="hljs-literal">None</span>, fx=<span class="hljs-number">2</span>, fy=<span class="hljs-number">2</span>, interpolation=cv2.INTER_LINEAR)<br><br>cv2.imshow(<span class="hljs-string">'shrink'</span>, res), cv2.imshow(<span class="hljs-string">'zoom'</span>, res2)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>我们也可以指定缩放方法<code>interpolation</code>，更专业点叫插值方法，默认是<code>INTER_LINEAR</code>，全部可以参考：<a href="https://docs.opencv.org/4.0.0/da/d54/group__imgproc__transform.html#ga5bb5a1fea74ea38e1a5445ca803ff121" target="_blank" rel="noopener">InterpolationFlags</a></p><h2 id="翻转图片"><a href="#翻转图片" class="headerlink" title="翻转图片"></a>翻转图片</h2><p>镜像翻转图片，可以用<code>cv2.flip()</code>函数：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">dst = cv2.flip(img, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>其中，参数2 = 0：垂直翻转(沿x轴)，参数2 &gt; 0: 水平翻转(沿y轴)，参数2 &lt; 0: 水平垂直翻转。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_flip_image_sample.jpg"></p><h2 id="平移图片"><a href="#平移图片" class="headerlink" title="平移图片"></a>平移图片</h2><p>要平移图片，我们需要定义下面这样一个矩阵，$t_x$，$t_y$是向$x$和$y$方向平移的距离：</p><script type="math/tex; mode=display">M=\begin{bmatrix} 0 & -1 & t_x \\ 1 & 0 & t_y\end{bmatrix}</script><p>平移是用仿射变换函数<code>cv2.warpAffine()</code>实现的：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>img = cv2.imread(<span class="hljs-string">'drawing.jpg'</span>)<br><br><span class="hljs-comment"># 平移图片</span><br>rows, cols = img.shape[:<span class="hljs-number">2</span>]<br><span class="hljs-comment"># 定义平移矩阵，需要是numpy的float32类型</span><br><span class="hljs-comment"># x轴平移100，y轴平移50</span><br>M = np.float32([[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">50</span>]])<br>dst = cv2.warpAffine(img, M, (cols, rows))<br><br>cv2.imshow(<span class="hljs-string">'shift'</span>, dst)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_translation_100_50.jpg"></p><h2 id="旋转图片"><a href="#旋转图片" class="headerlink" title="旋转图片"></a>旋转图片</h2><p>旋转同平移一样，也是用仿射变换实现的，因此也需要定义一个变换矩阵。OpenCV直接提供了 <code>cv2.getRotationMatrix2D()</code>函数来生成这个矩阵，该函数有三个参数：</p><ul><li>参数1：图片的旋转中心</li><li>参数2：旋转角度(正：逆时针，负：顺时针)</li><li>参数3：缩放比例，0.5表示缩小一半</li></ul><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 45°顺时针旋转图片并缩小一半</span><br>M = cv2.getRotationMatrix2D((cols / <span class="hljs-number">2</span>, rows / <span class="hljs-number">2</span>), <span class="hljs-number">-45</span>, <span class="hljs-number">0.5</span>)<br>dst = cv2.warpAffine(img, M, (cols, rows))<br><br>cv2.imshow(<span class="hljs-string">'rotation'</span>, dst)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_rotation_45_degree.jpg"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><ul><li><a href="https://docs.opencv.org/4.0.0/da/d54/group__imgproc__transform.html#ga47a974309e9102f5f08231edc7e7529d" target="_blank" rel="noopener">cv2.resize()</a></li><li><a href="https://docs.opencv.org/4.0.0/d2/de8/group__core__array.html#gaca7be533e3dac7feb70fc60635adf441" target="_blank" rel="noopener">cv2.filp()</a></li><li><a href="https://docs.opencv.org/4.0.0/da/d54/group__imgproc__transform.html#ga0203d9ee5fcd28d40dbc4a1ea4451983" target="_blank" rel="noopener">cv2.warpAffine()</a></li><li><a href="https://docs.opencv.org/4.0.0/da/d54/group__imgproc__transform.html#gafbbc470ce83812914a70abfb604f4326" target="_blank" rel="noopener">cv2.getRotationMatrix2D()</a></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_geometric_transformations/py_geometric_transformations.html" target="_blank" rel="noopener">Geometric Transformations of Images</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 几何变换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程番外篇4：Otsu阈值法</title>
      <link href="/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%874%EF%BC%9AOtsu%E9%98%88%E5%80%BC%E6%B3%95/"/>
      <url>/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%874%EF%BC%9AOtsu%E9%98%88%E5%80%BC%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>大部分图像处理任务都需要先进行二值化操作，阈值的选取很关键，Otsu阈值法会自动计算阈值。</p><p><a href="https://baike.baidu.com/item/otsu/16252828" target="_blank" rel="noopener">Otsu阈值法</a>（日本人大津展之提出的，也可称大津算法）非常适用于双峰图片，啥意思呢？</p><a id="more"></a><h2 id="双峰图片"><a href="#双峰图片" class="headerlink" title="双峰图片"></a>双峰图片</h2><p>双峰图片就是指图片的灰度直方图上有两个峰值，直方图就是每个值（0~255）的像素点个数统计，后面会详细介绍。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_bimodal_image_two_peaks.jpg"></p><p>Otsu算法假设这副图片由前景色和背景色组成，通过统计学方法（最大类间方差）选取一个阈值，将前景和背景尽可能分开，我们先来看下代码，然后详细说明下算法原理。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>下面这段代码对比了使用固定阈值和Otsu阈值后的不同结果：</p><p>另外，对含噪点的图像，先进行滤波操作效果会更好。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><br>img = cv2.imread(<span class="hljs-string">'noisy.jpg'</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 固定阈值法</span><br>ret1, th1 = cv2.threshold(img, <span class="hljs-number">100</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY)<br><br><span class="hljs-comment"># Otsu阈值法</span><br>ret2, th2 = cv2.threshold(img, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)<br><br><span class="hljs-comment"># 先进行高斯滤波，再使用Otsu阈值法</span><br>blur = cv2.GaussianBlur(img, (<span class="hljs-number">5</span>, <span class="hljs-number">5</span>), <span class="hljs-number">0</span>)<br>ret3, th3 = cv2.threshold(blur, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY + cv2.THRESH_OTSU)<br></code></pre></td></tr></table></figure><p>下面我们用Matplotlib把原图、直方图和阈值图都显示出来：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python">images = [img, <span class="hljs-number">0</span>, th1,<br>          img, <span class="hljs-number">0</span>, th2,<br>          blur, <span class="hljs-number">0</span>, th3]<br><br>titles = [<span class="hljs-string">'Original'</span>, <span class="hljs-string">'Histogram'</span>, <span class="hljs-string">'Global(v=100)'</span>,<br>          <span class="hljs-string">'Original'</span>, <span class="hljs-string">'Histogram'</span>, <span class="hljs-string">"Otsu's"</span>,<br>          <span class="hljs-string">'Gaussian filtered Image'</span>, <span class="hljs-string">'Histogram'</span>, <span class="hljs-string">"Otsu's"</span>]<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):<br>    <span class="hljs-comment"># 绘制原图</span><br>    plt.subplot(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, i * <span class="hljs-number">3</span> + <span class="hljs-number">1</span>)<br>    plt.imshow(images[i * <span class="hljs-number">3</span>], <span class="hljs-string">'gray'</span>)<br>    plt.title(titles[i * <span class="hljs-number">3</span>], fontsize=<span class="hljs-number">8</span>)<br>    plt.xticks([]), plt.yticks([])<br><br>    <span class="hljs-comment"># 绘制直方图plt.hist，ravel函数将数组降成一维</span><br>    plt.subplot(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, i * <span class="hljs-number">3</span> + <span class="hljs-number">2</span>)<br>    plt.hist(images[i * <span class="hljs-number">3</span>].ravel(), <span class="hljs-number">256</span>)<br>    plt.title(titles[i * <span class="hljs-number">3</span> + <span class="hljs-number">1</span>], fontsize=<span class="hljs-number">8</span>)<br>    plt.xticks([]), plt.yticks([])<br><br>    <span class="hljs-comment"># 绘制阈值图</span><br>    plt.subplot(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, i * <span class="hljs-number">3</span> + <span class="hljs-number">3</span>)<br>    plt.imshow(images[i * <span class="hljs-number">3</span> + <span class="hljs-number">2</span>], <span class="hljs-string">'gray'</span>)<br>    plt.title(titles[i * <span class="hljs-number">3</span> + <span class="hljs-number">2</span>], fontsize=<span class="hljs-number">8</span>)<br>    plt.xticks([]), plt.yticks([])<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_otsu_vs_simple_thresholding.jpg"></p><p>可以看到，Otsu阈值明显优于固定阈值，省去了不断尝试阈值判断效果好坏的过程。其中，绘制直方图时，使用了numpy中的<a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ravel.html" target="_blank" rel="noopener">ravel()</a>函数，它会将原矩阵压缩成一维数组，便于画直方图。</p><h2 id="Otsu算法"><a href="#Otsu算法" class="headerlink" title="Otsu算法"></a>Otsu算法</h2><p>Otsu阈值法将整幅图分为前景（目标）和背景，以下是一些符号规定：</p><ul><li>$T$：分割阈值</li><li>$N_0$：前景像素点数</li><li>$N_1$：背景像素点数</li><li>$w_0$：前景的像素点数占整幅图像的比例</li><li>$w_1$：背景的像素点数占整幅图像的比例</li><li>$\mu_0$：前景的平均像素值</li><li>$\mu_1$：背景的平均像素值</li><li>$μ$：整幅图的平均像素值</li><li>$rows×cols$：图像的行数和列数</li></ul><p>结合下图会更容易理解一些，有一副大小为4×4的图片，假设阈值T为1，那么：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_otsu_theory_sample.jpg"></p><p>其实很好理解，$N_0+N_1$就是总的像素点个数，也就是行数乘列数：</p><script type="math/tex; mode=display">N_0 + N_1 = rows \times cols</script><p>$w_0$和$w_1$是前/背景所占的比例，也就是：</p><script type="math/tex; mode=display">w_0 = \frac{N_0}{rows\times{cols}}</script><script type="math/tex; mode=display">w_1 = \frac{N_1}{rows\times{cols}}</script><script type="math/tex; mode=display">w_0+w_1=1</script><p>整幅图的平均像素值就是：</p><script type="math/tex; mode=display">\mu=w_0\times{\mu_0}+w_1\times{\mu_1}</script><p>此时，我们定义一个前景$\mu_0$与背景$\mu_1$的方差$g$：</p><script type="math/tex; mode=display">g=w_0(\mu_0-\mu)^{2}+w_1(\mu_1-\mu)^{2}</script><p>将前述的(4)、(5)、(6)公式整合在一起，便是：</p><script type="math/tex; mode=display">g=w_0w_1(\mu_0-\mu_1)^{2}</script><p><strong>$g$就是前景与背景两类之间的方差，这个值越大，说明前景和背景的差别也就越大，效果越好。Otsu算法便是遍历阈值T，使得$g$最大，所以又称为最大类间方差法。</strong>基本上双峰图片的阈值T在两峰之间的谷底。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><ul><li><a href="https://docs.opencv.org/4.0.0/d7/d1b/group__imgproc__misc.html#gaa9e58d2860d4afa658ef70a9b1115576" target="_blank" rel="noopener">cv2.ThresholdTypes</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/d86/group__imgproc__filter.html#gaabe8c836e97159a9193fb0b11ac52cf1" target="_blank" rel="noopener">cv2.GaussianBlur()</a></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ravel.html" target="_blank" rel="noopener">numpy.ravel</a></li><li><a href="https://en.wikipedia.org/wiki/Otsu&#39;s_method" target="_blank" rel="noopener">Otsu’s Method(wikipedia)</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_thresholding/py_thresholding.html" target="_blank" rel="noopener">Image Thresholding</a></li><li><a href="https://blog.csdn.net/u011776903/article/details/73274802" target="_blank" rel="noopener">一维OTSU法、最小交叉熵法、二维OTSU法及C++源码</a></li><li><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4310076" target="_blank" rel="noopener">Otsu N. A threshold selection method from gray-level histograms[J\]. IEEE transactions on systems, man, and cybernetics, 1979, 9(1): 62-66.</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 阈值 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程6：阈值分割</title>
      <link href="/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B6%EF%BC%9A%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/"/>
      <url>/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B6%EF%BC%9A%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/</url>
      
        <content type="html"><![CDATA[<p>学习使用不同的阈值方法”二值化”图像。</p><p>目标：</p><ul><li>使用固定阈值、自适应阈值和Otsu阈值法“二值化”图像</li><li>二值化跟阈值分割并不等同。针对不同的图片，可以采用不同的阈值方法。</li><li>OpenCV函数：<ul><li><code>cv2.threshould()</code>：用来进行固定阈值分割。</li><li><code>cv2.adaptiveThreshold()</code>：固定阈值不适用于光线不均匀的图片，所以用该函数进行自适应阈值分割。</li></ul></li></ul><a id="more"></a><h2 id="固定阈值分割"><a href="#固定阈值分割" class="headerlink" title="固定阈值分割"></a>固定阈值分割</h2><p>固定阈值分割很直接，一句话说就是像素点值大于阈值变成一类值，小于阈值变成另一类值。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_threshold_binary_demo.jpg"></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br><span class="hljs-comment"># 灰度图读入</span><br>img = cv2.imread(<span class="hljs-string">'gradient.jpg'</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 阈值分割，ret：return value缩写，代表当前的阈值，暂时不用理会</span><br>ret, th = cv2.threshold(img, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY)<br>cv2.imshow(<span class="hljs-string">'thresh'</span>, th)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><code>cv2.threshold()</code>用来实现阈值分割，ret是return value缩写，代表当前的阈值，暂时不用理会。函数有4个参数：</p><ul><li>参数1：要处理的原图，<strong>一般是灰度图</strong></li><li>参数2：设定的阈值</li><li>参数3：最大阈值，一般为255</li><li>参数4：阈值的方式，主要有5种，详情：<a href="https://docs.opencv.org/4.0.0/d7/d1b/group__imgproc__misc.html#gaa9e58d2860d4afa658ef70a9b1115576" target="_blank" rel="noopener">ThresholdTypes</a></li></ul><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># 灰度图读入</span><br>img = cv2.imread(<span class="hljs-string">'gradient.jpg'</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 应用5种不同的阈值方法</span><br>ret, th1 = cv2.threshold(img, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY)<br>ret, th2 = cv2.threshold(img, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY_INV)<br>ret, th3 = cv2.threshold(img, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_TRUNC)<br>ret, th4 = cv2.threshold(img, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_TOZERO)<br>ret, th5 = cv2.threshold(img, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_TOZERO_INV)<br><br>titles = [<span class="hljs-string">'Original'</span>, <span class="hljs-string">'BINARY'</span>, <span class="hljs-string">'BINARY_INV'</span>, <span class="hljs-string">'TRUNC'</span>, <span class="hljs-string">'TOZERO'</span>, <span class="hljs-string">'TOZERO_INV'</span>]<br>images = [img, th1, th2, th3, th4, th5]<br><br><span class="hljs-comment"># 使用Matplotlib显示</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">6</span>):<br>    plt.subplot(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, i + <span class="hljs-number">1</span>)<br>    plt.imshow(images[i], <span class="hljs-string">'gray'</span>)<br>    plt.title(titles[i], fontsize=<span class="hljs-number">8</span>)<br>    plt.xticks([]), plt.yticks([])  <span class="hljs-comment"># 隐藏坐标轴</span><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_different_threshold_demo.jpg"></p><blockquote><p>经验之谈：很多人误以为阈值分割就是<a href="https://baike.baidu.com/item/二值化" target="_blank" rel="noopener">二值化</a>。从上图中可以发现，两者并不等同，阈值分割结果是两类值，而不是两个值，所以教程开头我把二值化加了引号。</p></blockquote><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_different_thresholds_theory.jpg" width="70%"></p><h2 id="自适应阈值"><a href="#自适应阈值" class="headerlink" title="自适应阈值"></a>自适应阈值</h2><p>看得出来固定阈值是在整幅图片上应用一个阈值进行分割，<em>它并不适用于明暗分布不均的图片</em>。 <code>cv2.adaptiveThreshold()</code>自适应阈值会每次取图片的一小部分计算阈值，这样图片不同区域的阈值就不尽相同。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br><span class="hljs-comment"># 自适应阈值对比固定阈值</span><br>img = cv2.imread(<span class="hljs-string">'sudoku.jpg'</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 固定阈值</span><br>ret, th1 = cv2.threshold(img, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY)<br><br><span class="hljs-comment"># 自适应阈值</span><br>th2 = cv2.adaptiveThreshold(<br>    img, <span class="hljs-number">255</span>, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, <span class="hljs-number">11</span>, <span class="hljs-number">4</span>)<br><br>th3 = cv2.adaptiveThreshold(<br>    img, <span class="hljs-number">255</span>, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, <span class="hljs-number">17</span>, <span class="hljs-number">6</span>)<br><br>titles = [<span class="hljs-string">'Original'</span>, <span class="hljs-string">'Global(v = 127)'</span>, <span class="hljs-string">'Adaptive Mean'</span>, <span class="hljs-string">'Adaptive Gaussian'</span>]<br>images = [img, th1, th2, th3]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">4</span>):<br>    plt.subplot(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, i + <span class="hljs-number">1</span>), plt.imshow(images[i], <span class="hljs-string">'gray'</span>)<br>    plt.title(titles[i], fontsize=<span class="hljs-number">8</span>)<br>    plt.xticks([]), plt.yticks([])<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_adaptive_vs_global_thresholding.jpg"></p><p><code>cv2.adaptiveThreshold()</code>有5个参数，其实很好理解：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">th2 = cv2.adaptiveThreshold(<br>    img, <span class="hljs-number">255</span>, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, <span class="hljs-number">11</span>, <span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><ul><li>参数1：要处理的原图</li><li>参数2：最大阈值，一般为255</li><li>参数3：小区域阈值的计算方式<ul><li><code>ADAPTIVE_THRESH_MEAN_C</code>：小区域内取均值</li><li><code>ADAPTIVE_THRESH_GAUSSIAN_C</code>：小区域内加权求和，权重是个高斯核</li></ul></li><li>参数4：阈值方式（跟前面讲的那5种相同）</li><li>参数5：小区域的面积，如11就是11*11的小块</li><li>参数6：最终阈值等于小区域计算出的阈值再减去此值</li></ul><p>如果你没看懂上面的参数也不要紧，暂时会用就行，当然我建议你调整下参数看看不同的结果。</p><h2 id="Otsu阈值"><a href="#Otsu阈值" class="headerlink" title="Otsu阈值"></a>Otsu阈值</h2><p>在前面固定阈值中，我们是随便选了一个阈值如127，那如何知道我们选的这个阈值效果好不好呢？答案是：不断尝试，所以这种方法在很多文献中都被称为经验阈值。</p><p><a href="https://baike.baidu.com/item/otsu/16252828" target="_blank" rel="noopener">Otsu阈值法</a>就提供了一种自动高效的二值化方法，不过我们直方图还没学，这里暂时略过。</p><p>具体可以参考<a href="[http://huris.xyz/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%874%EF%BC%9AOtsu%E9%98%88%E5%80%BC%E6%B3%95/](http://huris.xyz/2019/08/14/Python-OpenCV教程番外篇4：Otsu阈值法/">Python+OpenCV教程番外篇4：Otsu阈值法</a>)</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><p><a href="https://docs.opencv.org/4.0.0/d7/d1b/group__imgproc__misc.html#gae8a4a146d1ca78c626a53577199e9c57" target="_blank" rel="noopener"><br>cv2.threshold()</a></p><p><a href="https://docs.opencv.org/4.0.0/d7/d1b/group__imgproc__misc.html#ga72b913f352e4a1b1b397736707afcde3" target="_blank" rel="noopener">cv2.adaptiveThreshold()</a></p><p><a href="https://docs.opencv.org/4.0.0/d7/d1b/group__imgproc__misc.html#gaa9e58d2860d4afa658ef70a9b1115576" target="_blank" rel="noopener">cv2.ThresholdTypes()</a></p><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><ul><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_thresholding/py_thresholding.html" target="_blank" rel="noopener">Image Thresholding</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 阈值 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程5：颜色空间转换</title>
      <link href="/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B5%EF%BC%9A%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2/"/>
      <url>/2019/08/14/Python-OpenCV%E6%95%99%E7%A8%8B5%EF%BC%9A%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>学习如何进行图片的颜色空间转换，视频中追踪特定颜色的物体。</p><p>目标：</p><ul><li><p>颜色空间转换，如BGR↔Gray，BGR↔HSV等</p></li><li><p>追踪视频中特定颜色的物体</p></li><li><p>HSV颜色模型常用于颜色识别。要想知道某种颜色在HSV下的值，可以将它的BGR值用<code>cvtColor()</code>转换得到。</p></li><li><p>OpenCV函数：</p><ul><li><p><code>cv2.cvtColor()</code>：用来进行颜色空间转换，常用BGR↔Gray，BGR↔HSV。</p><p>  <code>hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)</code></p></li><li><p><code>cv2.inRange()</code>：指定颜色范围。</p><p> <code>mask = cv2.inRange(hsv, lower_blue, upper_blue)</code></p></li></ul></li></ul><a id="more"></a><h2 id="颜色空间转换"><a href="#颜色空间转换" class="headerlink" title="颜色空间转换"></a>颜色空间转换</h2><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br>img = cv2.imread(<span class="hljs-string">'lena.jpg'</span>)<br><br><span class="hljs-comment"># 转成灰度图</span><br><span class="hljs-comment"># cv2.cvtColor()用来进行颜色模型转换</span><br><span class="hljs-comment"># 参数1是要转换的图片</span><br><span class="hljs-comment"># 参数2是转换模式</span><br>img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br><br>cv2.imshow(<span class="hljs-string">'img'</span>, img)<br>cv2.imshow(<span class="hljs-string">'gray'</span>, img_gray)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><code>COLOR_BGR2GRAY</code>表示BGR→Gray，可用下面的代码显示所有的转换模式：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">flags = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> dir(cv2) <span class="hljs-keyword">if</span> i.startswith(<span class="hljs-string">'COLOR_'</span>)]<br>print(flags)<br><br>**************************************************************************<br><br>运行结果：<br>[<span class="hljs-string">'COLOR_BAYER_BG2BGR'</span>, <span class="hljs-string">'COLOR_BAYER_BG2BGRA'</span>, <span class="hljs-string">'COLOR_BAYER_BG2BGR_EA'</span>, <span class="hljs-string">'COLOR_BAYER_BG2BGR_VNG'</span>, <span class="hljs-string">'COLOR_BAYER_BG2GRAY'</span>, <span class="hljs-string">'COLOR_BAYER_BG2RGB'</span>, <span class="hljs-string">'COLOR_BAYER_BG2RGBA'</span>, <span class="hljs-string">'COLOR_BAYER_BG2RGB_EA'</span>, <span class="hljs-string">'COLOR_BAYER_BG2RGB_VNG'</span>, <span class="hljs-string">'COLOR_BAYER_GB2BGR'</span>, <span class="hljs-string">'COLOR_BAYER_GB2BGRA'</span>, <span class="hljs-string">'COLOR_BAYER_GB2BGR_EA'</span>, <span class="hljs-string">'COLOR_BAYER_GB2BGR_VNG'</span>, <span class="hljs-string">'COLOR_BAYER_GB2GRAY'</span>, <span class="hljs-string">'COLOR_BAYER_GB2RGB'</span>, <span class="hljs-string">'COLOR_BAYER_GB2RGBA'</span>, <span class="hljs-string">'COLOR_BAYER_GB2RGB_EA'</span>, <span class="hljs-string">'COLOR_BAYER_GB2RGB_VNG'</span>, <span class="hljs-string">'COLOR_BAYER_GR2BGR'</span>, <span class="hljs-string">'COLOR_BAYER_GR2BGRA'</span>, <span class="hljs-string">'COLOR_BAYER_GR2BGR_EA'</span>, <span class="hljs-string">'COLOR_BAYER_GR2BGR_VNG'</span>, <span class="hljs-string">'COLOR_BAYER_GR2GRAY'</span>, <span class="hljs-string">'COLOR_BAYER_GR2RGB'</span>, <span class="hljs-string">'COLOR_BAYER_GR2RGBA'</span>, <span class="hljs-string">'COLOR_BAYER_GR2RGB_EA'</span>, <span class="hljs-string">'COLOR_BAYER_GR2RGB_VNG'</span>, <span class="hljs-string">'COLOR_BAYER_RG2BGR'</span>, <span class="hljs-string">'COLOR_BAYER_RG2BGRA'</span>, <span class="hljs-string">'COLOR_BAYER_RG2BGR_EA'</span>, <span class="hljs-string">'COLOR_BAYER_RG2BGR_VNG'</span>, <span class="hljs-string">'COLOR_BAYER_RG2GRAY'</span>, <span class="hljs-string">'COLOR_BAYER_RG2RGB'</span>, <span class="hljs-string">'COLOR_BAYER_RG2RGBA'</span>, <span class="hljs-string">'COLOR_BAYER_RG2RGB_EA'</span>, <span class="hljs-string">'COLOR_BAYER_RG2RGB_VNG'</span>, <span class="hljs-string">'COLOR_BGR2BGR555'</span>, <span class="hljs-string">'COLOR_BGR2BGR565'</span>, <span class="hljs-string">'COLOR_BGR2BGRA'</span>, <span class="hljs-string">'COLOR_BGR2GRAY'</span>, <span class="hljs-string">'COLOR_BGR2HLS'</span>, <span class="hljs-string">'COLOR_BGR2HLS_FULL'</span>, <span class="hljs-string">'COLOR_BGR2HSV'</span>, <span class="hljs-string">'COLOR_BGR2HSV_FULL'</span>, <span class="hljs-string">'COLOR_BGR2LAB'</span>, <span class="hljs-string">'COLOR_BGR2LUV'</span>, <span class="hljs-string">'COLOR_BGR2Lab'</span>, <span class="hljs-string">'COLOR_BGR2Luv'</span>, <span class="hljs-string">'COLOR_BGR2RGB'</span>, <span class="hljs-string">'COLOR_BGR2RGBA'</span>, <span class="hljs-string">'COLOR_BGR2XYZ'</span>, <span class="hljs-string">'COLOR_BGR2YCR_CB'</span>, <span class="hljs-string">'COLOR_BGR2YCrCb'</span>, <span class="hljs-string">'COLOR_BGR2YUV'</span>, <span class="hljs-string">'COLOR_BGR2YUV_I420'</span>, <span class="hljs-string">'COLOR_BGR2YUV_IYUV'</span>, <span class="hljs-string">'COLOR_BGR2YUV_YV12'</span>, <span class="hljs-string">'COLOR_BGR5552BGR'</span>, <span class="hljs-string">'COLOR_BGR5552BGRA'</span>, <span class="hljs-string">'COLOR_BGR5552GRAY'</span>, <span class="hljs-string">'COLOR_BGR5552RGB'</span>, <span class="hljs-string">'COLOR_BGR5552RGBA'</span>, <span class="hljs-string">'COLOR_BGR5652BGR'</span>, <span class="hljs-string">'COLOR_BGR5652BGRA'</span>, <span class="hljs-string">'COLOR_BGR5652GRAY'</span>, <span class="hljs-string">'COLOR_BGR5652RGB'</span>, <span class="hljs-string">'COLOR_BGR5652RGBA'</span>, <span class="hljs-string">'COLOR_BGRA2BGR'</span>, <span class="hljs-string">'COLOR_BGRA2BGR555'</span>, <span class="hljs-string">'COLOR_BGRA2BGR565'</span>, <span class="hljs-string">'COLOR_BGRA2GRAY'</span>, <span class="hljs-string">'COLOR_BGRA2RGB'</span>, <span class="hljs-string">'COLOR_BGRA2RGBA'</span>, <span class="hljs-string">'COLOR_BGRA2YUV_I420'</span>, <span class="hljs-string">'COLOR_BGRA2YUV_IYUV'</span>, <span class="hljs-string">'COLOR_BGRA2YUV_YV12'</span>, <span class="hljs-string">'COLOR_BayerBG2BGR'</span>, <span class="hljs-string">'COLOR_BayerBG2BGRA'</span>, <span class="hljs-string">'COLOR_BayerBG2BGR_EA'</span>, <span class="hljs-string">'COLOR_BayerBG2BGR_VNG'</span>, <span class="hljs-string">'COLOR_BayerBG2GRAY'</span>, <span class="hljs-string">'COLOR_BayerBG2RGB'</span>, <span class="hljs-string">'COLOR_BayerBG2RGBA'</span>, <span class="hljs-string">'COLOR_BayerBG2RGB_EA'</span>, <span class="hljs-string">'COLOR_BayerBG2RGB_VNG'</span>, <span class="hljs-string">'COLOR_BayerGB2BGR'</span>, <span class="hljs-string">'COLOR_BayerGB2BGRA'</span>, <span class="hljs-string">'COLOR_BayerGB2BGR_EA'</span>, <span class="hljs-string">'COLOR_BayerGB2BGR_VNG'</span>, <span class="hljs-string">'COLOR_BayerGB2GRAY'</span>, <span class="hljs-string">'COLOR_BayerGB2RGB'</span>, <span class="hljs-string">'COLOR_BayerGB2RGBA'</span>, <span class="hljs-string">'COLOR_BayerGB2RGB_EA'</span>, <span class="hljs-string">'COLOR_BayerGB2RGB_VNG'</span>, <span class="hljs-string">'COLOR_BayerGR2BGR'</span>, <span class="hljs-string">'COLOR_BayerGR2BGRA'</span>, <span class="hljs-string">'COLOR_BayerGR2BGR_EA'</span>, <span class="hljs-string">'COLOR_BayerGR2BGR_VNG'</span>, <span class="hljs-string">'COLOR_BayerGR2GRAY'</span>, <span class="hljs-string">'COLOR_BayerGR2RGB'</span>, <span class="hljs-string">'COLOR_BayerGR2RGBA'</span>, <span class="hljs-string">'COLOR_BayerGR2RGB_EA'</span>, <span class="hljs-string">'COLOR_BayerGR2RGB_VNG'</span>, <span class="hljs-string">'COLOR_BayerRG2BGR'</span>, <span class="hljs-string">'COLOR_BayerRG2BGRA'</span>, <span class="hljs-string">'COLOR_BayerRG2BGR_EA'</span>, <span class="hljs-string">'COLOR_BayerRG2BGR_VNG'</span>, <span class="hljs-string">'COLOR_BayerRG2GRAY'</span>, <span class="hljs-string">'COLOR_BayerRG2RGB'</span>, <span class="hljs-string">'COLOR_BayerRG2RGBA'</span>, <span class="hljs-string">'COLOR_BayerRG2RGB_EA'</span>, <span class="hljs-string">'COLOR_BayerRG2RGB_VNG'</span>, <span class="hljs-string">'COLOR_COLORCVT_MAX'</span>, <span class="hljs-string">'COLOR_GRAY2BGR'</span>, <span class="hljs-string">'COLOR_GRAY2BGR555'</span>, <span class="hljs-string">'COLOR_GRAY2BGR565'</span>, <span class="hljs-string">'COLOR_GRAY2BGRA'</span>, <span class="hljs-string">'COLOR_GRAY2RGB'</span>, <span class="hljs-string">'COLOR_GRAY2RGBA'</span>, <span class="hljs-string">'COLOR_HLS2BGR'</span>, <span class="hljs-string">'COLOR_HLS2BGR_FULL'</span>, <span class="hljs-string">'COLOR_HLS2RGB'</span>, <span class="hljs-string">'COLOR_HLS2RGB_FULL'</span>, <span class="hljs-string">'COLOR_HSV2BGR'</span>, <span class="hljs-string">'COLOR_HSV2BGR_FULL'</span>, <span class="hljs-string">'COLOR_HSV2RGB'</span>, <span class="hljs-string">'COLOR_HSV2RGB_FULL'</span>, <span class="hljs-string">'COLOR_LAB2BGR'</span>, <span class="hljs-string">'COLOR_LAB2LBGR'</span>, <span class="hljs-string">'COLOR_LAB2LRGB'</span>, <span class="hljs-string">'COLOR_LAB2RGB'</span>, <span class="hljs-string">'COLOR_LBGR2LAB'</span>, <span class="hljs-string">'COLOR_LBGR2LUV'</span>, <span class="hljs-string">'COLOR_LBGR2Lab'</span>, <span class="hljs-string">'COLOR_LBGR2Luv'</span>, <span class="hljs-string">'COLOR_LRGB2LAB'</span>, <span class="hljs-string">'COLOR_LRGB2LUV'</span>, <span class="hljs-string">'COLOR_LRGB2Lab'</span>, <span class="hljs-string">'COLOR_LRGB2Luv'</span>, <span class="hljs-string">'COLOR_LUV2BGR'</span>, <span class="hljs-string">'COLOR_LUV2LBGR'</span>, <span class="hljs-string">'COLOR_LUV2LRGB'</span>, <span class="hljs-string">'COLOR_LUV2RGB'</span>, <span class="hljs-string">'COLOR_Lab2BGR'</span>, <span class="hljs-string">'COLOR_Lab2LBGR'</span>, <span class="hljs-string">'COLOR_Lab2LRGB'</span>, <span class="hljs-string">'COLOR_Lab2RGB'</span>, <span class="hljs-string">'COLOR_Luv2BGR'</span>, <span class="hljs-string">'COLOR_Luv2LBGR'</span>, <span class="hljs-string">'COLOR_Luv2LRGB'</span>, <span class="hljs-string">'COLOR_Luv2RGB'</span>, <span class="hljs-string">'COLOR_M_RGBA2RGBA'</span>, <span class="hljs-string">'COLOR_RGB2BGR'</span>, <span class="hljs-string">'COLOR_RGB2BGR555'</span>, <span class="hljs-string">'COLOR_RGB2BGR565'</span>, <span class="hljs-string">'COLOR_RGB2BGRA'</span>, <span class="hljs-string">'COLOR_RGB2GRAY'</span>, <span class="hljs-string">'COLOR_RGB2HLS'</span>, <span class="hljs-string">'COLOR_RGB2HLS_FULL'</span>, <span class="hljs-string">'COLOR_RGB2HSV'</span>, <span class="hljs-string">'COLOR_RGB2HSV_FULL'</span>, <span class="hljs-string">'COLOR_RGB2LAB'</span>, <span class="hljs-string">'COLOR_RGB2LUV'</span>, <span class="hljs-string">'COLOR_RGB2Lab'</span>, <span class="hljs-string">'COLOR_RGB2Luv'</span>, <span class="hljs-string">'COLOR_RGB2RGBA'</span>, <span class="hljs-string">'COLOR_RGB2XYZ'</span>, <span class="hljs-string">'COLOR_RGB2YCR_CB'</span>, <span class="hljs-string">'COLOR_RGB2YCrCb'</span>, <span class="hljs-string">'COLOR_RGB2YUV'</span>, <span class="hljs-string">'COLOR_RGB2YUV_I420'</span>, <span class="hljs-string">'COLOR_RGB2YUV_IYUV'</span>, <span class="hljs-string">'COLOR_RGB2YUV_YV12'</span>, <span class="hljs-string">'COLOR_RGBA2BGR'</span>, <span class="hljs-string">'COLOR_RGBA2BGR555'</span>, <span class="hljs-string">'COLOR_RGBA2BGR565'</span>, <span class="hljs-string">'COLOR_RGBA2BGRA'</span>, <span class="hljs-string">'COLOR_RGBA2GRAY'</span>, <span class="hljs-string">'COLOR_RGBA2M_RGBA'</span>, <span class="hljs-string">'COLOR_RGBA2RGB'</span>, <span class="hljs-string">'COLOR_RGBA2YUV_I420'</span>, <span class="hljs-string">'COLOR_RGBA2YUV_IYUV'</span>, <span class="hljs-string">'COLOR_RGBA2YUV_YV12'</span>, <span class="hljs-string">'COLOR_RGBA2mRGBA'</span>, <span class="hljs-string">'COLOR_XYZ2BGR'</span>, <span class="hljs-string">'COLOR_XYZ2RGB'</span>, <span class="hljs-string">'COLOR_YCR_CB2BGR'</span>, <span class="hljs-string">'COLOR_YCR_CB2RGB'</span>, <span class="hljs-string">'COLOR_YCrCb2BGR'</span>, <span class="hljs-string">'COLOR_YCrCb2RGB'</span>, <span class="hljs-string">'COLOR_YUV2BGR'</span>, <span class="hljs-string">'COLOR_YUV2BGRA_I420'</span>, <span class="hljs-string">'COLOR_YUV2BGRA_IYUV'</span>, <span class="hljs-string">'COLOR_YUV2BGRA_NV12'</span>, <span class="hljs-string">'COLOR_YUV2BGRA_NV21'</span>, <span class="hljs-string">'COLOR_YUV2BGRA_UYNV'</span>, <span class="hljs-string">'COLOR_YUV2BGRA_UYVY'</span>, <span class="hljs-string">'COLOR_YUV2BGRA_Y422'</span>, <span class="hljs-string">'COLOR_YUV2BGRA_YUNV'</span>, <span class="hljs-string">'COLOR_YUV2BGRA_YUY2'</span>, <span class="hljs-string">'COLOR_YUV2BGRA_YUYV'</span>, <span class="hljs-string">'COLOR_YUV2BGRA_YV12'</span>, <span class="hljs-string">'COLOR_YUV2BGRA_YVYU'</span>, <span class="hljs-string">'COLOR_YUV2BGR_I420'</span>, <span class="hljs-string">'COLOR_YUV2BGR_IYUV'</span>, <span class="hljs-string">'COLOR_YUV2BGR_NV12'</span>, <span class="hljs-string">'COLOR_YUV2BGR_NV21'</span>, <span class="hljs-string">'COLOR_YUV2BGR_UYNV'</span>, <span class="hljs-string">'COLOR_YUV2BGR_UYVY'</span>, <span class="hljs-string">'COLOR_YUV2BGR_Y422'</span>, <span class="hljs-string">'COLOR_YUV2BGR_YUNV'</span>, <span class="hljs-string">'COLOR_YUV2BGR_YUY2'</span>, <span class="hljs-string">'COLOR_YUV2BGR_YUYV'</span>, <span class="hljs-string">'COLOR_YUV2BGR_YV12'</span>, <span class="hljs-string">'COLOR_YUV2BGR_YVYU'</span>, <span class="hljs-string">'COLOR_YUV2GRAY_420'</span>, <span class="hljs-string">'COLOR_YUV2GRAY_I420'</span>, <span class="hljs-string">'COLOR_YUV2GRAY_IYUV'</span>, <span class="hljs-string">'COLOR_YUV2GRAY_NV12'</span>, <span class="hljs-string">'COLOR_YUV2GRAY_NV21'</span>, <span class="hljs-string">'COLOR_YUV2GRAY_UYNV'</span>, <span class="hljs-string">'COLOR_YUV2GRAY_UYVY'</span>, <span class="hljs-string">'COLOR_YUV2GRAY_Y422'</span>, <span class="hljs-string">'COLOR_YUV2GRAY_YUNV'</span>, <span class="hljs-string">'COLOR_YUV2GRAY_YUY2'</span>, <span class="hljs-string">'COLOR_YUV2GRAY_YUYV'</span>, <span class="hljs-string">'COLOR_YUV2GRAY_YV12'</span>, <span class="hljs-string">'COLOR_YUV2GRAY_YVYU'</span>, <span class="hljs-string">'COLOR_YUV2RGB'</span>, <span class="hljs-string">'COLOR_YUV2RGBA_I420'</span>, <span class="hljs-string">'COLOR_YUV2RGBA_IYUV'</span>, <span class="hljs-string">'COLOR_YUV2RGBA_NV12'</span>, <span class="hljs-string">'COLOR_YUV2RGBA_NV21'</span>, <span class="hljs-string">'COLOR_YUV2RGBA_UYNV'</span>, <span class="hljs-string">'COLOR_YUV2RGBA_UYVY'</span>, <span class="hljs-string">'COLOR_YUV2RGBA_Y422'</span>, <span class="hljs-string">'COLOR_YUV2RGBA_YUNV'</span>, <span class="hljs-string">'COLOR_YUV2RGBA_YUY2'</span>, <span class="hljs-string">'COLOR_YUV2RGBA_YUYV'</span>, <span class="hljs-string">'COLOR_YUV2RGBA_YV12'</span>, <span class="hljs-string">'COLOR_YUV2RGBA_YVYU'</span>, <span class="hljs-string">'COLOR_YUV2RGB_I420'</span>, <span class="hljs-string">'COLOR_YUV2RGB_IYUV'</span>, <span class="hljs-string">'COLOR_YUV2RGB_NV12'</span>, <span class="hljs-string">'COLOR_YUV2RGB_NV21'</span>, <span class="hljs-string">'COLOR_YUV2RGB_UYNV'</span>, <span class="hljs-string">'COLOR_YUV2RGB_UYVY'</span>, <span class="hljs-string">'COLOR_YUV2RGB_Y422'</span>, <span class="hljs-string">'COLOR_YUV2RGB_YUNV'</span>, <span class="hljs-string">'COLOR_YUV2RGB_YUY2'</span>, <span class="hljs-string">'COLOR_YUV2RGB_YUYV'</span>, <span class="hljs-string">'COLOR_YUV2RGB_YV12'</span>, <span class="hljs-string">'COLOR_YUV2RGB_YVYU'</span>, <span class="hljs-string">'COLOR_YUV420P2BGR'</span>, <span class="hljs-string">'COLOR_YUV420P2BGRA'</span>, <span class="hljs-string">'COLOR_YUV420P2GRAY'</span>, <span class="hljs-string">'COLOR_YUV420P2RGB'</span>, <span class="hljs-string">'COLOR_YUV420P2RGBA'</span>, <span class="hljs-string">'COLOR_YUV420SP2BGR'</span>, <span class="hljs-string">'COLOR_YUV420SP2BGRA'</span>, <span class="hljs-string">'COLOR_YUV420SP2GRAY'</span>, <span class="hljs-string">'COLOR_YUV420SP2RGB'</span>, <span class="hljs-string">'COLOR_YUV420SP2RGBA'</span>, <span class="hljs-string">'COLOR_YUV420p2BGR'</span>, <span class="hljs-string">'COLOR_YUV420p2BGRA'</span>, <span class="hljs-string">'COLOR_YUV420p2GRAY'</span>, <span class="hljs-string">'COLOR_YUV420p2RGB'</span>, <span class="hljs-string">'COLOR_YUV420p2RGBA'</span>, <span class="hljs-string">'COLOR_YUV420sp2BGR'</span>, <span class="hljs-string">'COLOR_YUV420sp2BGRA'</span>, <span class="hljs-string">'COLOR_YUV420sp2GRAY'</span>, <span class="hljs-string">'COLOR_YUV420sp2RGB'</span>, <span class="hljs-string">'COLOR_YUV420sp2RGBA'</span>, <span class="hljs-string">'COLOR_mRGBA2RGBA'</span>]<br></code></pre></td></tr></table></figure><blockquote><p>经验之谈：颜色转换其实是数学运算，如灰度化最常用的是：<code>gray=R*0.299+G*0.587+B*0.114</code>。</p></blockquote><h2 id="视频中特定颜色物体追踪"><a href="#视频中特定颜色物体追踪" class="headerlink" title="视频中特定颜色物体追踪"></a>视频中特定颜色物体追踪</h2><p><a href="https://baike.baidu.com/item/HSV/547122" target="_blank" rel="noopener">HSV</a>是一个常用于颜色识别的模型，相比BGR更易区分颜色，转换模式用<code>COLOR_BGR2HSV</code>表示。</p><blockquote><p>经验之谈：OpenCV中色调H范围为[0,179]，饱和度S是[0,255]，明度V是[0,255]。虽然H的理论数值是0°~360°，但8位图像像素点的最大值是255，所以OpenCV中除以了2，某些软件可能使用不同的尺度表示，所以同其他软件混用时，记得归一化。</p></blockquote><p>现在，我们实现一个使用HSV来只显示视频中蓝色物体的例子，步骤如下：</p><ol><li>捕获视频中的一帧</li><li>从BGR转换到HSV</li><li>提取蓝色范围的物体</li><li>只显示蓝色物体</li></ol><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_blue_object_tracking.jpg"></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>capture = cv2.VideoCapture(<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 蓝色的范围，不同光照条件下不一样，可灵活调整</span><br>lower_blue = np.array([<span class="hljs-number">100</span>, <span class="hljs-number">110</span>, <span class="hljs-number">110</span>])<br>upper_blue = np.array([<span class="hljs-number">130</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>])<br><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">True</span>):<br>    <span class="hljs-comment"># 1.捕获视频中的一帧</span><br>    ret, frame = capture.read()<br>    <span class="hljs-comment"># 2.从BGR转换到HSV</span><br>    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)<br>    <span class="hljs-comment"># 3.inRange()：介于lower/upper之间的为白色，其余黑色</span><br>    mask = cv2.inRange(hsv, lower_blue, upper_blue)<br>    <span class="hljs-comment"># 4.只保留原图中的蓝色部分</span><br>    res = cv2.bitwise_and(frame, frame, mask=mask)<br>    cv2.imshow(<span class="hljs-string">'frame'</span>, frame)<br>    cv2.imshow(<span class="hljs-string">'mask'</span>, mask)<br>    cv2.imshow(<span class="hljs-string">'res'</span>, res)<br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">1</span>) == ord(<span class="hljs-string">'q'</span>):<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p>蓝色的HSV值的上下限lower和upper范围是怎么得到的呢？其实很简单，我们先把标准蓝色的BGR值用<code>cvtColor()</code>转换下：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 蓝色的HSV值</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>blue = np.uint8([[[<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]]])<br>hsv_blue = cv2.cvtColor(blue, cv2.COLOR_BGR2HSV)<br>print(hsv_blue)  <span class="hljs-comment"># [[[120 255 255]]]</span><br></code></pre></td></tr></table></figure><p>结果是[120, 255, 255]，所以，我们把蓝色的范围调整成了上面代码那样。</p><p><strong>除了HSV，<a href="https://baike.baidu.com/item/Lab/1514615" target="_blank" rel="noopener">Lab</a>颜色空间也经常用来做颜色识别。</strong></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>尝试在视频中同时提取红色、蓝色、绿色的物体。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_exercise_tracking_three_colors.jpg"></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># HSV中</span><br><span class="hljs-comment"># Blue：[[[120 255 255]]]</span><br><span class="hljs-comment"># Green：[[[ 60 255 255]]]</span><br><span class="hljs-comment"># Red：[[[  0 255 255]]]</span><br><br>capture = cv2.VideoCapture(<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 蓝色的范围</span><br>lower_blue = np.array([<span class="hljs-number">100</span>, <span class="hljs-number">110</span>, <span class="hljs-number">110</span>])<br>upper_blue = np.array([<span class="hljs-number">130</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>])<br><br><span class="hljs-comment"># 绿色的范围</span><br>lower_green = np.array([<span class="hljs-number">40</span>, <span class="hljs-number">90</span>, <span class="hljs-number">90</span>])<br>upper_green = np.array([<span class="hljs-number">70</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>])<br><br><span class="hljs-comment"># 红色的范围</span><br>lower_red = np.array([<span class="hljs-number">160</span>, <span class="hljs-number">120</span>, <span class="hljs-number">120</span>])<br>upper_red = np.array([<span class="hljs-number">179</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>])<br><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">True</span>):<br>    <span class="hljs-comment"># 1.捕获视频中的一帧</span><br>    ret, frame = capture.read()<br><br>    <span class="hljs-comment"># 2.从BGR转换到HSV</span><br>    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)<br><br>    mask_blue = cv2.inRange(hsv, lower_blue, upper_blue)<br>    mask_green = cv2.inRange(hsv, lower_green, upper_green)<br>    mask_red = cv2.inRange(hsv, lower_red, upper_red)<br><br>    <span class="hljs-comment"># 3.将所有的mask相加，就可以同时显示了</span><br>    mask = mask_blue + mask_green + mask_red<br><br>    <span class="hljs-comment"># 4.保留原图中的三种颜色部分</span><br>    res = cv2.bitwise_and(frame, frame, mask=mask)<br><br>    cv2.imshow(<span class="hljs-string">'frame'</span>, frame)<br>    cv2.imshow(<span class="hljs-string">'mask'</span>, mask)<br>    cv2.imshow(<span class="hljs-string">'res'</span>, res)<br><br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">1</span>) == ord(<span class="hljs-string">'q'</span>):<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><ul><li><a href="https://docs.opencv.org/4.0.0/d8/d01/group__imgproc__color__conversions.html#ga397ae87e1288a81d2363b61574eb8cab" target="_blank" rel="noopener">cv2.cvtColor()</a></li><li><a href="https://docs.opencv.org/4.0.0/d2/de8/group__core__array.html#ga48af0ab51e36436c5d04340e036ce981" target="_blank" rel="noopener">cv2.inRange()</a></li><li><a href="https://docs.opencv.org/4.0.0/d2/de8/group__core__array.html#ga60b4d04b251ba5eb1392c34425497e14" target="_blank" rel="noopener">cv2.bitwise_and()</a></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_colorspaces/py_colorspaces.html" target="_blank" rel="noopener">Changing Colorspaces</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> HSV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程4：图像基本操作</title>
      <link href="/2019/08/13/Python-OpenCV%E6%95%99%E7%A8%8B4%EF%BC%9A%E5%9B%BE%E5%83%8F%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/08/13/Python-OpenCV%E6%95%99%E7%A8%8B4%EF%BC%9A%E5%9B%BE%E5%83%8F%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>学习<strong>获取和修改像素点的值</strong>，<strong>ROI感兴趣区域</strong>，<strong>通道分离合并</strong>等基本操作。</p><p>目标：</p><ul><li>访问和修改图片像素点的值</li><li>获取图片的宽、高、通道数等属性</li><li>了解感兴趣区域ROI</li><li>分离和合并图像通道</li></ul><p>小结：</p><ul><li><code>img[y,x]</code>获取/设置像素点值，<code>img.shape</code>：图片的形状（行数、列数、通道数）,<code>img.dtype</code>：图像的数据类型。</li><li><code>img[y1:y2,x1:x2]</code>进行ROI截取，<code>cv2.split()/cv2.merge()</code>通道分割/合并。更推荐的获取单通道方式：<code>b = img[:, :, 0]</code>。</li></ul><a id="more"></a><h2 id="获取和修改像素点值"><a href="#获取和修改像素点值" class="headerlink" title="获取和修改像素点值"></a>获取和修改像素点值</h2><p>先读取一张图片，通过行列的坐标来获取某像素点的值。</p><p>对于彩色图，结果是B, G, R三个值的列表。</p><p>对于灰度图或单通道，只有一个值。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br>img = cv2.imread(<span class="hljs-string">'lena.jpg'</span>)<br><br><span class="hljs-comment"># 获取像素的值</span><br>px = img[<span class="hljs-number">100</span>, <span class="hljs-number">90</span>]<span class="hljs-comment"># 行对应y，列对应x，所以其实是img[y, x]</span><br>print(px)  <span class="hljs-comment"># [103 98 197]</span><br><br><span class="hljs-comment"># 只获取蓝色blue通道的值</span><br>px_blue = img[<span class="hljs-number">100</span>, <span class="hljs-number">90</span>, <span class="hljs-number">0</span>]<br>print(px_blue)  <span class="hljs-comment"># 103</span><br></code></pre></td></tr></table></figure><p>修改像素的值也是同样的方式：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">img[<span class="hljs-number">100</span>, <span class="hljs-number">90</span>] = [<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>]<br>print(img[<span class="hljs-number">100</span>, <span class="hljs-number">90</span>])  <span class="hljs-comment"># [255 255 255]</span><br></code></pre></td></tr></table></figure><blockquote><p>经验之谈：还有一种性能更好的方式，获取：<code>img.item(100,100,0)</code>，修改：<code>img.itemset((100,100,0),255)</code>，但这种方式只能B,G,R逐一进行。</p></blockquote><p><strong>注意：这步操作只是内存中的img像素点值变了，因为没有保存，所以原图并没有更改。</strong></p><h2 id="图片属性"><a href="#图片属性" class="headerlink" title="图片属性"></a>图片属性</h2><p><code>img.shape</code>获取图像的形状，图片是彩色的话，返回一个包含<strong>行数（高度）、列数（宽度）和通道数</strong>的元组，灰度图只返回行数和列数：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">print(img.shape)  <span class="hljs-comment"># (263, 247, 3)</span><br><span class="hljs-comment"># 形状中包括行数、列数和通道数</span><br>height, width, channels = img.shape<br><span class="hljs-comment"># img是灰度图的话：height, width = img.shape</span><br></code></pre></td></tr></table></figure><p><code>img.size</code>获取图像总像素：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">print(img.size)  <span class="hljs-comment"># 263*247*3=194883</span><br></code></pre></td></tr></table></figure><p><code>img.dtype</code>获取图像数据类型：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">print(img.dtype)  <span class="hljs-comment"># uint8</span><br></code></pre></td></tr></table></figure><blockquote><p>经验之谈：多数错误是因为数据类型不对导致的，所以健壮的代码应该对这个属性加以判断。</p></blockquote><h2 id="ROI"><a href="#ROI" class="headerlink" title="ROI"></a>ROI</h2><p><a href="https://baike.baidu.com/item/ROI/1125333#viewPageContent" target="_blank" rel="noopener">ROI</a>：Region of Interest，感兴趣区域。</p><p>例如：我们要检测眼睛，因为眼睛肯定在脸上，所以我们感兴趣的只有脸这部分，其他都不care，所以可以单独把脸截取出来，这样就可以大大节省计算量，提高运行速度。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_lena_face_roi_crop.jpg"></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ROI截取</span><br>face = img[<span class="hljs-number">100</span>:<span class="hljs-number">200</span>, <span class="hljs-number">115</span>:<span class="hljs-number">188</span>]<br>cv2.imshow(<span class="hljs-string">'face'</span>, face)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h2 id="通道分割与合并"><a href="#通道分割与合并" class="headerlink" title="通道分割与合并"></a>通道分割与合并</h2><p>彩色图的BGR三个通道是可以分开单独访问的，也可以将单独的三个通道合并成一副图像。分别使用<code>cv2.split()</code>和<code>cv2.merge()</code>：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 通道分割与合并</span><br>b, g, r = cv2.split(img)<br>img = cv2.merge((b, g, r))<br></code></pre></td></tr></table></figure><p><code>split()</code>函数比较耗时，<strong>更高效的方式是用numpy中的索引</strong>，如提取B通道：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">b = img[:, :, <span class="hljs-number">0</span>]<br>cv2.imshow(<span class="hljs-string">'blue'</span>, b)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>打开lena.jpg，将帽子部分（高：25~120，宽：50~220）的红色通道截取出来并显示。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br>img = cv2.imread(<span class="hljs-string">'lena.jpg'</span>)<br><br><span class="hljs-comment"># 帽子ROI的红色通道</span><br>hat_r = img[<span class="hljs-number">25</span>:<span class="hljs-number">120</span>, <span class="hljs-number">50</span>:<span class="hljs-number">220</span>, <span class="hljs-number">2</span>]<br>cv2.imshow(<span class="hljs-string">'hat'</span>, hat_r)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><ul><li><a href="https://docs.opencv.org/4.0.0/d2/de8/group__core__array.html#ga0547c7fed86152d7e9d0096029c8518a" target="_blank" rel="noopener">cv2.split()</a></li><li><a href="https://docs.opencv.org/4.0.0/d2/de8/group__core__array.html#ga7d7b4d6c6ee504b30a20b1680029c7b4" target="_blank" rel="noopener">cv2.merge()</a></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_core/py_basic_ops/py_basic_ops.html#basic-ops" target="_blank" rel="noopener">Basic Operations on Images</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> ROI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程番外篇3：滑动条</title>
      <link href="/2019/08/13/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%873%EF%BC%9A%E6%BB%91%E5%8A%A8%E6%9D%A1/"/>
      <url>/2019/08/13/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%873%EF%BC%9A%E6%BB%91%E5%8A%A8%E6%9D%A1/</url>
      
        <content type="html"><![CDATA[<p>学习使用滑动条动态调整参数。</p><p>使用方式：</p><ul><li><code>cv2.createTrackbar(&#39;R&#39;, &#39;image&#39;, 0, 255, nothing)</code>：创建滑动条</li><li><code>r = cv2.getTrackbarPos(&#39;R&#39;, &#39;image&#39;)</code>：得到滑块位置</li><li>另外在回调函数中也可以获取滑块位置</li></ul><a id="more"></a><h2 id="滑动条的使用"><a href="#滑动条的使用" class="headerlink" title="滑动条的使用"></a>滑动条的使用</h2><p>首先我们需要创建一个滑动条，如<code>cv2.createTrackbar(&#39;R&#39;,&#39;image&#39;,0,255,call_back)</code>，其中</p><ul><li>参数1：滑动条的名称</li><li>参数2：所在窗口的名称</li><li>参数3：当前的值</li><li>参数4：最大值</li><li>参数5：回调函数名称，回调函数默认有一个表示当前值的参数</li></ul><p>创建好之后，可以在回调函数中获取滑动条的值。</p><p>也可以用：<code>cv2.getTrackbarPos()</code>得到，其中，参数1是滑动条的名称，参数2是窗口的名称。</p><h2 id="实例：RGB调色板"><a href="#实例：RGB调色板" class="headerlink" title="实例：RGB调色板"></a>实例：RGB调色板</h2><p>下面我们实现一个RGB的调色板，理解下滑动条的用法：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nothing</span><span class="hljs-params">(x)</span>:</span><br>    <span class="hljs-string">"""<br>    ### 回调函数,x表示滑块的位置,输出x<br>    """</span><br>    print(x)<br><br><br><span class="hljs-comment"># 创建一副300×512的纯黑色图</span><br>img = np.zeros((<span class="hljs-number">300</span>, <span class="hljs-number">512</span>, <span class="hljs-number">3</span>), np.uint8)<br>cv2.namedWindow(<span class="hljs-string">'image'</span>)<br><br><span class="hljs-comment"># 创建RGB三个滑动条</span><br>cv2.createTrackbar(<span class="hljs-string">'R'</span>, <span class="hljs-string">'image'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, nothing)<br>cv2.createTrackbar(<span class="hljs-string">'G'</span>, <span class="hljs-string">'image'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, nothing)<br>cv2.createTrackbar(<span class="hljs-string">'B'</span>, <span class="hljs-string">'image'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, nothing)<br><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">True</span>):<br>    cv2.imshow(<span class="hljs-string">'image'</span>, img)<br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">1</span>) == ord(<span class="hljs-string">'q'</span>):<br>        <span class="hljs-keyword">break</span><br><br>    <span class="hljs-comment"># 获取滑块的值</span><br>    r = cv2.getTrackbarPos(<span class="hljs-string">'R'</span>, <span class="hljs-string">'image'</span>)<br>    g = cv2.getTrackbarPos(<span class="hljs-string">'G'</span>, <span class="hljs-string">'image'</span>)<br>    b = cv2.getTrackbarPos(<span class="hljs-string">'B'</span>, <span class="hljs-string">'image'</span>)<br>    <span class="hljs-comment"># 设定img的颜色</span><br>    img[:] = [b, g, r]<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/%E8%B0%83%E8%89%B2%E6%9D%BF.png" width="70%"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><ul><li><a href="https://docs.opencv.org/4.0.0/d7/dfc/group__highgui.html#gaf78d2155d30b728fc413803745b67a9b" target="_blank" rel="noopener">cv2.createTrackbar()</a></li><li><a href="https://docs.opencv.org/4.0.0/d7/dfc/group__highgui.html#ga122632e9e91b9ec06943472c55d9cda8" target="_blank" rel="noopener">cv2.getTrackbarPos()</a></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_trackbar/py_trackbar.html" target="_blank" rel="noopener">Trackbar as the Color Palette</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程3：打开摄像头</title>
      <link href="/2019/08/13/Python-OpenCV%E6%95%99%E7%A8%8B3%EF%BC%9A%E6%89%93%E5%BC%80%E6%91%84%E5%83%8F%E5%A4%B4/"/>
      <url>/2019/08/13/Python-OpenCV%E6%95%99%E7%A8%8B3%EF%BC%9A%E6%89%93%E5%BC%80%E6%91%84%E5%83%8F%E5%A4%B4/</url>
      
        <content type="html"><![CDATA[<p>学习打开摄像头捕获照片、播放本地视频、录制视频等。</p><p>目标：</p><ul><li>打开摄像头并捕获照片</li><li>播放本地视频，录制视频</li><li>OpenCV函数：<code>cv2.VideoCapture()</code>、<code>cv2.VideoWriter()</code></li></ul><a id="more"></a><h2 id="打开摄像头"><a href="#打开摄像头" class="headerlink" title="打开摄像头"></a>打开摄像头</h2><p>要使用摄像头，需要使用<code>cv2.VideoCapture(0)</code>创建VideoCapture对象，参数0指的是摄像头的编号，如果你电脑上有两个摄像头的话，访问第2个摄像头就可以传入1，依此类推。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 打开摄像头并灰度化显示</span><br><span class="hljs-keyword">import</span> cv2<br><br>capture = cv2.VideoCapture(<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 获取捕获的分辨率</span><br><span class="hljs-comment"># propId可以直接写数字，也可以用OpenCV的符号表示</span><br>width, height = capture.get(<span class="hljs-number">3</span>), capture.get(<span class="hljs-number">4</span>)<br>print(width, height)<br><br><span class="hljs-comment"># 以原分辨率的一倍来捕获</span><br>capture.set(cv2.CAP_PROP_FRAME_WIDTH, width * <span class="hljs-number">5</span>)<br>capture.set(cv2.CAP_PROP_FRAME_HEIGHT, height * <span class="hljs-number">2</span>)<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment"># 获取一帧</span><br>    <span class="hljs-comment"># ret(return value):布尔值，表示当前这一帧是否获取正确</span><br>    ret, frame = capture.read()<br>    <span class="hljs-comment"># cv2.cvtColor()用来转换颜色，这里将这帧彩色图转化为灰度图</span><br>    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)<br><br>    cv2.imshow(<span class="hljs-string">'frame'</span>, gray)<br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">1</span>) == ord(<span class="hljs-string">'q'</span>):<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><blockquote><p>经验之谈：某些摄像头设定分辨率等参数时会无效，因为它有固定的分辨率大小支持，一般可在摄像头的资料页中找到。</p></blockquote><h2 id="播放本地视频"><a href="#播放本地视频" class="headerlink" title="播放本地视频"></a>播放本地视频</h2><p>跟打开摄像头一样，如果把摄像头的编号换成视频的路径就可以播放本地视频了。回想一下<code>cv2.waitKey()</code>，它的参数表示暂停时间，所以这个值越大，视频播放速度越慢，反之，播放速度越快，通常设置为25或30</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br><span class="hljs-comment"># 播放本地视频</span><br>capture = cv2.VideoCapture(<span class="hljs-string">'demo_video.mp4'</span>)<br><br><span class="hljs-keyword">while</span> capture.isOpened():<br>    ret, frame = capture.read()<br>    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)<br><br>    cv2.imshow(<span class="hljs-string">'frame'</span>, gray)<br>    <span class="hljs-comment"># cv2.waitKey(),参数表示暂停时间,值越大,播放速度越慢,一般设为25或30</span><br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">30</span>) == ord(<span class="hljs-string">'q'</span>):<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h2 id="录制视频"><a href="#录制视频" class="headerlink" title="录制视频"></a>录制视频</h2><p>之前我们保存图片用的是<code>cv2.imwrite()</code>，要保存视频，我们需要创建一个<code>VideoWriter</code>的对象，需要给它传入四个参数：</p><ul><li>输出的文件名，如<strong>output.avi</strong></li><li>编码方式<a href="https://baike.baidu.com/item/fourcc/6168470?fr=aladdin" target="_blank" rel="noopener">FourCC</a>码</li><li>帧率<a href="https://baike.baidu.com/item/FPS/3227416" target="_blank" rel="noopener">FPS</a></li><li>要保存的分辨率大小</li></ul><p>FourCC是用来指定视频编码方式的四字节码，所有的编码可参考<a href="http://www.fourcc.org/codecs.php" target="_blank" rel="noopener">Video Codecs</a>。如MJPG编码可以这样写： <code>cv2.VideoWriter_fourcc(*&#39;MJPG&#39;)</code>或<code>cv2.VideoWriter_fourcc(&#39;M&#39;,&#39;J&#39;,&#39;P&#39;,&#39;G&#39;)</code></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br>capture = cv2.VideoCapture(<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 定义编码方式并创建VideoWriter对象</span><br>fourcc = cv2.VideoWriter_fourcc(*<span class="hljs-string">'MJPG'</span>)<br>outfile = cv2.VideoWriter(<span class="hljs-string">'output.avi'</span>, fourcc, <span class="hljs-number">25.</span>, (<span class="hljs-number">640</span>, <span class="hljs-number">480</span>))<br><br><span class="hljs-keyword">while</span> capture.isOpened():<br>    ret, frame = capture.read()<br><br>    <span class="hljs-keyword">if</span> ret:<br>        <span class="hljs-comment"># 写入文件</span><br>        outfile.write(frame)<br><br>        cv2.imshow(<span class="hljs-string">'frame'</span>, frame)<br>        <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">1</span>) == ord(<span class="hljs-string">'q'</span>):<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>实现一个可以拖动滑块播放视频的功能。（提示：需要用到 <code>cv2.CAP_PROP_FRAME_COUNT</code>和<code>cv2.CAP_PROP_POS_FRAMES</code>两个属性）</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">track_back</span><span class="hljs-params">(x)</span>:</span><br>    <span class="hljs-string">'''<br>    ### 回调函数，x表示滑块的位置<br>    '''</span><br>    <span class="hljs-comment"># 更改视频的帧位置</span><br>    capture.set(cv2.CAP_PROP_POS_FRAMES, x)<br><br><br>cv2.namedWindow(<span class="hljs-string">'window'</span>)<br><br>capture = cv2.VideoCapture(<span class="hljs-string">'demo_video.mp4'</span>)<br><span class="hljs-comment"># 获取视频总共多少帧</span><br>frames = capture.get(cv2.CAP_PROP_FRAME_COUNT)<br><span class="hljs-comment"># 创建滑动条</span><br>cv2.createTrackbar(<span class="hljs-string">'process'</span>, <span class="hljs-string">'window'</span>, <span class="hljs-number">1</span>, int(frames), track_back)<br><br><span class="hljs-keyword">while</span> (capture.isOpened()):<br>    ret, frame = capture.read()<br><br>    cv2.imshow(<span class="hljs-string">'window'</span>, frame)<br>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">30</span>) == ord(<span class="hljs-string">'q'</span>):<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><ul><li><a href="https://docs.opencv.org/4.0.0/d8/dfe/classcv_1_1VideoCapture.html" target="_blank" rel="noopener">VideoCapture Object</a></li><li><a href="https://docs.opencv.org/4.0.0/dd/d9e/classcv_1_1VideoWriter.html" target="_blank" rel="noopener">VideoWriter Object</a></li><li><a href="https://docs.opencv.org/4.0.0/d8/d01/group__imgproc__color__conversions.html#ga397ae87e1288a81d2363b61574eb8cab" target="_blank" rel="noopener">cv2.cvtColor()</a></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="http://www.fourcc.org/codecs.php" target="_blank" rel="noopener">Video Codecs by FOURCC</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_video_display/py_video_display.html" target="_blank" rel="noopener">Getting Started with Videos</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python字符串切片(slice)</title>
      <link href="/2019/08/13/Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E7%89%87-slice/"/>
      <url>/2019/08/13/Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E7%89%87-slice/</url>
      
        <content type="html"><![CDATA[<p>切片操作（slice）可以从一个字符串中获取子字符串（字符串的一部分）。我们使用<strong>一对方括号、起始偏移量start、终止偏移量end 以及可选的步长step 来定义一个分片</strong>。</p><p>格式： <code>[start:end:step]</code></p><ul><li><code>[:]</code> 提取从开头（默认位置0）到结尾（默认位置-1）的整个字符串</li><li><code>[start:]</code> 从start 提取到结尾</li><li><code>[:end]</code> 从开头提取到end - 1</li><li><code>[start:end]</code> 从start 提取到end - 1</li><li><code>[start:end:step]</code> 从start 提取到end - 1，每step 个字符提取一个</li><li>左侧第一个字符的位置偏移量为0，右侧最后一个字符的位置偏移量为-1</li></ul><a id="more"></a><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="提取最后N个字符"><a href="#提取最后N个字符" class="headerlink" title="提取最后N个字符"></a>提取最后N个字符</h3><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>letter = <span class="hljs-string">'abcdefghijklmnopqrstuvwxyz'</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>letter[<span class="hljs-number">-3</span>:]<br><span class="hljs-string">'xyz'</span><br></code></pre></td></tr></table></figure><h3 id="从开头到结尾，step为N："><a href="#从开头到结尾，step为N：" class="headerlink" title="从开头到结尾，step为N："></a>从开头到结尾，step为N：</h3><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>letter[::<span class="hljs-number">5</span>]<br><span class="hljs-string">'afkpuz'</span><br></code></pre></td></tr></table></figure><h3 id="将字符串倒转-reverse-，-通过设置步长为负数："><a href="#将字符串倒转-reverse-，-通过设置步长为负数：" class="headerlink" title="将字符串倒转(reverse)， 通过设置步长为负数："></a>将字符串倒转(reverse)， 通过设置步长为负数：</h3><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>letter[::<span class="hljs-number">-1</span>]<br><span class="hljs-string">'zyxwvutsrqponmlkjihgfedcba'</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程番外篇2：无损保存和Matplotlib使用</title>
      <link href="/2019/08/13/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%872%EF%BC%9A%E6%97%A0%E6%8D%9F%E4%BF%9D%E5%AD%98%E5%92%8CMatplotlib%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/08/13/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%872%EF%BC%9A%E6%97%A0%E6%8D%9F%E4%BF%9D%E5%AD%98%E5%92%8CMatplotlib%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>了解常用图片格式和OpenCV高质量保存图片的方式，学习如何使用Matplotlib显示OpenCV图像。</p><a id="more"></a><h2 id="无损保存"><a href="#无损保存" class="headerlink" title="无损保存"></a>无损保存</h2><p>事实上，我们日常看到的大部分图片都是压缩过的，那么都有哪些常见的图片格式呢？</p><h3 id="图片格式"><a href="#图片格式" class="headerlink" title="图片格式"></a>图片格式</h3><h4 id="格式分类"><a href="#格式分类" class="headerlink" title="格式分类"></a>格式分类</h4><ul><li>无压缩。无压缩的图片格式不对图片数据进行压缩处理，能准确地呈现原图片。BMP格式就是其中之一。</li><li>无损压缩。压缩算法对图片的所有的数据进行编码压缩，能在保证图片的质量的同时降低图片的尺寸。png是其中的代表。</li><li>有损压缩。压缩算法不会对图片所有的数据进行编码压缩，而是在压缩的时候，去除了人眼无法识别的图片细节。因此有损压缩可以在同等图片质量的情况下大幅降低图片的尺寸。其中的代表是jpg。</li></ul><h4 id="常见图片格式"><a href="#常见图片格式" class="headerlink" title="常见图片格式"></a>常见图片格式</h4><ul><li><strong>bmp：</strong>全称Bitmap，不压缩</li><li><strong>jpg：</strong>全称Joint Photographic Experts Group，有损压缩</li><li><strong>png：</strong>全称Portable Network Graphics，无损压缩</li></ul><p>简单来说，同一个文件保存成不同的格式后，<strong>文件大小上bmp肯定是最大的</strong>，而png和jpg，不同的压缩比结果会有所不同。可以用画图工具新建一副100×100的图像，分别保存成这三种格式来验证：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_high_save_mspaint_format.jpg"></p><h3 id="高质量保存"><a href="#高质量保存" class="headerlink" title="高质量保存"></a>高质量保存</h3><p>用<code>cv2.imwrite()</code>保存图片时，可以传入第三个参数（请参考<a href="https://docs.opencv.org/4.0.0/d4/da8/group__imgcodecs.html#gabbc7ef1aa2edfaa87772f1202d67e0ce" target="_blank" rel="noopener">接口文档</a>），用于控制保存质量：</p><ul><li><code>cv2.IMWRITE_JPEG_QUALITY</code>：jpg质量控制，取值0~100，值越大，质量越好，默认为95</li><li><code>cv2.IMWRITE_PNG_COMPRESSION</code>：png质量控制，取值0~9，值越大，压缩比越高，默认为1</li></ul><p>还有诸如<code>CV_IMWRITE_WEBP_QUALITY</code>的参量，不常用，请参考：<a href="https://docs.opencv.org/4.0.0/d4/da8/group__imgcodecs.html#ga292d81be8d76901bff7988d18d2b42ac" target="_blank" rel="noopener">ImwriteFlags</a>。</p><p>举例来说，原图lena.jpg的分辨率是350×350，大小49.7KB。我们把它转成不同格式看下：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>new_img = cv2.imread(<span class="hljs-string">'lena.jpg'</span>)<br><span class="hljs-comment"># new_img = np.zeros((100,100,3)) # 新建一副纯黑色图</span><br><br><span class="hljs-comment"># bmp</span><br>cv2.imwrite(<span class="hljs-string">'img_bmp.bmp'</span>, new_img)  <span class="hljs-comment"># 文件大小：359KB</span><br><br><span class="hljs-comment"># jpg 100%质量</span><br>cv2.imwrite(<span class="hljs-string">'img_jpg100.jpg'</span>, new_img, [int(cv2.IMWRITE_JPEG_QUALITY), <span class="hljs-number">100</span>])  <span class="hljs-comment"># 文件大小：82.5KB</span><br><span class="hljs-comment"># jpg 默认95%质量</span><br>cv2.imwrite(<span class="hljs-string">'img_jpg95.jpg'</span>, new_img)  <span class="hljs-comment"># 文件大小：52.3KB</span><br><span class="hljs-comment"># jpg 20%质量</span><br>cv2.imwrite(<span class="hljs-string">'img_jpg20.jpg'</span>, new_img, [int(cv2.IMWRITE_JPEG_QUALITY), <span class="hljs-number">20</span>])  <span class="hljs-comment"># 文件大小：8.01KB</span><br><br><span class="hljs-comment"># png 默认1压缩比</span><br>cv2.imwrite(<span class="hljs-string">'img_png1.png'</span>, new_img)  <span class="hljs-comment"># 文件大小：240KB</span><br><span class="hljs-comment"># png 9压缩比</span><br>cv2.imwrite(<span class="hljs-string">'img_png9.png'</span>, new_img, [int(cv2.IMWRITE_PNG_COMPRESSION), <span class="hljs-number">9</span>])  <span class="hljs-comment"># 文件大小：207KB</span><br></code></pre></td></tr></table></figure><p>可以看到：</p><ul><li>bmp文件是最大的，没有任何压缩（1个像素点1byte，3通道的彩色图总大小：350×350×3/1024 ≈ 359 KB）</li><li>jpg/png本身就有压缩的，所以就算是100%的质量保存，体积也比bmp小很多</li><li>jpg的容量优势很明显，这也是它为什么如此流行的原因</li></ul><blockquote><p>思考：为什么原图49.7KB，保存成bmp或其他格式反而大了呢？</p><p>原因：这里需要明确的是保存新格式时，<strong>容量大小跟原图的容量没有直接关系，而是取决于原图的分辨率大小和原图本身的内容（压缩方式）</strong>，所以lena.jpg保存成不压缩的bmp格式时，容量大小就是固定的350×350×3/1024 ≈ 359 KB；另外，容量变大不代表画质提升噢，不然就逆天了~~~</p></blockquote><h2 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h2><p>Matplotlib是Python的一个很常用的绘图库。</p><h3 id="显示灰度图"><a href="#显示灰度图" class="headerlink" title="显示灰度图"></a>显示灰度图</h3><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>img = cv2.imread(<span class="hljs-string">'lena.jpg'</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 显示灰度图</span><br>plt.imshow(img, cmap=<span class="hljs-string">'gray'</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><h3 id="显示彩色图"><a href="#显示彩色图" class="headerlink" title="显示彩色图"></a>显示彩色图</h3><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>img = cv2.imread(<span class="hljs-string">'lena.jpg'</span>)<br><br>img2 = img[:, :, ::<span class="hljs-number">-1</span>]<br><span class="hljs-comment"># 或使用</span><br><span class="hljs-comment"># img2 = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</span><br><span class="hljs-comment"># 显示不正确的图</span><br>plt.subplot(<span class="hljs-number">121</span>)<br>plt.imshow(img) <br><br><span class="hljs-comment"># 显示正确的图</span><br>plt.subplot(<span class="hljs-number">122</span>)<br>plt.xticks([]), plt.yticks([]) <span class="hljs-comment"># 隐藏x和y轴</span><br>plt.imshow(img2)<br><br>plt.show()<br></code></pre></td></tr></table></figure><blockquote><p><code>img[:,:,0]</code>表示图片的蓝色通道，<code>img[:,:,::-1]</code>就表示BGR翻转，变成RGB，说明一下：</p><p>熟悉Python的童鞋应该知道，对一个字符串s翻转可以这样写：<code>s[::-1]</code>，<strong>abc</strong>变成<strong>cba</strong>，-1表示逆序。图片是二维的，所以完整地复制一副图像就是：</p><p><code>img2 = img[:,:]  # 写全就是：img2 = img[0:height,0:width]</code></p><p>而图片是有三个通道，相当于一个长度为3的字符串，所以通道翻转与图片复制组合起来便是<code>img[:,:,::-1]</code>。</p></blockquote><h3 id="加载和保存图片"><a href="#加载和保存图片" class="headerlink" title="加载和保存图片"></a>加载和保存图片</h3><p>不使用OpenCV，Matplotlib也可以加载和保存图片：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 加载和保存图片</span><br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> matplotlib.image <span class="hljs-keyword">as</span> pli<br><br>img = pli.imread(<span class="hljs-string">'lena.jpg'</span>)<br>plt.imshow(img)<br><br><span class="hljs-comment"># 保存图片，需放在show()函数之前</span><br>plt.savefig(<span class="hljs-string">'lena2.jpg'</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><ul><li><a href="https://docs.opencv.org/4.0.0/d4/da8/group__imgcodecs.html#gabbc7ef1aa2edfaa87772f1202d67e0ce" target="_blank" rel="noopener">cv2.imwrite()</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/da8/group__imgcodecs.html#ga292d81be8d76901bff7988d18d2b42ac" target="_blank" rel="noopener">ImwriteFlags</a></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="https://segmentfault.com/a/1190000013589397" target="_blank" rel="noopener">聊一聊几种常用web图片格式</a></li><li><a href="http://ex2tron.wang/opencv-python-extra-high-quality-save-and-using-matplotlib/www.matplotlib.org/" target="_blank" rel="noopener">Matplotlib官网</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Matplotlib </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程2：基本元素-图片</title>
      <link href="/2019/08/13/Python-OpenCV%E6%95%99%E7%A8%8B2%EF%BC%9A%E5%9F%BA%E6%9C%AC%E5%85%83%E7%B4%A0-%E5%9B%BE%E7%89%87/"/>
      <url>/2019/08/13/Python-OpenCV%E6%95%99%E7%A8%8B2%EF%BC%9A%E5%9F%BA%E6%9C%AC%E5%85%83%E7%B4%A0-%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p>学习如何加载图片，显示并保存图片。</p><p>目标：</p><ul><li>加载图片，显示图片，保存图片</li><li>OpenCV函数：<code>cv2.imread()</code>加载图片、<code>cv2.imshow()</code>显示图片、<code>cv2.imwrite()</code>保存图片</li></ul><a id="more"></a><p>大部分人可能都知道电脑上的彩色图是以RGB(红-绿-蓝，Red-Green-Blue)颜色模式显示的，但OpenCV中彩色图是以<strong>B-G-R</strong>通道顺序存储的，灰度图只有一个通道。</p><p>图像坐标的起始点是在左上角，所以行对应的是y，列对应的是x：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/%E5%9F%BA%E6%9C%AC%E5%85%83%E7%B4%A0%E5%9B%BE%E7%89%87.jpg"></p><h2 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h2><p>使用<code>cv2.imread()</code>读取一张图片：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br><span class="hljs-comment"># 灰度图加载一张彩色图</span><br>img = cv2.imread(<span class="hljs-string">'lena.jpg'</span>, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><ul><li>参数1：图片的文件名<ul><li>如果图片放在当前文件夹下，直接写文件名就行了，如’lena.jpg’</li><li>否则需要给出绝对路径，如’D:\OpenCVSamples\lena.jpg’</li></ul></li><li>参数2：读入方式，省略即采用默认值<ul><li><code>cv2.IMREAD_COLOR</code>：彩色图，默认值(1)</li><li><code>cv2.IMREAD_GRAYSCALE</code>：灰度图(0)</li><li><code>cv2.IMREAD_UNCHANGED</code>：包含透明通道的彩色图(-1)</li></ul></li></ul><blockquote><p>经验之谈：路径中不能有中文噢，并且没有加载成功的话是不会报错的，<code>print(img)</code>的结果为None，后面处理才会报错，算是个小坑。</p></blockquote><h2 id="显示图片"><a href="#显示图片" class="headerlink" title="显示图片"></a>显示图片</h2><p>使用<code>cv2.imshow()</code>显示图片，窗口会自适应图片的大小：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 显示图片</span><br>cv2.imshow(<span class="hljs-string">'lena'</span>, img)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><code>cv2.waitKey()</code>是让程序暂停的意思，参数是等待时间(毫秒ms)。</p><p>时间一到，会继续执行接下来的程序，传入0的话表示一直等待。</p><p>等待期间可以获取用户的按键输入：<code>k=cv2.waitKey(0)</code></p><p>我们也可以先用<code>cv2.namedWindow()</code>创建一个窗口，之后再显示图片：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 先定义窗口，后显示图片</span><br>cv2.namedWindow(<span class="hljs-string">'lena2'</span>, cv2.WINDOW_NORMAL)<br>cv2.imshow(<span class="hljs-string">'lena2'</span>, img)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>参数1依旧是窗口的名字，参数2默认是<code>cv2.WINDOW_AUTOSIZE</code>，表示窗口大小自适应图片，也可以设置为<code>cv2.WINDOW_NORMAL</code>，表示窗口大小可调整。图片比较大的时候，可以考虑用后者。</p><h2 id="保存图片"><a href="#保存图片" class="headerlink" title="保存图片"></a>保存图片</h2><p>使用<code>cv2.imwrite()</code>保存图片，参数1是包含后缀名的文件名：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 保存图片</span><br>cv2.imwrite(<span class="hljs-string">'lena_gray.jpg'</span>, img)<br></code></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br><span class="hljs-comment"># 1.灰度图加载一张彩色图</span><br>img = cv2.imread(<span class="hljs-string">'lena.jpg'</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 2.显示图片</span><br>cv2.imshow(<span class="hljs-string">'lena'</span>, img)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 先定义窗口，后显示图片</span><br>cv2.namedWindow(<span class="hljs-string">'lena2'</span>, cv2.WINDOW_NORMAL)<br>cv2.imshow(<span class="hljs-string">'lena2'</span>, img)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 3.保存图片</span><br>cv2.imwrite(<span class="hljs-string">'lena_gray.jpg'</span>, img)<br></code></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>打开<strong>lena.jpg</strong>并显示，如果按下<strong>s</strong>，就保存图片为<strong>lena_save.bmp</strong>，否则就结束程序。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br>img = cv2.imread(<span class="hljs-string">'lena.jpg'</span>)<br>cv2.imshow(<span class="hljs-string">'lena'</span>, img)<br><br>k = cv2.waitKey(<span class="hljs-number">0</span>)<br><span class="hljs-comment"># ord()用来获取某个字符的编码</span><br><span class="hljs-keyword">if</span> k == ord(<span class="hljs-string">'s'</span>):<br>    cv2.imwrite(<span class="hljs-string">'lena_save.bmp'</span>, img)<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h3><ul><li><a href="https://docs.opencv.org/4.0.0/d3/d63/classcv_1_1Mat.html" target="_blank" rel="noopener">Mat Object</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/da8/group__imgcodecs.html#ga288b8b3da0892bd651fce07b3bbd3a56" target="_blank" rel="noopener">cv2.imread()</a></li><li><a href="https://docs.opencv.org/4.0.0/d7/dfc/group__highgui.html#ga453d42fe4cb60e5723281a89973ee563" target="_blank" rel="noopener">cv2.imshow()</a></li><li><a href="https://docs.opencv.org/4.0.0/d4/da8/group__imgcodecs.html#gabbc7ef1aa2edfaa87772f1202d67e0ce" target="_blank" rel="noopener">cv2.imwrite()</a></li><li><a href="https://docs.opencv.org/4.0.0/d7/dfc/group__highgui.html#ga5afdf8410934fd099df85c75b2e0888b" target="_blank" rel="noopener">cv.namedWindow()</a></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_image_display/py_image_display.html" target="_blank" rel="noopener">Getting Started with Images</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程番外篇1：代码性能优化</title>
      <link href="/2019/08/13/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%871%EF%BC%9A%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2019/08/13/Python-OpenCV%E6%95%99%E7%A8%8B%E7%95%AA%E5%A4%96%E7%AF%871%EF%BC%9A%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>完成一项任务很重要，高效地完成更重要。图像处理是对矩阵的操作，数据量巨大。如果代码写的不好，性能差距将很大，所以这节我们来了解下如何评估和提升代码性能。</p><a id="more"></a><h2 id="评估代码运行时间"><a href="#评估代码运行时间" class="headerlink" title="评估代码运行时间"></a>评估代码运行时间</h2><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><br>start = cv2.getTickCount()<br><span class="hljs-comment"># 这里写测试代码...</span><br>end = cv2.getTickCount()<br>print((end - start) / cv2.getTickFrequency())<br></code></pre></td></tr></table></figure><p>这段代码就是用来测量程序运行时间的（单位：s），其中<code>cv2.getTickCount()</code>函数得到电脑启动以来的时钟周期数，<code>cv2.getTickFrequency()</code>返回你电脑的主频，前后相减再除以主频就是你代码的运行时间（这样解释并不完全准确，但能理解就行）。另外，也可以用Python中的time模块计时：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br>start = time.clock()<br><span class="hljs-comment"># 这里写测试代码...</span><br>end = time.clock()<br>print(end - start)<br></code></pre></td></tr></table></figure><h2 id="优化原则"><a href="#优化原则" class="headerlink" title="优化原则"></a>优化原则</h2><p>数据元素少时用Python语法，数据元素多时用Numpy：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> time<br><br>x = <span class="hljs-number">10</span><br>z = np.uint8([<span class="hljs-number">10</span>])<br><br><span class="hljs-comment"># 尝试比较下面三句话各自的运行时间</span><br>s1 = time.clock()<br>y1 = x * x * x<br>e1 = time.clock()<br>print(e1 - s1)  <span class="hljs-comment"># 1.2000000000012001e-05</span><br><br>s2 = time.clock()<br>y2 = x ** <span class="hljs-number">3</span><br>e2 = time.clock()<br>print(e2 - s2)  <span class="hljs-comment"># 8.999999999925734e-06</span><br><br>s3 = time.clock()<br>y3 = z * z * z<br>e3 = time.clock()<br>print(e3 - s3)  <span class="hljs-comment"># 0.003105999999999942</span><br></code></pre></td></tr></table></figure><p>所以Numpy的运行速度并不一定比Python本身语法快，元素数量较少时，请用Python本身格式。</p><ul><li>尽量避免使用循环，尤其嵌套循环，因为极其慢！！！</li><li>优先使用OpenCV/Numpy中封装好的函数</li><li>尽量将数据向量化，变成Numpy的数据格式</li><li>尽量避免数组的复制操作</li></ul><h2 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h2><ul><li><a href="https://docs.opencv.org/4.0.0/db/de0/group__core__utils.html#gae73f58000611a1af25dd36d496bf4487" target="_blank" rel="noopener">cv2.getTickCount()</a></li><li><a href="https://docs.opencv.org/4.0.0/db/de0/group__core__utils.html#ga705441a9ef01f47acdc55d87fbe5090c" target="_blank" rel="noopener">cv2.getTickFrequency()</a></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://wiki.python.org/moin/PythonSpeed/PerformanceTips" target="_blank" rel="noopener">Python Optimization Techniques</a></li><li><a href="http://pynash.org/2013/03/06/timing-and-profiling/" target="_blank" rel="noopener">Timing and Profiling in IPython</a></li><li><a href="http://www.scipy-lectures.org/advanced/advanced_numpy/index.html#advanced-numpy" target="_blank" rel="noopener">Advanced Numpy</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+OpenCV教程1：简介与安装</title>
      <link href="/2019/08/13/Python+OpenCV%E6%95%99%E7%A8%8B1%EF%BC%9A%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85/"/>
      <url>/2019/08/13/Python+OpenCV%E6%95%99%E7%A8%8B1%EF%BC%9A%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>相信大部分人知道的OpenCV都是用C++来开发的，那为什么我推荐使用Python呢？</p><a id="more"></a><h2 id="Python照样快！"><a href="#Python照样快！" class="headerlink" title="Python照样快！"></a>Python照样快！</h2><p>众所周知，虽然Python语法简洁，编写高效，但相比C/C++运行慢很多。然而Python还有个重要的特性：它是一门胶水语言！Python可以很容易地扩展C/C++。<strong>OpenCV-Python</strong>就是用Python包装了C++的实现，背后实际就是C++的代码在跑，所以代码的运行速度跟原生C/C++速度一样快。</p><p>我举两个简单的例子就一目了然了：一个是读入图片，另一个是调整图片的对比度和亮度：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_python_vs_cplus_speed.jpg"></p><p><strong>可以看到某些情况下Python的运行速度甚至好于C++，代码行数也直接少一半多！</strong>另外，图像是矩阵数据，OpenCV-Python原生支持<a href="https://baike.baidu.com/item/numpy" target="_blank" rel="noopener">Numpy</a>，相当于Python中的Matlab，为矩阵运算、科学计算提供了极大的便利性。</p><h2 id="人工智能浪潮"><a href="#人工智能浪潮" class="headerlink" title="人工智能浪潮"></a>人工智能浪潮</h2><p>近些年，人工智能相关技术的快速发展大家有目共睹，不必多说。在编程语言方面，更多人希望的是具备高效开发效率、跨平台、高度扩展性的语言，尤其是一些AI巨头优先推出支持Python语言的深度学习框架，如Facebook的<a href="https://pytorch.org/" target="_blank" rel="noopener">PyTorch</a>、Google的<a href="https://tensorflow.google.cn/" target="_blank" rel="noopener">Tensorflow</a>等，可以说Python是名副其实的“网红语言”了。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/opencv/cv2_ai_ml_dl2.jpg"></p><p>从<a href="https://www.tiobe.com/tiobe-index/" target="_blank" rel="noopener">TIOBE编程语言排行榜</a>也可以看到，Python发展迅猛，已经逼近C++的份额。这个排行榜每月更新，我就不截图了，编写时TOP5：Java/C/Python/C++/C#。</p><h2 id="人生苦短，我用Python"><a href="#人生苦短，我用Python" class="headerlink" title="人生苦短，我用Python"></a>人生苦短，我用Python</h2><ul><li>如果你搞科研用，果断放弃C++（Matlab？出门左拐）</li><li>如果你是快速原型开发，验证方案，果断放弃C++</li><li>如果你懒的配置OpenCV环境，果断放弃C++</li><li>如果你的程序是在支持Python的较高硬件环境下运行，果断放弃C++</li><li>如果你担心Python写不了界面，那是你的问题o_o ….</li><li>除非你的程序是MFC或已经用C++编写其他模块或是嵌入式设备，那就用C++吧</li></ul><p><strong>“人生苦短，我用Python！！！”</strong></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>要安装OpenCV，只需执行指令：<code>pip install opencv-python</code></p><p>安装完成后，输入：<code>import cv2</code>，如果运行没有报错说明一切正常。</p><p>如果要查看OpenCV的版本，可以：<code>print(cv2.__version__)</code></p><h2 id="网络资料"><a href="#网络资料" class="headerlink" title="网络资料"></a>网络资料</h2><ul><li><a href="https://docs.opencv.org/" target="_blank" rel="noopener"><strong>OpenCV Docs官方文档</strong></a></li><li><a href="https://github.com/opencv/opencv" target="_blank" rel="noopener">OpenCV 官方Github</a></li><li><a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_tutorials.html" target="_blank" rel="noopener">官方英文教程：OpenCV-Python Tutorials</a></li><li><a href="http://www.learnopencv.com/" target="_blank" rel="noopener">LearnOpenCV</a>、<a href="https://github.com/spmallick/learnopencv" target="_blank" rel="noopener">LearnOpenCV Github</a></li><li><a href="https://docs.scipy.org/doc/numpy-dev/user/quickstart.html" target="_blank" rel="noopener">Numpy Quickstart Tutorial</a></li><li><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/tutorials.html" target="_blank" rel="noopener">OpenCV 中文教程</a></li></ul><h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><ul><li><a href="http://programmingcomputervision.com/" target="_blank" rel="noopener">Programming Computer Vision with Python</a>、<a href="https://www.amazon.cn/dp/B00L3Y3NEM/ref=sr_1_1?ie=UTF8&amp;qid=1543929834&amp;sr=8-1&amp;keywords=Python+计算机视觉" target="_blank" rel="noopener">中文书</a></li><li><a href="https://www.pyimagesearch.com/practical-python-opencv/" target="_blank" rel="noopener">https://www.pyimagesearch.com/practical-python-opencv/</a></li></ul><h2 id="名校视觉研究所-课程"><a href="#名校视觉研究所-课程" class="headerlink" title="名校视觉研究所/课程"></a>名校视觉研究所/课程</h2><ul><li><a href="http://graphics.cs.cmu.edu/" target="_blank" rel="noopener">卡内基梅隆大学</a></li><li><a href="https://www.cs.toronto.edu/~guerzhoy/320/" target="_blank" rel="noopener">多伦多大学</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
          <category> OpenCV </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
            <tag> 计算机视觉 </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k-近邻算法</title>
      <link href="/2019/08/13/k-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/"/>
      <url>/2019/08/13/k-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NearestNeighbor</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">train</span><span class="hljs-params">(self, X, y)</span>:</span><br>        <span class="hljs-string">"""X is N x D where each row is an example. Y is 1-dimension of sizee N"""</span><br>        self.Xtr = X<br>        self.ytr = y<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">predict</span><span class="hljs-params">(self, X)</span>:</span><br>        <span class="hljs-string">"""X is N x D where each row is an example we wish to predict label for"""</span><br>        num_test = X.shape[<span class="hljs-number">0</span>]<br>        <span class="hljs-comment"># lets make sure that the output type matches the input type</span><br>        Ypred = np.zeros(num_test, dtype=self.ytr.dtype)<br><br>        <span class="hljs-comment"># loop over all test rows</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(num_test):<br>            <span class="hljs-comment"># find the nearest training image to the i'th test image</span><br>            <span class="hljs-comment"># using the L1 distance(sum of absolute value differences)</span><br>            distances = np.sum(np.abs(self.Xtr - X[i, :]), axis=<span class="hljs-number">1</span>)<br>            min_index = np.argmin(distances)  <span class="hljs-comment"># get the index with smallest distance</span><br>            Ypred[i] = self.ytr[min_index]  <span class="hljs-comment"># predict the label of the nearest example</span><br><br>        <span class="hljs-keyword">return</span> Ypred<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
          <category> 监督学习 </category>
          
          <category> 分类算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> k-近邻算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解析库的使用</title>
      <link href="/2019/08/11/%E8%A7%A3%E6%9E%90%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/08/11/%E8%A7%A3%E6%9E%90%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>对于网页节点来说，它可以定义<code>id</code>，<code>class</code>或其他属性。节点之间还有层次关系，在网页中可以通过<strong>XPath</strong>或<strong>CSS选择器</strong>来定位一个或多个节点。</p><a id="more"></a><h2 id="XPath"><a href="#XPath" class="headerlink" title="XPath"></a>XPath</h2><p>XPath(XML Path Language，XML路径语言)，它是一门在XML文档中查找信息的语言。</p><p>它最初是用来搜寻XML文档的，但是它同样适用于HTML文档的搜索。</p><h3 id="XPath简介"><a href="#XPath简介" class="headerlink" title="XPath简介"></a>XPath简介</h3><p>XPath的选择功能十分强大，它提供了非常简洁明了的<strong>路径选择表达式</strong>。另外，它还提供100个内建函数，用于字符串、数值、时间的匹配以及节点、序列的处理等。<strong>几乎所有我们想要定位的节点，都可以用XPath来选择。</strong></p><p>XPath于1999年11月16日成为W3C的标准，它被设计为供XSLT、XPointer以及其他XML解析软件使用。</p><h3 id="XPath规则"><a href="#XPath规则" class="headerlink" title="XPath规则"></a>XPath规则</h3><div class="table-container"><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>nodename</td><td>选取此节点的所有子节点</td></tr><tr><td>/</td><td>从当前节点选取直接子节点</td></tr><tr><td>//</td><td>从当前节点选取子孙节点</td></tr><tr><td>.</td><td>选取当前节点</td></tr><tr><td>..</td><td>选取当前节点的父节点</td></tr><tr><td>@</td><td>选取属性</td></tr></tbody></table></div><p>举个例子：<code>//title[@lang=&#39;eng&#39;]</code></p><p>它代表选择所有名称为<strong>title</strong>，同时属性<strong>lang</strong>的值为<strong>eng</strong>的节点。</p><h3 id="实例引入"><a href="#实例引入" class="headerlink" title="实例引入"></a>实例引入</h3><p>通过实例来感受一下使用XPath对网页进行解析的过程。</p><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python">from lxml import etree  # 导入lxml库的etree模块<br><br># 申明一段HTML文本<br>text = '''<br>&lt;div&gt;<br>&lt;ul&gt;<br>&lt;li class="item-0"&gt;&lt;a href="link1.html"&gt;first item&lt;/a&gt;&lt;/li&gt;<br>&lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt;<br>&lt;li class="item-inactive"&gt;&lt;a href="link3.html"&gt;third item&lt;/a&gt;&lt;/li&gt;<br>&lt;li class="item-1"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt;<br>&lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt;<br>&lt;/ul&gt;<br>&lt;/div&gt;<br>'''<br><br># 调用HTML类进行初始化,这样就可以成功构造一个XPath解析对象<br>html = etree.HTML(text)<br># 通过调用tostring()方法可以输出修正后的HTML代码,但是结果是bytes类型<br>result = etree.tostring(html)   <br># 利用decode()方法可以将其转成str类型<br>print(result.decode('utf-8'))<br><br>***************************************************************<br><br>运行结果：<br>&lt;html&gt;&lt;body&gt;&lt;div&gt;<br>&lt;ul&gt;<br>&lt;li class="item-0"&gt;&lt;a href="link1.html"&gt;first item&lt;/a&gt;&lt;/li&gt;<br>&lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt;<br>&lt;li class="item-inactive"&gt;&lt;a href="link3.html"&gt;third item&lt;/a&gt;&lt;/li&gt;<br>&lt;li class="item-1"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt;<br>&lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt;<br>&lt;/ul&gt;<br>&lt;/div&gt;<br>&lt;/body&gt;&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>另外也可以直接读取文本文件进行解析，如下：</p><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python">from lxml import etree  # 导入lxml库的etree模块<br><br># 调用HTML类进行初始化,这样就可以成功构造一个XPath解析对象<br># test.html存放HTML代码<br>html = etree.parse('./test.html', etree.HTMLParser())<br># 通过调用tostring()方法可以输出修正后的HTML代码,但是结果是bytes类型<br>result = etree.tostring(html)<br># 利用decode()方法可以将其转成str类型<br>print(result.decode('utf-8'))<br><br>***************************************************************<br><br>运行结果：<br>&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"&gt;<br>&lt;html&gt;&lt;body&gt;&lt;div&gt;<br>&lt;ul&gt;<br>&lt;li class="item-0"&gt;&lt;a href="link1.html"&gt;first item&lt;/a&gt;&lt;/li&gt;<br>&lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt;<br>&lt;li class="item-inactive"&gt;&lt;a href="link3.html"&gt;third item&lt;/a&gt;&lt;/li&gt;<br>&lt;li class="item-1"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt;<br>&lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt;<br>&lt;/ul&gt;<br>&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>虽然输出多了一个DOCTYPE的声明，不过对解析无影响。</p><h3 id="所有结点"><a href="#所有结点" class="headerlink" title="所有结点"></a>所有结点</h3><p>我们一般会用<code>//</code>开头的XPath规则来选取所有符合要求的节点。</p><p>以上面的HTML文本为例，如果要选取所有节点，则可以这样实现：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree  <span class="hljs-comment"># 导入lxml库的etree模块</span><br><br><span class="hljs-comment"># 调用HTML类进行初始化,这样就可以成功构造一个XPath解析对象</span><br>html = etree.parse(<span class="hljs-string">'./test.html'</span>, etree.HTMLParser())<br><span class="hljs-comment"># 这里*代表匹配所有节点,即整个HTML文本中的所有节点都会被获取</span><br>result = html.xpath(<span class="hljs-string">'//*'</span>)<br>print(result)<br><br>***************************************************************<br><br>运行结果：<br>[&lt;Element html at <span class="hljs-number">0x1078e2b48</span>&gt;, &lt;Element body at <span class="hljs-number">0x1078e2c48</span>&gt;, &lt;Element div at <span class="hljs-number">0x1078e2c88</span>&gt;, &lt;Element ul at <span class="hljs-number">0x1078e2cc8</span>&gt;, &lt;Element li at <span class="hljs-number">0x1078e2d08</span>&gt;, &lt;Element a at <span class="hljs-number">0x1078e2d48</span>&gt;, &lt;Element li at <span class="hljs-number">0x1078e2d88</span>&gt;, &lt;Element a at <span class="hljs-number">0x1078e2dc8</span>&gt;, &lt;Element li at <span class="hljs-number">0x1078e2e08</span>&gt;, &lt;Element a at <span class="hljs-number">0x1078e2e48</span>&gt;, &lt;Element li at <span class="hljs-number">0x1078e2e88</span>&gt;, &lt;Element a at <span class="hljs-number">0x1078e2ec8</span>&gt;, &lt;Element li at <span class="hljs-number">0x1078e2f08</span>&gt;, &lt;Element a at <span class="hljs-number">0x1078e2f48</span>&gt;]<br></code></pre></td></tr></table></figure><p>可以看到运行结果是一个列表，每个元素是<strong>Element类型</strong>，其后跟了节点的名称，如html、body、div、ul、li、a等，所有节点都包含在列表中了。</p><p>当然，我们也可以通过匹配指定节点名称。如果想要获取所有li节点，可以做如下选择：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree  <span class="hljs-comment"># 导入lxml库的etree模块</span><br><br><span class="hljs-comment"># 调用HTML类进行初始化,这样就可以成功构造一个XPath解析对象</span><br>html = etree.parse(<span class="hljs-string">'./test.html'</span>, etree.HTMLParser())<br><span class="hljs-comment"># 这里使用"//li"选取所有li节点</span><br>result = html.xpath(<span class="hljs-string">'//li'</span>)<br>print(result)<br><span class="hljs-comment"># 如果要取出其中的一个对象，可以直接用中括号加索引，如[0]</span><br>print(result[<span class="hljs-number">0</span>])<br><br>***************************************************************<br><br>运行结果：<br>[&lt;Element li at <span class="hljs-number">0x1067c9c48</span>&gt;, &lt;Element li at <span class="hljs-number">0x1067c9c88</span>&gt;, &lt;Element li at <span class="hljs-number">0x1067c9cc8</span>&gt;, &lt;Element li at <span class="hljs-number">0x1067c9d08</span>&gt;, &lt;Element li at <span class="hljs-number">0x1067c9d48</span>&gt;]<br>&lt;Element li at <span class="hljs-number">0x1067c9c48</span>&gt;<br></code></pre></td></tr></table></figure><p>可以看到提取结果是一个列表形式，其中每个元素都是一个<strong>Element对象</strong>。</p><h3 id="子节点"><a href="#子节点" class="headerlink" title="子节点"></a>子节点</h3><p>我们通过<code>/</code>或<code>//</code>即可查找元素的子节点或子孙节点。</p><p>假如现在想要选择li节点的所有直接a子节点，可以这样实现：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree  <span class="hljs-comment"># 导入lxml库的etree模块</span><br><br><span class="hljs-comment"># 调用HTML类进行初始化,这样就可以成功构造一个XPath解析对象</span><br>html = etree.parse(<span class="hljs-string">'./test.html'</span>, etree.HTMLParser())<br><span class="hljs-comment"># 这里通过追加"/a"即选择了所有li节点的所有直接a子节点</span><br>result = html.xpath(<span class="hljs-string">'//li/a'</span>)<br>print(result)<br><br>***************************************************************<br><br>运行结果：<br>[&lt;Element a at <span class="hljs-number">0x1065c2c48</span>&gt;, &lt;Element a at <span class="hljs-number">0x1065c2c88</span>&gt;, &lt;Element a at <span class="hljs-number">0x1065c2cc8</span>&gt;, &lt;Element a at <span class="hljs-number">0x1065c2d08</span>&gt;, &lt;Element a at <span class="hljs-number">0x1065c2d48</span>&gt;]<br></code></pre></td></tr></table></figure><p>此处的<code>/</code>用于选取直接子节点，如果要获取所有子孙节点，就可以使用<code>//</code>。</p><p>例如，要获取ul节点下的所有子孙a节点，可以这样实现：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree  <span class="hljs-comment"># 导入lxml库的etree模块</span><br><br><span class="hljs-comment"># 调用HTML类进行初始化,这样就可以成功构造一个XPath解析对象</span><br>html = etree.parse(<span class="hljs-string">'./test.html'</span>, etree.HTMLParser())<br><span class="hljs-comment"># 这里通过追加"/a"即选择了所有li节点的所有直接a子节点</span><br>result = html.xpath(<span class="hljs-string">'//ul//a'</span>)<br>print(result)<br><br>***************************************************************<br><br>运行结果：<br>[&lt;Element a at <span class="hljs-number">0x1088e2c48</span>&gt;, &lt;Element a at <span class="hljs-number">0x1088e2c88</span>&gt;, &lt;Element a at <span class="hljs-number">0x1088e2cc8</span>&gt;, &lt;Element a at <span class="hljs-number">0x1088e2d08</span>&gt;, &lt;Element a at <span class="hljs-number">0x1088e2d48</span>&gt;]<br></code></pre></td></tr></table></figure><p>但是如果这里使用<code>result = html.xpath(&#39;//ul/a&#39;)</code>，则无法获取任何结果。因为<code>/</code>用户获取直接子节点，而在ul节点下没有直接a子节点，只有li节点，所以无法获取任何匹配结果。</p><h3 id="父节点"><a href="#父节点" class="headerlink" title="父节点"></a>父节点</h3><p>可以用<code>..</code>来实现查找父节点。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree  <span class="hljs-comment"># 导入lxml库的etree模块</span><br><br><span class="hljs-comment"># 调用HTML类进行初始化,这样就可以成功构造一个XPath解析对象</span><br>html = etree.parse(<span class="hljs-string">'./test.html'</span>, etree.HTMLParser())<br><span class="hljs-comment"># 现在首先选中href属性为link4.html的a节点,</span><br><span class="hljs-comment"># 然后再获取其父节点,然后再获取其class属性</span><br>result = html.xpath(<span class="hljs-string">'//a[@href="link4.html"]/../@class'</span>)<br>print(result)<br><br>***************************************************************<br><br>运行结果：<br>[<span class="hljs-string">'item-1'</span>]<br></code></pre></td></tr></table></figure><p>检查一下结果发现，这正是我们获取目标li节点的class。</p><p>同时我们也可以通过<code>parent::</code>来获取父节点，代码如下：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree  <span class="hljs-comment"># 导入lxml库的etree模块</span><br><br><span class="hljs-comment"># 调用HTML类进行初始化,这样就可以成功构造一个XPath解析对象</span><br>html = etree.parse(<span class="hljs-string">'./test.html'</span>, etree.HTMLParser())<br><span class="hljs-comment"># 现在首先选中href属性为link4.html的a节点,</span><br><span class="hljs-comment"># 然后再获取其父节点,然后再获取其class属性</span><br>result = html.xpath(<span class="hljs-string">'//a[@href="link4.html"]/parent::*/@class'</span>)<br>print(result)<br><br>***************************************************************<br><br>运行结果：<br>[<span class="hljs-string">'item-1'</span>]<br></code></pre></td></tr></table></figure><h3 id="属性匹配"><a href="#属性匹配" class="headerlink" title="属性匹配"></a>属性匹配</h3><p>在选取的时候，我们还可以通过<code>@</code>符号进行属性过滤。</p><p>比如，我们要选取class为<code>item-0</code>的li节点，可以这样实现：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree  <span class="hljs-comment"># 导入lxml库的etree模块</span><br><br><span class="hljs-comment"># 调用HTML类进行初始化,这样就可以成功构造一个XPath解析对象</span><br>html = etree.parse(<span class="hljs-string">'./test.html'</span>, etree.HTMLParser())<br><span class="hljs-comment"># 通过加入[@class="item-0"]限制了节点的class属性为"item-0"</span><br>result = html.xpath(<span class="hljs-string">'//li[@class="item-0"]'</span>)<br>print(result)<br><br>***************************************************************<br><br>运行结果：<br>[&lt;Element li at <span class="hljs-number">0x1078e2c48</span>&gt;, &lt;Element li at <span class="hljs-number">0x1078e2c88</span>&gt;]<br></code></pre></td></tr></table></figure><h3 id="文本获取"><a href="#文本获取" class="headerlink" title="文本获取"></a>文本获取</h3><p>我们用XPath中的<code>text()</code>方法获取节点中的文本，接下来尝试获取前面li节点中的文本，相关代码如下：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree  <span class="hljs-comment"># 导入lxml库的etree模块</span><br><br><span class="hljs-comment"># 调用HTML类进行初始化,这样就可以成功构造一个XPath解析对象</span><br>html = etree.parse(<span class="hljs-string">'./test.html'</span>, etree.HTMLParser())<br><span class="hljs-comment"># 两种方式:</span><br><span class="hljs-comment"># 一种是先选取a节点再获取文本</span><br>result1 = html.xpath(<span class="hljs-string">'//li[@class="item-0"]/a/text()'</span>)<br><span class="hljs-comment"># 一种是直接使用//获取文本</span><br>result2 = html.xpath(<span class="hljs-string">'//li[@class="item-0"]//text()'</span>)<br><span class="hljs-comment"># 两者结果一样,但使用“//”有时会获取更多的内容</span><br>print(result1, result2)<br><br>***************************************************************<br><br>运行结果：<br>[<span class="hljs-string">'first item'</span>, <span class="hljs-string">'fifth item'</span>] [<span class="hljs-string">'first item'</span>, <span class="hljs-string">'fifth item'</span>]<br></code></pre></td></tr></table></figure><ul><li>如果想要获取子孙节点内部的所有文本，可以直接用<code>//text()</code>的方式，这样可以保证获取到最全面的文本信息，但是可能会夹杂一些换行符等特殊字符；</li><li>如果想要获取某些特定子孙节点下的所有文本，可以先选取到特定的子孙节点，然后再调用<code>text()</code>方法获取其内部文本，这样可以保证获取的结果是整洁的。</li></ul><h3 id="属性获取"><a href="#属性获取" class="headerlink" title="属性获取"></a>属性获取</h3><p>用<code>@</code>符号来获取属性。</p><p>例如，我们想要获取<strong>所有li节点下所有a节点的href属性</strong>，代码如下：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree  <span class="hljs-comment"># 导入lxml库的etree模块</span><br><br><span class="hljs-comment"># 调用HTML类进行初始化,这样就可以成功构造一个XPath解析对象</span><br>html = etree.parse(<span class="hljs-string">'./test.html'</span>, etree.HTMLParser())<br><span class="hljs-comment"># 通过@href即可获取节点的href属性</span><br>result = html.xpath(<span class="hljs-string">'//li/a/@href'</span>)<br>print(result)<br><br>***************************************************************<br><br>运行结果：<br>[<span class="hljs-string">'link1.html'</span>, <span class="hljs-string">'link2.html'</span>, <span class="hljs-string">'link3.html'</span>, <span class="hljs-string">'link4.html'</span>, <span class="hljs-string">'link5.html'</span>]<br></code></pre></td></tr></table></figure><p>可以看到，我们成功获取了<strong>所有li节点下a节点的href属性</strong>，它们以列表形式返回。</p><p>注意，<strong>属性获取</strong>和<strong>属性匹配</strong>不同：</p><ul><li><strong>属性匹配</strong>：是中括号加属性名和值来限定某个属性，如：<code>[@href=&quot;link1.html&quot;]</code></li><li><strong>属性获取</strong>：是值获取节点的某个属性，如：<code>@href</code></li></ul><h3 id="属性多值匹配"><a href="#属性多值匹配" class="headerlink" title="属性多值匹配"></a>属性多值匹配</h3><p>有时候，某些节点的某个属性可能有多个值，例如：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree  <span class="hljs-comment"># 导入lxml库的etree模块</span><br><br>text = <span class="hljs-string">'''<br>&lt;li class="li li-first"&gt;&lt;a href="link1.html"&gt;first item&lt;/a&gt;&lt;/li&gt;<br>'''</span><br>html = etree.HTML(text)<br>result = html.xpath(<span class="hljs-string">'//li[@class="li"]/a/text()'</span>)<br>print(result)<br><br>***************************************************************<br><br>运行结果：<br>[]<br></code></pre></td></tr></table></figure><p>这里HTML文本中li节点的<strong>class属性</strong>有两个值<strong>li</strong>和<strong>li-first</strong>，此时如果还想用之前的属性匹配获取，就无法匹配了。</p><p>因此，就需要使用<code>contains()</code>函数了，代码可以改写如下：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree  <span class="hljs-comment"># 导入lxml库的etree模块</span><br><br>text = <span class="hljs-string">'''<br>&lt;li class="li li-first"&gt;&lt;a href="link1.html"&gt;first item&lt;/a&gt;&lt;/li&gt;<br>'''</span><br>html = etree.HTML(text)<br>result = html.xpath(<span class="hljs-string">'//li[contains(@class,"li")]/a/text()'</span>)<br>print(result)<br><br>***************************************************************<br><br>运行结果：<br>[<span class="hljs-string">'first item'</span>]<br></code></pre></td></tr></table></figure><p>这样通过<code>contains()</code>方法：</p><ul><li>第一个参数传入属性名称</li><li>第二个参数传入属性值</li></ul><p>只要此属性包含所传入的属性值，就可以完成匹配了。</p><p>这种方式在某个节点的某个属性有多个值的时候经常用到，如：某个节点的class属性通常由多个。</p><h3 id="多属性匹配"><a href="#多属性匹配" class="headerlink" title="多属性匹配"></a>多属性匹配</h3><p>根据多个属性确定一个节点，这时就需要同时匹配多个属性。</p><p>此时可以使用运算符<code>and</code>来连接，实例如下：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree  <span class="hljs-comment"># 导入lxml库的etree模块</span><br><br>text = <span class="hljs-string">'''<br>&lt;li class="li li-first" name="item"&gt;&lt;a href="link1.html"&gt;first item&lt;/a&gt;&lt;/li&gt;<br>'''</span><br>html = etree.HTML(text)<br>result = html.xpath(<span class="hljs-string">'//li[contains(@class,"li") and @name="item"]/a/text()'</span>)<br>print(result)<br><br>***************************************************************<br><br>运行结果：<br>[<span class="hljs-string">'first item'</span>]<br></code></pre></td></tr></table></figure><p>这里li节点又增加了一个属性name。要确定这个节点，需要同时根据class和name属性来选择，一个条件是class属性里面包含li字符串，另一个条件是name属性为item字符串，二者需要同时满足，用<code>and</code>操作符相连，相连之后置于中括号<code>[]</code>内进行条件筛选。</p><p>另外还有其他运算符：</p><div class="table-container"><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th><th>返回值</th></tr></thead><tbody><tr><td>or</td><td>或</td><td>age=19 or age=20</td><td>如果age是19或20，则返回true。否则，返回false。</td></tr><tr><td>and</td><td>与</td><td>age&gt;19 and age&lt;21</td><td>如果age是20，则返回true。否则，返回false。</td></tr><tr><td>mod</td><td>计算机除法的余数</td><td>5 mod 2</td><td>1</td></tr><tr><td>\</td><td></td><td>计算两个节点集</td><td>//book \</td><td>//cd</td><td>返回所有拥有book和cd元素的节点集</td></tr><tr><td>+</td><td>加法</td><td>6 + 4</td><td>10</td></tr><tr><td>-</td><td>减法</td><td>6 - 4</td><td>2</td></tr><tr><td>*</td><td>乘法</td><td>6 * 4</td><td>24</td></tr><tr><td>div</td><td>除法</td><td>8 div 4</td><td>2</td></tr><tr><td>=</td><td>等于</td><td>age=19</td><td>如果age是19，则返回true。否则，返回false。</td></tr><tr><td>!=</td><td>不等于</td><td>age!=19</td><td>如果age是19，则返回false。否则，返回true。</td></tr><tr><td>&lt;</td><td>小于</td><td>age&lt;19</td><td>如果age小于19，则返回true。否则，返回false。</td></tr><tr><td>&lt;=</td><td>小于等于</td><td>age\&lt;=19</td><td>如果age小于等于19，则返回true。否则，返回false。</td></tr><tr><td>&gt;</td><td>大于</td><td>age&gt;19</td><td>如果age大于19，则返回true。否则，返回false。</td></tr><tr><td>>=</td><td>大于等于</td><td>age>=19</td><td>如果age大于等于19，则返回true。否则，返回false。</td></tr></tbody></table></div><h3 id="按序选择"><a href="#按序选择" class="headerlink" title="按序选择"></a>按序选择</h3><p>有时候，在选择的时候某些属性可能同时匹配了多个节点，但是只想要其中的某个节点，如第二个节点或者最后一个节点，此时可以 利用中括号传入索引的方法获取特定次序的节点，示例如下：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree  <span class="hljs-comment"># 导入lxml库的etree模块</span><br><br><span class="hljs-comment"># 调用HTML类进行初始化,这样就可以成功构造一个XPath解析对象</span><br>html = etree.parse(<span class="hljs-string">'./test.html'</span>, etree.HTMLParser())<br><span class="hljs-comment"># 选取第一个节点,注意从1开始</span><br>result = html.xpath(<span class="hljs-string">'//li[1]/a/text()'</span>)<br>print(result)<br><span class="hljs-comment"># 选取最后一个节点</span><br>result = html.xpath(<span class="hljs-string">'//li[last()]/a/text()'</span>)<br>print(result)<br><span class="hljs-comment"># 选取位置小于3的节点,即位置序号为1和2的节点</span><br>result = html.xpath(<span class="hljs-string">'//li[position()&lt;3]/a/text()'</span>)<br>print(result)<br><span class="hljs-comment"># 选取倒数第三个li节点</span><br>result = html.xpath(<span class="hljs-string">'//li[last()-2]/a/text()'</span>)<br>print(result)<br><br>***************************************************************<br><br>运行结果：<br>[<span class="hljs-string">'first item'</span>]<br>[<span class="hljs-string">'fifth item'</span>]<br>[<span class="hljs-string">'first item'</span>, <span class="hljs-string">'second item'</span>]<br>[<span class="hljs-string">'third item'</span>]<br></code></pre></td></tr></table></figure><p>这里使用了<code>last()</code>、<code>position()</code>函数。</p><p>在XPath中，提供了100多个函数，包括存取、数值、字符串、逻辑、节点、序列等处理功能。</p><p>具体可以参考<a href="https://www.w3school.com.cn/xpath/xpath_functions.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/xpath/xpath_functions.asp</a></p><h3 id="节点轴选择"><a href="#节点轴选择" class="headerlink" title="节点轴选择"></a>节点轴选择</h3>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> 原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 解析库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫实例1-猫眼电影排行</title>
      <link href="/2019/08/11/%E7%88%AC%E8%99%AB%E5%AE%9E%E4%BE%8B1-%E7%8C%AB%E7%9C%BC%E7%94%B5%E5%BD%B1%E6%8E%92%E8%A1%8C/"/>
      <url>/2019/08/11/%E7%88%AC%E8%99%AB%E5%AE%9E%E4%BE%8B1-%E7%8C%AB%E7%9C%BC%E7%94%B5%E5%BD%B1%E6%8E%92%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>本文简单介绍爬取猫眼电影排行前100榜单。</p><p>主要爬取的电影信息有：排名，名称，图片，详情页，演员，上映时间，评分，简介。</p><a id="more"></a><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> json<br><br><span class="hljs-comment"># 存放所有电影内容</span><br>contents = []<br><br><br><span class="hljs-comment"># 获取一个榜单页面</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_one_page</span><span class="hljs-params">(url)</span>:</span><br>    headers = &#123;<br>        <span class="hljs-string">'User-Agent'</span>: <span class="hljs-string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) \<br>                      AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36'</span><br>    &#125;<br>    response = requests.get(url, headers=headers)<br>    <span class="hljs-keyword">if</span> response.status_code == <span class="hljs-number">200</span>:    <span class="hljs-comment"># 如果正常返回请求</span><br>        <span class="hljs-keyword">return</span> response.text<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br><br><span class="hljs-comment"># 获取该电影的简单描述</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_movie_desc</span><span class="hljs-params">(url)</span>:</span><br>    headers = &#123;<br>        <span class="hljs-string">'User-Agent'</span>: <span class="hljs-string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) \<br>                          AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36'</span><br>    &#125;<br>    response = requests.get(url, headers=headers)<br>    desc = re.search(<span class="hljs-string">'&lt;meta name="description" content=".*?故事梗概:(.*?)"&gt;'</span>, response.text).group(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> desc<br><br><br><span class="hljs-comment"># 处理每一部电影</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse_one_page</span><span class="hljs-params">(html)</span>:</span><br>    pattern = re.compile(<br>        <span class="hljs-string">'&lt;i class="board-index board-index-.*?"&gt;(.*?)&lt;/i&gt;.*?(/films/.*?)" title="(.*?)".*?&lt;img data-src="(.*?)".*?&lt;p class="star"&gt;.*?主演：(.*?)\\n.*?&lt;/p&gt;.*?上映时间：(.*?)&lt;/p&gt;.*?&lt;i class="integer"&gt;(.*?).&lt;/i&gt;&lt;i class="fraction"&gt;(.*?)&lt;/i&gt;&lt;/p&gt;'</span>,<br>        re.S)<br>    items = re.findall(pattern, html)<br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> items:<br>        content = &#123;<br>            <span class="hljs-string">'index'</span>: item[<span class="hljs-number">0</span>],   <span class="hljs-comment"># 电影排名</span><br>            <span class="hljs-string">'details'</span>: <span class="hljs-string">'https://maoyan.com'</span> + item[<span class="hljs-number">1</span>],  <span class="hljs-comment"># 电影详情页</span><br>            <span class="hljs-string">'title'</span>: item[<span class="hljs-number">2</span>],   <span class="hljs-comment"># 电影名称</span><br>            <span class="hljs-string">'image'</span>: item[<span class="hljs-number">3</span>],   <span class="hljs-comment"># 电影图片</span><br>            <span class="hljs-string">'actor'</span>: item[<span class="hljs-number">4</span>],   <span class="hljs-comment"># 电影演员</span><br>            <span class="hljs-string">'time'</span>: item[<span class="hljs-number">5</span>],    <span class="hljs-comment"># 电影上映时间</span><br>            <span class="hljs-string">'score'</span>: item[<span class="hljs-number">6</span>] + <span class="hljs-string">'.'</span> + item[<span class="hljs-number">7</span>]    <span class="hljs-comment"># 电影评分</span><br>        &#125;<br>        content[<span class="hljs-string">'desc'</span>] = get_movie_desc(content[<span class="hljs-string">'details'</span>])    <span class="hljs-comment"># 电影简介</span><br>        print(content)<br>        time.sleep(<span class="hljs-number">2</span>)   <span class="hljs-comment"># 休息2s再爬,防止封ip</span><br>        contents.append(content)<br><br><br><span class="hljs-comment"># 将电影存放到maoyan.json文件中,方便以后调用</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write_to_file</span><span class="hljs-params">(contents)</span>:</span><br>    <span class="hljs-keyword">with</span> open(<span class="hljs-string">'maoyan.json'</span>, <span class="hljs-string">'w'</span>, encoding=<span class="hljs-string">'utf-8'</span>) <span class="hljs-keyword">as</span> f:<br>        f.write(json.dumps(contents, ensure_ascii=<span class="hljs-literal">False</span>) + <span class="hljs-string">'\n'</span>)<br><span class="hljs-comment"># 指定ensure_ascii为False可以确保输出结果是中文形式而不是Unicode编码</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    url = <span class="hljs-string">'https://maoyan.com/board/4?offset='</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):<br>        <span class="hljs-comment"># print(url+str(i*10))</span><br>        html = get_one_page(url + str(i * <span class="hljs-number">10</span>))<br>        parse_one_page(html)<br>    write_to_file(contents)<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> 爬虫实例 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> 正则表达式 </tag>
            
            <tag> 实例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2019/08/11/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2019/08/11/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>正则表达式是描述一组字符串特征的模式，有助于找到文本字符串中的各种模式。</p><p>更确切的说，正则表达式是经过专门编写的文本字符串，用来匹配字符串（尤其是文件内字符串）集合中符合该模式的所有字符串。</p><a id="more"></a><h2 id="常用匹配规则"><a href="#常用匹配规则" class="headerlink" title="常用匹配规则"></a>常用匹配规则</h2><div class="table-container"><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>\w</td><td>匹配字母、数字及下划线</td></tr><tr><td>\W</td><td>匹配除字母、数字及下划线以外</td></tr><tr><td>\s</td><td>匹配任意空白字符，等价于 <code>[\t\n\r\f]</code></td></tr><tr><td>\S</td><td>匹配任意非空字符</td></tr><tr><td>\d</td><td>匹配任意数字，等价于 <code>[0-9]</code></td></tr><tr><td>\D</td><td>匹配除数字外的字符</td></tr><tr><td>\A</td><td>匹配字符串开头</td></tr><tr><td>\z</td><td>匹配字符串结尾，如果存在换行，同时还会匹配换行符</td></tr><tr><td>\Z</td><td>匹配字符串结尾，如果存在换行，只匹配到换行前的结束字符串</td></tr><tr><td>\G</td><td>匹配最后匹配完成的位置</td></tr><tr><td>\n</td><td>匹配一个换行符</td></tr><tr><td>\t</td><td>匹配一个制表符</td></tr><tr><td>^</td><td>匹配一行字符串的开头</td></tr><tr><td>$</td><td>匹配一行字符串的结尾</td></tr><tr><td>.</td><td>匹配除了换行符外的任意字符。当<code>re.DOTALL</code>标记被指定时，则可以匹配包括换行符的任意字符。</td></tr><tr><td>[…]</td><td>用来表示一组字符，单独列出，比如 <code>[amk]</code>匹配a、m或k</td></tr><tr><td><sup><a href="#fn_..." id="reffn_...">...</a></sup></td><td>不在<code>[...]</code>中的字符，比如<code>[^abc]</code>匹配除了a、b、c之外的字符</td></tr><tr><td>*</td><td>匹配0个或多个表达式</td></tr><tr><td>+</td><td>匹配1个或多个表达式</td></tr><tr><td>?</td><td>匹配0个或1个前面的正则表达式定义的片段，非贪婪方式</td></tr><tr><td>{n}</td><td>精确匹配n个前面的表达式</td></tr><tr><td>{n,m}</td><td>匹配n到m个由前面正则表达式定义的片段，贪婪方式</td></tr><tr><td>a\</td><td>b</td><td>匹配a或b</td></tr><tr><td>( )</td><td>匹配括号内的表达式，也表示一个组</td></tr></tbody></table></div><h2 id="re库-Python"><a href="#re库-Python" class="headerlink" title="re库(Python)"></a>re库(Python)</h2><h3 id="match方法"><a href="#match方法" class="headerlink" title="match方法"></a>match方法</h3><p>向<code>match</code>传入要匹配的字符串以及正则表达式，就可以检测这个正则表达式是否匹配字符串。</p><p><strong><em>第一个参数传入正则表达式，第二个参数传入要匹配的字符串。</em></strong></p><p><code>match</code>从字符串的起始位置匹配正则表达式：</p><ul><li>如果匹配，就返回匹配成功的结果</li><li>如果不匹配，就返回None</li></ul><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>content = <span class="hljs-string">'Hello 123 4567 World_This is a Regex Demo'</span><br>print(len(content))<br>result = re.match(<span class="hljs-string">'^Hello\s\d\d\d\s\d&#123;4&#125;\s\w&#123;10&#125;'</span>, content)<br>print(result)<br>print(result.group())<br>print(result.span())<br><br>*************************************************************<br><br>运行结果如下:<br><span class="hljs-number">41</span><br>&lt;_sre.SRE_Match object; span=(<span class="hljs-number">0</span>, <span class="hljs-number">25</span>), match=<span class="hljs-string">'Hello 123 4567 World_This'</span>&gt;<br>Hello <span class="hljs-number">123</span> <span class="hljs-number">4567</span> World_This<br>(<span class="hljs-number">0</span>, <span class="hljs-number">25</span>)<br></code></pre></td></tr></table></figure><ol><li>开头的<code>^</code>是匹配字符串的开头，也就是以<code>Hello</code>开头；</li><li><code>\s</code>匹配空白字符，用来匹配目标串的空格；</li><li><code>\d</code>匹配数字，3个<code>\d</code>匹配123；</li><li><code>\s</code>匹配1个空格；</li><li><code>\d{4}</code>代表匹配前面的规则4次，也就是匹配4个数字；</li><li><code>\s</code>匹配1个空格；</li><li><code>\w{10}</code>匹配10个字母、数字及下划线；</li></ol><p>若输出结果是<strong>SRE_Match</strong>对象，则证明匹配成功。</p><p>该对象有两个方法：</p><ul><li><strong>group()：</strong>可以输出正则表达式规则匹配到的内容；</li><li><strong>span()：</strong>可以输出正则表达式规则所匹配到的结果字符串在原字符串中的位置范围；</li></ul><h4 id="匹配目标"><a href="#匹配目标" class="headerlink" title="匹配目标"></a>匹配目标</h4><p>可以使用<code>()</code>括号将想提取的子字符串括起来。<code>()</code>实际上标记了一个子表达式的开始和结束位置，被标记的每个子表达式会依次对应每一个分组，调用<code>group()</code>传入分组的索引即可获取提取的结果。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>content = <span class="hljs-string">'Hello 1234567 World_This is a Regex Demo'</span><br>print(len(content))<br>result = re.match(<span class="hljs-string">'^Hello\s(\d+)\s(World)'</span>, content)<br>print(result)<br>print(result.group())<br>print(result.group(<span class="hljs-number">0</span>))<br>print(result.group(<span class="hljs-number">1</span>))<br>print(result.group(<span class="hljs-number">2</span>))<br>print(result.span())<br><br>******************************************************************<br><br>运行结果：<br><span class="hljs-number">40</span><br>&lt;_sre.SRE_Match object; span=(<span class="hljs-number">0</span>, <span class="hljs-number">19</span>), match=<span class="hljs-string">'Hello 1234567 World'</span>&gt;<br>Hello <span class="hljs-number">1234567</span> World<br>Hello <span class="hljs-number">1234567</span> World<br><span class="hljs-number">1234567</span><br>World<br>(<span class="hljs-number">0</span>, <span class="hljs-number">19</span>)<br></code></pre></td></tr></table></figure><p>从结果中看出：</p><ul><li><code>group()</code>和<code>group(0)</code>结果相同，都是输出完整的匹配内容；</li><li><code>group(1)</code>输出第一个被<code>()</code>包围的内容；</li><li>如果正则表达式后面还有被<code>()</code>包围的内容，可以依次用<code>group(2)</code>、<code>group(3)</code>等来获取；</li></ul><h4 id="通用匹配"><a href="#通用匹配" class="headerlink" title="通用匹配"></a>通用匹配</h4><p>在正则表达式中，可以使用通用匹配(即万能匹配)，其中：</p><ul><li><code>.(点)</code>可以匹配<strong>除换行符外</strong>任意字符</li><li><code>*(星)</code>代表前面的字符可以匹配无线次</li></ul><p>因此，可以用<code>.*</code>组合匹配任意字符串。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>content = <span class="hljs-string">'Hello 123 4567 World_This is a Regex Demo'</span><br>print(len(content))<br>result = re.match(<span class="hljs-string">'^Hello.*Demo$'</span>, content)<br>print(result)<br>print(result.group())<br>print(result.span())<br><br>******************************************************************<br><br>运行结果：<br><span class="hljs-number">41</span><br>&lt;_sre.SRE_Match object; span=(<span class="hljs-number">0</span>, <span class="hljs-number">41</span>), match=<span class="hljs-string">'Hello 123 4567 World_This is a Regex Demo'</span>&gt;<br>Hello <span class="hljs-number">123</span> <span class="hljs-number">4567</span> World_This <span class="hljs-keyword">is</span> a Regex Demo<br>(<span class="hljs-number">0</span>, <span class="hljs-number">41</span>)<br></code></pre></td></tr></table></figure><p>可以看到，<code>group()</code>方法输出了匹配的全部字符串，也就是说我们写的正则表达式匹配到了目标字符串的全部内容，<code>span()</code>方法输出(0, 41)，这是整个字符串的长度。</p><h4 id="贪婪和非贪婪"><a href="#贪婪和非贪婪" class="headerlink" title="贪婪和非贪婪"></a>贪婪和非贪婪</h4><ul><li>在贪婪匹配下，<code>.*</code> 会匹配尽可能多的字符。</li><li>在非贪婪匹配下，<code>.*?</code> 会匹配尽可能少的字符。</li></ul><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>content = <span class="hljs-string">'Hello 1234567 World_This is a Regex Demo'</span><br>print(len(content))<br><br><span class="hljs-comment"># 贪婪匹配</span><br>result = re.match(<span class="hljs-string">'^He.*(\d+).*Demo$'</span>, content)<br>print(<span class="hljs-string">'贪婪匹配: '</span>+ result.group(<span class="hljs-number">1</span>))<br><br><span class="hljs-comment"># 非贪婪匹配</span><br>result = re.match(<span class="hljs-string">'^He.*?(\d+).*Demo$'</span>, content)<br>print(<span class="hljs-string">'非贪婪匹配: '</span>+ result.group(<span class="hljs-number">1</span>))<br><br>******************************************************************<br><br>运行结果：<br><span class="hljs-number">40</span><br>贪婪匹配: <span class="hljs-number">7</span><br>非贪婪匹配: <span class="hljs-number">1234567</span><br></code></pre></td></tr></table></figure><p><strong>在做匹配的时候，字符串中间尽量使用非贪婪匹配，也就是用 <code>.*?</code> 代替 <code>.*</code> ，以免出现匹配结果缺失的情况。</strong></p><p>但是要注意，如果匹配的结果在字符串的结尾，<code>.*?</code>就有可能匹配不到任何内容了，因为他会匹配尽可能少的字符。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>content = <span class="hljs-string">'Hello 1234567 World_This is a Regex Demo'</span><br>print(len(content))<br><br><span class="hljs-comment"># 贪婪匹配</span><br>result = re.match(<span class="hljs-string">'^He.*Regex (.*)'</span>, content)<br>print(<span class="hljs-string">'贪婪匹配: '</span>+ result.group(<span class="hljs-number">1</span>))<br><br><span class="hljs-comment"># 非贪婪匹配</span><br>result = re.match(<span class="hljs-string">'^He.*Regex (.*?)'</span>, content)<br>print(<span class="hljs-string">'非贪婪匹配: '</span>+ result.group(<span class="hljs-number">1</span>))<br><br>******************************************************************<br><br>运行结果：<br><span class="hljs-number">40</span><br>贪婪匹配: Demo<br>非贪婪匹配:<br></code></pre></td></tr></table></figure><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><p>正则表达式可以包含一些可选标志修饰符来控制匹配的模式。</p><p>修饰符被指定为一个可选的标志。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>content = <span class="hljs-string">'''Hello 1234567 World_This<br> is a Regex Demo'''</span><br>print(len(content))<br>result = re.match(<span class="hljs-string">'^He.*Regex (.*)'</span>, content)<br>print(result.group(<span class="hljs-number">1</span>))<br><br>******************************************************************<br><br>运行结果：<br><span class="hljs-number">41</span><br>Traceback (most recent call last):<br>  File <span class="hljs-string">"/Users/huben/Desktop/spider/cs.py"</span>, line <span class="hljs-number">7</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    print(result.group(<span class="hljs-number">1</span>))<br>AttributeError: <span class="hljs-string">'NoneType'</span> object has no attribute <span class="hljs-string">'group'</span><br></code></pre></td></tr></table></figure><p>运行直接报错，也就是说正则表达式没有匹配到这个字符串，返回的结果为None，而又调用了<code>group()</code>方法导致<code>AttributeError</code>。</p><p><strong>原因：</strong> <code>.</code> 匹配的是除了换行符之外的任意字符，当遇到换行符时，<code>.*?</code> 就不能匹配了，所以导致失败。</p><p>这里可以加上修饰符 <code>re.S</code> ，即可修正这个错误。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>content = <span class="hljs-string">'''Hello 1234567 World_This<br> is a Regex Demo'''</span><br>print(len(content))<br>result = re.match(<span class="hljs-string">'^He.*Regex (.*)'</span>, content, re.S)<br>print(result.group(<span class="hljs-number">1</span>))<br><br>******************************************************************<br><br>运行结果：<br><span class="hljs-number">41</span><br>Demo<br></code></pre></td></tr></table></figure><p>这个<code>re.S</code>在网页匹配中经常用到。因为HTML节点经常会有换行，加上它，就可以匹配节点与节点之间的换行了。</p><p>另外还有一些修饰符如下：</p><div class="table-container"><table><thead><tr><th>修饰符</th><th>描述</th></tr></thead><tbody><tr><td>re.I</td><td>使匹配与大小写不敏感</td></tr><tr><td>re.L</td><td>做本地化识别(locale-aware)匹配</td></tr><tr><td>re.M</td><td>多行匹配，影响 ^ 和 $</td></tr><tr><td>re.S</td><td>使 . (点) 匹配包括换行在内的所有字符</td></tr><tr><td>re.U</td><td>根据Unicode字符集解析字符。这个标志影响\w, \W, \b, \B</td></tr><tr><td>re.X</td><td>该标志通过给予更灵活的格式以便将正则表达式写的更易于理解</td></tr></tbody></table></div><p>较为常用的是 <code>re.I</code> ，和 <code>re.S</code> 。</p><h4 id="转义匹配"><a href="#转义匹配" class="headerlink" title="转义匹配"></a>转义匹配</h4><p>在正则表达式中定义了很多匹配，但是如果要匹配包含 <code>.</code> 等特殊字符时，就需要使用转义匹配了。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>content = <span class="hljs-string">'(百度)www.baidu.com'</span><br>result = re.match(<span class="hljs-string">'\(百度\)www\.baidu\.com'</span>, content)<br>print(result.group())<br><br>******************************************************************<br><br>运行结果：<br>(百度)www.baidu.com<br></code></pre></td></tr></table></figure><p>当遇到用于正则匹配模式的特殊字符时，<strong>在前面加反斜杠转义一下即可</strong>。</p><h3 id="search方法"><a href="#search方法" class="headerlink" title="search方法"></a>search方法</h3><p><code>match()</code>方法在匹配时是从字符串的开头开始匹配的，一旦开头不匹配，那么整个匹配就会失败。这在做匹配时会非常不方便，它更适合用来检测某个字符串是否符合某个正则表达式的规则。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>content = <span class="hljs-string">'Extra strings Hello 1234567 World_This is a Regex Demo'</span><br>print(len(content))<br>result = re.match(<span class="hljs-string">'He.*Regex (.*)'</span>, content)<br>print(result.group(<span class="hljs-number">1</span>))<br><br>******************************************************************<br><br>运行结果：<br>Traceback (most recent call last):<br>  File <span class="hljs-string">"/Users/huben/Desktop/spider/cs.py"</span>, line <span class="hljs-number">6</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br><span class="hljs-number">54</span><br>    print(result.group(<span class="hljs-number">1</span>))<br>AttributeError: <span class="hljs-string">'NoneType'</span> object has no attribute <span class="hljs-string">'group'</span><br></code></pre></td></tr></table></figure><p>而<code>search()</code>方法在匹配的时候会扫描整个字符串，然后<strong>返回第一个成功匹配的结果</strong>。</p><p>即，<strong>正则表达式可以是字符串的一部分</strong>，在匹配时，<code>search()</code>方法会依次扫描字符串，直到找到第一个符合规则的字符串，然后返回匹配内容，如果搜索完了还没有找到，则返回<strong>None</strong>。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>content = <span class="hljs-string">'Extra strings Hello 1234567 World_This is a Regex Demo'</span><br>print(len(content))<br>result = re.search(<span class="hljs-string">'He.*Regex (.*)'</span>, content)<br>print(result.group())<br><br>******************************************************************<br><br>运行结果：<br><span class="hljs-number">54</span><br>Hello <span class="hljs-number">1234567</span> World_This <span class="hljs-keyword">is</span> a Regex Demo<br></code></pre></td></tr></table></figure><p>因此，为了匹配方便，我们尽量使用<code>search()</code>方法。</p><h3 id="findall方法"><a href="#findall方法" class="headerlink" title="findall方法"></a>findall方法</h3><p>如果想要获取正则表达式的所有内容，则需要借助 <code>findall()</code> 方法。</p><p>该方法会搜索整个字符串，然后返回匹配正则表达式的所有内容。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">results = re.findall(RegEx, content, re.S) <span class="hljs-comment"># 匹配所有结果</span><br><span class="hljs-keyword">for</span> result <span class="hljs-keyword">in</span> results:<br>    print(result)<br>    print(result[<span class="hljs-number">0</span>],result[<span class="hljs-number">1</span>],result[<span class="hljs-number">2</span>])<span class="hljs-comment"># 这里相当于group(1),group(2)...</span><br></code></pre></td></tr></table></figure><p>可以看出，返回的列表中的每个元素都是元组类型，可以用对应的索引依次取出即可。</p><h3 id="sub方法"><a href="#sub方法" class="headerlink" title="sub方法"></a>sub方法</h3><p>除了使用正则表达式提取信息外，有时候还需要借助它来修改文本。</p><p>比如要把一串文本中的所有数字都去掉，如果只用字符串的<code>replace()</code>方法，那就太繁琐了。</p><p>可以使用<code>sub()</code>方法。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>content = <span class="hljs-string">"Hello 1234567 World_This is a Regex Demo"</span><br>content = re.sub(<span class="hljs-string">' \d+'</span>, <span class="hljs-string">''</span>, content)<br>print(content)<br><br>******************************************************************<br><br>运行结果：<br>Hello World_This <span class="hljs-keyword">is</span> a Regex Demo<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><strong>第一个参数：</strong>传入<code>\d+</code>来匹配所有的数字；</li><li><strong>第二个参数：</strong>替换成的字符串(如果去掉该参数的话，可以赋值为空)；</li><li><strong>第三个参数：</strong>原字符串；</li></ul><h3 id="compile方法"><a href="#compile方法" class="headerlink" title="compile方法"></a>compile方法</h3><p><code>compile()</code>方法可以将正则字符串编译成正则表达式对象，以便在后面的匹配中复用。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>content1 = <span class="hljs-string">'2016-12-15 12:00'</span><br>content2 = <span class="hljs-string">'2016-12-17 12:55'</span><br>content3 = <span class="hljs-string">'2016-12-22 13:21'</span><br><br>pattern = re.compile(<span class="hljs-string">'\d&#123;2&#125;:\d&#123;2&#125;'</span>)<br><br>result1 = re.sub(pattern, <span class="hljs-string">''</span>, content1)<br>result2 = re.sub(pattern, <span class="hljs-string">''</span>, content2)<br>result3 = re.sub(pattern, <span class="hljs-string">''</span>, content3)<br><br>print(result1, result2, result3)<br><br>******************************************************************<br><br>运行结果：<br><span class="hljs-number">2016</span><span class="hljs-number">-12</span><span class="hljs-number">-15</span>  <span class="hljs-number">2016</span><span class="hljs-number">-12</span><span class="hljs-number">-17</span>  <span class="hljs-number">2016</span><span class="hljs-number">-12</span><span class="hljs-number">-22</span><br></code></pre></td></tr></table></figure><p>例如，如果我们想要将三个日期中的时间去掉，此时可以借助<code>sub()</code>方法。</p><p>该方法的第一个参数是正则表达式，但是这里没有必要重复写3个同样的正则表达式，此时可以借助<code>compile()</code>方法将正则表达式编译成一个正则表达式对象，以便复用。</p><p>另外，<code>compile()</code>还可以传入修饰符，例如<code>re.S</code>等修饰符，这样在<code>search()</code>、<code>findall()</code>等方法中就不需要额外传了。例如：<code>pattern = re.compile(&#39;\d{2}:\d{2}&#39;, re.S)</code></p>]]></content>
      
      
      <categories>
          
          <category> 计算机工具 </category>
          
          <category> 正则表达式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> 正则表达式 </tag>
            
            <tag> 字符串处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代理的基本原理</title>
      <link href="/2019/08/11/%E4%BB%A3%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
      <url>/2019/08/11/%E4%BB%A3%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>当我们在做爬虫的时候，刚开始可以正常抓取数据，然而一段时间过后可能会出现错误，比如<strong>403 Forbidden</strong>，这时候打开网页一看，可能会看到<strong>IP访问频率过高</strong>这样的提示。出现这种现象的原因是网站采取了反爬虫措施。</p><p>当服务器检测到某个IP在单位时间内的请求次数，如果超过了这个阈值，就会直接拒绝服务，返回一些错误信息，这种情况可以称为封IP。</p><p>既然服务器检测的是某个IP单位时间的请求次数，那么借助某种方式来伪装我们的IP，让服务器识别不出是由我们本机发起的请求，就可以防止封IP了。</p><p>一种有效的方式就是使用代理，本文主要介绍了代理的一些基本原理。</p><a id="more"></a><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>代理实际上指的是代理服务器(proxy server)，功能是代理网络用户去取得网络信息，即网络信息的中转站。</p><p>如果设置了代理服务器，就可以在本机和服务器之间搭建一个桥，此时本机不是直接向Web服务器发起请求，而是向代理服务器发起请求，请求会发送给代理服务器，然后由代理服务器再发送给Web服务器，接着由代理服务器再把Web服务器返回的响应转发给本机。</p><p>这样我们同样可以正常访问页面，但这个过程中Web服务器识别出的真实IP就不再是我们本机的IP，就成功实现了IP伪装，即代理。</p><h2 id="代理的作用"><a href="#代理的作用" class="headerlink" title="代理的作用"></a>代理的作用</h2><ul><li>突破自身IP访问限制，访问一些平时不能访问的站点。</li><li>访问一些单位或团体内部资源：比如使用教育网内地址段免费代理服务器，就可以用于对教育网开放的各类FTP下载上传，以及各类资料查询共享等服务。</li><li>提高访问速度：通常代理服务器都设置一个较大的硬盘缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时，则直接由缓冲区中取信息，传给用户，以提高访问速度。</li><li>隐藏真实IP：上网者也可以通过这种方法隐藏自己的IP，免受攻击。对于爬虫来说，我们用代理就是为了隐藏自身的IP，防止自身的IP被封锁。</li></ul><h2 id="代理分类"><a href="#代理分类" class="headerlink" title="代理分类"></a>代理分类</h2><p>代理分类时，既可以根据协议区分，也可以根据其匿名程度区分。</p><h3 id="根据协议区分"><a href="#根据协议区分" class="headerlink" title="根据协议区分"></a>根据协议区分</h3><p>根据代理的协议，代理可以分为如下类别：</p><ul><li><strong>FTP代理服务器：</strong>主要用于访问FTP服务器，一般有上传、下载以及缓存功能，短裤一般为21、2121等。</li><li><strong>HTTP代理服务器：</strong>主要用于访问网页，一般有内容过滤和缓存功能，端口一般为80、8080、3128等。</li><li><strong>SSL/TLS代理：</strong>主要用于访问加密网站，一般有SSL或TLS加密功能(最高支持128位加密强度)，端口一般为443。</li><li><strong>RTSP代理：</strong>主要用于访问Real流媒体服务器，一般有缓存功能，端口一般为554。</li><li><strong>Telnet代理：</strong>主要用于telnet远程控制(黑客入侵计算机时常用于隐藏身份)，端口一把为23。</li><li><strong>POP3/SMTP代理：</strong>主要用于POP3/SMTP方式收发邮件，一般有缓存功能，端口一般为110/25。</li><li><strong>SOCKS代理：</strong>只是单纯传递数据包，不关心具体协议和用法，所以速度快很多，一般有缓存功能，端口一般为1080。SOCKS代理又分为SOCKS4和SOCKS5，前者只支持TCP，后者支持TCP和UDP，还支持各种身份验证机制、服务器域名解析等。SOCKS4能做的，SOCKS5都能做。</li></ul><h3 id="根据匿名程度区分"><a href="#根据匿名程度区分" class="headerlink" title="根据匿名程度区分"></a>根据匿名程度区分</h3><p>根据代理的匿名程度，代理可以分为如下类别：</p><ul><li><strong>高度匿名代理：</strong>会将数据包原封不动地转发，在服务端看来就好像真的是一个普通客户端在访问，而记录的IP是代理服务器的IP。</li><li><strong>普通匿名代理：</strong>会在数据包上做一些改动，服务端上有可能发现这是个代理服务器，也有一定几率追查到客户端的真实IP。代理服务器通常会加入的HTTP头有<code>HTTP_VIA</code>和<code>HTTP_X_FORWARDED_FOR</code>。</li><li><strong>透明代理：</strong>不但改动了数据包，还会告诉服务器客户端的真实IP。这种代理除了能用缓存的技术提高浏览速度，能用内容过滤提高安全性外，并无其他显著作用，最常见的例子是内网中的硬件防火墙。</li><li><strong>间谍代理：</strong>指组织或个人创建的用于记录用户传输的数据，然后进行研究、监控等目的的代理服务器。</li></ul><h2 id="常见的代理设置"><a href="#常见的代理设置" class="headerlink" title="常见的代理设置"></a>常见的代理设置</h2><ul><li><strong>使用网上的免费代理：</strong>最好使用高匿代理，另外可用的代理不多，需要在使用前筛选一下可用代理，也可以进一步维护一个代理池。</li><li><strong>使用付费代理：</strong>互联网上存在许多代理商，可以付费使用，质量比免费代理好很多。</li><li><strong>ASDL拨号：</strong>拨一次换一次IP，稳定性高，也是一种比较有效的解决方案。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> 原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>会话和Cookies</title>
      <link href="/2019/08/07/%E4%BC%9A%E8%AF%9D%E5%92%8CCookies/"/>
      <url>/2019/08/07/%E4%BC%9A%E8%AF%9D%E5%92%8CCookies/</url>
      
        <content type="html"><![CDATA[<p>在浏览网站的时候，我们经常会遇到需要登录的情况，有些页面只有登录之后才可以访问，而且登录之后可以连续访问很多次网站，但是有时候过一段时间就需要重新登录。</p><p>还有一些网站，再打开浏览器时就自动登录了，而且很长时间都不会失效，这里面涉及会话(<strong>Session</strong>)和<strong>Cookies</strong>的相关知识。</p><a id="more"></a><h2 id="静态网页和动态网页"><a href="#静态网页和动态网页" class="headerlink" title="静态网页和动态网页"></a>静态网页和动态网页</h2><p>在开始之前，需要先了解一下动态网页和静态网页的概念，代码如下：</p><figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>This is a Demo<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"container"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"wrapper"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title"</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"text"</span>&gt;</span>Hello, this is a paragraph.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这种网页的内容是HTML代码编写的，文字、图片等内容均通过写好的HTML代码来指定，这种网页叫作静态网页。它<strong>加载速度快</strong>，<strong>编写简单</strong>，但是存在很大的缺陷，如<strong>可维护性差</strong>，<strong>不能根据URL灵活多变地显示内容</strong>等。例如，我们想要给这个网页的URL传入一个name参数，让其在网页中显示出来，是无法做到的。</p><p>动态网站可以动态解析URL中参数的变化，关联数据库并动态呈现不同页面内容，非常灵活多变。我们现在遇到的大多数网站都是动态网站，它们不再是一个简单的HTML，而是可能由<strong>JSP</strong>、<strong>PHP</strong>、<strong>Python</strong>等语言编写的，其功能比静态网页强大和丰富。</p><p>此外，动态网站还可以实现用户登录和注册的功能。很多页面时需要登录之后才可以查看的。按照一般的逻辑来说，输入用户名和密码登录之后，肯定是拿到了一种类似于<strong>凭证</strong>（会话和Cookies共同产生的结果）的东西，有了它，我们才能保持登录状态，才能访问登录之后才能看到的页面。</p><h2 id="无状态HTTP"><a href="#无状态HTTP" class="headerlink" title="无状态HTTP"></a>无状态HTTP</h2><p>HTTP的无状态是指HTTP协议对事务处理是没有记忆能力的，也就说<strong>服务器不知道客户端是什么状态</strong>。</p><blockquote><p>当我们向服务器发送请求后，服务器解析此请求，然后返回对应的响应，服务器负责完成这个过程，而且这个过程是完全独立的，服务器不会记录前后状态的变化，也就是缺少状态记录。</p></blockquote><p>这意味着如果后续需要处理前面的信息，则必须重传，这导致需要额外传递一些前面的重复请求，才能获取后续响应，然而这种效果显然不是我们想要的。为了保持前后状态，我们肯定不能将前面的请求全部重传一次，这太浪费资源了，对于这种需要用户登录的页面来说，更为棘手。</p><p>这时，两个用于保持HTTP连接状态的技术就出现了，它们分别是<strong>会话</strong>和<strong>Cookies</strong>。</p><ul><li><strong>会话</strong>在服务端，也就是网站的服务器，用来保存用户的会话信息。</li><li><strong>Cookies</strong>在客户端，也可以理解为浏览器端，有了Cookies，浏览器在下次访问网页时会自动附带上它发送给服务器，服务器通过识别Cookies并鉴定出是哪个用户，然后再判断用户是否是登录状态，然后返回对应的响应。</li></ul><p>可以理解为Cookies里面保存了登陆的凭证，有了它，只需要在下次<strong>携带Cookies发送请求</strong>，而不必重新输入用户名、密码等信息重新登录了。</p><p>因此在爬虫中，有时候处理需要登录才能访问的页面时，我们一般会直接将登录成功后获取的Cookies放在请求头里面直接请求，而不必重新模拟登录。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p>会话，本来的含义是指有始有终的一系列动作/消息。比如，打电话时，从拿起电话拨号到挂断电话这中间的一系列过程可以称为一个会话。</p><p>在Web中，会话对象用来存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的Web页之间跳转时，存储在会话对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当用户请求来自应用程序的Web页时，如果该用户还没有会话，则Web服务器将自动创建一个会话对象。当会话过期或被放弃后，服务器将终止该会话。</p><h3 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h3><p>Cookies指某些网站为了辨别用户身份、进行会话跟踪而存储在用户本地终端上的数据。</p><h4 id="会话维持"><a href="#会话维持" class="headerlink" title="会话维持"></a>会话维持</h4><p>当客户端第一次请求服务器时，服务器会返回一个请求头中带有<strong>Set-Cookie</strong>字段的响应给客户端，用来标记是哪一个用户，客户端浏览器会把Cookies保存起来。当浏览器下一次再请求该网站时，浏览器会把此Cookies放到请求头一起提交给服务器，Cookies携带了会话ID消息，服务器检查该Cookies即可找到对应的会话是什么，然后再判断会话来辨认用户状态。</p><p>在成功登录某个网站时，服务器会告诉客户端设置哪些Cookies信息，在后续访问页面时客户端会把Cookies发送给服务器，服务器再找到对应的会话加以判断。如果会话中的某些设置登录状态的变量是有效的，那就证明用户处于登录状态，此时返回登录之后才可以查看的网页内容，浏览器再进行解析便可以看到了。</p><p>反之，如果传给服务器的Cookies是无效的，或者会话已经过期了，我们将不能继续访问页面，此时可能会收到错误的响应或者跳转到登录界面重新登录。</p><p>Cookies和会话需要配合，一个处于客户端，一个处于服务端，二者协作，就实现了登录会话控制。</p><h4 id="属性结构"><a href="#属性结构" class="headerlink" title="属性结构"></a>属性结构</h4><ul><li>Name：该Cookie的名称。一旦创建，该名称便不可更改。</li><li>Value：该Cookie的值。如果值为Unicode字符，需要为字符编码。如果值为二进制数据，则需要使用BASE64编码。</li><li>Domain：可以访问该Cookie的域名。例如，如果设置为<code>.zhihu.com</code>，则所有以<code>zhihu.com</code>结尾的域名都可以访问该Cookie。</li><li>Max Age：该Cookie失效的时间，单位为秒，也常和<strong>Expires</strong>一起使用，通过它可以计算出其有效时间。Max Age如果为正数，则该Cookie在Max Age秒之后失效。如果为负数，则关闭浏览器时Cookie即失效，浏览器不会以任何形式保存该Cookie。</li><li>Path：该Cookie的使用路径。如果设置为<code>/path/</code>，则只有路径为<code>/path/</code>的页面可以访问该Cookie。如果设置为<code>/</code>，则本域名下的所有页面都可以访问该Cookie。</li><li>Size字段：此Cookie的大小。</li><li>HTTP字段：Cookie的<strong>httponly</strong>属性。若此属性为<strong>true</strong>，则只有在HTTP头中会带有此Cookie的信息，而不能通过<code>document.cookie</code>来访问此Cookie。</li><li>Secure：该Cookie是否仅被使用安全协议传输。安全协议有HTTPS和SSL等，在网络上传输数据之前先将数据加密。默认为<strong>false</strong>。</li></ul><h4 id="会话Cookie和持久Cookie"><a href="#会话Cookie和持久Cookie" class="headerlink" title="会话Cookie和持久Cookie"></a>会话Cookie和持久Cookie</h4><ul><li>会话Cookie：把Cookie放在浏览器的内存里，浏览器在关闭之后该Cookie即失效。</li><li>持久Cookie：会将Cookie保存到客户端的硬盘中，下次还可以继续使用，用于长久保存用户登录状态。</li></ul><p>一些持久化登录的网站其实就是把Cookie的有效时间和会话有效期设置得比较长，下次我们再访问页面时仍然携带之前的Cookie，就可以直接保持登录状态。</p><h2 id="常见误区"><a href="#常见误区" class="headerlink" title="常见误区"></a>常见误区</h2><p><strong>关闭浏览器，会话结束</strong></p><p>当我们关闭浏览器时，浏览器不会主动在关闭之前通知服务器它将要关闭，所以服务器不会有机会知道浏览器已经关闭。</p><p>之所以会有这种误区，是因为大部分会话机制都使用<strong>会话Cookie</strong>来保存会话ID信息，而关闭浏览器后Cookies就消失了，再次连接服务器时，也就无法找到原来的会话了。</p><p>如果服务器设置的Cookies保存在硬盘上，或者使用某种手段改写浏览器发出的HTTP请求头，把原来的Cookies发送给服务器，则再次打开浏览器，仍然能够找到原来的会话ID，依旧还是可以保持登录状态的。</p><p>由于关闭浏览器不会导致会话删除，这就需要服务器为会话设置一个失效时间，当距离客户端上一次使用会话的时间超过这个失效时间时，服务器就可以认为客户端已经停止了活动，才会把会话删除以节省存储空间。</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> 原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> cookies </tag>
            
            <tag> 会话 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫的基本原理</title>
      <link href="/2019/08/07/%E7%88%AC%E8%99%AB%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
      <url>/2019/08/07/%E7%88%AC%E8%99%AB%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>我们可以把互联网比作一张大网，而爬虫便是在网上爬行的蜘蛛。</p><p>把网的节点比作一个个网页，爬虫爬到这就相当于访问了该页面，获取了其信息。</p><p>可以把节点间的连线比作网页与网页之间的链接关系，这样蜘蛛通过一个节点后，可以顺着节点连线继续爬行到达下一个节点，即通过一个网页继续获取后续的网页，这样整个网的节点便可以被蜘蛛全部爬行到，网站的数据就可以被抓取下来了。</p><a id="more"></a><h2 id="爬虫概述"><a href="#爬虫概述" class="headerlink" title="爬虫概述"></a>爬虫概述</h2><p>简单来说，爬虫就是获取网页并提取和保存信息的自动化程序。</p><h3 id="获取网页"><a href="#获取网页" class="headerlink" title="获取网页"></a>获取网页</h3><p>爬虫首先要做的工作就是获取网页，这里就是获取网页的源代码。源代码里包含了网页的部分有用信息，所以只要把源代码获取下来，，就可以从中提取想要的信息了。</p><p><strong>最关键的部分就是构造一个请求并发送给服务器，然后接收到响应并将其解析出来。</strong></p><p>Python提供了很多库来帮我们实现这个操作，如<code>urllib</code>、<code>requests</code>等。我们可以用这些库来帮助我们实现HTTP请求操作，请求和响应都可以用类库提供的数据结构来表示，得到相应之后只需要解析数据结构中的<strong>Body</strong>部分即可得到网页的源代码，这样我们可以用程序来实现获取网页的过程了。</p><h3 id="提取信息"><a href="#提取信息" class="headerlink" title="提取信息"></a>提取信息</h3><p>获取网页源代码后，接下来就是分析网页源代码，从中提取我们想要的数据。</p><p>最通用的方法是采用正则表达式提取，这是一个万能的方法，但是在构造正则表达式时比较复杂且容易出错。</p><p>另外，由于网页的结构有一定的规则，所以还有一些根据网页节点属性、CSS选择器或XPath来提取网页信息的库，如<strong>Beautiful Soup</strong>、<strong>Pyquery</strong>、<strong>lxml</strong>等，使用这些库，我们可以高效快速地从中提取网页信息，如节点属性、文本值等。</p><p>提取信息是爬虫非常重要的部分，他可以使杂乱的数据变得条理清晰，以便我们后续处理和分析数据。</p><h3 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h3><p>提取信息后，我们一般会将提取到的数据保存在某处以便后续使用。这里保存形式有多种多样，如可简单保存为<strong>TXT文本</strong>或<strong>JSON文本</strong>，也可以保存到数据库，如<strong>MySQL</strong>和<strong>MongoDB</strong>等，也可保存至远程服务器，如借助<strong>SFTP</strong>进行操作等。</p><h3 id="自动化程序"><a href="#自动化程序" class="headerlink" title="自动化程序"></a>自动化程序</h3><p>即爬虫可以代替人来完成这些操作。当量特别大或者想快速获取大量数据的话，肯定要借助程序。爬虫就是替我们来完成这份爬取工作的自动化程序，它可以在抓取过程中进行各种异常处理、错误重试等操作，确保爬取持续高效地运行。</p><h2 id="能抓怎样的数据"><a href="#能抓怎样的数据" class="headerlink" title="能抓怎样的数据"></a>能抓怎样的数据</h2><ul><li>最常抓取的是<strong>HTML源代码</strong>。</li><li>有些网页返回的是一个<strong>JSON字符串</strong>(其中API接口大多采用这样的形式)，这种格式的数据方便传输和解析，它们同样可以抓取，而且数据提取方便。</li><li><strong>各种二进制数据</strong>，如图片、视频和音频等。利用爬虫，我们可以将这些二进制数据抓取下来，然后保存成对应的文件名。</li><li><strong>各种扩展名的文件</strong>，如CSS、JavaScript和配置文件等，这些其实也是最普通的文件，只要在浏览器里面可以访问到，就可以将其抓取下来。</li></ul><p>上述内容其实都对应各自的URL，是基于HTTP或HTTPS协议的，只要是这种数据，爬虫都可以抓取。</p><h2 id="JavaScript渲染页面"><a href="#JavaScript渲染页面" class="headerlink" title="JavaScript渲染页面"></a>JavaScript渲染页面</h2><p>有时候，我们使用<code>urllib</code>和<code>requests</code>抓取网页时，得到的源代码实际和浏览器中看到的不一样。</p><p>这是由于现在越来越多的网页采用<strong>Ajax</strong>、<strong>前端模块化工具</strong>来构建，整个网页可能都是由JavaScript渲染出来的，也就是说原始的HTML代码就是一个空壳，例如：</p><figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>This is a Demo<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"container"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"app.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>body</code>节点里面只有一个<strong>id为container</strong>的节点，但是需要注意在<code>body</code>节点后引入了<code>app.js</code>，它便负责整个网站的渲染。</p><p>在浏览器中打开这个页面时，首先会加载这个HTML内容，接着浏览器会发现其中引入了一个<code>app.js</code>文件，然后便会接着去请求这个文件，获取到该文件后，便会执行其中的JavaScript代码，而JavaScript则会改变HTML中的节点，向其添加内容，最后得到完整的页面。</p><p>但是用<code>urllib</code>或<code>requests</code>等库请求当前页面时，我们得到的只是这个HTML代码，它不会帮助我们继续去加载这个JavaScript文件，这样也就看不到浏览器中的内容了。</p><p>这也就解释了为什么有时我们得到的源代码和浏览器中看到的不一样。</p><p>因此，使用基本HTTP请求库得到的源代码可能跟浏览器中的页面源代码不太一样。对于这样的情况，我们可以分析其后台<strong>Ajax接口</strong>，也可使用<strong>Selenium</strong>、<strong>Splash</strong>这样的库来实现模拟JavaScript渲染。</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> 原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网页基础</title>
      <link href="/2019/08/06/%E7%BD%91%E9%A1%B5%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/08/06/%E7%BD%91%E9%A1%B5%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>用浏览器访问网站时，网页各不相同，本文简单介绍了网页的基本组成、结构和结点等内容。</p><p>了解了这些内容，我们才有更加清晰的思路去解析和提取网页内容。</p><a id="more"></a><h2 id="网页的组成"><a href="#网页的组成" class="headerlink" title="网页的组成"></a>网页的组成</h2><p>网页可以分为三个部分(<strong>HTML</strong>、<strong>CSS</strong>和<strong>JavaScript</strong>)。</p><p>如果把一个网页比作一个人的话，HTML相当于骨架，CSS相当于皮肤，JavaScript相当于肌肉。</p><p>即，HTML定义了网页的内容和结构，CSS描述了网页的布局，JavaScript定义了网页的行为。</p><p>三者结合起来才能形成一个完善的网页。</p><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p>HTML(Hyper Text Markup Language，超文本标记语言)是用来描述网页的一种语言。</p><p>网页包括文字、按钮、图片和视频等各种复杂元素，其基础架构就是HTML。</p><p>不同类型的元素通过不同类型的标签来表示，如图片用<code>img</code>标签表示，视频用<code>video</code>标签表示，段落用<code>p</code>标签表示。</p><p>它们之间的布局又常通过布局标签<code>div</code>嵌套组合而成，各种标签通过不同的排列和嵌套才形成了网页的框架。</p><p>在浏览器中可以查看网页源代码，以下为www.baidu.com的网页源代码：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E7%BD%91%E9%A1%B5%E5%9F%BA%E7%A1%80/%E7%99%BE%E5%BA%A6%E6%BA%90%E4%BB%A3%E7%A0%81.png" width="70%"></p><p>这就是HTML，整个网页就是由各种标签嵌套组合而成的。这些标签定义的节点元素相互嵌套和组合形成了复杂的层次关系，就形成了网页的架构。</p><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p>HTML定义了网页的结构，但是只有HTML页面的布局并不美观，可能只是简单的节点元素的排列，为了让网页看起来更好看一些，可以借助CSS。</p><p>CSS(Cascading Style Sheets，层叠样式表)。”层叠”是指当在HTML中引用了数个样式文件，并且样式发生冲突时，浏览器能依据层叠顺序处理。”样式”指网页中文字大小、颜色、元素间距、排列等格式。</p><p>CSS是目前唯一的网页页面排版样式标准，有了它的帮助，页面才会变得更为美观。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E7%BD%91%E9%A1%B5%E5%9F%BA%E7%A1%80/CSS.png" width="70%"></p><p>上图中右边<strong>Styles</strong>中存放的即是CSS，例如：</p><figure class="hljs highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">min-width</span>: <span class="hljs-number">1000px</span>;<br>    <span class="hljs-attribute">cursor</span>: default<br>&#125;<br></code></pre></td></tr></table></figure><p>就是一个CSS样式。</p><p>在网页中，一般会统一定义整个网页的样式规则，并写入CSS文件中(其后缀为css)。在HTML中，只需要用link标签即可引入写好的CSS文件，这样整个页面就会变得美观、优雅。</p><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>JavaScript是一种脚本语言。</p><p>若仅仅HTML和CSS配合使用，提供给用户的只是一种静态信息，缺乏交互性。</p><p>我们在网页里可能会看到一些交互和动画效果，如下载进度条、提示框、轮播图等，这通常就是JavaScript的功劳。它的出现使得用户与信息之间不只是一种浏览与现实的关系，而是实现了一种实时、动态、交互的页面功能。</p><p>JavaScript通常也是以单独的文件形式加载的，后缀为<code>js</code>，在HTML中通过<code>script</code>即可引入，例如：</p><p><code>&lt;script src=&quot;jquery-2.1.0.js&quot;&gt;&lt;/script&gt;</code></p><h2 id="网页的结构"><a href="#网页的结构" class="headerlink" title="网页的结构"></a>网页的结构</h2><p>首先以一个例子来讲解一些HTML的基本结构。</p><p>新建一个文本文件，名字可以自取，后缀为<code>html</code>。</p><p>内容如下：</p><figure class="hljs highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>This is a Demo<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"container"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"wrapper"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title"</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"text"</span>&gt;</span>Hello, this is a paragraph.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这就是一个最简单的HTML实例。</p><p>开头用<strong>DOCTYPE</strong>定义了文档类型，其次最外层是<code>html</code>标签，最后还有对应的结束标签来表示闭合，其内部是<code>head</code>标签和<code>body</code>标签，分别代表网页头和网页体，它们也需要结束标签。</p><p><code>head</code>标签内定义了一些页面的配置和引用，如：<code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code>指定了网页的编码为UTF-8。</p><p><code>title</code>标签则定义了网页的标题，会显示在网页的选项卡中，不会显示在正文中。</p><p><code>body</code>标签内则是在网页正文中显示的内容。</p><p><code>div</code>标签定义了网页中的区块，它的id是container，这是一个非常常用的属性，且id的内容在网页中是唯一的，我们可以通过它来获取这个区块。然后在此区块内又有一个div标签，它的class为wrapper，这也是一个非常常用的属性，经常与CSS配合使用来设定样式。</p><p><code>h2</code>标签代表一个二级标题。</p><p><code>p</code>标签代表一个段落。</p><p>将代码保存后，在浏览器中打开该文件，可以看到下图所示的内容。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E7%BD%91%E9%A1%B5%E5%9F%BA%E7%A1%80/Demo%E7%BD%91%E9%A1%B5.png" width="70%"></p><p>这个实例便是网页的一般结构。一个网页的标准形式是<code>html</code>标签内嵌套<code>head</code>和<code>body</code>标签。</p><h2 id="节点树及节点间的关系"><a href="#节点树及节点间的关系" class="headerlink" title="节点树及节点间的关系"></a>节点树及节点间的关系</h2><p>在HTML中，所有标签定义的内容都是节点，他们构成了一个<strong>HTML DOM树</strong>。</p><p><strong>DOM(Document Object Model，文档对象模型)</strong>是W3C(万维网联盟)的标准，定义了访问HTML和XML文档的标准：</p><blockquote><p>W3C文档对象模型(DOM)是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。</p></blockquote><p>W3C DOM标准被分为3个不同的部分：</p><ul><li><strong>核心DOM：</strong>针对任何结构化文档的标准模型</li><li><strong>XML DOM：</strong>针对XML文档的标准模型</li><li><strong>HTML DOM：</strong>针对HTML文档的标准模型</li></ul><p>根据W3C的HTML DOM标准，HTML文档中的所有内容都是节点。</p><ul><li>整个文档是一个文档节点</li><li>每个HTML元素是元素节点</li><li>HTML元素内的文本是文本节点</li><li>每个HTML属性是属性节点</li><li>注释是注释节点</li></ul><p><strong>HTML DOM</strong>将HTML文档视作树结构，这种结构被称为节点树，如下图所示：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E7%BD%91%E9%A1%B5%E5%9F%BA%E7%A1%80/HTML%20DOM" width="70%"></p><p><em>通过HTML DOM树中所有的节点均可通过JavaScript访问</em>，所有HTML节点元素均可被修改，也可以被创建或删除。</p><p>节点树中的节点彼此拥有层级关系。常用<strong>父(parent)、子(child)和兄弟(sibling)</strong>等术语描述这些关系。父节点拥有子节点，同级的子节点被称为兄弟。</p><p>在节点树中，顶端节点称为根(root)。除了根结点之外，每个节点都有父节点，同时可拥有任意数量的子节点或兄弟结点。</p><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>网页由一个个节点组成，<strong>CSS选择器</strong>会根据不同的节点设置不同的样式规则。</p><p>在CSS中，我们使用CSS选择器来定位节点。一共有三种方式：</p><ul><li><code>&lt;div id=&quot;container&quot;&gt;</code>，则可以表示为<code>#container</code>，其中#开头代表选择id，其后紧跟id的名称。</li><li>若想选择<strong>class为wrapper</strong>的节点，可以使用<code>.wrapper</code>，这里的<code>.</code>代表选择class，其后紧跟class的名称。</li><li>根据<strong>标签名</strong>筛选，例如想选择二级标题，直接用<code>h2</code>即可。</li></ul><p>另外，CSS选择器还支持<em>嵌套选择</em>，各个选择器之间加上空格分隔开便可以代表嵌套关系，如：<code>#container .wrapper p</code>则代表先选择id为container的节点，然后选其内部的class为wrapper的节点，然后再进一步选其内部的p节点。另外，若不加空格，则代表并列关系，如<code>div#container .wrapper p.text</code>代表先选择id为container的div节点，然后选其中内部的class为wrapper的节点，再进一步选其内部的class为text的p节点。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 网页 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP基本原理</title>
      <link href="/2019/08/06/HTTP%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
      <url>/2019/08/06/HTTP%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>在本文中，我们会详细了解HTTP的基本原理，了解在浏览器中敲入URL到获取网页内容之间发生了什么。</p><a id="more"></a><h2 id="URI和URL"><a href="#URI和URL" class="headerlink" title="URI和URL"></a>URI和URL</h2><ul><li>URI：Uniform Resource Identifier，统一资源标志符。</li><li>URL：Uniform Resource Locator，统一资源定位符。</li></ul><p><a href="https://github.com/favicon.ico" target="_blank" rel="noopener">https://github.com/favicon.ico</a> 是Github的网站图标链接，它是一个URL，也是一个URI。</p><p>即有这样一个图标资源，我们用URL/URI来唯一指定了它的访问方式，这其中包括了<strong>访问协议https</strong>、<strong>访问路径(/即根目录)</strong>、<strong>资源名称</strong>(favicon.ico)。通过这样一个链接，我们便可以从互联网上找到这个资源，这就是URL/URI。</p><p><strong>URL是URI的子集</strong>。URI还包括一个子类<strong>URN</strong>(Uniform Resource Name，即统一资源名称)。URN只命名资源而不指定如何定位资源，比如<code>urn:isbn:0451450523</code>指定了一本书的ISBN，可以唯一标识这本书，但是没有指定到哪里定位这本书。</p><p>URL、URN和URI的关系如下图所示。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/HTTP%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/URN%3AURL%3AURI%E5%85%B3%E7%B3%BB.png" width="30%"></p><p>在目前的互联网中，URN用的非常少，所以几乎所有的URI都是URL。</p><h2 id="超文本-Hypertext"><a href="#超文本-Hypertext" class="headerlink" title="超文本(Hypertext)"></a>超文本(Hypertext)</h2><p>我们在浏览器里看到的网页就是超文本解析而成的，其网页源代码是一系列HTML代码，里面包含了一系列标签，比如img显示图片，p指定显示段落等。浏览器解析这些标签后，便形成了平常看到的网页，而网页的源代码HTML就可以称作超文本。下图是百度网页的源代码。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/HTTP%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/%E7%99%BE%E5%BA%A6%E7%BD%91%E9%A1%B5%E6%BA%90%E4%BB%A3%E7%A0%81.png" width="70%"></p><h3 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h3><p><strong>HTTP</strong>和<strong>HTTPS</strong>是访问资源所需要的协议类型，另外还有<strong>ftp</strong>、<strong>sftp</strong>、<strong>smb</strong>等。</p><p><strong>HTTP</strong>(Hyper Text Transfer Protocol，超文本传输协议)。HTTP协议是用于从网络传输超文本数据到本地浏览器的传送协议，它能保证高效而准确地传送超文本文档。HTTP由<strong>万维网协会</strong>(World Wide Web Consortium)和<strong>Internet工作小组IETF</strong>(Internet Engineering Task Force)共同合作制定的规范，目前广泛使用的是<strong>HTTP1.1版本</strong>。</p><p><strong>HTTPS</strong>(Hyper Text Transfer Protocol over Secure Socket Layer)，以安全为目标的HTTP通道，即HTTP下加入<strong>SSL层</strong>。HTTPS的安全基础是SSL，因此<em>通过它传输的内容都是经过SSL加密的</em>，主要作用可以分为两种：</p><ul><li>建立一个信息安全通道来保证数据传输的安全。</li><li>确认网站的真实性，凡是使用了HTTPS的网站，都可以通过点击浏览器地址栏的锁头标志来查看网站认证之后的真实信息，也可以通过CA机构颁发的安全签章来查询。</li></ul><h2 id="HTTP请求过程"><a href="#HTTP请求过程" class="headerlink" title="HTTP请求过程"></a>HTTP请求过程</h2><ol><li>在浏览器中输入一个URL。</li><li>浏览器向网站所在的服务器发送了一个请求。</li><li>网络服务器接收到这个请求后进行处理和解析，然后返回对应的响应，接着传回给浏览器。</li><li>响应里包含了页面的源代码等内容，浏览器再对其进行解析，便将网页呈现了出来。</li></ol><h2 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h2><p>请求，由客户端向服务端发出，可以分为4部分内容：</p><ul><li>请求方法(Request Method)</li><li>请求的网址(Request URL)</li><li>请求头(Request Header)</li><li>请求体(Request Body)</li></ul><h3 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h3><p>常见的请求方法有两种：<strong>GET</strong>和<strong>POST</strong>。</p><p>在浏览器中直接输入URL并回车，这便发起了一个<strong>GET请求</strong>，请求的参数会直接包含到URL里。例如：在百度中搜索Python，这就是一个GET请求，链接为：<a href="https://www.baidu.com/s?wd=Python，其中URL中包含了请求的参数信息，这里参数wd表示要搜寻的关键字。" target="_blank" rel="noopener">https://www.baidu.com/s?wd=Python，其中URL中包含了请求的参数信息，这里参数wd表示要搜寻的关键字。</a></p><p><strong>POST请求</strong>大多在表单提交时发起。比如，对于一个登录表单，输入用户名和密码后，点击”登录”按钮，这通常会发起一个POST请求，其数据通常以表单的形式传输，而不会体现在URL中。</p><p><strong>GET</strong>和<strong>POST</strong>请求方法的区别：</p><ul><li>GET请求中的参数包含在URL里面，数据可以在URL中看到，而POST请求的URL不会包含这些数据，数据都是通过表单形式传输的，会包含在请求体中。</li><li>GET请求提交的数据最多只有1024个字节，而POST方式没有限制。</li></ul><p>一般来说，登录时，需要提供账号和密码，其中包含了敏感信息，使用GET方法请求的话，密码就会暴露在URL里面，造成密码的泄露，所以最好选择POST方式传输。上传文件时，由于文件的内容比较大，也会选择使用POST方式。</p><p>另外还有其他的一些请求方法，如下表所示：</p><div class="table-container"><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>GET</td><td>请求网页，并返回页面内容</td></tr><tr><td>POST</td><td>大多用于提交表单或上传文件，数据包含在请求体中</td></tr><tr><td>HEAD</td><td>类似于GET请求， 只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td>PUT</td><td>从客户端向服务器传送的数据取代指定文档中的内容</td></tr><tr><td>DELETE</td><td>请求服务器删除指定页面</td></tr><tr><td>CONNECT</td><td>把服务器当做跳板，让服务器代替客户端访问其他网页</td></tr><tr><td>OPTIONS</td><td>允许客户端查看服务器的性能</td></tr><tr><td>TRACE</td><td>回显服务器收到的请求，主要用于测试或诊断</td></tr></tbody></table></div><h3 id="请求网址"><a href="#请求网址" class="headerlink" title="请求网址"></a>请求网址</h3><p>请求的网址，即统一资源定位符URL，它可以唯一确定我们想请求的资源。</p><h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h3><p>用来说明服务器要使用的附加信息，比较重要的信息有Cookie、Referer、User-Agent等。</p><p>常用的请求头信息：</p><ul><li>Accept：请求报头域，用于指定客户端可接受哪些类型的信息。</li><li>Accept-Language：指定客户端可接受的语言类型。</li><li>Accept-Encoding：指定客户端可接受的内容编码。</li><li>Host：用于指定请求资源的主机IP和端口号，其内容为请求URL的原始服务器或网关的位置。从HTTP1.1版本开始，请求必须包含此内容。</li><li>Cookie：常用复数形式Cookies，这是网站为了辨别用户进行会话跟踪而存储在用户本地的数据。它的主要功能是维持当前访问会话。例如：我们输入用户名和密码成功登录某而过网站后，服务器会用会话保存登录状态信息，后面我们每次刷新或请求该站点的其他网页时，会发现都是登录状态，这就是Cookies的功劳。Cookies里有信息标识了我们所对应的服务器的会话，每次浏览器在请求该站点的页面时，都会在请求头中加入Cookies并将其发送给服务器，服务器通过Cookies识别出是我们自己，并且查出当前状态是登录状态，所以返回结果就是登录之后才能看到的网页内容。</li><li>Referer：此内容用来标识这个请求时从哪个页面发过来的，服务器可以拿到这一信息并做出相应的处理，如做来源统计，防盗链处理等。</li><li>User-Agent：简称UA，它是一个特殊的字符串头，可以是服务器识别客户使用的操作系统及版本、浏览器及版本信息。在做爬虫时加上此信息，可以伪装为浏览器；如果不加，很可能会被识别出为爬虫。</li><li>Content-Type：也叫互联网媒体类型(Internet Media Type)或者MIME类型，在HTTP协议消息头中，它用来表示具体请求中的媒体类型信息。例如：text/html代表HTML格式，image/gif代表GIF图片，application/json代表JSON类型等(具体可以查看<a href="[http://tool.oschina.net/commons](http://tool.oschina.net/commons">这里</a>))。</li></ul><p>请求头是请求的重要组成部分，在写爬虫时，大部分情况下都需要设定请求头。</p><h3 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h3><p>请求体一般承载的内容是<strong>POST请求中的表单数据</strong>，而对于GET请求，请求体则为空。</p><p><strong>Content-Type</strong>和<strong>POST提交数据方式</strong>的联系。</p><div class="table-container"><table><thead><tr><th>Content-Type</th><th>提交数据的方式</th></tr></thead><tbody><tr><td>application/x-www-form-urlencoded</td><td>表单数据</td></tr><tr><td>multipart/form-data</td><td>表单文件上传</td></tr><tr><td>application/json</td><td>序列化JSON数据</td></tr><tr><td>text/xml</td><td>XML数据</td></tr></tbody></table></div><p>在爬虫时，如果要构造POST请求，需要使用正确的Content-Type，并了解各种请求库的各个参数设置时使用的是哪种Content-Type，不然可能会导致POST提交后无法正常相应。</p><h2 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h2><p>由服务端返回给客户端，可以分为三部分：</p><ul><li>响应状态码(Response Status Code)</li><li>响应头(Response Headers)</li><li>响应体(Response Body)</li></ul><h3 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h3><p>响应状态码表示服务器的响应状态，如<em>200代表服务器正常响应</em>，<em>404代表页面未找到</em>，<em>500代表服务器内部发生错误</em>。</p><p>在爬虫过程中，我们可以根据状态码来判断服务器响应状态，如状态码为200，则证明成功返回数据，再进行处理，否则直接忽略。</p><p>响应状态码一共分五大类：</p><ul><li>消息响应</li></ul><div class="table-container"><table><thead><tr><th>状态码</th><th>说明</th><th>详情</th></tr></thead><tbody><tr><td>100</td><td>继续</td><td>请求者应当继续提出请求。服务器已收到请求的一部分，正在等待其他部分</td></tr><tr><td>101</td><td>切换协议</td><td>请求者已要求服务器切换协议，服务器已确认并准备切换</td></tr></tbody></table></div><ul><li>成功响应</li></ul><div class="table-container"><table><thead><tr><th>状态码</th><th>说明</th><th>详情</th></tr></thead><tbody><tr><td>200</td><td>成功</td><td>服务器已成功处理了请求</td></tr><tr><td>201</td><td>已创建</td><td>请求成功并且服务器创建了新的资源</td></tr><tr><td>202</td><td>已接受</td><td>服务器已接受请求，但尚未处理</td></tr><tr><td>203</td><td>非授权信息</td><td>服务器已成功处理了请求，但返回的信息可能来自另一个源</td></tr><tr><td>204</td><td>无内容</td><td>服务器成功处理了请求，但没有返回任何内容</td></tr><tr><td>205</td><td>重置内容</td><td>服务器成功处理了请求，内容被重置</td></tr><tr><td>206</td><td>部分内容</td><td>服务器成功处理了部分请求</td></tr></tbody></table></div><ul><li>重定向</li></ul><div class="table-container"><table><thead><tr><th>状态码</th><th>说明</th><th>详情</th></tr></thead><tbody><tr><td>300</td><td>多种选择</td><td>针对请求，服务器可执行多种操作</td></tr><tr><td>301</td><td>已创建</td><td>请求的网页已永久移动到新位置，即永久重定向</td></tr><tr><td>302</td><td>临时移动</td><td>请求的网页暂时跳转到其他页面，即暂时重定向</td></tr><tr><td>303</td><td>非授权信息</td><td>如果原来的请求是POST，重定向目标文档应该通过GET提取</td></tr><tr><td>304</td><td>无内容</td><td>此次请求返回的页面未修改，继续使用上次的资源</td></tr><tr><td>305</td><td>重置内容</td><td>请求者应该使用代理访问该页面</td></tr><tr><td>307</td><td>部分内容</td><td>请求的资源临时从其他位置响应</td></tr></tbody></table></div><ul><li>客户端错误</li></ul><div class="table-container"><table><thead><tr><th>状态码</th><th>说明</th><th>详情</th></tr></thead><tbody><tr><td>400</td><td>错误请求</td><td>服务器无法解析该请求</td></tr><tr><td>401</td><td>未授权</td><td>请求没有进行身份验证或验证未通过</td></tr><tr><td>403</td><td>禁止访问</td><td>服务器拒绝此请求</td></tr><tr><td>404</td><td>未找到</td><td>服务器找不到请求的页面</td></tr><tr><td>405</td><td>方法禁用</td><td>服务器禁用了请求中指定的方法</td></tr><tr><td>406</td><td>不接受</td><td>无法使用请求的内容响应请求的页面</td></tr><tr><td>407</td><td>需要代理授权</td><td>请求者需要使用代理授权</td></tr><tr><td>408</td><td>请求超时</td><td>服务器请求超时</td></tr><tr><td>409</td><td>冲突</td><td>服务器在完成请求时发生冲突</td></tr><tr><td>410</td><td>已删除</td><td>请求的资源已永久删除</td></tr><tr><td>411</td><td>需要有效长度</td><td>服务器不接受不含有效内容长度标头字段的请求</td></tr><tr><td>412</td><td>未满足前提条件</td><td>服务器未满足请求者在请求中设置的其中一个前提条件</td></tr><tr><td>413</td><td>请求实体过大</td><td>请求实体过大，超出服务器的处理能力</td></tr><tr><td>414</td><td>请求URL过长</td><td>请求网址过长，服务器无法处理</td></tr><tr><td>415</td><td>不支持类型</td><td>请求格式不被请求页面支持</td></tr><tr><td>416</td><td>请求范围不符</td><td>页面无法提供请求的范围</td></tr><tr><td>417</td><td>未满足期望值</td><td>服务器未满足期望请求标头字段的要求</td></tr></tbody></table></div><ul><li>服务器端错误</li></ul><div class="table-container"><table><thead><tr><th>状态码</th><th>说明</th><th>详情</th></tr></thead><tbody><tr><td>500</td><td>成功</td><td>服务器遇到错误，无法完成请求</td></tr><tr><td>501</td><td>未实现</td><td>服务器不具备完成请求的功能</td></tr><tr><td>502</td><td>错误网关</td><td>服务器作为网关或代理，从上游服务器收到无效响应</td></tr><tr><td>503</td><td>服务不可用</td><td>服务器目前无法使用</td></tr><tr><td>504</td><td>网关超时</td><td>服务器作为网关或代理。但是没有及时从上游服务器收到请求</td></tr></tbody></table></div><h3 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h3><p>响应头包含了服务器对请求的应答信息，如Content-Type、Server、Set-Cookie等。</p><p>下面简要说明一些常用的头信息：</p><ul><li>Date：标识响应产生的时间。</li><li>Last-Modified：指定资源的最后修改时间。</li><li>Content-Encoding：指定响应内容的编码。</li><li>Server：包含服务器的信息，比如名称、版本号。</li><li>Content-Type：文档类型，指定返回的数据类型是什么，如text/html代表返回HTML文档，application/x-javascript则代表返回JavaScript文件，image/jpeg则代表返回图片。</li><li>Set-Cookie：设置Cookies。响应头中的Set-Cookie告诉浏览器需要将此内容放在Cookies中，下次请求携带Cookies请求。</li><li>Expires：指定响应的过期时间，可以使代理服务器或浏览器将加载的内容更新到缓存中。如果再次访问时，就可以直接从缓存中加载，降低服务器负载，缩短加载时间。</li></ul><h3 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h3><p>响应的正文数据都在响应体中，比如请求网页时，它的响应体就是网页的HTML代码，请求一张图片时，它的响应体就是图片的二进制数据。做爬虫请求网页后，要解析的内容就是响应体。</p><p>在浏览器开发者工具中点击<strong>Preview</strong>，就可以看到网页的源代码，也就是响应体的内容，它是解析的目标。</p><p>在做爬虫时，我们主要通过响应体得到网页的源代码、JSON数据等，然后从中做相应内容的提取。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> HTTP </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell后台执行</title>
      <link href="/2019/08/05/shell%E5%90%8E%E5%8F%B0%E6%89%A7%E8%A1%8C/"/>
      <url>/2019/08/05/shell%E5%90%8E%E5%8F%B0%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>后台执行：<code>nohup sh run.sh &gt;log.txt 2&gt;&amp;1 &amp;</code></p><p>后台查看：<code>ps -ef | grep 13549</code></p><p>终止进程：<code>kill -9 pid</code></p><a id="more"></a><h2 id="后台执行"><a href="#后台执行" class="headerlink" title="后台执行"></a>后台执行</h2><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nohup sh run.sh &gt;log.txt 2&gt;&amp;1 &amp;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[1] 13549  <span class="hljs-comment"># 进程号，后面查看相关信息用到。</span><br></code></pre></td></tr></table></figure><p>这个命令分为五个部分，分别是<code>nohup</code>、<code>sh run.sh</code>、<code>&gt;log.txt</code>、<code>2&gt;&amp;1</code>、<code>&amp;</code>。</p><ul><li><code>nohup</code>和最后的<code>&amp;</code>：表示命令在后台执行</li><li><code>sh run.sh</code>执行<strong>run.sh</strong>脚本</li><li><code>&gt;log.txt</code>是将信息输出到<strong>log.txt</strong>日志中</li><li><code>2&gt;&amp;1</code>是将标准错误信息转变成标准输出，这样就可以将错误信息输出到<strong>log.txt</strong>日志里。</li></ul><p>其中0、1、2分别代表如下含义：</p><ul><li>0：stdin(标准输入)</li><li>1：stdout(标准输出)</li><li>2：stderr(标准错误)</li></ul><h2 id="后台查看"><a href="#后台查看" class="headerlink" title="后台查看"></a>后台查看</h2><h3 id="查看本地进程"><a href="#查看本地进程" class="headerlink" title="查看本地进程"></a>查看本地进程</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps -ef | grep 13549<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">work  12929 44118  0 11:36 pts/2    00:00:00 grep 13549<br></code></pre></td></tr></table></figure><p>这个命令也是分五个部分<code>ps</code> 、<code>-ef</code>、 <code>|</code>、 <code>grep</code>、 <code>13549</code>。</p><ul><li><code>ps</code>表示将某个进程显示出来</li><li><code>-e</code>表示显示所有程序、<code>-f</code>表示显示UID,PPIP,C与STIME栏位</li><li><code>grep</code>表示查找和其后面内容相关的信息，即和<code>13549</code>相关的信息</li><li><code>|</code>是管道命令 是指ps命令与grep同时执行</li></ul><p>输出的信息分别是：UID 、 PID 、PPID 、 C STIME 、 TTY、 TIME 、 CMD。</p><ul><li>UID 程序被该 UID 所拥有</li><li>PID 就是这个程序的 ID</li><li>PPID 则是其上级父程序的ID</li><li>C CPU 使用的资源百分比</li><li>STIME 系统启动时间</li><li>TTY 登入者的终端机位置</li><li>TIME 使用掉的 CPU 时间</li></ul><h3 id="查看hadoop进程"><a href="#查看hadoop进程" class="headerlink" title="查看hadoop进程"></a>查看hadoop进程</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim log.txt<br></code></pre></td></tr></table></figure><h2 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h2><h3 id="终止本地进程"><a href="#终止本地进程" class="headerlink" title="终止本地进程"></a>终止本地进程</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">kill</span> -9 pid<br><span class="hljs-comment"># kill -9 13549</span><br></code></pre></td></tr></table></figure><h3 id="终止hadoop进程"><a href="#终止hadoop进程" class="headerlink" title="终止hadoop进程"></a>终止hadoop进程</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop job -<span class="hljs-built_in">kill</span> jobid<br><span class="hljs-comment"># hadoop job -kill job_20180809144936_572433</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>App爬取相关库的安装</title>
      <link href="/2019/08/05/App%E7%88%AC%E5%8F%96%E7%9B%B8%E5%85%B3%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2019/08/05/App%E7%88%AC%E5%8F%96%E7%9B%B8%E5%85%B3%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>爬虫也可以抓取App的数据。App中的页面要加载出来，首先需要获取数据，而这些数据一般是通过请求服务器的接口来获取的。由于App没有浏览器这种可以比较直观地看到后台请求的工具，所以主要用一些抓包技术来抓取数据。</p><p>本文介绍的抓包工具有 <strong>Charles</strong> 、 <strong>mitmproxy</strong> 和 <strong>mitmdump</strong> 。一些简单的接口可以通过<strong>Charles</strong>或<strong>mitmproxy</strong>分析，找出规律，然后直接用程序模拟来抓取。但是如果遇到更复杂的接口，就需要利用<strong>mitmdump</strong>对接Python来对抓取的请求和响应进行实时处理和保存。</p><p>另外，既然要做规模采集，就需要自动化App的操作而不是人工去采集，所以之力还需要一个工具叫做<strong>Appium</strong>，它可以对App进行自动化控制，如自动化模拟App的点击、下拉等操作。</p><a id="more"></a><h2 id="Charles"><a href="#Charles" class="headerlink" title="Charles"></a>Charles</h2><p>Charles是一个网络抓包工具，相比Fiddler，其功能更为强大，而且跨平台支持得更好，所以可以选用它来作为主要的移动端抓包工具。</p><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>官方网站：<a href="https://www.charlesproxy.com" target="_blank" rel="noopener">https://www.charlesproxy.com</a></li><li>下载链接：<a href="https://www.charlesproxy.com/download" target="_blank" rel="noopener">https://www.charlesproxy.com/download</a></li></ul><h3 id="下载Charles"><a href="#下载Charles" class="headerlink" title="下载Charles"></a>下载Charles</h3><p>可以选择官方正版或者破解版下载。</p><h3 id="证书配置"><a href="#证书配置" class="headerlink" title="证书配置"></a>证书配置</h3><p>现在很多页面都在向HTTPS方向发展，HTTPS通信协议应用得越来越广泛。如果一个App通信应用了HTTPS协议，那么它通信的数据都会是被加密的，常规的截包方法是无法识别请求内部的数据的。</p><p>安装完成后，如果我们想要做HTTPS抓包的话，那么还需要配置一下相关的<strong>SSL证书</strong>。</p><p><strong>Charles</strong>是运行在PC端的，我们要抓取的是App端的数据，所以要在<strong>PC和手机</strong>端都安装证书。</p><p>具体内容配置可以参考这篇<a href="https://www.jianshu.com/p/0bc767840e42" target="_blank" rel="noopener">博客</a>。</p><h2 id="mitmproxy"><a href="#mitmproxy" class="headerlink" title="mitmproxy"></a>mitmproxy</h2><p><strong>mitmproxy</strong>是一个支持HTTP和HTTPS的抓包程序，类似Fiddler、Charles的功能，只不过它是通过控制台的形式操作。</p><p>此外，<strong>mitmproxy</strong>还有两个关联组件：</p><ul><li><strong>mitmdump</strong>：它是<strong>mitmproxy</strong>的命令行接口，利用它可以对接Python脚本，实现监听后的处理。</li><li><strong>mitmweb</strong>：它是一个web程序，通过它可以清楚地观察到mitmproxy捕获的请求。</li></ul><h3 id="相关链接-1"><a href="#相关链接-1" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>Github：<a href="https://github.com/mitmproxy/mitmproxy" target="_blank" rel="noopener">https://github.com/mitmproxy/mitmproxy</a></li><li>官方网站：<a href="https://mitmproxy.org" target="_blank" rel="noopener">https://mitmproxy.org</a></li><li>官方文档：<a href="http://docs.mitmproxy.org" target="_blank" rel="noopener">http://docs.mitmproxy.org</a></li><li>mitmdump脚本：<a href="http://docs.mitmproxy.org/en/stable/scripting/overview.html" target="_blank" rel="noopener">http://docs.mitmproxy.org/en/stable/scripting/overview.html</a></li></ul><h3 id="pip安装"><a href="#pip安装" class="headerlink" title="pip安装"></a>pip安装</h3><p>输入命令：<code>pip3 install mitmproxy</code></p><p>执行完毕后即可完成<strong>mitmproxy</strong>的安装，另外还附带安装了<strong>mitmdump</strong>和<strong>mitmweb</strong>两个组件。</p><h3 id="证书配置-1"><a href="#证书配置-1" class="headerlink" title="证书配置"></a>证书配置</h3><p>对于mitmproxy来说，如果想要截获HTTPS请求，就需要设置证书（该证书在安装后会提供，只需信任即可）。</p><p>首先运行以下命令产生CA证书，并启动mitmproxy：<code>mitmdump</code></p><p>接下来我们可以在用户目录下的<code>.mitmproxy</code>目录里找到CA证书。</p><p>在Mac中，点击<code>mitmproxy-ca-cert.pem</code>这个证书，然后授权信任即可。</p><h2 id="Appium"><a href="#Appium" class="headerlink" title="Appium"></a>Appium</h2><p>Appium是移动端的自动化测试工具，类似于Selenium，利用它可以驱动Android、iOS等设备完成自动化测试，比如模拟点击、滑动、输入等操作。</p><h3 id="相关链接-2"><a href="#相关链接-2" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>Github：<a href="https://github.com/appium/appium" target="_blank" rel="noopener">https://github.com/appium/appium</a></li><li>官方网站：<a href="http://appium.io" target="_blank" rel="noopener">http://appium.io</a></li><li>官方文档：<a href="http://appium.io/introduction.html" target="_blank" rel="noopener">http://appium.io/introduction.html</a></li><li>Python Client：<a href="https://github.com/appium/python-client" target="_blank" rel="noopener">https://github.com/appium/python-client</a></li><li>下载链接：<a href="https://github.com/appium/appium-desktop/releases" target="_blank" rel="noopener">https://github.com/appium/appium-desktop/releases</a></li></ul><h3 id="安装Appium"><a href="#安装Appium" class="headerlink" title="安装Appium"></a>安装Appium</h3><p>首先需要安装Appium。Appium负责驱动移动端来完成一系列操作，对于<strong>iOS</strong>设备来说，它使用苹果的<strong>UIAutomation</strong>来实现驱动；对于<strong>Android</strong>来说，它使用<strong>UIAutomation</strong>和<strong>Selendroid</strong>来实现驱动。</p><p>同时Appium也相当于一个服务器，我们可以向他发送一些操作指令，它会根据不同的指令对移动设备进行驱动，以完成不同的动作。</p><p>两种方法安装：</p><ul><li>Appium Desktop：<a href="https://github.com/appium/appium-desktop/releases" target="_blank" rel="noopener">https://github.com/appium/appium-desktop/releases</a> 选择对应的版本下载安装。</li><li>Node.js：使用命令：<code>npm install -g appium</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> 开发环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发环境配置 </tag>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web库的安装</title>
      <link href="/2019/08/05/Web%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2019/08/05/Web%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>现在日常访问的网站都是Web服务程序搭建而成的。</p><p>Python也有一些这样的Web服务程序，比如Flask、Django等，我们可以拿它来开发网站和接口等。</p><p>在爬虫中主要使用这些Web服务程序来搭建一些API接口。例如：维护一个代理池，代理保存在Redis数据库中，我们要将代理池作为一个公共的组件使用，那么如何构建一个方便的平台来供我们获取这些代理呢？最合适不过的就是通过Web服务提供一个API接口，我们只需要请求接口即可获取新的代理，这样做，简单、高效、实用！</p><p>本文主要介绍Web服务程序<strong>Flask</strong>和<strong>Tornado</strong>。</p><a id="more"></a><h2 id="Flask"><a href="#Flask" class="headerlink" title="Flask"></a>Flask</h2><p>Flask是一个轻量级的Web服务程序，它简单、易用、灵活，这里主要用来做一些API服务。</p><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>Github：<a href="https://github.com/pallets/flask" target="_blank" rel="noopener">https://github.com/pallets/flask</a></li><li>官方文档：<a href="http://flask.pocoo.org" target="_blank" rel="noopener">http://flask.pocoo.org</a></li><li>中文文档：<a href="http://docs.jinkan.org/docs/flask" target="_blank" rel="noopener">http://docs.jinkan.org/docs/flask</a></li><li>PyPI：<a href="https://pypi.python.org/pypi/Flask" target="_blank" rel="noopener">https://pypi.python.org/pypi/Flask</a></li></ul><h3 id="pip安装"><a href="#pip安装" class="headerlink" title="pip安装"></a>pip安装</h3><p>执行命令：<code>pip3 install flask</code></p><h3 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h3><p>安装成功后，可以运行如下实例代码测试：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><br>app = Flask(__name__)<br><br><br><span class="hljs-meta">@app.route("/")</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello World!"</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    app.run()<br></code></pre></td></tr></table></figure><p>可以发现，系统会在<strong>5000端口</strong>开启Web服务，控制台输出如下：</p><p> <strong>* Running on <a href="http://127.0.0.1:5000/" target="_blank" rel="noopener">http://127.0.0.1:5000/</a> (Press CTRL+C to quit)</strong></p><p>直接访问<a href="http://127.0.0.1:5000/" target="_blank" rel="noopener">http://127.0.0.1:5000/</a>，可以观察到网页中呈现了 <strong>Hello World!</strong> ，如下图所示，一个简单的Flask程序就运行成功了。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Web%E5%BA%93%E5%AE%89%E8%A3%85/Flask%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" width="70%"></p><h2 id="Tornado安装"><a href="#Tornado安装" class="headerlink" title="Tornado安装"></a>Tornado安装</h2><p>Tornado是一个支持异步的Web框架，通过使用非阻塞I/O流，它可以支撑成千上万的开放连接，效率非常高。</p><h3 id="相关链接-1"><a href="#相关链接-1" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>Github：<a href="https://github.com/tornadoweb/tornado" target="_blank" rel="noopener">https://github.com/tornadoweb/tornado</a></li><li>PyPI：<a href="https://pypi.python.org/pypi/tornado" target="_blank" rel="noopener">https://pypi.python.org/pypi/tornado</a></li><li>官方文档：<a href="http://www.tornadoweb.org" target="_blank" rel="noopener">http://www.tornadoweb.org</a></li></ul><h3 id="pip安装-1"><a href="#pip安装-1" class="headerlink" title="pip安装"></a>pip安装</h3><p>执行命令：<code>pip3 install tornado</code></p><h3 id="验证安装-1"><a href="#验证安装-1" class="headerlink" title="验证安装"></a>验证安装</h3><p>安装成功后，可以运行如下实例代码测试：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tornado.ioloop<br><span class="hljs-keyword">import</span> tornado.web<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainHandler</span><span class="hljs-params">(tornado.web.RequestHandler)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span><span class="hljs-params">(self)</span>:</span><br>        self.write(<span class="hljs-string">"Hello World!"</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_app</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-keyword">return</span> tornado.web.Application([(<span class="hljs-string">r"/"</span>, MainHandler), ])<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>  app = make_app()<br>  app.listen(<span class="hljs-number">8888</span>)<br>  tornado.ioloop.IOLoop.current().start()<br></code></pre></td></tr></table></figure><p>可以发现，系统会在<strong>8888端口</strong>开启Web服务，控制台没有输出内容。</p><p>直接访问<a href="http://127.0.0.1:8888/" target="_blank" rel="noopener">http://127.0.0.1:8888/</a>，可以观察到网页中呈现了 <strong>Hello World!</strong> ，如下图所示，一个简单的<strong>Tornado</strong>程序就运行成功了。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Web%E5%BA%93%E5%AE%89%E8%A3%85/tornado.png" width="70%"></p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> 开发环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发环境配置 </tag>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>存储库的安装</title>
      <link href="/2019/08/05/%E5%AD%98%E5%82%A8%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2019/08/05/%E5%AD%98%E5%82%A8%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>数据库想要和Python进行交互的话，还需要安装一些Python存储库，如：<strong>MySQL</strong>需要安装<strong>PyMySQL</strong>、<strong>MongoDB</strong>需要安装<strong>PyMongo</strong>等。</p><p>本文主要说明这些存储库的安装方式。</p><a id="more"></a><h2 id="PyMySQL"><a href="#PyMySQL" class="headerlink" title="PyMySQL"></a>PyMySQL</h2><p>在<strong>Python3</strong>中，如果想要将数据存储到<strong>MySQL</strong>中，就需要借助<strong>PyMySQL</strong>来操作。</p><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>Github：<a href="https://github.com/PyMySQL/PyMySQL" target="_blank" rel="noopener">https://github.com/PyMySQL/PyMySQL</a></li><li>官方文档：<a href="http://pymysql.readthedocs.io" target="_blank" rel="noopener">http://pymysql.readthedocs.io</a></li><li>PyPI：<a href="https://pypi.python.org/pypi/PyMySQL" target="_blank" rel="noopener">https://pypi.python.org/pypi/PyMySQL</a></li></ul><h3 id="pip安装"><a href="#pip安装" class="headerlink" title="pip安装"></a>pip安装</h3><p>安装命令：<code>pip3 install pymysql</code></p><h3 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h3><p>使用以下命令进行验证：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python3<br>&gt;&gt;&gt; import pymysql<br>&gt;&gt;&gt; pymysql.VERSION<br>(0, 9, 3, None)<br></code></pre></td></tr></table></figure><p>如果成功输出了其版本内容，则证明PyMySQL成功安装。</p><h2 id="PyMongoDB"><a href="#PyMongoDB" class="headerlink" title="PyMongoDB"></a>PyMongoDB</h2><p>在Python中，如果想要和<strong>MongoDB</strong>进行交互，就需要借助于<strong>PyMongo</strong>库。</p><h3 id="相关链接-1"><a href="#相关链接-1" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>Github：<a href="https://github.com/mongodb/mongo-python-driver" target="_blank" rel="noopener">https://github.com/mongodb/mongo-python-driver</a></li><li>官方文档：<a href="http://api.mongodb.com/python/current" target="_blank" rel="noopener">http://api.mongodb.com/python/current</a></li><li>PyPI：<a href="https://pypi.python.org/pypi/pymongo" target="_blank" rel="noopener">https://pypi.python.org/pypi/pymongo</a></li></ul><h3 id="pip安装-1"><a href="#pip安装-1" class="headerlink" title="pip安装"></a>pip安装</h3><p>安装命令：<code>pip3 install pymongo</code></p><h3 id="验证安装-1"><a href="#验证安装-1" class="headerlink" title="验证安装"></a>验证安装</h3><p>使用以下命令进行验证：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python3<br>&gt;&gt;&gt; import pymongo<br>&gt;&gt;&gt; pymongo.VERSION<br><span class="hljs-string">'3.8.0'</span><br></code></pre></td></tr></table></figure><p>如果成功输出了其版本内容，则证明<strong>PyMongo</strong>成功安装。</p><h2 id="redis-py"><a href="#redis-py" class="headerlink" title="redis-py"></a>redis-py</h2><p>在Python中，如果想要和<strong>Redis</strong>进行交互，就需要借助于<strong>redis-py</strong>库。</p><h3 id="相关链接-2"><a href="#相关链接-2" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>Github：<a href="https://github.com/andymccurdy/redis-py" target="_blank" rel="noopener">https://github.com/andymccurdy/redis-py</a></li><li>官方文档：<a href="https://redis-py.readthedocs.io/" target="_blank" rel="noopener">https://redis-py.readthedocs.io/</a></li></ul><h3 id="pip安装-2"><a href="#pip安装-2" class="headerlink" title="pip安装"></a>pip安装</h3><p>安装命令：<code>pip3 install redis</code></p><h3 id="验证安装-2"><a href="#验证安装-2" class="headerlink" title="验证安装"></a>验证安装</h3><p>使用以下命令进行验证：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python3<br>&gt;&gt;&gt; import redis<br>&gt;&gt;&gt; redis.VERSION<br>(3, 3, 5)<br></code></pre></td></tr></table></figure><p>如果成功输出了其版本内容，则证明<strong>redis-py</strong>成功安装。</p><h2 id="RedisDump"><a href="#RedisDump" class="headerlink" title="RedisDump"></a>RedisDump</h2><p>RedisDump是一个用于Redis数据导入/导出的工具，是基于Ruby实现的，所以要安装RedisDump，需要先安装Ruby。</p><h3 id="相关链接-3"><a href="#相关链接-3" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>Github：<a href="https://github.com/delano/redis-dump" target="_blank" rel="noopener">https://github.com/delano/redis-dump</a></li><li>官方文档：<a href="http://delanotes.com/redis-dump" target="_blank" rel="noopener">http://delanotes.com/redis-dump</a></li></ul><h3 id="gem安装"><a href="#gem安装" class="headerlink" title="gem安装"></a>gem安装</h3><p>安装Ruby(参考<a href="http://www.ruby-lang.org/zh_cn/documentation/installation" target="_blank" rel="noopener">这里</a>)后，利用<strong>gem命令</strong>安装RedisDump：<code>gem install redis-dump</code></p><h3 id="验证安装-3"><a href="#验证安装-3" class="headerlink" title="验证安装"></a>验证安装</h3><p>安装成功后，可以执行如下两个命令：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">redis-dump<br>redis-load<br></code></pre></td></tr></table></figure><p>如果可以成功调用，则说明安装成功。</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> 开发环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发环境配置 </tag>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库的安装</title>
      <link href="/2019/08/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2019/08/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>作为数据存储的重要部分，数据库同样是必不可少的，数据库可以分为关系型数据库和非关系型数据库。</p><p>关系型数据库如SQLite、MySQL、Oracle、SQL Server、DB2等，其数据库是以表的形式存储。</p><p>非关系型数据库如MongoDB、Redis它们的存储形式是键值对，存储形式更加灵活。</p><p>本文主要介绍关系型数据库MySQL以及非关系型数据库MongoDB、Redis的安装。</p><a id="more"></a><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>MySQL是一个轻量级的关系型数据库。</p><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>官方网站：<a href="https://www.mysql.com/cn" target="_blank" rel="noopener">https://www.mysql.com/cn</a></li><li>下载地址：<a href="https://www.mysql.com/cn/downloads" target="_blank" rel="noopener">https://www.mysql.com/cn/downloads</a></li><li>中文教程：<a href="http://www.runoob.com/mysql/mysql-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/mysql/mysql-tutorial.html</a></li></ul><h3 id="Mac下安装"><a href="#Mac下安装" class="headerlink" title="Mac下安装"></a>Mac下安装</h3><p>使用<strong>HomeBrew</strong>安装，直接执行brew命令即可：<code>brew install mysql</code></p><p>启动、停止和重启MySQL服务的命令如下：</p><ul><li><code>sudo mysql.server start</code></li><li><code>sudo mysql.server stop</code></li><li><code>sudo mysql.server restart</code></li></ul><p>Mac一般不会作为服务器使用，如果想取消本地host绑定，那么需要修改<strong>my.cnf</strong>文件，然后重启服务。</p><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><p>MongoDB是由<strong>C++</strong>语言编写的非关系型数据库，是一个基于分布式文件存储的开源数据库系统，其内容存储形式类似JSON对象，它的字段值可以包含其他文档，数组及文档数据，非常灵活。</p><h3 id="相关链接-1"><a href="#相关链接-1" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>官方网站：<a href="https://www.mongodb.com" target="_blank" rel="noopener">https://www.mongodb.com</a></li><li>官方文档：<a href="https://docs.mongodb.com" target="_blank" rel="noopener">https://docs.mongodb.com</a></li><li>Github：<a href="https://github.com/mongodb" target="_blank" rel="noopener">https://github.com/mongodb</a></li><li>中文教程：<a href="https://www.runoob.com/mongodb/mongodb-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/mongodb/mongodb-tutorial.html</a></li></ul><h3 id="Mac下安装-1"><a href="#Mac下安装-1" class="headerlink" title="Mac下安装"></a>Mac下安装</h3><p>使用<strong>HomeBrew</strong>安装，直接执行brew命令即可：<code>brew install mongodb</code></p><p>然后创建一个新文件夹/data/db，用于存放MongoDB数据。</p><p>启动MongoDB命令：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew services start mongodb<br>sudo mongod<br></code></pre></td></tr></table></figure><p>停止和重启MongoDB服务的命令：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew services stop mongodb<br>brew services restart mongodb<br></code></pre></td></tr></table></figure><h3 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h3><p>二选一即可。</p><p><strong>RoboMongo/Robo 3T</strong>：</p><ul><li>官方网址：<a href="https://robomongo.org" target="_blank" rel="noopener">https://robomongo.org</a></li><li>下载链接：<a href="https://robomongo.org/download" target="_blank" rel="noopener">https://robomongo.org/download</a></li></ul><p><strong>Studio 3T</strong>：</p><ul><li>官方网站：<a href="https://studio3t.com" target="_blank" rel="noopener">https://studio3t.com</a></li><li>下载链接：<a href="https://studio3t.com/download" target="_blank" rel="noopener">https://studio3t.com/download</a></li></ul><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>Redis是一个基于内存的高效的非关系型数据库。</p><h3 id="相关链接-2"><a href="#相关链接-2" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>官方网站：<a href="https://redis.io" target="_blank" rel="noopener">https://redis.io</a></li><li>官方文档：<a href="https://redis.io/documentation" target="_blank" rel="noopener">https://redis.io/documentation</a></li><li>中文官网：<a href="http://www.redis.cn" target="_blank" rel="noopener">http://www.redis.cn</a></li><li>Github：<a href="https://github.com/antirez/redis" target="_blank" rel="noopener">https://github.com/antirez/redis</a></li><li>中文教程：<a href="https://www.runoob.com/redis/redis-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/redis/redis-tutorial.html</a></li></ul><h3 id="Mac下安装-2"><a href="#Mac下安装-2" class="headerlink" title="Mac下安装"></a>Mac下安装</h3><p>使用<strong>HomeBrew</strong>安装，直接执行brew命令即可：<code>brew install redis</code></p><p>启动<strong>redis</strong>命令：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew services start redis<br>redis-server /usr/<span class="hljs-built_in">local</span>/etc/redis.conf<br></code></pre></td></tr></table></figure><p>这里可以使用命令：<code>redis-cli</code>进入Redis命令行模式。</p><p>Mac下的Redis配置文件路径是：<code>/usr/local/etc/redis.conf</code>，可以通过修改它来配置访问密码。</p><p>修改配置文件后，需要重启Redis服务。停止和重启Redis服务的命令如下：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew services stop redis<br>brew services restart redis<br></code></pre></td></tr></table></figure><p>另外Mac下可以安装<strong>Redis Desktop Manager</strong>可视化管理工具来管理Redis。</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> 开发环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发环境配置 </tag>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解析库的安装</title>
      <link href="/2019/08/05/%E8%A7%A3%E6%9E%90%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2019/08/05/%E8%A7%A3%E6%9E%90%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>爬取网页代码后，下一步就是从网页中提取信息。</p><p>提取信息的方式有多种多样，可以使用正则表达式来提取，但是写起来相对比较繁琐。</p><p>这里还有许多强大的解析库，如lxml、Beautiful Soup、pyquery等。</p><p>此外还有非常强大的解析方法，如XPath解析和CSS选择器解析等，利用它们，我们可以高效便捷地从网页中提取有效信息。</p><a id="more"></a><h2 id="lxml库"><a href="#lxml库" class="headerlink" title="lxml库"></a>lxml库</h2><p>lxml是Python的一个解析库，支持HTML和XML的解析，支持XPath解析方式而且解析效率非常高。</p><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>官方网站：<a href="http://lxml.de" target="_blank" rel="noopener">http://lxml.de</a></li><li>Github：<a href="https://github.com/lxml/lxml" target="_blank" rel="noopener">https://github.com/lxml/lxml</a></li><li>PyPI：<a href="https://pypi.python.org/pypi/lxml" target="_blank" rel="noopener">https://pypi.python.org/pypi/lxml</a></li></ul><h3 id="pip安装"><a href="#pip安装" class="headerlink" title="pip安装"></a>pip安装</h3><p>命令行输入：<code>pip3 install lxml</code></p><p>如果产生错误，可以执行如下命令将必要的类库安装(Mac操作系统)：<code>xcode-select --install</code></p><p>lxml是一个非常重要的库，后面的Beautiful Soup、Scrapy框架都需要用到此库。</p><h3 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h3><p>安装完成之后，可以在Python命令下测试：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python3<br>&gt;&gt;&gt;import lxml<br></code></pre></td></tr></table></figure><p>如果没有报错，则证明库已经安装好了。</p><h2 id="Beautiful-Soup库"><a href="#Beautiful-Soup库" class="headerlink" title="Beautiful Soup库"></a>Beautiful Soup库</h2><p>Beautiful Soup是Python的一个HTML或XML的解析库，我们可以用它来方便地从网页中提取数据。</p><p>它拥有强大的API和多样的解析方式。</p><h3 id="相关链接-1"><a href="#相关链接-1" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>官方文档：<a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/" target="_blank" rel="noopener">https://www.crummy.com/software/BeautifulSoup/bs4/doc</a></li><li>中文文档：<a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/" target="_blank" rel="noopener">https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/</a></li><li>PyPI：<a href="https://pypi.python.org/pypi/beautifulsoup4" target="_blank" rel="noopener">https://pypi.python.org/pypi/beautifulsoup4</a></li></ul><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>Beautiful Soup的HTML和XML解析器是依赖于lxml库的，所以在此之前请确保已经安装了<strong>lxml库</strong>。</p><h3 id="pip安装-1"><a href="#pip安装-1" class="headerlink" title="pip安装"></a>pip安装</h3><p>目前，Beautiful Soup的最新版本是4.x版本，之前的版本以及停止开发。</p><p>这里推荐使用pip安装，命令为：<code>pip3 install beautifulsoup4</code></p><h3 id="验证安装-1"><a href="#验证安装-1" class="headerlink" title="验证安装"></a>验证安装</h3><p>安装完成之后，可以运行如下代码验证一下：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br>soup = BeautifulSoup(<span class="hljs-string">'&lt;p&gt;hello&lt;/p&gt;'</span>, <span class="hljs-string">'lxml'</span>)<br>print(soup.p.string)<br></code></pre></td></tr></table></figure><p>若输出结果为：<code>hello</code>，则证明安装成功。</p><p><strong>注意</strong>：</p><p>这里我们虽然安装的是beautifulsoup4这个包，但在引入的时候却是bs4。这是因为这个包源代码本身的库文件夹名称就是bs4，所以安装完成之后，这个库文件夹就被移入到本机Python3的lib库里，所以识别到的库文件名就叫做bs4。</p><p>因此，<em>包本身的名称和我们使用时导入的包的名称并不一定是一致的</em>。</p><h2 id="pyquery库"><a href="#pyquery库" class="headerlink" title="pyquery库"></a>pyquery库</h2><p>pyquery是一个强大的网页解析工具，它提供了和jQuery类似的语法来解析HTML文档，支持CSS选择器。</p><h3 id="相关链接-2"><a href="#相关链接-2" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>Github：<a href="https://github.com/gawel/pyquery" target="_blank" rel="noopener">https://github.com/gawel/pyquery</a></li><li>PyPI：<a href="https://pypi.python.org/pypi/pyquery" target="_blank" rel="noopener">https://pypi.python.org/pypi/pyquery</a></li><li>官方文档：<a href="http://pyquery.readthedocs.io" target="_blank" rel="noopener">http://pyquery.readthedocs.io</a></li></ul><h3 id="pip安装-2"><a href="#pip安装-2" class="headerlink" title="pip安装"></a>pip安装</h3><p>命令行：<code>pip3 install pyquery</code></p><h3 id="验证安装-2"><a href="#验证安装-2" class="headerlink" title="验证安装"></a>验证安装</h3><p>安装完成之后，可以在Python命令下测试：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python3<br>&gt;&gt;&gt;import pyquery<br></code></pre></td></tr></table></figure><p>如果没有报错，则证明库已经安装好了。</p><h2 id="tesserocr库"><a href="#tesserocr库" class="headerlink" title="tesserocr库"></a>tesserocr库</h2><p>在爬虫过程中，难免会遇到各种各样的验证码，而大多数验证码还是图形验证码，这时候我们可以直接使用OCR来识别。</p><p>OCR( Optical Character Recognition )，光学字符识别，是指通过扫描字符，然后通过其形状将其翻译成电子文本的过程。对于图形验证码来说，它们都是一些不规则的字符，这些符确实是由字符稍加扭曲变换得到的内容。</p><p>tesserocr是Python的一个OCR识别库，但其实是对tesseract做的一层Python API封装，所以它的核心是tesseract。因此，在安装tesserocr之前，我们需要安装tesseract。</p><h3 id="相关链接-3"><a href="#相关链接-3" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>tesserocr Github：<a href="https://github.com/sirfz/tesserocr" target="_blank" rel="noopener">https://github.com/sirfz/tesserocr</a></li><li>tesserocr PyPI：<a href="https://pypi.python.org/pypi/tesserocr" target="_blank" rel="noopener">https://pypi.python.org/pypi/tesserocr</a></li><li>tesseract 下载地址：<a href="http://digi.bib.uni-mannheim.de/tesseract" target="_blank" rel="noopener">http://digi.bib.uni-mannheim.de/tesseract</a></li><li>tesseract Github：<a href="https://github.com/tesseract-ocr/tesseract" target="_blank" rel="noopener">https://github.com/tesseract-ocr/tesseract</a></li><li>tesseract 语言包：<a href="https://github.com/tesseract-ocr/tessdata" target="_blank" rel="noopener">https://github.com/tesseract-ocr/tessdata</a></li><li>tesseract文档：<a href="https://github.com/tesseract-ocr/tesseract/wiki/Documentation" target="_blank" rel="noopener">https://github.com/tesseract-ocr/tesseract/wiki/Documentation</a></li></ul><h3 id="Mac下安装"><a href="#Mac下安装" class="headerlink" title="Mac下安装"></a>Mac下安装</h3><ol><li>使用<strong>HomeBrew</strong>安装<strong>ImageMagick</strong>和<strong>tesseract</strong>库。</li></ol><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install imagemagick<br>//先安装依赖库libpng, jpeg, libtiff, leptonica<br>brew install leptonica<br>brew install tesseract<br></code></pre></td></tr></table></figure><ol><li><p>下载语言库</p><p> 下载地址:<a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Ftesseract-ocr%2Ftessdata" target="_blank" rel="noopener">https://github.com/tesseract-ocr/tessdata</a></p><p> 根据自己的需求选择所要的语言库，在这里我们选择的是简体中文和英文，所以选择的库是<code>chi_sim.traineddata</code>、<code>eng.traineddata</code><br>  将文件拷贝到到：/usr/local/Cellar/tesseract/4.1.0/share/tessdata目录下。</p></li><li><p>接下来再安装tesserocr即可</p></li></ol><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip3 install tesserocr pillow<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：</p><p>这里可能会出现无法安装<strong>tesserocr</strong>的错误，需要执行以下两个步骤：</p><ol><li>命令行中输入：<code>xcode-select --install</code></li></ol><p>输出：</p><p><strong>xcode-select: error: command line tools are already installed, use “Software Update” to install updates</strong></p><p>不用管它。</p><ol><li>命令行中输入：<code>export MACOSX_DEPLOYMENT_TARGET=10.13</code></li></ol><p>这里 <strong>10.13</strong> 是我自己的macOS的系统版本号。换成自己电脑相对应的就行。</p><ol><li>执行以上两个步骤，再次执行<code>pip3 install tesserocr pillow</code>就能成功安装啦。</li></ol><h3 id="验证安装-3"><a href="#验证安装-3" class="headerlink" title="验证安装"></a>验证安装</h3><p>可以使用tesseract和tesserocr来分别进行测试。</p><p>从<a href="https://raw.githubusercontent.com/Python3WebSpider/TestTess/master/image.png" target="_blank" rel="noopener">链接</a>中获取样例图片，如下所示。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/%E8%A7%A3%E6%9E%90%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/%E9%AA%8C%E8%AF%81%E7%A0%81.png" width="50%"></p><p>首先使用命令进行测试，将图片下载来并保存为<strong>image.png</strong>，然后用<code>tesseract</code>命令测试：</p><p><code>tesseract image.png result -l eng &amp;&amp; cat result.txt</code></p><p>运行结果如下：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Tesseract Open Source OCR Engine v4.1.0 with Leptonica<br>Python3WebSpider<br></code></pre></td></tr></table></figure><p>这里我们调用了<code>tesseract</code>命令，其中</p><ul><li>第一个参数为图片名称。</li><li>第二个参数result为结果保存的目标文件名称。</li><li><code>-l</code>指定使用的语言包，此处使用英文(eng)。</li><li>然后再用cat命令将结果输出。</li></ul><p>运行结果便是图片的识别结果：<code>Python3WebSpider</code>，可以看到，这时已经成功将图片转化为文本了。</p><p>然后还可以利用Python代码来进行测试，这里就需要借助于tesserocr库了，测试代码如下：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tesserocr<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br>image = Image.open(<span class="hljs-string">'image.png'</span>)<br>print(tesserocr.image_to_text(image))<br></code></pre></td></tr></table></figure><p>我们首先使用<code>Image</code>读取了图片文件，然后调用了<strong>tesserocr</strong>的<code>image_to_text()</code>方法，再将其识别结果输出。</p><p>运行结果如下：</p><p><code>Python3WebSpider</code></p><p>另外，我们还可以直接调用<code>file_to_text()</code>方法，达到同样的效果：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tesserocr<br>print(tesserocr.file_to_text(<span class="hljs-string">'image.png'</span>))<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><code>Python3WebSpider</code></p><p>如果成功输出结果，则证明<strong>tesseract</strong>和<strong>tesserocr</strong>都已经成功安装。</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> 开发环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发环境配置 </tag>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>请求库的安装</title>
      <link href="/2019/08/03/%E8%AF%B7%E6%B1%82%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2019/08/03/%E8%AF%B7%E6%B1%82%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>爬虫可以简单分为几步：抓取页面、分析页面和存储数据。</p><p>在抓取页面的过程中，我们需要模拟浏览器向服务器发出请求，所以需要用到一些Python库来实现HTTP请求操作。</p><p>我们要用到的第三方库有requests、Selenium和aiohttp等。</p><a id="more"></a><h2 id="requests库"><a href="#requests库" class="headerlink" title="requests库"></a>requests库</h2><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>Github：<a href="https://github.com/requests/requests" target="_blank" rel="noopener">https://github.com/requests/requests</a></li><li>PyPI：<a href="https://pypi.python.org/pypi/requests" target="_blank" rel="noopener">https://pypi.python.org/pypi/requests</a></li><li>官方文档：<a href="https://www.python-requests.org" target="_blank" rel="noopener">https://www.python-requests.org</a>  (需要科学上网)</li><li>中文文档：<a href="http://docs.python-requests.org/zh_CN/latest" target="_blank" rel="noopener">http://docs.python-requests.org/zh_CN/latest</a></li></ul><h3 id="pip安装-推荐"><a href="#pip安装-推荐" class="headerlink" title="pip安装(推荐)"></a>pip安装(推荐)</h3><p>在命令行界面中运行如下命令，即可完成requests库的安装。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip3 install requests<br></code></pre></td></tr></table></figure><h3 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h3><p>如果想要获取某一特定版本，可以选择下载源码安装。</p><p>requests项目的地址是：<a href="https://github.com/psf/requests" target="_blank" rel="noopener">https://github.com/psf/requests</a></p><p>可以通过Git来下载源代码：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/psf/requests.git<br></code></pre></td></tr></table></figure><p>下载完成后，进入目录，进行安装</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> requests<br>python3 setup.py install<br></code></pre></td></tr></table></figure><h3 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h3><p>进入Python命令行交互模式，导入requests包，如果没有报错，则证明安装成功：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python3<br>&gt;&gt;&gt; import requests<br></code></pre></td></tr></table></figure><h2 id="Selenium库"><a href="#Selenium库" class="headerlink" title="Selenium库"></a>Selenium库</h2><p>Selenium是一个自动化测试工具，利用它我们可以驱动浏览器执行特定的动作，如点击、下拉等操作。</p><p>对于一些JavaScript渲染的页面来说，这种抓取方式非常有效。</p><h3 id="相关链接-1"><a href="#相关链接-1" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>Github：<a href="https://github.com/SeleniumHQ/selenium/tree/master/py" target="_blank" rel="noopener">https://github.com/SeleniumHQ/selenium/tree/master/py</a></li><li>PyPI：<a href="https://pypi.org/project/selenium/" target="_blank" rel="noopener">https://pypi.org/project/selenium/</a></li><li>官方文档：<a href="https://selenium-python.readthedocs.io/" target="_blank" rel="noopener">https://selenium-python.readthedocs.io/</a></li><li>中文文档：<a href="https://selenium-python-zh.readthedocs.io/en/latest/" target="_blank" rel="noopener">https://selenium-python-zh.readthedocs.io/en/latest/</a></li></ul><h3 id="pip安装-推荐-1"><a href="#pip安装-推荐-1" class="headerlink" title="pip安装(推荐)"></a>pip安装(推荐)</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip3 install selenium<br></code></pre></td></tr></table></figure><h3 id="验证安装-1"><a href="#验证安装-1" class="headerlink" title="验证安装"></a>验证安装</h3><p>进入Python命令行交互模式，导入selenium包，如果没有报错，则证明安装成功：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python3<br>&gt;&gt;&gt; import selenium<br></code></pre></td></tr></table></figure><p>但是这样做还不够，还需要用浏览器(如Chrome、Firefox等)来配合Selenium工作。</p><h2 id="ChromeDriver的安装"><a href="#ChromeDriver的安装" class="headerlink" title="ChromeDriver的安装"></a>ChromeDriver的安装</h2><p>上一部已经安装好Selenium，但是它是一个自动化测试工具，需要浏览器来配合使用。</p><p>该节中我们就介绍一下Chrome浏览器及ChromeDriver驱动的配置。</p><h3 id="相关链接-2"><a href="#相关链接-2" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>官方网址：<a href="https://sites.google.com/a/chromium.org/chromedriver" target="_blank" rel="noopener">https://sites.google.com/a/chromium.org/chromedriver</a> (需要科学上网)</li><li>下载地址：<a href="https://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">https://chromedriver.storage.googleapis.com/index.html</a></li></ul><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>确保安装好Chrome浏览器并可以正常运行。</p><h3 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h3><p>点击Chrome菜单 “帮助” -&gt; “关于Google Chrome(G)”，即可查看Chrome的版本号，如下图所示。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E7%89%88%E6%9C%AC.png" width="70%"></p><p>这里我的版本号是 <em>75.0</em> ，这个版本号在选择ChromeDriver版本的时候会用到。</p><h3 id="下载ChromeDriver"><a href="#下载ChromeDriver" class="headerlink" title="下载ChromeDriver"></a>下载ChromeDriver</h3><p>打开<a href="https://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">下载链接</a>，选择对应的版本进行下载。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/ChromeDriver%E7%89%88%E6%9C%AC.png" width="70%"></p><h3 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h3><p>下载完成后，将ChromeDriver的可执行文件配置到环境变量下。</p><ul><li>在Windows下，建议直接将ChromeDriver.exe文件拖到Python的Scripts目录下。</li><li>在Linux和Mac下，需要将可执行文件配置到环境变量或将文件移动到属于环境变量的目录里。</li></ul><p>Mac配置：</p><p>方法一：</p><p>例如要移动文件到<code>/usr/bin</code>目录。首先需要在命令行模式下进入其所在路径，然后将其移动到<code>/usr/bin</code>：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo mv chromedriver /usr/bin<br></code></pre></td></tr></table></figure><p>另外，若系统为Mac OS X EI Capitan 10.11 及以上版本时，需要先关闭Rootless内核保护机制。具体操作如下：</p><ol><li>重启电脑后按住<code>command+R</code>进入恢复分区。</li><li>在<code>实用工具栏</code>找到<code>终端</code>启动运行。</li><li>输入：<code>csrutil disable; reboot</code>。</li><li>执行上述移动语句：<code>sudo mv chromedriver /usr/bin</code>。</li><li>重复执行1-2，在3中输入：<code>csrutil enable; reboot</code>，开启保护。</li></ol><p>方法二：</p><p>将ChromeDriver配置到<code>$PATH</code>：</p><ol><li><p>将可执行文件放到某一目录，目录可以任意选择。例如将当前可执行文件放在<code>/usr/local/chromedriver</code>目录下。</p></li><li><p>Linux修改<code>~/.profile</code>文件，mac修改<code>~/.bash_profile</code>文件，添加如下内容：</p><p> <code>export PATH=&quot;$PATH:/usr/local/chromedriver&quot;</code></p></li><li><p>保存后，</p><ul><li>在linux执行：<code>source ~/.profile</code></li><li>在mac执行：<code>source ~/.bash_profile</code></li></ul></li></ol><h3 id="验证安装-2"><a href="#验证安装-2" class="headerlink" title="验证安装"></a>验证安装</h3><p>配置完成后，可以在命令行中直接执行<code>chromedriver</code>命令了</p><p>如果输入控制台有如下所示的输出，则证明ChromeDriver的环境变量配置好了。</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/chromedriver%E6%8E%A7%E5%88%B6%E5%8F%B0.png" width="70%"></p><p>随后再在程序中测试，执行如下Python代码：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br>browser = webdriver.Chrome()<br></code></pre></td></tr></table></figure><p>运行后，如果弹出一个空白的Chrome浏览器，则证明所有的配置都没有问题。如果没有弹出，则检查之前的每一步配置。</p><p>如果弹出后闪退，则可能是ChromeDriver版本和Chrome版本不兼容，请更换ChromeDriver版本。</p><h2 id="PhantomJS的安装"><a href="#PhantomJS的安装" class="headerlink" title="PhantomJS的安装"></a>PhantomJS的安装</h2><p>PhantomJS是一个无界面的、可脚本编程的WebKit浏览器引擎，它原生支持多种Web标准：DOM操作，CSS选择器，JSON，Canvas以及SVG。</p><p>Selenium支持PhantomJS，这样在运行的时候就不会再弹出一个浏览器了。而且PhantomJS的运行效率也很高，还支持各种参数配置，使用非常方便。</p><h3 id="相关链接-3"><a href="#相关链接-3" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>官方网站：<a href="http://phantomjs.org" target="_blank" rel="noopener">http://phantomjs.org</a></li><li>官方文档：<a href="https://phantomjs.org/quick-start.html" target="_blank" rel="noopener">https://phantomjs.org/quick-start.html</a></li><li>下载地址：<a href="https://phantomjs.org/download.html" target="_blank" rel="noopener">https://phantomjs.org/download.html</a></li><li>API接口说明：<a href="https://phantomjs.org/api/command-line.html" target="_blank" rel="noopener">https://phantomjs.org/api/command-line.html</a></li></ul><h3 id="下载PhantomJS"><a href="#下载PhantomJS" class="headerlink" title="下载PhantomJS"></a>下载PhantomJS</h3><p>在<a href="https://phantomjs.org/download.html" target="_blank" rel="noopener">下载页面</a>选择对应的操作系统版本进行下载，并将PhantomJS可执行文件所在的路径配置到环境变量里（与ChromeDriver安装一致）。</p><p>配置成功后，可以在命令行下测试，输入：<code>phantomjs</code></p><p>如果可以进入到PhantomJS的命令行，则证明配置完成。</p><h3 id="验证安装-3"><a href="#验证安装-3" class="headerlink" title="验证安装"></a>验证安装</h3><p>在Selenium中使用的话，只需要将Chrome切换成PhantomJS即可：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br>driver = webdriver.PhantomJS()<br>driver.get(<span class="hljs-string">"http://www.baidu.com/"</span>)<br>print(driver.current_url)<br></code></pre></td></tr></table></figure><p>运行之后就会发现没有浏览器弹出了，但实际上PhantomJS已经运行起来了。</p><p>这里我们访问了百度，然后将当前URL打印出来了。</p><p>控制台的输出为：<code>https://www.baidu.com</code></p><p>如此一来，我们便完成了PhantomJS的配置，后面可以利用它来完成一些页面的抓取。</p><h2 id="aiohttp库"><a href="#aiohttp库" class="headerlink" title="aiohttp库"></a>aiohttp库</h2><p>上述提到的requests库是一个阻塞式HTTP请求库。(当我们发出一个请求后，程序会一直等待服务器响应，直到得到响应后，程序才会进行下一步处理)。其实，这个过程比较耗费时间。</p><p>如果程序可以在这个等待过程中做一些其他事情，如进行请求的调度、响应的处理等，那么爬取的效率会大大提高。</p><p>aiohttp就是这样一个提供异步Web服务的库，从Python3.5版本开始，Python中加入了<code>async/await</code>关键字，使得回调的写法更加直观和人性化。aiohttp的异步操作借助于<code>async/await</code>关键字的写法变得更加简洁，架构更加清晰。使用异步请求库进行数据抓取时，会大大提高效率。</p><h3 id="相关链接-4"><a href="#相关链接-4" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li>官方文档：<a href="http://aiohttp.readthedocs.io/en/stable" target="_blank" rel="noopener">http://aiohttp.readthedocs.io/en/stable</a></li><li>Github：<a href="https://github.com/aio-libs/aiohttp/" target="_blank" rel="noopener">https://github.com/aio-libs/aiohttp/</a></li><li>PyPI：<a href="https://pypi.org/project/aiohttp/3.5.4/" target="_blank" rel="noopener">https://pypi.org/project/aiohttp/3.5.4/</a></li></ul><h3 id="pip安装"><a href="#pip安装" class="headerlink" title="pip安装"></a>pip安装</h3><p>安装命令：<code>pip3 install aiohttp</code></p><p>另外，官方还推荐安装如下两个库：</p><ul><li>字符编码检测库<strong>cchardet</strong></li><li>加速DNS的解析库<strong>aiodns</strong></li></ul><p>安装命令：<code>pip3 install cchardet aiodns</code></p><h3 id="测试安装"><a href="#测试安装" class="headerlink" title="测试安装"></a>测试安装</h3><p>安装完成后，可以在Python命令行下测试：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python3<br>&gt;&gt;&gt; import aiohttp<br></code></pre></td></tr></table></figure><p>如果没有错误报出，则证明库已经安装好了。</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> 开发环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发环境配置 </tag>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天一个linux命令(1): ls</title>
      <link href="/2019/08/03/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4-1-ls/"/>
      <url>/2019/08/03/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4-1-ls/</url>
      
        <content type="html"><![CDATA[<p>ls命令是linux下最常用的命令。ls命令就是list的缩写，缺省下ls用来打印出当前目录的清单，如果ls指定其他目录，那么就会显示指定目录里的文件及文件夹清单。</p><p>通过ls命令不仅可以查看linux文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限)、查看目录信息等等。ls命令在日常的linux操作中用的很多。</p><a id="more"></a><h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ls [选项] [目录名]<br></code></pre></td></tr></table></figure><h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p>列出目标目录中所有的子目录和文件。</p><h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">-a,—all</td><td style="text-align:left">列出目录下的所有文件，包括以 . 开头的隐含文件</td></tr><tr><td style="text-align:left">-A</td><td style="text-align:left">同-a，但不列出“.”(表示当前目录)和“..”(表示当前目录的父目录)。</td></tr><tr><td style="text-align:left">-c  配合 -lt</td><td style="text-align:left">根据 ctime 排序及显示 ctime (文件状态最后更改的时间)配合 -lt：显示 ctime 但根据名称排序否则：根据 ctime 排序</td></tr><tr><td style="text-align:left">-C</td><td style="text-align:left">每栏由上至下列出项目</td></tr><tr><td style="text-align:left">-color[=WHEN]</td><td style="text-align:left">控制是否使用色彩分辨文件。WHEN 可以是’never’、’always’或’auto’其中之一</td></tr><tr><td style="text-align:left">-d,—directory</td><td style="text-align:left">将目录象文件一样显示，而不是显示其下的文件。</td></tr><tr><td style="text-align:left">-D,—dired</td><td style="text-align:left">产生适合 Emacs 的 dired 模式使用的结果</td></tr><tr><td style="text-align:left">-f</td><td style="text-align:left">对输出的文件不进行排序，-aU 选项生效，-lst 选项失效</td></tr><tr><td style="text-align:left">-g</td><td style="text-align:left">类似 -l,但不列出所有者</td></tr><tr><td style="text-align:left">-G, —no-group</td><td style="text-align:left">不列出任何有关组的信息</td></tr><tr><td style="text-align:left">-h,—human-readable</td><td style="text-align:left">以容易理解的格式列出文件大小 (例如 1K 234M 2G)</td></tr><tr><td style="text-align:left">—si</td><td style="text-align:left">类似 -h,但文件大小取 1000 的次方而不是 1024</td></tr><tr><td style="text-align:left">-H, —dereference-command-line</td><td style="text-align:left">使用命令列中的符号链接指示的真正目的地</td></tr><tr><td style="text-align:left">—indicator-style=&lt;方式&gt;</td><td style="text-align:left">指定在每个项目名称后加上指示符号&lt;方式&gt;：none (默认)，classify (-F)，file-type (-p)</td></tr><tr><td style="text-align:left">-i, —inode</td><td style="text-align:left">印出每个文件的 inode 号</td></tr><tr><td style="text-align:left">-I,—ignore=样式</td><td style="text-align:left">不印出任何符合 shell 万用字符&lt;样式&gt;的项目</td></tr><tr><td style="text-align:left">-k</td><td style="text-align:left">即 –block-size=1K,以 k 字节的形式表示文件的大小</td></tr><tr><td style="text-align:left">-l</td><td style="text-align:left">除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来。</td></tr><tr><td style="text-align:left">-L, —dereference</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">-m</td><td style="text-align:left">所有项目以逗号分隔，并填满整行行宽</td></tr><tr><td style="text-align:left">-o</td><td style="text-align:left">类似 -l,显示文件的除组信息外的详细信息。</td></tr><tr><td style="text-align:left">-r, —reverse</td><td style="text-align:left">依相反次序排列</td></tr><tr><td style="text-align:left">-R, —recursive</td><td style="text-align:left">同时列出所有子目录层</td></tr><tr><td style="text-align:left">-s,—size</td><td style="text-align:left">以块大小为单位列出所有文件的大小</td></tr><tr><td style="text-align:left">-S</td><td style="text-align:left">根据文件大小排序</td></tr><tr><td style="text-align:left">—sort=WORD</td><td style="text-align:left">可选用的 WORD 和它们代表的相应选项： <br>extension -X status -c<br>none -U time -t<br>size -S atime -u<br>time -t access -u<br>version -v use -u</td></tr><tr><td style="text-align:left">-t</td><td style="text-align:left">以文件修改时间排序</td></tr><tr><td style="text-align:left">-u</td><td style="text-align:left">配合 -lt:显示访问时间而且依访问时间排序<br>配合 -l:显示访问时间但根据名称排序<br>否则：根据访问时间排序</td></tr><tr><td style="text-align:left">-U</td><td style="text-align:left">不进行排序;依文件系统原有的次序列出项目</td></tr><tr><td style="text-align:left">-v</td><td style="text-align:left">根据版本进行排序</td></tr><tr><td style="text-align:left">-w, —width=COLS</td><td style="text-align:left">自行指定屏幕宽度而不使用目前的数值</td></tr><tr><td style="text-align:left">-x</td><td style="text-align:left">逐行列出项目而不是逐栏列出</td></tr><tr><td style="text-align:left">-X</td><td style="text-align:left">根据扩展名排序</td></tr><tr><td style="text-align:left">-1</td><td style="text-align:left">每行只列出一个文件</td></tr><tr><td style="text-align:left">—help</td><td style="text-align:left">显示此帮助信息并离开</td></tr><tr><td style="text-align:left">—version</td><td style="text-align:left">显示版本信息并离开</td></tr></tbody></table></div><h2 id="常用范例"><a href="#常用范例" class="headerlink" title="常用范例"></a>常用范例</h2><p><code>例一</code>：<strong>列出/home/huben/ 文件夹下的所有文件和目录的详细信息</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ls -l -R /home/huben<br>$ ls -lR /home/huben<br></code></pre></td></tr></table></figure><p><code>例二</code>：<strong>列出当前目录中所有以“t”开头的目录的详细内容，可以使用如下命令</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ls -l t*<br></code></pre></td></tr></table></figure><p><code>例三</code>：<strong>只列出文件下的子目录</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ls -F /opt/soft |grep /$<br></code></pre></td></tr></table></figure><p><code>例四</code>：<strong>列出文件下的子目录详细情况</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ls -l /opt/soft | grep <span class="hljs-string">"^d"</span><br></code></pre></td></tr></table></figure><p><code>例五</code>：<strong>列出目前工作目录下所有名称是s 开头的文件，愈新的排愈后面，可以使用如下命令</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ls -ltr s*<br></code></pre></td></tr></table></figure><p><code>例六</code>：<strong>列出目前工作目录下所有档案及目录;目录于名称后加”/“, 可执行档于名称后加*</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ls -AF<br></code></pre></td></tr></table></figure><p><code>例七</code>：<strong>计算当前目录下的文件数和目录数</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ls -l * |grep <span class="hljs-string">"^-"</span>|wc -l    ---文件个数<br>$ ls -l * |grep <span class="hljs-string">"^d"</span>|wc -l    ---目录个数<br></code></pre></td></tr></table></figure><p><code>例八</code>：<strong>在ls中列出文件的绝对路径</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ls | sed <span class="hljs-string">"s:^:`pwd`/:"</span><br></code></pre></td></tr></table></figure><p><code>例九</code>：<strong>列出当前目录下的所有文件（包括隐藏文件）的绝对路径， 对目录不做递归</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ find <span class="hljs-variable">$PWD</span> -maxdepth 1 | xargs ls -ld<br></code></pre></td></tr></table></figure><p><code>例十</code>：<strong>列出当前目录下的所有文件（包括隐藏文件）的绝对路径， 对目录不做递归</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ find <span class="hljs-variable">$PWD</span> -maxdepth 1 | xargs ls -ld<br></code></pre></td></tr></table></figure><p><code>例十一</code>：<strong>递归列出当前目录下的所有文件（包括隐藏文件）的绝对路径</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ find <span class="hljs-variable">$PWD</span> | xargs ls -ld<br></code></pre></td></tr></table></figure><p><code>例十二</code>：<strong>指定文件时间输出格式</strong></p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ls -tl --time-style=full-iso<br>$ ls -ctl --time-style=long-iso<br><br>2016-08-05 22:17:06.020535551 +0800<br>2016-10-29 12:03<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> linux基础命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python多线程</title>
      <link href="/2019/08/03/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2019/08/03/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>本文主要介绍了以下内容:</strong></p><p>Python多线程相关基础</p><a id="more"></a><h2 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h2><p>Python中多线程用在IO密集型代码中。</p><ul><li>计算密集型：需要大量计算，绝大部分时间都消耗在CPU计算上，此时，无论开多少线程，所需要的时间就是那么多，甚至比原来时间还长，因为全局解释器锁(GIL)一个时刻只让跑一个线程，大部分计算密集型任务分了很多线程但是依然会按照代码顺序线性执行，甚至代码变得冗长了，反而使执行时间增加了。</li><li>IO密集型：90%以上的时间都花费在网络、硬盘、输入输出上，CPU执行完命令之后剩下的就不需要在CPU中跑了，就可以释放内存在跑下一条命令了。</li></ul><p>每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。</p><p>但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p><p>每个线程都有自己的一组CPU寄存器，称为线程的上下文，该上下文反映了线程上次运行该线程的CPU寄存器的状态。</p><p>指令指针和堆栈指针寄存器是线程上下文中两个最重要的寄存器，线程总是在进程得到上下文中运行的，这些地址都用于标志拥有线程的进程的进程地址空间中的内存。</p><ul><li>线程可以被抢断(中断)</li><li>在其他线程正在运行时，线程可以暂时搁置(也称为睡眠）— — 即线程的退让。</li></ul><p>线程可分为：</p><ul><li>内核线程：由操作系统内核创建和撤销。</li><li>用户线程：不需要内核支持而在用户程序中实现的线程。</li></ul><h2 id="Threading模块"><a href="#Threading模块" class="headerlink" title="Threading模块"></a>Threading模块</h2><h4 id="Threading模块对象"><a href="#Threading模块对象" class="headerlink" title="Threading模块对象"></a>Threading模块对象</h4><div class="table-container"><table><thead><tr><th style="text-align:center">对象</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">Thread</td><td style="text-align:center">线程对象</td></tr><tr><td style="text-align:center">Lock</td><td style="text-align:center">互斥锁</td></tr><tr><td style="text-align:center">Condition</td><td style="text-align:center">条件变量</td></tr><tr><td style="text-align:center">Event</td><td style="text-align:center">事件，该事件发生后所有等待该事件的线程将被激活</td></tr><tr><td style="text-align:center">Semaphore</td><td style="text-align:center">信号量</td></tr><tr><td style="text-align:center">Timer</td><td style="text-align:center">定时器，运行前会等待一段时间</td></tr><tr><td style="text-align:center">Barrier</td><td style="text-align:center">创建一个障碍，必须达到指定数量的线程才开始运行</td></tr></tbody></table></div><h4 id="Threading模块的Thread类"><a href="#Threading模块的Thread类" class="headerlink" title="Threading模块的Thread类"></a>Threading模块的Thread类</h4><div class="table-container"><table><thead><tr><th style="text-align:center">对象</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">name</td><td style="text-align:center">线程名(属性)</td></tr><tr><td style="text-align:center">ident</td><td style="text-align:center">线程标识符(属性)</td></tr><tr><td style="text-align:center">daemon</td><td style="text-align:center">线程是否是守护线程(属性)</td></tr><tr><td style="text-align:center">__init__(group=None,tatget=None,name=None,args=(),kwargs={},verbose=None,daemon=None)</td><td style="text-align:center">实例化一个线程对象，需要有一个可调用的target，以及其参数args或kwargs。还可以传递name或group参数，不过后者还未实现。此外，verbose标志也是可接受的。而daemon的值将会设定thread.daemon属性/标志</td></tr><tr><td style="text-align:center">start()</td><td style="text-align:center">开启线程活动</td></tr><tr><td style="text-align:center">run()</td><td style="text-align:center">定义线程活动的方法(通常在子类中被应用开发者重写)</td></tr><tr><td style="text-align:center">join([time])</td><td style="text-align:center">等待至线程中止。阻塞调用线程直至线程的join()方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生</td></tr><tr><td style="text-align:center">Barrier</td><td style="text-align:center">创建一个障碍，必须达到指定数量线程才开始运行</td></tr><tr><td style="text-align:center">isAlive()</td><td style="text-align:center">返回线程是否活动的</td></tr><tr><td style="text-align:center">getName()</td><td style="text-align:center">返回线程名</td></tr><tr><td style="text-align:center">setName()</td><td style="text-align:center">设置线程名</td></tr></tbody></table></div><h5 id="Threading模块常用方法"><a href="#Threading模块常用方法" class="headerlink" title="Threading模块常用方法"></a>Threading模块常用方法</h5><ol><li>threading.Lock()</li></ol><p>如果多个线程共同对某个数据修改，则可能出现不可预料的结果，为了保证数据的正确性，需要对多个线程进行同步。</p><p>使用Thread对象的<code>Lock</code>和<code>RLock</code>可以实现简单的线程同步，这两个对象都有<code>acquire</code>方法和<code>release</code>方法，对于那些需要每次只允许一个线程操作的数据，可以将其放到<code>acquire</code>和<code>release</code>方法之间。</p><p>多个线程同时操作一个变量可能会把内容给改乱了</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><br><span class="hljs-keyword">import</span> time, threading<br><br><span class="hljs-comment"># 假定这是你的银行存款:</span><br>balance = <span class="hljs-number">0</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">change_it</span><span class="hljs-params">(n)</span>:</span><br>    <span class="hljs-comment"># 先存后取，结果应该为0:</span><br>    <span class="hljs-keyword">global</span> balance<br>    balance = balance + n<br>    balance = balance - n<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_thread</span><span class="hljs-params">(n)</span>:</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1000000</span>):<br>        change_it(n)<br><br><br>t1 = threading.Thread(target=run_thread, args=(<span class="hljs-number">5</span>,))<br>t2 = threading.Thread(target=run_thread, args=(<span class="hljs-number">8</span>,))<br>t1.start()<br>t2.start()<br>t1.join()<br>t2.join()<br>print(balance)<br></code></pre></td></tr></table></figure><p>上述代码中首先定义了一个共享变量<strong>balance</strong>，初始值为0，并且启动两个线程，先存后取，理论上结果应该为0。但是，由于线程的调度是由操作系统决定的，当<strong>t1</strong>,<strong>t2</strong>交替执行时，只要循环次数足够多，<strong>balance</strong>的结果就不一定是0了。</p><p>如果要确保balance计算争取，就要给<code>change_it()</code>上一把锁，当某个线程开始执行<code>change_it()</code>时，由于该进程获得了锁，因此其他线程不能同时执行<code>change_it()</code>，只能等待，直到锁被释放后，获得该锁以后才能改。</p><p>由于锁只有一个，无论多少线程，同一时刻最多只有一个线程持有该锁，所以，不会造成修改的冲突。</p><p>创建一个锁就是<code>threading.Lock()</code>来实现</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><br><span class="hljs-keyword">import</span> time, threading<br><br>balance = <span class="hljs-number">0</span><br>lock = threading.Lock()<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">change_it</span><span class="hljs-params">(n)</span>:</span><br>    <span class="hljs-comment"># 先存后取，结果应该为0:</span><br>    <span class="hljs-keyword">global</span> balance<br>    balance = balance + n<br>    balance = balance - n<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_thread</span><span class="hljs-params">(n)</span>:</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1000000</span>):<br>        <span class="hljs-comment"># 先要获取锁:</span><br>        lock.acquire()<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 放心地改吧:</span><br>            change_it(n)<br>        <span class="hljs-keyword">finally</span>:<br>            <span class="hljs-comment"># 改完了一定要释放锁:</span><br>            lock.release()<br><br><br>t1 = threading.Thread(target=run_thread, args=(<span class="hljs-number">5</span>,))<br>t2 = threading.Thread(target=run_thread, args=(<span class="hljs-number">8</span>,))<br>t1.start()<br>t2.start()<br>t1.join()<br>t2.join()<br>print(balance)<br></code></pre></td></tr></table></figure><p>当多个线程同时执行<code>lock.acquire()</code>时，只有一个线程能成功地获取锁，然后继续执行代码，其他线程就继续等待直到获得锁为止。</p><p>获得锁的线程用完后一定要释放锁，否则那些苦苦等待锁的线程将永远等待下去，成为死线程。此处可以用try…finally来确保锁一定会被释放。</p><p>锁的好处就是确保了某段关键代码只能由一个线程从头到尾完整地执行，坏处当然也有很多：</p><ul><li>首先是阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了。</li><li>其次，由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁，导致多个线程全部挂起，既不能执行，也无法结束，只能靠操作系统强制终止。</li></ul><ol><li>threading.RLock()</li></ol><p>RLock允许在同一线程中被多次<code>acquire</code>。而Lock却不允许这种情况。注意：如果使用RLock，那么<code>acquire</code>和<code>release</code>必须成对出现，即调用了n次<code>acquire</code>，必须调用n次的<code>release</code>才能真正释放所占用的锁。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br>lock = threading.Lock() <br><span class="hljs-comment">#Lock对象</span><br>lock.acquire()<br>lock.acquire() <br><span class="hljs-comment">#产生了死琐。</span><br>lock.release()<br>lock.release()<br>  <br><span class="hljs-keyword">import</span> threading<br>rLock = threading.RLock() <br><span class="hljs-comment">#RLock对象</span><br>rLock.acquire()<br>rLock.acquire() <br><span class="hljs-comment">#在同一线程内，程序不会堵塞。</span><br>rLock.release()<br>rLock.release()<br></code></pre></td></tr></table></figure><ol><li>threading.Condition()</li></ol><p>可以把Condition理解为一把高级的锁，它提供了比Lock，RLock更高级的功能，允许我们能够控制复杂的线程同步问题。threading.Condition在内部维护一个锁对象(默认是RLock)，可以在创建Condition对象的时候把锁对象作为参数传入。Condition也提供了<code>acquire</code>，<code>release</code>方法，其含义与锁的<code>acquire</code>，<code>release</code>方法一致，其实它只是简单的调用内部锁对象的对应的方法而已。Condition还提供<code>wait</code>方法、<code>notify</code>方法、<code>notifyAll</code>方法(特别要注意：这些方法只有在占用锁(<code>acquire</code>)之后才能调用，否则将会报<code>RuntimeError</code>异常。)</p><blockquote><p><code>acquire()</code>/<code>release()</code>：获得/释放 Lock</p><p><code>wait([timeout])</code>：线程挂起，直到收到一个<code>notify</code>通知或者超时(可选的，浮点数，单位是秒s)才会被唤醒继续执行。<strong><code>wait()</code>必须在已获得Lock前提下才能调用，否则会触发RuntimeError。调用<code>wait()</code>释放Lock，直至该线程被<code>Notify()</code>、<code>NotifyAll()</code>或者超时线程又重新获得Lock</strong>。</p><p><code>notify(n=1)</code>通知其他线程，那些挂起的线程接到这个通知之后会开始运行，默认是通知一个正等待该condition的线程，最多唤醒n个等待的线程。</p><p><strong><code>notify()</code>必须在已获得Lock前提下才能调用，否则会触发RuntimeError。<code>notify()</code>不会主动释放Lock</strong></p><p><code>notifyAll()</code>如果wait状态线程比较多，notifyAll的作用就是通知所有线程(这个一般用的比较少)</p></blockquote><p>捉迷藏游戏：</p><p>假设该游戏有两个人玩，一个藏(Hider)，一个找(Seeker)。</p><p>游戏规则如下：</p><ul><li>游戏开始后，Seeker先把自己眼睛蒙上，蒙上眼睛后，就通知Hider；</li><li>Hider接收到通知后开始找地方将自己藏起来，藏好之后，再通知Seeker可以找了；</li><li>Seeker就收到通知后，就开始找Hider</li></ul><p>Hider和Seeker都是独立的个体，在程序中用两个独立的线程表示，在游戏过程中，两者之间的行为有一定的时序关系，我们可以通过Condition来控制这种关系。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Seeker</span><span class="hljs-params">(cond, name)</span>:</span><br>    time.sleep(<span class="hljs-number">2</span>)<br>    cond.acquire()<br>    print(<span class="hljs-string">'%s :我已经把眼睛蒙上了！'</span> % name)<br>    cond.notify()<br>    cond.wait()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):<br>        print(<span class="hljs-string">'%s is finding!!!'</span> % name)<br>        time.sleep(<span class="hljs-number">2</span>)<br>    cond.notify()<br>    cond.release()<br>    print(<span class="hljs-string">'%s :我赢了！'</span> % name)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Hider</span><span class="hljs-params">(cond, name)</span>:</span><br>    cond.acquire()<br>    cond.wait()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>):<br>        print(<span class="hljs-string">'%s is hiding!!!'</span> % name)<br>        time.sleep(<span class="hljs-number">3</span>)<br>    print(<span class="hljs-string">'%s :我已经藏好了，你快来找我吧！'</span> % name)<br>    cond.notify()<br>    cond.wait()<br>    cond.release()<br>    print(<span class="hljs-string">'%s :被你找到了，唉~^~!'</span> % name)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    cond = threading.Condition()<br>    seeker = threading.Thread(target=Seeker, args=(cond, <span class="hljs-string">'seeker'</span>))<br>    hider = threading.Thread(target=Hider, args=(cond, <span class="hljs-string">'hider'</span>))<br>    seeker.start()<br>    hider.start()<br></code></pre></td></tr></table></figure><ol><li>threading.Semaphore和BoundedSemaphore</li></ol><p>Semaphore：Semaphore在内部管理者一个计数器。调用<code>acquire()</code>会使这个计数器-1，<code>release()</code>则是+1(可以多次<code>release()</code>，所以计数器的值理论上可以无限)，计数器的值永远不会小于0，当计数器到0时，再调用<code>acquire()</code>就会阻塞，直到其他线程来调用<code>release()</code></p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(n)</span>:</span><br>    <span class="hljs-comment"># 获得信号量，信号量减一</span><br>    semaphore.acquire()<br>    time.sleep(<span class="hljs-number">1</span>)<br>    print(<span class="hljs-string">"run the thread: %s"</span> % n)<br><br>    <span class="hljs-comment"># 释放信号量，信号量加一</span><br>    semaphore.release()<br>    <span class="hljs-comment"># semaphore.release()    # 可以多次释放信号量，每次释放计数器+1</span><br>    <span class="hljs-comment"># semaphore.release()    # 可以多次释放信号量，每次释放计数器+1</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br><br>    num = <span class="hljs-number">0</span><br>    semaphore = threading.Semaphore(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 最多允许2个线程同时运行(即计数器值)；在多次释放信号量后，计数器值增加后每次可以运行的线程数也会增加</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">20</span>):<br>        t = threading.Thread(target=run, args=(i,))<br>        t.start()<br><br><span class="hljs-keyword">while</span> threading.active_count() != <span class="hljs-number">1</span>:<br>    <span class="hljs-keyword">pass</span>  <span class="hljs-comment"># print threading.active_count()</span><br><span class="hljs-keyword">else</span>:<br>    print(<span class="hljs-string">'----all threads done---'</span>)<br>    print(num)<br></code></pre></td></tr></table></figure><p>BoundedSemaphore：类似于Semaphore，不同在于BoundedSemaphore会检查内部计数器的值，并保证它不会大于初始值，如果超了，就引发一个ValueError。</p><p>多数情况下，semaphore用于守护限制(但不限于1)的资源，如果semaphore被<code>release()</code>过多次，这意味着存在bug</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(n)</span>:</span><br>    semaphore.acquire()<br>    time.sleep(<span class="hljs-number">1</span>)<br>    print(<span class="hljs-string">"run the thread: %s"</span> % n)<br>    semaphore.release()<br>    <span class="hljs-comment"># 如果再次释放信号量，信号量加一，这是超过限定的信号量数目，这时会报错ValueError: Semaphore released too many times</span><br>    <span class="hljs-comment"># semaphore.release()</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br><br>    num = <span class="hljs-number">0</span><br>    semaphore = threading.BoundedSemaphore(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 最多允许2个线程同时运行</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">20</span>):<br>        t = threading.Thread(target=run, args=(i,))<br>        t.start()<br><br><span class="hljs-keyword">while</span> threading.active_count() != <span class="hljs-number">1</span>:<br>    <span class="hljs-keyword">pass</span>  <span class="hljs-comment"># print threading.active_count()</span><br><span class="hljs-keyword">else</span>:<br>    print(<span class="hljs-string">'----all threads done---'</span>)<br>    print(num)<br></code></pre></td></tr></table></figure><ol><li>threading.Event</li></ol><p>时间处理的机制：全局定义了一个”Flag”，如果“Flag“值为False，那么当程序执行<code>event.wait</code>方法时就会阻塞；如果”Flag”值为True，那么执行<code>event.wait</code>方法时便不再阻塞。</p><ul><li>clear：将”Flag”设置为False</li><li>set：将”Flag”设置为True</li></ul><p>用threading.Event实现线程间通信，使用threading.Event可以使一个线程等待其他线程的通知，我们把这个Event传递到线程对象中。</p><p>Event默认内置了一个标志，初始值为False。一旦该线程通过<code>wait()</code>方法进入等待状态，知道另一个线程调用该Event的<code>set()</code>方法将内置标志设置为True时，该Event会通知所有等待状态的线程恢复运行。</p><p>通过Event来实现两个或多个线程间的交互，下面是一个红绿灯的例子，即启动一个线程做交通指挥灯，生成几个线程做车辆，车辆行驶按红灯停，绿灯行的规则。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time<br><span class="hljs-keyword">import</span> random<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">light</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> event.isSet():  <span class="hljs-comment"># 初始化evet的flag为真</span><br>        event.set()  <span class="hljs-comment"># wait就不阻塞 #绿灯状态</span><br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">if</span> count &lt; <span class="hljs-number">10</span>:<br>            print(<span class="hljs-string">'\033[42;1m---green light on---\033[0m'</span>)<br>        <span class="hljs-keyword">elif</span> count &lt; <span class="hljs-number">13</span>:<br>            print(<span class="hljs-string">'\033[43;1m---yellow light on---\033[0m'</span>)<br>        <span class="hljs-keyword">elif</span> count &lt; <span class="hljs-number">20</span>:<br>            <span class="hljs-keyword">if</span> event.isSet():<br>                event.clear()<br>            print(<span class="hljs-string">'\033[41;1m---red light on---\033[0m'</span>)<br>        <span class="hljs-keyword">else</span>:<br>            count = <span class="hljs-number">0</span><br>            event.set()  <span class="hljs-comment"># 打开绿灯</span><br>        time.sleep(<span class="hljs-number">1</span>)<br>        count += <span class="hljs-number">1</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">car</span><span class="hljs-params">(n)</span>:</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>        time.sleep(random.randrange(<span class="hljs-number">3</span>, <span class="hljs-number">10</span>))<br>        <span class="hljs-comment"># print(event.isSet())</span><br>        <span class="hljs-keyword">if</span> event.isSet():<br>            print(<span class="hljs-string">"car [%s] is running..."</span> % n)<br>        <span class="hljs-keyword">else</span>:<br>            print(<span class="hljs-string">'car [%s] is waiting for the red light...'</span> % n)<br>            event.wait()  <span class="hljs-comment"># 红灯状态下调用wait方法阻塞，汽车等待状态</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    car_list = [<span class="hljs-string">'BMW'</span>, <span class="hljs-string">'AUDI'</span>, <span class="hljs-string">'SANTANA'</span>]<br>    event = threading.Event()<br>    Light = threading.Thread(target=light)<br>    Light.start()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> car_list:<br>        t = threading.Thread(target=car, args=(i,))<br>        t.start()<br></code></pre></td></tr></table></figure><ol><li>threading.active_count()</li></ol><p>返回当前存活的线程对象数量；通过计算len(threading.enumerate())长度而来</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">()</span>:</span><br>    thread = threading.current_thread()<br>    print(<span class="hljs-string">'%s is running...'</span>% thread.getName())    <span class="hljs-comment">#返回线程名称</span><br>    time.sleep(<span class="hljs-number">10</span>)    <span class="hljs-comment">#休眠10S方便统计存活线程数量</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    <span class="hljs-comment">#print('The current number of threads is: %s' % threading.active_count())</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):<br>        print(<span class="hljs-string">'The current number of threads is: %s'</span> % threading.active_count())    <span class="hljs-comment">#返回当前存活线程数量</span><br>        thread_alive = threading.Thread(target=run, name=<span class="hljs-string">'Thread-***%s***'</span> % i)<br>        thread_alive.start()<br>    thread_alive.join()<br>    print(<span class="hljs-string">'\n%s thread is done...'</span>% threading.current_thread().getName())<br></code></pre></td></tr></table></figure><ol><li>threading.current_thread()</li></ol><p>返回当前线程对象</p><p>继承线程threading方法；通过help(threading.current_thread())查看</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(n)</span>:</span><br>    thread = threading.current_thread()<br>    thread.setName(<span class="hljs-string">'Thread-***%s***'</span> % n)  <span class="hljs-comment"># 自定义线程名称</span><br>    print(<span class="hljs-string">'-'</span> * <span class="hljs-number">30</span>)<br>    print(<span class="hljs-string">"Pid is :%s"</span> % thread.ident)  <span class="hljs-comment"># 返回线程pid</span><br>    <span class="hljs-comment"># print('ThreadName is :%s' % thread.name)  # 返回线程名称</span><br>    print(<span class="hljs-string">'ThreadName is :%s'</span> % thread.getName())  <span class="hljs-comment"># 返回线程名称</span><br>    time.sleep(<span class="hljs-number">2</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    <span class="hljs-comment"># print('The current number of threads is: %s' % threading.active_count())</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):<br>        <span class="hljs-comment"># print('The current number of threads is: %s' % threading.active_count())    #返回当前存活线程数量</span><br>        thread_alive = threading.Thread(target=run, args=(i,))<br>        thread_alive.start()<br>    thread_alive.join()<br>    print(<span class="hljs-string">'\n%s thread is done...'</span> % threading.current_thread().getName())<br></code></pre></td></tr></table></figure><ol><li>threading.enumerate()</li></ol><p>返回当前存在的所有线程对象的列表</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(n)</span>:</span><br>    thread = threading.current_thread()<br>    thread.setName(<span class="hljs-string">'Thread-***%s***'</span> % n)<br>    print(<span class="hljs-string">'-'</span> * <span class="hljs-number">30</span>)<br>    print(<span class="hljs-string">"Pid is :%s"</span> % thread.ident)  <span class="hljs-comment"># 返回线程pid</span><br>    <span class="hljs-comment"># print('ThreadName is :%s' % thread.name)  # 返回线程名称</span><br>    print(<span class="hljs-string">'ThreadName is :%s'</span> % threading.enumerate())  <span class="hljs-comment"># 返回所有线程对象列表</span><br>    time.sleep(<span class="hljs-number">2</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    <span class="hljs-comment"># print('The current number of threads is: %s' % threading.active_count())</span><br>    threading.main_thread().setName(<span class="hljs-string">'Chengd---python'</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):<br>        <span class="hljs-comment"># print('The current number of threads is: %s' % threading.active_count())    #返回当前存活线程数量</span><br>        thread_alive = threading.Thread(target=run, args=(i,))<br>        thread_alive.start()<br>    thread_alive.join()<br>    print(<span class="hljs-string">'\n%s thread is done...'</span> % threading.current_thread().getName())<br></code></pre></td></tr></table></figure><ol><li>threading.get_ident()</li></ol><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(n)</span>:</span><br>    print(<span class="hljs-string">'-'</span> * <span class="hljs-number">30</span>)<br>    print(<span class="hljs-string">"Pid is :%s"</span> % threading.get_ident())  <span class="hljs-comment"># 返回线程pid</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    threading.main_thread().setName(<span class="hljs-string">'Chengd---python'</span>)  <span class="hljs-comment"># 自定义线程名</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):<br>        thread_alive = threading.Thread(target=run, args=(i,))<br>        thread_alive.start()<br>    thread_alive.join()<br>    print(<span class="hljs-string">'\n%s thread is done...'</span> % threading.current_thread().getName())  <span class="hljs-comment"># 获取线程名</span><br></code></pre></td></tr></table></figure><ol><li>threading.main_thread()</li></ol><p>返回主线程对象，类似threading.current_thread()；只不过一个是返回当前线程对象，一个是返回主线程对象。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(n)</span>:</span><br>    print(<span class="hljs-string">'-'</span> * <span class="hljs-number">30</span>)<br>    print(<span class="hljs-string">"Now Pid is :%s"</span> % threading.current_thread().ident)  <span class="hljs-comment"># 返回当前线程pid</span><br>    print(<span class="hljs-string">"Main Pid is :%s"</span> % threading.main_thread().ident)  <span class="hljs-comment"># 返回主线程pid</span><br>    print(<span class="hljs-string">'Now thread is %s...'</span> % threading.current_thread().getName())  <span class="hljs-comment"># 获取当前线程名</span><br>    print(<span class="hljs-string">'Main thread is %s...'</span> % threading.main_thread().getName())  <span class="hljs-comment"># 获取主线程线程名</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    threading.main_thread().setName(<span class="hljs-string">'Chengd---python'</span>)  <span class="hljs-comment"># 自定义线程名</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):<br>        thread_alive = threading.Thread(target=run, args=(i,))<br>        thread_alive.start()<br>        time.sleep(<span class="hljs-number">2</span>)<br>    thread_alive.join()<br></code></pre></td></tr></table></figure><h4 id="Threading模块的Thread类方法"><a href="#Threading模块的Thread类方法" class="headerlink" title="Threading模块的Thread类方法"></a>Threading模块的Thread类方法</h4><div class="table-container"><table><thead><tr><th style="text-align:center">类方法</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">threading.currentThread()</td><td>返回当前的线程变量</td></tr><tr><td style="text-align:center">threading.enumerate()</td><td>返回一个包含正在运行的线程的list，正在运行指线程启动后、结束前，不包括启动前和终止后的线程</td></tr><tr><td style="text-align:center">threading.activeCount()</td><td>返回正在运行的线程数量，与len(threading.enumerate())有相同的结果</td></tr></tbody></table></div><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-comment"># 继承类threading.Thread</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(threading.Thread)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, n)</span>:</span><br>        <span class="hljs-comment"># 这里要继承构造函数</span><br>        super(MyThread, self).__init__()<br>        <span class="hljs-comment"># 可以定义自己的实例变量</span><br>        self.n = n<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span><br>        print(<span class="hljs-string">'running task'</span>, self.n)<br>        time.sleep(<span class="hljs-number">2</span>)<br><br><br>t1 = MyThread(<span class="hljs-string">'t1'</span>)<br>t2 = MyThread(<span class="hljs-string">'t2'</span>)<br><br>t1.start()<br>t2.start()<br></code></pre></td></tr></table></figure><p>这样就实现了通过继承父类的方式使用多线程，这里注意的几个点：</p><ul><li>继承类之后还要继承构造函数</li><li>这里的<code>run</code>函数时重写的，所以说<code>t1.start()</code>之后才会自动调用<code>run</code>函数</li><li>线程是通过start()函数激活，而不是对象建立时激活的！</li></ul><p>循环创建多个进程</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-comment"># 继承类threading.Thread</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(threading.Thread)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, n)</span>:</span><br>        <span class="hljs-comment"># 这里要继承构造函数</span><br>        super(MyThread, self).__init__()<br>        <span class="hljs-comment"># 可以定义自己的实例变量</span><br>        self.n = n<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span><br>        print(<span class="hljs-string">'running task'</span>, self.n)<br>        time.sleep(<span class="hljs-number">2</span>)<br><br><br><span class="hljs-comment"># t1 = MyThread('t1')</span><br><span class="hljs-comment"># t2 = MyThread('t2')</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">50</span>):<br>    t = MyThread(i)<br>    t.start()<br><br><span class="hljs-comment"># t1.start()</span><br><span class="hljs-comment"># t2.start()</span><br></code></pre></td></tr></table></figure><h4 id="计算这些线程执行所花费的时间join"><a href="#计算这些线程执行所花费的时间join" class="headerlink" title="计算这些线程执行所花费的时间join()"></a>计算这些线程执行所花费的时间<code>join()</code></h4><p>能够使主线程等待子线程的执行完毕才会继续主线程</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-comment"># 继承类threading.Thread</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(threading.Thread)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, n)</span>:</span><br>        <span class="hljs-comment"># 这里要继承构造函数</span><br>        super(MyThread, self).__init__()<br>        <span class="hljs-comment"># 可以定义自己的实例变量</span><br>        self.n = n<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span><br>        print(<span class="hljs-string">'running task'</span>, self.n)<br>        time.sleep(<span class="hljs-number">2</span>)<br><br><br><span class="hljs-comment"># 得到开始时间</span><br>start_time = time.time()<br><span class="hljs-comment"># 声明空列表</span><br>threads = []<br><br><span class="hljs-comment"># 循环开启50线程</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">50</span>):<br>    t = MyThread(i)<br>    t.start()<br>    <span class="hljs-comment"># 线程实例放入列表中</span><br>    threads.append(t)<br><br><span class="hljs-comment"># 对线程实例所在列表再循环</span><br><span class="hljs-keyword">for</span> res <span class="hljs-keyword">in</span> threads:<br>    <span class="hljs-comment"># 对每一个实例使用jion()方法</span><br>    res.join()<br><span class="hljs-comment"># 获得结束时间</span><br>end_time = time.time()<br><span class="hljs-comment"># 计算花费时间</span><br>spend_time = end_time - start_time<br><span class="hljs-comment"># 打印花费时间</span><br>print(spend_time)<br></code></pre></td></tr></table></figure><p>这里需要注意的点就是<code>join()</code>方法不能在线程启动之后就使用，这样的话50个线程就会变成串行，必须要等50个线程全部启动之后才能使用<code>join()</code>方法，这里就用到了一个小技巧新建了一个空列表，再将50个线程实例放进去，这样后面就可以实现对这50个线程使用<code>join()</code>方法了。</p><h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><p>多线程的优势在于可以同时运行多个任务(至少感觉起来是这样)。但是当线程需要共享数据时，可能存在数据不同步的问题。</p><p>使用Threading对象的Lock和Rlock可以实现简单的线程同步，这两个对象都有<code>acquire</code>方法和<code>release</code>方法，对于那些需要每次只允许一个线程操作的数据，可以将其操作放到acquire和release方法之间。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time<br><br><span class="hljs-comment"># 创建锁</span><br>threadLock = threading.Lock()<br><span class="hljs-comment"># 创建线程列表</span><br>threads = []<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myThread</span><span class="hljs-params">(threading.Thread)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, threadID, name, counter)</span>:</span><br>        threading.Thread.__init__(self)<br>        self.threadID = threadID<br>        self.name = name<br>        self.counter = counter<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span><br>        print(<span class="hljs-string">"Thread Start: "</span> + self.name)<br>        <span class="hljs-comment"># 获取锁，同步线程</span><br>        threadLock.acquire()<br>        print_time(self.name, self.counter, <span class="hljs-number">3</span>)<br>        <span class="hljs-comment"># 释放锁，开启下一个线程</span><br>        threadLock.release()<br>        print(<span class="hljs-string">"Thread Exit: "</span> + self.name)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_time</span><span class="hljs-params">(threadName, delay, counter)</span>:</span><br>    <span class="hljs-keyword">while</span> counter:<br>        time.sleep(delay)<br>        print(<span class="hljs-string">"&#123;&#125;: &#123;&#125;"</span>.format(threadName, time.ctime()))<br>        counter -= <span class="hljs-number">1</span><br><br><br><span class="hljs-comment"># 创建线程</span><br>thread1 = myThread(<span class="hljs-number">1001</span>, <span class="hljs-string">"Thread-1"</span>, <span class="hljs-number">1</span>)<br>thread2 = myThread(<span class="hljs-number">1002</span>, <span class="hljs-string">"Thread-2"</span>, <span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 开启线程</span><br>thread1.start()<br>thread2.start()<br><br><span class="hljs-comment"># 添加线程列表</span><br>threads.append(thread1)<br>threads.append(thread2)<br><br><span class="hljs-comment"># 等待所有线程完成</span><br><span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads:<br>    t.join()<br>print(<span class="hljs-string">"exit"</span>)<br></code></pre></td></tr></table></figure><h5 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h5><p>同一个进程下的线程数据之间可以共享，多线程中GIL锁，一个时刻只有一线程在运行，所以说就是有很多线程在修改这些共享数据。</p><p>当开启了很多个线程，当这些线程一起修改全局变量的时候，最后得出的结果可能跟期望的不太一样。</p><p>Python提供了另一把锁，给用户的锁，叫做<strong>线程锁</strong>，可以在多个线程操作共享数据时更加有规律，来防止操作数据失误的情况出现。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-comment"># 获取锁</span><br>    lock.acquire()<br>    <span class="hljs-comment"># 声明全局变量num</span><br>    <span class="hljs-keyword">global</span> num<br>    <span class="hljs-comment"># num+=1</span><br>    num += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 释放锁</span><br>    lock.release()<br><br><br><span class="hljs-comment"># 生成线程锁实例</span><br>lock = threading.Lock()<br>num = <span class="hljs-number">0</span><br><br><span class="hljs-comment"># 开启1000个线程</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1000</span>):<br>    t = threading.Thread(target=run)<br>    t.start()<br><br>print(<span class="hljs-string">"-----all thread has finshed"</span>)<br>print(<span class="hljs-string">"num:"</span>, num)<br></code></pre></td></tr></table></figure><p>注意获取锁与释放锁之间的这一段锁操作的数据量不是很大，如果数据量很大，需要的时间很多，那么程序就会变成串行。</p><h5 id="递归锁"><a href="#递归锁" class="headerlink" title="递归锁"></a>递归锁</h5><p>在我们分出一个线程，使用线程锁之后里面再调用别的函数，然后调用的这个函数中再使用线程锁的话就不能在使用Lock()实例了， 不然就会出现死循环错误，这是因为一把锁对应一个钥匙，锁里面再加一把锁就会导致程序分不清哪把钥匙开哪把锁，导致程序一直在锁中出不来，如下：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run1</span><span class="hljs-params">()</span>:</span><br>    print(<span class="hljs-string">"grab the first part data"</span>)<br>    <span class="hljs-comment"># 获取锁</span><br>    lock.acquire()<br>    <span class="hljs-keyword">global</span> num<br>    num += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 释放锁</span><br>    lock.release()<br>    <span class="hljs-keyword">return</span> num<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run2</span><span class="hljs-params">()</span>:</span><br>    print(<span class="hljs-string">"grab the second part data"</span>)<br>    <span class="hljs-comment"># 获取锁</span><br>    lock.acquire()<br>    <span class="hljs-keyword">global</span> num2<br>    num2 += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 释放锁</span><br>    lock.release()<br>    <span class="hljs-keyword">return</span> num2<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run3</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-comment"># 获取锁</span><br>    lock.acquire()<br>    <span class="hljs-comment"># 去跑run1</span><br>    res = run1()<br>    print(<span class="hljs-string">'--------between run1 and run2-----'</span>)<br>    <span class="hljs-comment"># 去跑run2</span><br>    res2 = run2()<br>    <span class="hljs-comment"># 释放锁</span><br>    lock.release()<br>    print(res, res2)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    <span class="hljs-comment"># 初始化两个为0的变量</span><br>    num, num2 = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 生成lock实例</span><br>    lock = threading.Lock()<br>    <span class="hljs-comment"># 开始10个线程</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):<br>        <span class="hljs-comment"># 线程跑的是run3</span><br>        t = threading.Thread(target=run3)<br>        t.start()<br><br><span class="hljs-comment"># 判读是否有多个线程，有多个就继续打印，只剩一个说明子线程都执行完了，只剩主线程了，然后跳出循环程序结束</span><br><span class="hljs-comment"># 可以用之前学到的join()方法来实现一样的效果</span><br><span class="hljs-keyword">while</span> threading.active_count() != <span class="hljs-number">1</span>:<br>    print(threading.active_count())<br><span class="hljs-keyword">else</span>:<br>    print(<span class="hljs-string">'----all threads done---'</span>)<br>    print(num, num2)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Iimage3.png" width="50%"></p><p>可以看到一直在打印线程数11，说明一直有11个线程在活跃，说明分出的10个线程一直在运行不结束，这个时候就不能使用<code>Lock()</code>了，而是使用<code>RLock()</code></p><p>修改后结果：</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run1</span><span class="hljs-params">()</span>:</span><br>    print(<span class="hljs-string">"grab the first part data"</span>)<br>    <span class="hljs-comment"># 获取锁</span><br>    lock.acquire()<br>    <span class="hljs-keyword">global</span> num<br>    num += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 释放锁</span><br>    lock.release()<br>    <span class="hljs-keyword">return</span> num<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run2</span><span class="hljs-params">()</span>:</span><br>    print(<span class="hljs-string">"grab the second part data"</span>)<br>    <span class="hljs-comment"># 获取锁</span><br>    lock.acquire()<br>    <span class="hljs-keyword">global</span> num2<br>    num2 += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 释放锁</span><br>    lock.release()<br>    <span class="hljs-keyword">return</span> num2<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run3</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-comment"># 获取锁</span><br>    lock.acquire()<br>    <span class="hljs-comment"># 去跑run1</span><br>    res = run1()<br>    print(<span class="hljs-string">'--------between run1 and run2-----'</span>)<br>    <span class="hljs-comment"># 去跑run2</span><br>    res2 = run2()<br>    <span class="hljs-comment"># 释放锁</span><br>    lock.release()<br>    print(res, res2)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    <span class="hljs-comment"># 初始化两个为0的变量</span><br>    num, num2 = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 生成lock实例</span><br>    lock = threading.RLock()<br>    <span class="hljs-comment"># 开始10个线程</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):<br>        <span class="hljs-comment"># 线程跑的是run3</span><br>        t = threading.Thread(target=run3)<br>        t.start()<br><br><span class="hljs-comment"># 判读是否有多个线程，有多个就继续打印，只剩一个说明子线程都执行完了，只剩主线程了，然后跳出循环程序结束</span><br><span class="hljs-comment"># 可以用之前学到的join()方法来实现一样的效果</span><br><span class="hljs-keyword">while</span> threading.active_count() != <span class="hljs-number">1</span>:<br>    print(threading.active_count())<br><span class="hljs-keyword">else</span>:<br>    print(<span class="hljs-string">'----all threads done---'</span>)<br>    print(num, num2)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Iimage4.png" width="50%"></p><h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><p>信号量的用法和线程锁非常相似。</p><p>线程锁锁住一个线程在运行和修改数据，而信号量可以自己控制同一时刻运行几个线程和几个线程修改数据，也就是设置最大同时运行的线程数。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(n)</span>:</span><br>    <span class="hljs-comment"># 获取信号量</span><br>    semaphore.acquire()<br>    print(<span class="hljs-string">'task %s is running'</span> % n)<br>    <span class="hljs-comment"># 暂停1s方便看出一次运行几个线程</span><br>    time.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 释放信号量</span><br>    semaphore.release()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    <span class="hljs-comment"># 生成信号量实例并设置信号量为5</span><br>    semaphore = threading.BoundedSemaphore(<span class="hljs-number">5</span>)<br>    <span class="hljs-comment"># 开启50个线程</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">50</span>):<br>        t = threading.Thread(target=run, args=(i,))<br>        t.start()<br><br><span class="hljs-comment"># 线程没有运行完就不退出</span><br><span class="hljs-keyword">while</span> threading.active_count() != <span class="hljs-number">1</span>:<br>    <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">else</span>:<br>    print(<span class="hljs-string">'----all threads done---'</span>)<br></code></pre></td></tr></table></figure><p>虽然我们看到的是一次执行五个线程，但并不是五个一组五个一组分组执行的，因为这五个线程同时完成，所以我们看不出来，但是其中的过程是执行完一个线程放进去一个线程，加入这五个中有两个先完成，那么就会立刻再放进去两个，也就是说这五个线程之间不会互相等待，这个设置的信号量5不是按5来分组，而是同时运行的线程最大数，可以写多个执行时间不同的函数然后一次执行几个来证明这一点。</p><h4 id="区分主-子线程"><a href="#区分主-子线程" class="headerlink" title="区分主/子线程"></a>区分主/子线程</h4><p>子线程可能比较明白的看出来，而主线程有的时候是看不到的，主线程就是程序本身，但是跟子线程还是有区分的，而threading module提供给我们方法让我们可以知道当前线程是主线程还是子线程。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">threading.current_thread() <span class="hljs-comment"># 返回当前线程类型</span><br>threading.active_count()<span class="hljs-comment"># 返回当前活跃线程数</span><br></code></pre></td></tr></table></figure><p>实例</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-comment"># 继承类threading.Thread</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(threading.Thread)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, n)</span>:</span><br>        <span class="hljs-comment"># 这里要继承构造函数</span><br>        super(MyThread, self).__init__()<br>        <span class="hljs-comment"># 可以定义自己的实例变量</span><br>        self.n = n<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-comment"># 打印当前线程类型</span><br>        print(<span class="hljs-string">'running task'</span>, self.n, threading.current_thread())<br>        time.sleep(<span class="hljs-number">2</span>)<br><br><br><span class="hljs-comment"># 得到开始时间</span><br>start_time = time.time()<br><span class="hljs-comment"># 声明空列表</span><br>threads = []<br><br><span class="hljs-comment"># 循环开启50线程</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">50</span>):<br>    t = MyThread(i)<br>    t.start()<br>    <span class="hljs-comment"># 线程实例放入列表中</span><br>    threads.append(t)<br><span class="hljs-comment"># 打印当前活跃的线程数</span><br>print(threading.active_count())<br><span class="hljs-comment"># 对线程实例所在列表再循环</span><br><span class="hljs-keyword">for</span> res <span class="hljs-keyword">in</span> threads:<br>    <span class="hljs-comment"># 对每一个实例使用jion()方法</span><br>    res.join()<br><span class="hljs-comment"># 获得结束时间</span><br>end_time = time.time()<br><span class="hljs-comment"># 计算花费时间</span><br>spend_time = end_time - start_time<br><span class="hljs-comment"># 打印当前线程类型</span><br>print(<span class="hljs-string">'all thread has finished'</span>, threading.current_thread())<br><span class="hljs-comment"># 打印花费时间</span><br>print(spend_time)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Iimage1.png" width="50%"></p><p>可以看到在开启50个子线程后活跃线程数为51，这些线程的类型都为Thread(子线程)，而最后的则为Main Thread(主线程)</p><p>这样，我们就可以知道当前线程是主线程还是子线程了，甚至还可以知道当前活跃的线程数。</p><h4 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h4><p>顾名思义，守护进程就是用来守护主线程的，一旦主线程没了，那这些守护线程也就没有存在的意义了。</p><p>threading module提供<code>setDaemon(True)</code>来使子线程变为守护线程，守护线程就是一旦主线程结束了，即使子线程还在运行，也会跟着一起结束。</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-comment"># 继承类threading.Thread</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(threading.Thread)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, n)</span>:</span><br>        <span class="hljs-comment"># 这里要继承构造函数</span><br>        super(MyThread, self).__init__()<br>        <span class="hljs-comment"># 可以定义自己的实例变量</span><br>        self.n = n<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-comment"># 打印当前线程类型</span><br>        print(<span class="hljs-string">'running task'</span>, self.n, threading.current_thread())<br>        time.sleep(<span class="hljs-number">2</span>)<br>        <span class="hljs-comment"># 线程结束打印一句话</span><br>        print(<span class="hljs-string">'done'</span>)<br><br><br><span class="hljs-comment"># 得到开始时间</span><br>start_time = time.time()<br><br><span class="hljs-comment"># 循环开启50线程</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">50</span>):<br>    t = MyThread(i)<br>    <span class="hljs-comment"># 设置这个线程为守护线程</span><br>    t.setDaemon(<span class="hljs-literal">True</span>)<br>    t.start()<br><span class="hljs-comment"># 打印当前活跃的线程数</span><br>print(threading.active_count())<br><br><span class="hljs-comment"># 获得结束时间</span><br>end_time = time.time()<br><span class="hljs-comment"># 计算花费时间</span><br>spend_time = end_time - start_time<br><span class="hljs-comment"># 打印当前线程类型</span><br>print(<span class="hljs-string">'all thread has finished'</span>, threading.current_thread())<br><span class="hljs-comment"># 打印花费时间</span><br>print(spend_time)<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Iimage2.png" width="50%"></p><p>可以看到，直到程序结束都没有执行每一个线程中的打印<code>done</code>的这段代码，这是因为子线程变成了守护线程，一旦主线程结束，这些守护线程也会跟着结束。</p><p>这里也有注意的地方，就是设置子线程为守护线程时必须要在子线程开始之前也就是<code>start()</code>之前。</p><p>程序会等待主线程的完成，而不会等待守护线程</p><h2 id="queue模块-线程间通信"><a href="#queue模块-线程间通信" class="headerlink" title="queue模块(线程间通信)"></a>queue模块(线程间通信)</h2><p>Python的Queue模块中提供了同步的、线程安全的队列类，包括：</p><ul><li>FIFO队列Queue</li><li>LIFO队列LifoQueue</li><li>优先级队列PriorityQueue</li></ul><h4 id="Queue模块中常用方法"><a href="#Queue模块中常用方法" class="headerlink" title="Queue模块中常用方法"></a>Queue模块中常用方法</h4><div class="table-container"><table><thead><tr><th style="text-align:center">对象</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">Queue(maxsize=0)</td><td style="text-align:left">创建一个先入先出队列。如果给定最大值，则在队列没有空间时阻塞；否则(没有指定最大值)，为无限队列</td></tr><tr><td style="text-align:center">LifoQueue(maxsize=0)</td><td style="text-align:left">创建一个后入先出队列。如果给定最大值，则在队列没有空间时阻塞；否则(没有指定最大值)，为无限队列</td></tr><tr><td style="text-align:center">PriorityQueue(maxsize=0)</td><td style="text-align:left">创建一个优先级队列。如果给定最大值，则在队列没有空间时阻塞，否则(没有指定最大值)，为无限队列</td></tr><tr><td style="text-align:center">Empty</td><td style="text-align:left">当对空队列调用get*()方法时抛出异常</td></tr><tr><td style="text-align:center">Full</td><td style="text-align:left">当对已满的队列调用put*()方法时抛出异常</td></tr><tr><td style="text-align:center">qsize()</td><td style="text-align:left">返回队列大小</td></tr><tr><td style="text-align:center">empty()</td><td style="text-align:left">如果队列为空，则返回True；否则，返回False</td></tr><tr><td style="text-align:center">full()</td><td style="text-align:left">如果队列为满，则返回True；否则，返回False</td></tr><tr><td style="text-align:center">put(item,block=True,timeout=None)</td><td style="text-align:left">将item放入队列。如果block为True(默认)且timeout为None，则在有可用空间之前阻塞；如果timeout为正值，则最多阻塞timeout秒；如果block为False，则抛出Empty异常</td></tr><tr><td style="text-align:center">put_nowait(item)</td><td style="text-align:left">相当于put(item,False)</td></tr><tr><td style="text-align:center">get(blcok=True,timeout=None)</td><td style="text-align:left">获取队列。如果给定了block(非0)，则一直阻塞到有可用的元素为止</td></tr><tr><td style="text-align:center">get_nowait()</td><td style="text-align:left">相当于get(False)</td></tr><tr><td style="text-align:center">join()</td><td style="text-align:left">在队列中所有元素执行完毕并调用上面的task_done()信号之前，保持阻塞</td></tr></tbody></table></div><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> randint<br><span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> ctime, sleep<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mythread</span><span class="hljs-params">(threading.Thread)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, func, name=<span class="hljs-string">''</span>)</span>:</span><br>        threading.Thread.__init__(self)<br>        self.name = name<br>        self.func = func<br><br>    <span class="hljs-string">''' rewrite run() '''</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span><br>        self.func()<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, q, loops)</span>:</span><br>        self.q = q<br>        self.loops = loops<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">WriteQueue</span><span class="hljs-params">(self)</span>:</span><br>        self.q.put(<span class="hljs-string">'xxx'</span>, <span class="hljs-number">1</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ReadQueue</span><span class="hljs-params">(self)</span>:</span><br>        value = self.q.get(<span class="hljs-number">1</span>)<br>        print(<span class="hljs-string">'value: '</span> + str(value))<br>        <span class="hljs-keyword">return</span> value<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Writer</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(self.loops):<br>                self.WriteQueue()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Reader</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(self.loops):<br>                aaa = self.ReadQueue()<br>                print(<span class="hljs-string">"aaa = "</span> + str(aaa))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span><br>    que = Queue(<span class="hljs-number">32</span>)<br>    nloops = randint(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>)<br>    q = MyQueue(que, nloops)<br><br>    t1 = Mythread(q.Writer, q.Writer.__name__)<br><br>    t2 = Mythread(q.Reader, q.Reader.__name__)<br><br>    t1.start()<br>    t2.start()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    main()<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matplotlib基础</title>
      <link href="/2019/08/03/Matplotlib%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/08/03/Matplotlib%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p><strong>本文主要介绍了以下内容:</strong></p><p>Matplotlib的一些基础画图命令</p><a id="more"></a><h3 id="标准头文件"><a href="#标准头文件" class="headerlink" title="标准头文件"></a>标准头文件</h3><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>plt.rcParams[<span class="hljs-string">'font.sans-serif'</span>] = [<span class="hljs-string">'STHeiti'</span>]  <span class="hljs-comment"># 用来正常显示中文标签</span><br>plt.rcParams[<span class="hljs-string">'axes.unicode_minus'</span>] = <span class="hljs-literal">False</span>  <span class="hljs-comment"># 用来正常显示负号</span><br><br>plt.show()<br></code></pre></td></tr></table></figure><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h5 id="figure-函数，创建图表"><a href="#figure-函数，创建图表" class="headerlink" title="figure()函数，创建图表"></a><code>figure()</code>函数，创建图表</h5><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> matplotlib.patches <span class="hljs-keyword">import</span> Polygon<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>plt.figure(<span class="hljs-number">1</span>)   <span class="hljs-comment"># 创建图表1</span><br>plt.figure(<span class="hljs-number">2</span>)   <span class="hljs-comment"># 创建图表2</span><br><br>plt.show()<br></code></pre></td></tr></table></figure><h5 id="subplot-创建子图"><a href="#subplot-创建子图" class="headerlink" title="subplot()创建子图"></a><code>subplot()</code>创建子图</h5><p>子图序号排序顺序：从左到右，从上到下，逐次增加1</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> matplotlib.patches <span class="hljs-keyword">import</span> Polygon<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>plt.figure(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 创建图表1</span><br>plt.subplot(<span class="hljs-number">221</span>)  <span class="hljs-comment"># 创建2*2的图表矩阵，绘制的子图为矩阵中的1序号</span><br>plt.subplot(<span class="hljs-number">222</span>)  <span class="hljs-comment"># 创建2*2的图表矩阵，绘制的子图为矩阵中的2序号</span><br>plt.subplot(<span class="hljs-number">223</span>)  <span class="hljs-comment"># 创建2*2的图表矩阵，绘制的子图为矩阵中的3序号</span><br>plt.subplot(<span class="hljs-number">224</span>)  <span class="hljs-comment"># 创建2*2的图表矩阵，绘制的子图为矩阵中的4序号</span><br><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Image1.png" width="50%"></p><h5 id="在多个表中创建子图"><a href="#在多个表中创建子图" class="headerlink" title="在多个表中创建子图"></a>在多个表中创建子图</h5><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> matplotlib.patches <span class="hljs-keyword">import</span> Polygon<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>plt.figure(<span class="hljs-number">1</span>, dpi=<span class="hljs-number">50</span>)  <span class="hljs-comment"># 创建图表1</span><br>plt.subplot(<span class="hljs-number">111</span>)  <span class="hljs-comment"># 在图表1中创建子图</span><br>plt.figure(<span class="hljs-number">2</span>, dpi=<span class="hljs-number">50</span>)  <span class="hljs-comment"># 创建图表2</span><br>plt.subplot(<span class="hljs-number">221</span>)  <span class="hljs-comment"># 在图表2中创建子图</span><br>plt.show()  <span class="hljs-comment"># 显示所有图表</span><br></code></pre></td></tr></table></figure><h5 id="plot-函数，画函数图像"><a href="#plot-函数，画函数图像" class="headerlink" title="plot()函数，画函数图像"></a><code>plot()</code>函数，画函数图像</h5><p><code>splot(x,y)</code>中<code>x</code>表示横坐标，<code>y</code>表示纵坐标</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>plt.figure(<span class="hljs-number">1</span>, dpi=<span class="hljs-number">100</span>)<br><span class="hljs-comment"># x轴的定义域为 -3.14~3.14，中间间隔100个元素</span><br>x = np.linspace(-np.pi, np.pi, <span class="hljs-number">100</span>) <br>plt.plot(x, np.sin(x))<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Image2.png" width="50%"></p><h5 id="sca-函数，选择子图"><a href="#sca-函数，选择子图" class="headerlink" title="sca()函数，选择子图"></a><code>sca()</code>函数，选择子图</h5><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>plt.figure(<span class="hljs-number">1</span>, dpi=<span class="hljs-number">100</span>)<br>ax1 = plt.subplot(<span class="hljs-number">211</span>)  <span class="hljs-comment"># 创建子图 ax1</span><br>ax2 = plt.subplot(<span class="hljs-number">212</span>)  <span class="hljs-comment"># 创建子图 ax2</span><br><br>x = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>)  <span class="hljs-comment"># x轴定义域</span><br><br>plt.sca(ax1)  <span class="hljs-comment"># 选择子图ax1</span><br>plt.plot(x, np.exp(x))  <span class="hljs-comment"># 在子图ax1 中绘制函数 exp(x)</span><br><br>plt.sca(ax2)  <span class="hljs-comment"># 选择子图ax2</span><br>plt.plot(x, np.sin(x))  <span class="hljs-comment"># 在子图ax2 中绘制函数 sin(x)</span><br><br>plt.show()  <span class="hljs-comment"># 展示所有图表</span><br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Image3.png" width="50%"></p><h5 id="在一张图中画多条曲线"><a href="#在一张图中画多条曲线" class="headerlink" title="在一张图中画多条曲线"></a>在一张图中画多条曲线</h5><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pylab <span class="hljs-keyword">as</span> plt<br><br>x = np.linspace(-np.pi * <span class="hljs-number">2</span>, np.pi * <span class="hljs-number">2</span>, <span class="hljs-number">100</span>)  <span class="hljs-comment"># 定义域为： -2pi 到 2pi</span><br>plt.figure(<span class="hljs-number">1</span>, dpi=<span class="hljs-number">100</span>)  <span class="hljs-comment"># 创建图表1</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>):  <span class="hljs-comment"># 画四条线</span><br>    plt.plot(x, np.sin(x / i))<br><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Image4.png" width="50%"></p><h3 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h3><p>使用<code>plot()</code>函数</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>x = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>y = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]<br><br>x1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>y1 = [<span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">12</span>, <span class="hljs-number">14</span>]<br><br>plt.plot(x, y, label=<span class="hljs-string">'line one'</span>)<br>plt.plot(x1, y1, label=<span class="hljs-string">'line two'</span>)<br><br>plt.xlabel(<span class="hljs-string">'x_data'</span>)<br>plt.ylabel(<span class="hljs-string">'y_data'</span>)<br>plt.title(<span class="hljs-string">'title is here!'</span>)<br><br>plt.legend(loc=<span class="hljs-number">0</span>)<br><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Image9.png" width="50%"></p><h3 id="条形图"><a href="#条形图" class="headerlink" title="条形图"></a>条形图</h3><p>使用<code>bar()</code>函数</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>x = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>]<br>y = [<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]<br><br>plt.bar(x, y)<br><br>plt.axis([<span class="hljs-number">0</span>, <span class="hljs-number">12</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>])<br><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Image10.png" width="50%"></p><h3 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h3><p>使用<code>hist()</code>函数</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>plt.figure(<span class="hljs-number">1</span>, dpi=<span class="hljs-number">100</span>)  <span class="hljs-comment"># 创建图表1</span><br>data = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>]<br>plt.hist(data)  <span class="hljs-comment"># 只要传入数据，直方图就会统计数据出现的次数</span><br><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Image5.png" width="50%"></p><h3 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h3><p>散点图用<code>scatter(x,y)</code>绘制，x参数传入x轴的坐标，y参数传入y轴坐标</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># 产生测试数据</span><br>x = np.arange(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)<br>y = x<br>fig = plt.figure()<br>plt.scatter(x, y, c=<span class="hljs-string">'r'</span>, marker=<span class="hljs-string">'o'</span>)  <span class="hljs-comment"># c = 'r'表示散点的颜色为红色，marker 表示指定三点多形状为圆形</span><br><span class="hljs-comment"># 显示所画的图</span><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Image6.png" width="50%"></p><h3 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h3><p>使用<code>pie()</code>函数</p><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>data = [<span class="hljs-number">100</span>, <span class="hljs-number">500</span>, <span class="hljs-number">300</span>]  <span class="hljs-comment"># 饼图中的数据</span><br>fig = plt.figure(dpi=<span class="hljs-number">100</span>)<br>plt.pie(data,  <span class="hljs-comment"># 每个饼块的实际数据，如果大于1，会进行归一化，计算percentage</span><br>        explode=[<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.1</span>],  <span class="hljs-comment"># 每个饼块离中心的距离</span><br>        colors=[<span class="hljs-string">'y'</span>, <span class="hljs-string">'r'</span>, <span class="hljs-string">'g'</span>],  <span class="hljs-comment"># 每个饼块的颜色,黄红绿</span><br>        labels=[<span class="hljs-string">'A part'</span>, <span class="hljs-string">'B part'</span>, <span class="hljs-string">'C part'</span>],  <span class="hljs-comment"># 每个饼块的标签</span><br>        labeldistance=<span class="hljs-number">1.2</span>,  <span class="hljs-comment"># 每个饼块标签到中心的距离</span><br>        autopct=<span class="hljs-string">'%1.1f%%'</span>,  <span class="hljs-comment"># 百分比的显示格式</span><br>        pctdistance=<span class="hljs-number">0.5</span>,  <span class="hljs-comment"># 百分比到中心的距离</span><br>        shadow=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 每个饼块是否显示阴影</span><br>        startangle=<span class="hljs-number">0</span>,  <span class="hljs-comment"># 默认从x轴正半轴逆时针起</span><br>        radius=<span class="hljs-number">1</span>  <span class="hljs-comment"># 饼块的半径</span><br>        )<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Image7.png" width="50%"></p><h3 id="图标的注释与标识"><a href="#图标的注释与标识" class="headerlink" title="图标的注释与标识"></a>图标的注释与标识</h3><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>fig = plt.figure(dpi=<span class="hljs-number">100</span>)<br>x = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>)<br>plt.plot(x, np.sin(x), label=<span class="hljs-string">"sin(x)"</span>)  <span class="hljs-comment"># 先设置一个label用于显示图例</span><br>plt.xlabel(<span class="hljs-string">"X axe"</span>)  <span class="hljs-comment"># 设置X轴的文字</span><br>plt.ylabel(<span class="hljs-string">"Y axe"</span>)  <span class="hljs-comment"># 设置Y轴的文字</span><br><span class="hljs-comment"># 设置x轴y轴的起点和终点</span><br>plt.axis([np.min(x), np.max(x), np.min(np.sin(x)), np.max(np.sin(x))])<br>plt.title(<span class="hljs-string">"sin(x) function"</span>)  <span class="hljs-comment"># 设置图的标题</span><br>plt.legend()  <span class="hljs-comment"># 显示图例。</span><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/Image8.png" width="50%"></p><h3 id="插入Latex公式"><a href="#插入Latex公式" class="headerlink" title="插入Latex公式"></a>插入Latex公式</h3><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> matplotlib.patches <span class="hljs-keyword">import</span> Polygon<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>plt.rcParams[<span class="hljs-string">'font.sans-serif'</span>] = [<span class="hljs-string">'STHeiti'</span>]  <span class="hljs-comment"># 用来正常显示中文标签</span><br>plt.rcParams[<span class="hljs-string">'axes.unicode_minus'</span>] = <span class="hljs-literal">False</span>  <span class="hljs-comment"># 用来正常显示负号</span><br><br><br><span class="hljs-comment"># 定义一个求积分的函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(x)</span>:</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0.3</span> * (x ** <span class="hljs-number">2</span>) + (<span class="hljs-number">0.1</span> * x) + <span class="hljs-number">1</span><br><br><br><span class="hljs-comment"># 定义积分区间</span><br>a, b = <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br>x = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)<br>y = func(x)<br><br><span class="hljs-comment"># 绘制曲线</span><br>fig, ax = plt.subplots(figsize=(<span class="hljs-number">14</span>, <span class="hljs-number">8</span>))<br>plt.plot(x, y, <span class="hljs-string">'g'</span>)<br><br><span class="hljs-comment"># 使用Polygon生成阴影部分</span><br>Ix = np.linspace(a, b)<br>Iy = func(Ix)<br>verts = [(a, <span class="hljs-number">0</span>)] + list(zip(Ix, Iy)) + [(b, <span class="hljs-number">0</span>)]<br>ploy = Polygon(verts, facecolor=<span class="hljs-string">'0.7'</span>, edgecolor=<span class="hljs-string">'0.5'</span>)<br>ax.add_patch(ploy)<br><br><span class="hljs-comment"># 添加数学公式和坐标轴标签</span><br><span class="hljs-comment"># r" "中间为LaTex语法表示的公式</span><br>plt.text(<span class="hljs-number">0.5</span> * (a + b), <span class="hljs-number">1</span>, <span class="hljs-string">r"$\int_a^b f(x)\mathrm&#123;d&#125;x$"</span>,<br>         horizontalalignment=<span class="hljs-string">'center'</span>, fontsize=<span class="hljs-number">20</span>)<br><span class="hljs-comment"># 前两个参数是放置文本的坐标</span><br>plt.figtext(<span class="hljs-number">0.9</span>, <span class="hljs-number">0.075</span>, <span class="hljs-string">'$x$'</span>)<br>plt.figtext(<span class="hljs-number">0.075</span>, <span class="hljs-number">0.9</span>, <span class="hljs-string">'$f(x)$'</span>)<br><br>ax.set_xticks((a, b))<br>ax.set_xticklabels((<span class="hljs-string">'$a$'</span>, <span class="hljs-string">'$b$'</span>))<br>ax.set_yticks((func(a), func(b)))<br>ax.set_yticklabels((<span class="hljs-string">'$f(a)$'</span>, <span class="hljs-string">'$f(b)$'</span>))<br>plt.grid(<span class="hljs-literal">True</span>)<span class="hljs-comment"># 网格</span><br>plt.show()<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 画图 </tag>
            
            <tag> Matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTex学习</title>
      <link href="/2019/08/02/Latex%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/08/02/Latex%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><strong>本文主要介绍了以下内容:</strong></p><p>LaTex一些基础知识</p><a id="more"></a><h3 id="开始第一个LaTex文档"><a href="#开始第一个LaTex文档" class="headerlink" title="开始第一个LaTex文档"></a>开始第一个LaTex文档</h3><p>打开TeXstudio,新建一个TeX文件,写入以下内容</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass&#123;article&#125;<br>\begin&#123;document&#125;<br>Here comes \LaTeX!<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><p>​    此处的第一行<code>\documentclass{article}</code>中包含了一个控制序列(或称命令/标记).所谓控制序列,是以反斜杠<code>\</code>开头,以第一个空格或非字母的字符结束的一串文字.它们不能被输出,但是它们会影响输出文档的效果.这里的控制序列是<code>documentclass</code>,它后面紧跟着的<code>{article}</code>代表这个控制序列有一个必要的参数,该参数的值为<code>article</code>这个控制序列的作用,是调用名为<code>article</code>的文档类.</p><p>​    <strong>Tex对控制序列的大小写是敏感的</strong></p><ul><li><p>部分控制序列还有被方括号<code>[]</code>包括的可选参数</p></li><li><p>所谓文档类,即是Tex系统预设的(或是用户自定的)一些格式的集合.不同文档类在输出效果上会有差别.</p><p>  此处的第二行以<code>%</code>开头.Tex以<code>%</code>作为注释标记符.具体来说,Tex会忽略从<code>%</code>开始当当前行末尾的所有内容.这些内容不会被输出,也不影响最终的排版效果,只供人类阅读.若要输出<code>%</code>字符本身,则需要在<code>%</code>之前加上反斜杠<code>\</code>进行转义(escape).例如</p>  <figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">今年的净利润为20\%, 比去年高<br></code></pre></td></tr></table></figure><p>  此处<code>%</code>被当做正常的百分号来处理, 其后的文字也将被正常输出.</p><p>  在注释行之后出现了控制序列<code>begin</code>.这个控制序列总是与<code>end</code>成对出现.这两个控制序列以及它们中间的内容被称为[环境],它们之后的第一个必要参数总是一致,被称为环境名.</p><p>  只有在<code>document</code>环境中的内容,才会被正常输出到文档中去或是作为控制序列对文档产生影响.也就是说,在<code>\end{document}</code>之后插入任何内容都是无效的.</p><p>  从<code>\documentclass{article}</code>开始到<code>\begin{document}</code>之前的部分被称为导言区.你可以将导言区理解为时对整篇文档进行设置的区域——在导言区出现的控制序列,往往会影响整篇文档的格式.</p><p>  <strong>通常在导言区设置页面的大小,页眉页脚样式,章节标题等等</strong></p></li></ul><h3 id="实现中英文混排"><a href="#实现中英文混排" class="headerlink" title="实现中英文混排"></a>实现中英文混排</h3><p>​    <strong>关于LaTeX的中文支持,首先要说明的是:在现在,一切教你使用<code>CJK</code>宏包的模板,人,网页,书,都是糟糕的,有害的,恼人的,邪恶的和应该摒弃的</strong></p><p>​    成功编译出一个文档后,中国Tex用户面临的第二个普遍问题大概就是<strong>实现中英文混排</strong>了.</p><p>​    宏包,就是一系列控制序列的合集.这里控制序列太常用,以至于人们会觉得每次将他们写在导言区太过繁琐,于是将他们打包在同一个文件架中,称为所谓的宏包.<code>\usepackage{}</code>可以用来调用宏包</p><p>​    除去中文支持,中文的板式处理和标点禁则也是不小的挑战.好在由刘海洋,李清等人维护的<code>CTeX</code>宏集一次性解决了这些问题.<code>CTeX</code>宏集的优势在于,他能适配于多种编译方式,在内部处理好了中文和中文版式的支持,影藏了这些细节,并且提供了不少中文用户需要的功能接口.</p><figure class="hljs highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&gt;请注意,`CTeX`宏集和`CTeX`套装是两个不同的东西.`CTeX`宏集的本质是LaTeX宏的集合,包含若干文档类(`.cls`文件)和宏包(`.sty`文件).`CTeX`套装是一个过时的TeX系统.<br>&gt;<br>&gt;新版`CTeX`宏集默认能够自动检测用户的操作系统,并为之配置合适的字库.<br></code></pre></td></tr></table></figure><p>​    使用以下代码来完成对<code>CTeX</code>宏集的调用:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[UTF8]&#123;ctexart&#125;<br>\begin&#123;document&#125;<br>你好, world!<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><h3 id="组织你的文章"><a href="#组织你的文章" class="headerlink" title="组织你的文章"></a>组织你的文章</h3><h4 id="作者-标题-日期"><a href="#作者-标题-日期" class="headerlink" title="作者,标题,日期"></a>作者,标题,日期</h4><p>保存并用XeLaTeX编译如下文档:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[UTF8]&#123;ctexart&#125;<br>\title&#123;你好, world!&#125;<br>\author&#123;胡奔&#125;<br>\date&#123;\today&#125;<br>\begin&#123;document&#125;<br>\maketitle<br>你好, 胡奔<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><p>导言区复杂了很多,但和之前的文档区别只有一处: 定义了<strong>标题,作者,日期</strong></p><p>在<code>document</code>环境中,除了原本的<code>你好,world!</code>,还多了一个控制序列<code>\maketitle</code>,这个控制序列能将在导言区中定义的标题,作者,日期按照预定义的格式展现出来.</p><blockquote><p>使用<code>titling</code>红包可以修改上述默认格式,参考<a href="http://texdoc.net/texmf-dist/doc/latex/titling/titling.pdf" target="_blank" rel="noopener">TeXdoc</a>    </p></blockquote><h4 id="章节和段落"><a href="#章节和段落" class="headerlink" title="章节和段落"></a>章节和段落</h4><p>保存并用XeLaTeX编译如下文档,查看效果:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[UTF8]&#123;ctexart&#125;<br>\title&#123;你好,\LaTeX&#125;<br>\author&#123;Huris&#125;<br>\date&#123;\today&#125;<br>\begin&#123;document&#125;<br>\maketitle<br>\section&#123;你好中国&#125;<br>中国在East Asia.<br>\subsection&#123;Hello Beijing&#125;<br>北京是 captical of China<br>\subsubsection&#123;Hello Dongcheng District&#125;<br>\paragraph&#123;Tian&apos;anmen Square&#125;<br>is in the center of Beijing<br>\subparagraph&#123;Chairman Mao&#125;<br>is in the center of 天安门广场<br>\subsection&#123;Hello 山东&#125;<br>\paragraph&#123;山东大学&#125;<br>is one of the best university in 山东.<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><p>在文档类<code>article</code>/<code>ctexart</code>中,定义了五个控制序列(只有五个)来调整行文组织结构,他们分别是:</p><ul><li><code>\section{.}</code></li><li><code>\subsection{.}</code></li><li><code>\subsubsection{.}</code></li><li><code>\paragraph{.}</code></li><li><code>\subparagraph</code></li></ul><h4 id="插入目录"><a href="#插入目录" class="headerlink" title="插入目录"></a>插入目录</h4><p>在上一节文档中,找到<code>\maketitle</code>,在他的下面插入控制序列<code>\tableofcontents</code>,保存并用XeLaTeX编译两次,观察结果:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[UTF8]&#123;ctexart&#125;<br>\title&#123;你好,\LaTeX&#125;<br>\author&#123;Huris&#125;<br>\date&#123;\today&#125;<br>\begin&#123;document&#125;<br>\maketitle<br>\tableofcontents<br>\section&#123;你好中国&#125;<br>中国在East Asia.<br>\subsection&#123;Hello Beijing&#125;<br>北京是 captical of China<br>\subsubsection&#123;Hello Dongcheng District&#125;<br>\paragraph&#123;Tian&apos;anmen Square&#125;<br>is in the center of Beijing<br>\subparagraph&#123;Chairman Mao&#125;<br>is in the center of 天安门广场<br>\subsection&#123;Hello 山东&#125;<br>\paragraph&#123;山东大学&#125;<br>is one of the best university in 山东.<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意<code>\maketitle</code>与<code>\tableofcontents</code>位置不能交换</p></blockquote><p>另外,LaTeX中间一个换行当做是一个简单的空格来处理,如果需要换行另起一段,则需要使用两个换行(一个空行)来实现.</p><h4 id="插入数学公式"><a href="#插入数学公式" class="headerlink" title="插入数学公式"></a>插入数学公式</h4><p>为了使用AMS-LaTeX提供的数学功能,我们需要在导言区加载<code>amsmath</code>宏包</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\usepackage&#123;amsmath&#125;<br></code></pre></td></tr></table></figure><h5 id="数学模式"><a href="#数学模式" class="headerlink" title="数学模式"></a>数学模式</h5><p>LaTex的数学模式有两种: 行内模式(inline)和行间模式(display).前者在正文的行文中,插入数学公式;后者独立排列单独成行</p><p>在行文中,使用<script type="math/tex">...</script>可以插入行内公式,使用<code>\[...\]</code>可以插入行间公式,如果需要对行间公式进行编号,可以使用equation环境.</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex">\begin&#123;equation&#125;<br>...<br>\end&#123;equation&#125;<br></code></pre></td></tr></table></figure><h5 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h5><p>示例代码:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[UTF8]&#123;ctexart&#125;<br>\usepackage&#123;amsmath&#125;<br>\begin&#123;document&#125;<br>Einsten&apos;s $E=mc^2$.<br>\[E=mc^2.\]<br>\begin&#123;equation&#125;<br>E=mc^2.<br>\end&#123;equation&#125;<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><blockquote><p>标点公式使用的规范</p><p>行内公式: 应该放在数学模式限定符之外</p><p>行间公式: 应该放在数学模式限定符之内</p></blockquote><p><code>_{...}</code>表示下标,<code>^{...}</code>表示上标.它默认只作用于之后的一个字符,如果想对连续的几个字符起作用,请将这些字符用花括号<code>{}</code>括起来.</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\[ z = r\cdot e^&#123;2\pi i&#125;. \]<br></code></pre></td></tr></table></figure><h5 id="根式与分式"><a href="#根式与分式" class="headerlink" title="根式与分式"></a>根式与分式</h5><p>根式用<code>\sqrt{.}</code>表示,分式用<code>\frac{.}{.}</code>表示(第一个参数为分子,第二个参数为分母).</p><p>示例代码:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[UTF8]&#123;ctexart&#125;<br>\usepackage&#123;amsmath&#125;<br>\begin&#123;document&#125;<br>$\sqrt&#123;x&#125;$, $\frac&#123;1&#125;&#123;2&#125;$.<br><br>\[ \sqrt&#123;x&#125;, \]<br><br>\[ \frac&#123;1&#125;&#123;2&#125;. \]<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><p>可以发现,在行间公式和行内公式中,分式的输出效果是由差异的. 如果要强制行内模式的分式显示为行间模式的大小,可以使用<code>\dfrac</code>,反之可以使用<code>\tfrac</code></p><blockquote><p>在行内写分式,可能会喜欢<code>xfrac</code>宏包提供的<code>\sfrac</code>命令的效果</p><p>排版繁公式时,应该使用<code>\cfrac</code>命令</p></blockquote><h5 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h5><p>一些小的运算符,可以在数学模式下直接输入;另一些要用控制序列生成</p><blockquote><p>控制序列</p><p>凡是键盘不能够直接表示的符号或者起着特定作用的皆有命令,类似转义,叫做<strong>控制序列(control sequence)</strong>,比如求和符合$\sum$对应的命令为<code>\sum</code></p></blockquote><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex">\[ \pm\; \times \; \div\; \cdot\; \cap\; \cup\;<br>   \geq\; \leq\; \neq\; \approx\; \equiv \]<br></code></pre></td></tr></table></figure><p>连加,连乘,极限,积分符号等大型运算符分别用<code>\sum</code>,<code>\prod</code>,<code>\lim</code>,<code>\int</code>生成</p><p>他们的上下标在行内公式中被压缩,以适应行高.我们可以使用<code>\limits</code>和<code>\nolimits</code>来强制显示地指定是否压缩这些上下标.</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">$ \sum_&#123;i=1&#125;^n i\quad \prod_&#123;i=1&#125;^n $<br>$ \sum\limits _&#123;i=1&#125;^n i\quad \prod\limits _&#123;i=1&#125;^n $<br>\[ \lim_&#123;x\to0&#125;x^2 \quad \int_a^b x^2 dx \]<br>\[ \lim\nolimits _&#123;x\to0&#125;x^2\quad \int\nolimits_a^b x^2 dx \]<br></code></pre></td></tr></table></figure><p>多重积分可以使用<code>\iint</code>,<code>\iiint</code>,<code>\iiint</code>,<code>\idotsint</code>等命令输入</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\[ \iint\quad \iiint\quad \iiint\quad \idotsint \]<br></code></pre></td></tr></table></figure><h5 id="定界符"><a href="#定界符" class="headerlink" title="定界符"></a>定界符</h5><p>各种括号用<code>()</code>,<code>[]</code>,<code>\{\}</code>,<code>\langle\rangle</code>等命令表示</p><p>注意花括号通常用来输入命令和环境的参数,所以在数学公式中它们前面要加<code>\</code></p><p>因为LaTeX中<code>|</code>和<code>\|</code>的应用过于随意,amsmath宏包推荐用<code>\lvert\rvert</code>和<code>\lVert\rVert</code>取而代之.</p><p>为了调整这些定界符的大小,amsmath宏包推荐使用<code>\big</code>,<code>\Big</code>,<code>\bigg</code>,<code>\Bigg</code>等一系列命令放在上述括号前面调整大小</p><blockquote><p>有时候可能会觉得amsmath宏包提供的定界符放大命令不太够用.</p><p>通常这就意味着你的公式过于复杂</p><p>此时应当首先考虑将公式中的部分提出去,以字母符号代替以简化公式</p><p>如果真的想排版出如此复杂的公式,可以参考<a href="https://liam.page/2018/11/09/the-bigger-than-bigger-delimiter-in-LaTeX/" target="_blank" rel="noopener">这篇博文</a></p></blockquote><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs latex">\[ \Biggl(\biggl(\Bigl(\bigl((x)\bigr)\Bigr)\biggr)\Biggr) \]<br>\[ \Biggl[\biggl[\Bigl[\bigl[[x]\bigr]\Bigr]\biggr]\Biggr] \]<br>\[ \Biggl \&#123;\biggl \&#123;\Bigl \&#123;\bigl \&#123;\&#123;x\&#125;\bigr \&#125;\Bigr \&#125;\biggr \&#125;\Biggr\&#125; \]<br>\[ \Biggl\langle\biggl\langle\Bigl\langle\bigl\langle\langle x<br>\rangle\bigr\rangle\Bigr\rangle\biggr\rangle\Biggr\rangle \]<br>\[ \Biggl\lvert\biggl\lvert\Bigl\lvert\bigl\lvert\lvert x<br>\rvert\bigr\rvert\Bigr\rvert\biggr\rvert\Biggr\rvert \]<br>\[ \Biggl\lVert\biggl\lVert\Bigl\lVert\bigl\lVert\lVert x<br>\rVert\bigr\rVert\Bigr\rVert\biggr\rVert\Biggr\rVert \]<br></code></pre></td></tr></table></figure><h5 id="省略号"><a href="#省略号" class="headerlink" title="省略号"></a>省略号</h5><p>省略号用<code>\dots</code>,<code>\cdots</code>,<code>\vdots</code>,<code>\ddots</code>等命令表示.</p><p><code>\dots</code>和<code>\cdots</code>的纵向位置不同,前者一般用于有下标的序列.</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex">\[ x_1,x_2,\dots ,x_n\quad 1,2,\cdots ,n\quad<br>\vdots\quad \ddots \]<br></code></pre></td></tr></table></figure><h5 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h5><p><code>amsmath</code>的<code>pmatrix</code>,<code>bmatrix</code>,<code>Bmatrix</code>,<code>vmatrix</code>,<code>Vmatrix</code>等环境可以在矩阵两边加上各种分隔符.</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs latex">\[ \begin&#123;pmatrix&#125; a&amp;b\\c&amp;d \end&#123;pmatrix&#125; \quad<br>\begin&#123;bmatrix&#125; a&amp;b\\c&amp;d \end&#123;bmatrix&#125; \quad<br>\begin&#123;Bmatrix&#125; a&amp;b\\c&amp;d \end&#123;Bmatrix&#125; \quad<br>\begin&#123;vmatrix&#125; a&amp;b\\c&amp;d \end&#123;vmatrix&#125; \quad<br>\begin&#123;Vmatrix&#125; a&amp;b\\c&amp;d \end&#123;Vmatrix&#125; \]<br></code></pre></td></tr></table></figure><p>使用<code>smallmatrix</code>环境,可以生成行内公式的小矩阵</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">Marry has a little matrix $(\begin&#123;smallmatrix&#125; a&amp;b\\c&amp;d \end&#123;smallmatrix&#125; )$.<br></code></pre></td></tr></table></figure><h5 id="多行公式"><a href="#多行公式" class="headerlink" title="多行公式"></a>多行公式</h5><ul><li>有的公式特别长,需要手动为他们换行</li><li>有几个公式是一组,我们需要将他们放在一起</li><li>还有些类似分段函数,我们需要给他加上一个左边的花括号</li></ul><h6 id="长公式"><a href="#长公式" class="headerlink" title="长公式"></a>长公式</h6><h6 id="不对齐"><a href="#不对齐" class="headerlink" title="不对齐"></a>不对齐</h6><p>无须对齐的长公式可以使用<code>multline</code>环境.</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">\begin&#123;multline&#125;<br>x = a+b+c+&#123;&#125; \\<br>d+e+f+g<br>\end&#123;multline&#125;<br></code></pre></td></tr></table></figure><p>如果不需要编号,则可以使用<code>multline*</code>环境代替.</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[UTF8]&#123;ctexart&#125;<br>\usepackage&#123;amsmath&#125;<br>\begin&#123;document&#125;<br>\begin&#123;multline*&#125;<br>x = a+b+c+&#123;&#125; \\<br>d+e+f+g<br>\end&#123;multline*&#125;<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><h6 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h6><p>需要对齐公式,可以使用<code>aligned</code>次环境来实现,它必须包含在数学环境之内</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">\[\begin&#123;aligned&#125;<br>x =&#123;&#125;&amp; a+b+c+&#123;&#125; \\<br>&amp;d+e+f+g<br>\end&#123;aligned&#125;\]<br></code></pre></td></tr></table></figure><h6 id="公式组"><a href="#公式组" class="headerlink" title="公式组"></a>公式组</h6><p>无需对齐公式的公式组可以使用<code>gather</code>环境,需要对齐的公式组可以使用<code>align</code>环境</p><p>他们都带有编号,如果不需要编号可以使用待星花的版本.</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs latex">\begin&#123;gather&#125;<br>a=b+c+d \\<br>x=y+z<br>\end&#123;gather&#125;<br>\begin&#123;align&#125;<br>a &amp;= b+c+d \\<br>x &amp;= y+z<br>\end&#123;align&#125;<br></code></pre></td></tr></table></figure><h6 id="分段函数"><a href="#分段函数" class="headerlink" title="分段函数"></a>分段函数</h6><p>分段函数可以用<code>cases</code>次环境来实现,它必须包含在数学环境之内.</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">\[ y\begin&#123;cases&#125;<br>-x,\quad x\leq 0 \\<br>x,\quad x&gt;0<br>\end&#123;cases&#125; \]<br></code></pre></td></tr></table></figure><h4 id="插入图片和表格"><a href="#插入图片和表格" class="headerlink" title="插入图片和表格"></a>插入图片和表格</h4><h5 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h5><p>LaTeX中插入图片,有很多种方式.</p><p>最好用的应当属利用<code>graphicx</code>宏包提供的<code>\includegraphics</code>命令</p><p>比如,在TeX源文件同目录下,有名为<code>a.jpg</code>的图片,可以用这样的方式将他插入到输出文档中:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[UTF8]&#123;ctexart&#125;<br>\usepackage&#123;graphicx&#125;<br>\begin&#123;document&#125;<br>\includegraphics&#123;a.jpg&#125;<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><p>图片可能很大,超过了输出文件的纸张大小,或者输出效果不是很好</p><p>此时可以用<code>\includegraphics</code>控制序列的可选参数来控制.</p><p>比如:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\includegraphics[width = .8\textwidth]&#123;a.jpg&#125;<br></code></pre></td></tr></table></figure><p>这样图片的高度会缩小为原来的80%,图片的总高度会按比例缩放</p><p><code>\includegraphics</code>控制序列还有若干其他的可选参数,一般用不到,具体可以查看该宏包的<a href="http://texdoc.net/texmf-dist/doc/latex/graphics/graphicx.pdf" target="_blank" rel="noopener">参考文档</a></p><h5 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h5><p><code>tabular</code>环境提供了最简单的表格功能.它用<code>\hline</code>命令表示横线,在列格式中用<code>|</code>表示竖线,用<code>&amp;</code>来进行分列,用<code>\\</code>来换行,每列可以采用居左,居中,居右等横向对齐方式,分别用<code>l</code>,<code>c</code>,<code>r</code>来表示</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs latex">\begin&#123;tabular&#125;&#123;l|c|r&#125;<br>\hline<br>操作系统&amp;发行版&amp;编辑器\\<br>\hline<br>Windows &amp; MikTeX &amp;TexMakerX \\<br>\hline<br>Unix/Linux &amp; teTeX &amp; Kile \\<br>\hline<br>Mac OS &amp; MacTeX &amp; TeXShop \\<br>\hline<br>通用&amp; TeX Live &amp; TeXworks \\<br>\hline<br>\end&#123;tabular&#125;<br></code></pre></td></tr></table></figure><p>浮动体</p><p>插图和表格通常需要占据大块空间,所以在文字处理软件中我们经常需要调整他们的位置</p><p><code>figure</code>和<code>table</code>环境可以自动完成这样的任务</p><p>这种自动调整位置的环境称作浮动体(float)</p><p>以<code>figure</code>为例</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs latex">\begin&#123;figure&#125;[htbp]<br>\centering% 使插图居中<br>\includegraphics&#123;a.jpg&#125;<br>\caption&#123;有图有真相&#125;% 设置插图标题<br>\label&#123;fig:myphoto&#125;  <br>\end&#123;figure&#125;<br></code></pre></td></tr></table></figure><p><code>htbp</code>选项用来指定插图的理想位置,如下表所示:</p><div class="table-container"><table><thead><tr><th style="text-align:center">here</th><th style="text-align:center">top</th><th style="text-align:center">bottom</th><th style="text-align:center">float page(专门放浮动体的单独页面或芬兰)</th></tr></thead><tbody><tr><td style="text-align:center">这里</td><td style="text-align:center">页眉</td><td style="text-align:center">页尾</td><td style="text-align:center">浮动页</td></tr></tbody></table></div><h3 id="版面设置"><a href="#版面设置" class="headerlink" title="版面设置"></a>版面设置</h3><h4 id="页边距"><a href="#页边距" class="headerlink" title="页边距"></a>页边距</h4><p>设置页边距,推荐使用<code>geometry</code>宏包,可以看到<a href="http://texdoc.net/texmf-dist/doc/latex/geometry/geometry.pdf" target="_blank" rel="noopener">文档</a></p><p>将纸张的长度设置为20cm,宽度设置为15cm,左边距1cm,右边距2cm,上边距3cm,下边距4cm,可以在导言区加上这样的几行:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex">\usepackage&#123;geometry&#125;<br>\geometry&#123;papersize=&#123;20cm,15cm&#125;&#125;<br>\geometry&#123;left=1cm,right=2cm,top=3cm,bottom=4cm&#125;<br></code></pre></td></tr></table></figure><p>页眉页脚,推荐使用<code>fancyhdr</code>宏包,可以在这里查看它的<a href="http://texdoc.net/texmf-dist/doc/latex/fancyhdr/fancyhdr.pdf" target="_blank" rel="noopener">说明文档</a></p><p>页眉左边写上我的名字,中间写上今天的日期,右边写上我的电话</p><p>页脚的正中写上页码,页眉和正文之间有一道宽为0.4pt的横线分割,可以在导言区加上如下几行:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs latex">\usepackage&#123;fancyhdr&#125;<br>\pagestyle&#123;fancy&#125;<br>\lhead&#123;\author&#125;<br>\chead&#123;\date&#125;<br>\rhead&#123;18757479599&#125;<br>\lfoot&#123;&#125;<br>\cfoot&#123;\thepage&#125;<br>\rfoot&#123;&#125;<br>\renewcommand&#123;\headrulewidth&#125;&#123;0.4pt&#125;<br>\renewcommand&#123;\headwidth&#125;&#123;\textwidth&#125;<br>\renewcommand&#123;\footrulewidth&#125;&#123;0pt&#125;<br></code></pre></td></tr></table></figure><h4 id="首行缩进"><a href="#首行缩进" class="headerlink" title="首行缩进"></a>首行缩进</h4><p>CTeX宏集已经处理好了首行缩进的问题(自然段前空两格汉字宽度)</p><p>因此,使用CTeX宏集进行中西文混合排版时,不需要关注首行缩进的问题.</p><h4 id="行间距"><a href="#行间距" class="headerlink" title="行间距"></a>行间距</h4><p>可以通过<code>setspace</code>宏包提供的命令来调整行间距</p><p>在导言区添加如下内容,可以将行距设置为字号的1.5倍</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex">\usepackage&#123;setspace&#125;<br>\onehalfspacing<br></code></pre></td></tr></table></figure><p>注意用词的差别</p><ul><li>行距是字号的1.5倍</li><li>1.5倍行距</li></ul><p>事实上,这不是设置1.5倍行距的正确方法,具体可看<a href>此处</a></p><h4 id="段间距"><a href="#段间距" class="headerlink" title="段间距"></a>段间距</h4><p>可以通过修改长度<code>\parskip</code>的值来调整段间距.</p><p>在导言区添加如下内容:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\addtolength&#123;\parskip&#125;&#123;.4em&#125;<br></code></pre></td></tr></table></figure><h3 id="命令与环境"><a href="#命令与环境" class="headerlink" title="命令与环境"></a>命令与环境</h3><p>LaTeX中的命令通常是由一个反斜杠加上命令名称，再加上花括号内的参数构成的(有的命令不带参数，例如<code>\TeX</code>)</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass&#123;ctexart&#125;<br></code></pre></td></tr></table></figure><p>如果有一些选项是备选的，那么通常会在花括号前用方括号标出，比如：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[a4paper]&#123;ctexart&#125;<br></code></pre></td></tr></table></figure><p>还有一种重要指令叫做环境。它被定义于控制命令<code>\begin{environment}</code>和<code>\end{environment}</code>间的内容。比如：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex">\begin&#123;document&#125;<br>...内容...<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><p>环境如果有备选参数，只需要写在<code>\begin[...]{name}</code>这里就行。</p><p>注意：不带花括号的命令后面如果想打印空格，需加上<strong>一对内部为空的花括号</strong>再键入空格。否则空格会被忽略。例如<code>\LaTeX{}Studio</code></p><p><strong>有时候LaTeX编译出现异常，需要删除文件夹下除了tex以外的文件再编译。</strong></p><p><strong>另外，在某些独占程序打开了以上文件时(比如用Acrobat打开了pdf)，编译可能出现错误。在编译时确保关闭这些独占程序。</strong></p><h3 id="保留字符-共8个"><a href="#保留字符-共8个" class="headerlink" title="保留字符(共8个)"></a>保留字符(共8个)</h3><p>#：自定义命令时，用于标明参数序号</p><p>$： 数学环境命令符</p><p>%：注释符，在其后的该行命令都会视为注释。如果在回车前输入这个命令，可以防止行末LaTeX插入一些奇怪的空白符。</p><p>^：数学环境中的上标命令符。</p><p>&amp;：表格环境中的跳列符</p><p>_：数学环境中的下标命令符</p><p>{与}：花括号用于标记命令的必选参数，或者标记某一部分命令称为一个整体。</p><p>\：反斜杠用于开始各种LaTeX命令。</p><blockquote><p>以上命令除了反斜杠，均能在前加反斜杠的形式输出。</p></blockquote><p>反斜杠输出：<code>\texttt{\char92}</code></p><p>其中命令<code>\char[num]</code>是一个特殊的命令，使用环境需要是tt字体环境，用于输出USCII码对应的字符，92对应的即反斜杠。</p><p>也可以使用   <strong>\char`</strong>  后加字符的方式输出想要的命令，但需要包裹在<code>\texttt</code>或者<code>\ttfamily</code>内、如果想要输出的字符是保留字，则需要在前面加一个反斜杠。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex">\texttt&#123;\char`~&#125;% 输出一个波浪线<br>\texttt&#123;\char`\\&#125;% 输出保留字反斜杠<br>\texttt&#123;\char`@&#125;% 实际上可直接输入@<br></code></pre></td></tr></table></figure><p>另外上面说的波浪线<code>~</code>用来输出一个禁止在该处断行的空格，也不能能够直接输出。</p><p>尝试：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">a $\sim$ b<br>a\~b<br>a\~&#123;&#125; b<br>a\textasciitilde b<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/image1.png" width="30%"></p><h3 id="导言区"><a href="#导言区" class="headerlink" title="导言区"></a>导言区</h3><p>任何一份LaTeX文档都应当包含如下结构：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[options]&#123;doc-class&#125;<br>% 导言区<br>\begin&#123;document&#125;<br>...<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><p>其中，在语句<code>\begin{document}</code>之前的内容称为<strong>导言区</strong>。导言区可以留空，以可以进行一些文档的准备操作。即，<strong>导言区即为模板定义</strong>。</p><p>文档类参数<strong>doc-class</strong>和可选选项<strong>options</strong>由表3.1取值。</p><div class="table-container"><table><thead><tr><th>doc-class</th><th>文档类</th></tr></thead><tbody><tr><td>article</td><td>科学期刊，演示文稿，段报告，邀请函</td></tr><tr><td>proc</td><td>基于article的会议论文集</td></tr><tr><td>report</td><td>多章节的长报告、博士论文、短篇书</td></tr><tr><td>book</td><td>书籍</td></tr><tr><td>slides</td><td>幻灯片，使用了大号Scans Serif字体</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>options</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td>字体</td><td style="text-align:left">默认10pt，可选11pt和12pt</td></tr><tr><td>页面方向</td><td style="text-align:left">默认竖向protrait，可选横向landscape</td></tr><tr><td>纸张尺寸</td><td style="text-align:left">默认letterpaper，可选用a4paper，b5paper等</td></tr><tr><td>分栏</td><td style="text-align:left">默认onecolumn，还有twocolumn</td></tr><tr><td>双面打印</td><td style="text-align:left">有oneside/twoside两个选项，用于排版奇偶页。article/report默认单页</td></tr><tr><td>章节分页</td><td style="text-align:left">有openright/openany两个选项，决定是在奇数页开启新页或是任意页开启新页。注意article是没有chapter(“章”)命令的，默认任意页。</td></tr><tr><td>公式对齐</td><td style="text-align:left">默认居中，可改为左对齐fleqn，默认编号居中，可改为左对齐leqno</td></tr><tr><td>草稿选项</td><td style="text-align:left">默认final，可改为draft，使行溢出的部分显示为黑块。</td></tr></tbody></table></div><p>在导言区最常见的是<strong>宏包</strong>的加载工作，命令形如：<code>\usepackage{package}</code>。</p><p>宏包是一系列已经制作好的功能”模块”，在需要使用一些原生LaTeX不带有的功能时，只需要调用这些宏包就可以了。</p><h3 id="标点与强调"><a href="#标点与强调" class="headerlink" title="标点与强调"></a>标点与强调</h3><p>英文符号$|&lt;&gt;+=$一般用于数学环境中，如果在文本中使用，在两侧加上”$”</p><p>如果在LaTeX中直接输入大于，小于号而不把他们放在数学环境中，它们并不会被正确地打印。</p><p>应该使用<code>\textgreater</code>、<code>\textless</code>命令。</p><h4 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h4><p>英文单引号：左单引号是重音符`(键盘上1左侧)，右单引号是常用的引号符</p><p>英文双引号：左双引号是连续两个重音符``(键盘上1左侧)，右双引号是常用的引号符</p><p>英文下的引号嵌套需要借助<code>\thinspace</code>命令分隔，比如：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">``\thinspace`Max&apos; is here.&apos;&apos;<br></code></pre></td></tr></table></figure><p>中文下册单引号和双引号可用中文输入法直接输入。</p><h4 id="破折、省略号与短横"><a href="#破折、省略号与短横" class="headerlink" title="破折、省略号与短横"></a>破折、省略号与短横</h4><p>英文短横分为三种：</p><ul><li>连字符：输入一个短横：-，效果如daughter-in-law</li><li>数字起止符：输入链各个短横：- -，效果如：page 1-2</li><li>破折号：输入三个短横 - - -，效果如：Listen—I’m serious.</li></ul><p>中文的破折号可以直接使用日常的输入方式。中文的省略号同样。但是注意，英文的省略号使用<code>\ldots</code>这个命令而不是三个句点。</p><h4 id="强调：粗与斜"><a href="#强调：粗与斜" class="headerlink" title="强调：粗与斜"></a>强调：粗与斜</h4><p>LaTeX中专门有个叫做<code>\emph{text}</code>的命令，可以强调文本。对于通常的西文文本，上述命令的作用就是斜体。如果对一段已经这样转为斜体的文本再使用这个命令，他就会取消斜体，而成为正体。</p><p><strong>因为一般采用斜体强调的方式而不是粗体</strong></p><h4 id="下划线与删除线"><a href="#下划线与删除线" class="headerlink" title="下划线与删除线"></a>下划线与删除线</h4><p>建议使用<strong>ulem</strong>宏包中的uline命令代替原生的，<strong>ulem</strong>宏包还提供了一些实用命令：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[a4paper]&#123;ctexart&#125;<br>\usepackage[normalem]&#123;ulem&#125;<br><br>\begin&#123;document&#125;<br>\uline&#123;下划线&#125;<br>\uuline&#123;双下划线&#125;<br>\dashuline&#123;虚下划线&#125;<br>\dotuline&#123;点下划线&#125;<br>\uwave&#123;波浪线&#125;<br>\sout&#123;删除线&#125;<br>\xout&#123;斜删除线&#125;<br>\end&#123;document&#125;<br></code></pre></td></tr></table></figure><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/image2.png" width="30%"></p><p>需要注意，<strong>ulem</strong>宏包冲定义了<code>\emph</code>命令，<strong>使得原来的加斜强调变成了下划线，原来的两次强调就取消强调变成了两次强调就双下划线。</strong></p><p>通过宏包的<strong>normalem</strong>选项可以取消这个更改：<code>\usepackage[normalem]{ulem}</code></p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>角度符号或者温度符号需要借助数学模式$…$输入：</li></ul><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex">$30\,^&#123;\circ&#125;$ 三角形<br>$37\,^&#123;\circ&#125;\mathrm&#123;C&#125;$<br></code></pre></td></tr></table></figure><ul><li>欧元符号可能需要用到<strong>textcomp</strong>宏包支持的<code>\texteuro</code>命令</li><li>千分位分隔符，如果不想它在中间断行，就在外侧再加上一个<code>\mbox</code>命令：<code>\mbox{1\,000\,000}</code></li><li>注音符号</li></ul><p><strong>hologo</strong>宏包，它允许输出许多TeX家族标志。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">\LaTeX<br>\TeX<br>\hologo&#123;XeLaTeX&#125;<br>\hologo&#123;BibTex&#125;<br></code></pre></td></tr></table></figure><h3 id="格式控制"><a href="#格式控制" class="headerlink" title="格式控制"></a>格式控制</h3><p>LaTeX的长度单位：</p><ul><li><strong>pt</strong>：point，磅</li><li><strong>pc</strong>：pica，1pc=12pt，四号字大小</li><li><strong>in</strong>：inch，英寸，1in=72.72pt</li><li><strong>bp</strong>：bigpoint，大点。1bp=$\tfrac1{12}$in</li><li><strong>cm</strong>：centimeter，厘米，1cm=$\tfrac1{2.54}$in</li><li><strong>mm</strong>：millimeter，毫米，1mm=$\tfrac1{10}$cm</li><li><strong>sp</strong>：scaled point，TeX的基本长度单位，1sp=$\tfrac1{65536}$pt</li><li><strong>em</strong>：当前字号下，大写字母的宽度</li><li><strong>ex</strong>：当前字号下，小写字母x的高度</li></ul><p>几个常用的长度宏：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex">\textwidth % 页面上文字的总宽度，即页宽减去两侧边距<br>\linewidth % 当前行允许的行宽<br></code></pre></td></tr></table></figure><p>有时候可以使用可变长度，比如”5pt plus 3pt minus 2pt”，表示一个能收缩到3pt也能伸长到8pt的长度，直接使用倍数也是允许的，例如：1.5<code>\parindent</code>等。</p><p>通常使用<code>\hspace{len}</code>和<code>\vspace{len}</code>这两个命令控制特殊的空格。</p><h4 id="空格、换行与分段"><a href="#空格、换行与分段" class="headerlink" title="空格、换行与分段"></a>空格、换行与分段</h4><p>在LaTeX中，多个空格会被视为一个，多个换行也会被视为一个，如果想要禁止LaTeX在某个空格处的换行，将空格用~命令替代即可，比如”Fig .~8”</p><p>通常的换行方法非常简单：LaTeX会自动转行，然后在每一段的末尾，只需要输入两个回车即可完成分段。如果需要一个空白段落(实质是一个空白行)，先输入两个回车，再输入<code>\mbox{}</code>，最后再输入两个回车即可。也可以用<code>\par</code>来产生一个带缩进的新段。</p><p><strong>正文中想要换行，直接使用两个回车。</strong></p><p>段落之间的距离由<code>\parskip</code>控制，默认”0pt plus 1pt”</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\setlength&#123;\parskip&#125;&#123;0pt&#125;<br></code></pre></td></tr></table></figure><p>宏包<strong>lettrine</strong>能够产生首字下沉的效果：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex">\lettrine&#123;T&#125;&#123;his&#125; is an example.<br>Hope you like this package,<br>and enjoy your \LaTeX\ trip!<br></code></pre></td></tr></table></figure><h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><p>用<code>\newpage</code>命令开始新的一页</p><p>用<code>\clearpage</code>命令清空浮动体队列，并开始新的一页</p><p>用<code>\cleardoublepage</code>命令清空浮动体队列，并在偶数页上开始新的一页</p><p>注意：以上命令都是基于<code>\vfill</code>的，如果要连续新开两页，在中间加上一个空的箱子(<code>\mbox{}</code>)，如<code>\newpage\mbox{}\newpage</code></p><h4 id="缩进、对齐与行距"><a href="#缩进、对齐与行距" class="headerlink" title="缩进、对齐与行距"></a>缩进、对齐与行距</h4><p>英文的段首不需要缩进，但是对中文而言，段首缩进需要借助<strong>indentfirst</strong>宏包来完成</p><p>可能还需要使用<code>\setlength\parindent{2em}</code>这样的命令来设置缩进距离</p><p>如果在行首强制取消缩进，可以在段首使用<code>\noindent</code>命令</p><p>LaTeX默认使用两端对齐的排版方式。也可以使用<code>flushleft</code>，<code>flushright</code>，<code>center</code>这三种环境来构造居左，居中，居右三种效果。</p><h4 id="字体与颜色"><a href="#字体与颜色" class="headerlink" title="字体与颜色"></a>字体与颜色</h4><p>字族：宋体，黑体，楷体，罗马体，等宽体</p><p>字系和字形：加粗，加斜</p><p>字号：五号，小四</p><p><strong>字族+字系和字形+字号=字体</strong></p><h5 id="原生字体命令"><a href="#原生字体命令" class="headerlink" title="原生字体命令"></a>原生字体命令</h5><p>LaTeX提供了基本的字体命令</p><p>字族</p><ul><li><code>\rmfamily</code>：把字体设置为Roman罗马字族</li><li><code>\saffamily</code>：把字体设置为Sans Serif无衬线字族</li><li><code>\ttfamily</code>：把字体设置为Typewriter等宽字族</li></ul><p>字系</p><ul><li><code>\bfseries</code>：粗体BoldSeries字系属性</li><li><code>\mdseries</code>：中粗体MiddleSeries字系属性</li></ul><p>字形</p><ul><li><code>\upshape</code>：竖直Upright字形</li><li><code>\slshape</code>：斜体Slant字形</li><li><code>\itshape</code>：强调体Italic字形</li><li><code>\scshape</code>：小号大写体SCAP字形</li></ul><p>如果临时改变字体，使用<code>\textrm</code>，<code>\textbf</code>这类命令</p><p>字族，字系，字形三种命令是相互独立的，可以任意组合使用。</p><p>但这种复合字体的效果有时候无法达到(因为没有对应的设计)，比如<code>\scshape</code>字形和<code>\bfseries</code>字系。</p><p>如果在文中多次使用某种字体变换，可以将其自定义成一个命令。</p><p>使用text系列的命令而不要使用family，series或shape系列的命令。</p><p>否则需要多加一组花括号防止”泄露”。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">􏲨􏲫􏱌􏲲􏲩􏰾􏲪􏲪􏲬􏲫􏰼􏲮􏲨􏲩􏰾􏲫􏲩􏱌􏱖􏰺􏲯􏳭􏰉􏳮􏲮􏲨􏰺􏱌􏱛􏰺􏲰􏲿􏲮􏸙􏰉􏲯􏲯􏲨􏲫􏱌􏲲􏲩􏰾􏲪􏲪􏲬􏲫􏰼􏲮􏲨􏲩􏰾􏲫􏲩􏱌􏱖􏰺􏲯􏳭􏰉􏳮􏲮􏲨􏰺􏱌􏱛􏰺􏲰􏲿􏲮􏸙􏰉􏲯􏲯􏲨􏲫􏱌􏲲􏲩􏰾􏲪􏲪􏲬􏲫􏰼􏲮􏲨􏲩􏰾􏲫􏲩􏱌􏱖􏰺􏲯􏳭􏰉􏳮􏲮􏲨􏰺􏱌􏱛􏰺􏲰􏲿􏲮􏸙􏰉\newcommand&#123;\concept&#125;[1]&#123;\textbf&#123;#1&#125;&#125;<br></code></pre></td></tr></table></figure><h6 id="字号命令"><a href="#字号命令" class="headerlink" title="字号命令"></a>字号命令</h6><p>在行文中会有一个默认的”标准”字号，比如在documentclass的选项中设置的12pt</p><p>在LaTeX中给出了一系列”相对字号命令”，此外，<strong>ctex</strong>宏包的<code>\zihao</code>命令，参数0-8以及-0–8表示初号到八号，小初到小八</p><p>日常使用的小四为12pt，五号为10.5pt</p><div class="table-container"><table><thead><tr><th>命令</th><th>10pt</th><th>11pt</th><th>12pt</th></tr></thead><tbody><tr><td>\tiny</td><td>5pt</td><td>6pt</td><td>6pt</td></tr><tr><td>\scriptsize</td><td>7pt</td><td>8pt</td><td>8pt</td></tr><tr><td>\footnotesize</td><td>8pt</td><td>9pt</td><td>10pt</td></tr><tr><td>\small</td><td>9pt</td><td>10pt</td><td>11pt</td></tr><tr><td>\normalsize</td><td>10pt</td><td>11pt</td><td>12pt</td></tr><tr><td>\large</td><td>12pt</td><td>12pt</td><td>14pt</td></tr><tr><td>\Large</td><td>14pt</td><td>14pt</td><td>17pt</td></tr><tr><td>\LARGE</td><td>17pt</td><td>17pt</td><td>20pt</td></tr><tr><td>\huge</td><td>20pt</td><td>20pt</td><td>25pt</td></tr><tr><td>\Huge</td><td>25pt</td><td>25pt</td><td>25pt</td></tr></tbody></table></div><p>如果想要设置特殊的字号，使用：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\fontsize&#123;font-size&#125;&#123;line-height&#125;&#123;\selectfont &lt;text&gt;&#125;<br></code></pre></td></tr></table></figure><p>其中<strong>font-size</strong>填数字，单位pt，一般而言，<strong>line-height</strong>填<code>\baselineskip</code></p><p>默认全文的字体使用<code>\rmfamily</code>族的字体。可以通过重定义的方式改变他，使<code>\rmfamily</code>，<code>\textrm</code>命令都指向新的字体。甚至把默认字体改为sf/tt字族。</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs latex">\renewcommand&#123;\rmdefault&#125;&#123;font-name&#125;<br>% 默认字体改为sf字族，也可以用\ttdefault<br>\renewcommand&#123;\familydefault&#125;&#123;\sfdefault&#125;<br>\renewcommand&#123;\sfdefault&#125;&#123;font-name&#125;<br>% 如果你的排版CJK文档，还需要更改CJK默认字体<br>\renewcommand&#123;\CJKfamilydefault&#125;&#123;\CJKsfdefault&#125;<br></code></pre></td></tr></table></figure><h6 id="西文字体"><a href="#西文字体" class="headerlink" title="西文字体"></a>西文字体</h6><p>LaTeX预报含如下字体：</p><div class="table-container"><table><thead><tr><th>命令</th><th>字体名</th></tr></thead><tbody><tr><td>cmr</td><td>Computer Modern Roman(默认)</td></tr><tr><td>lmr</td><td>Latin Modern Roman</td></tr><tr><td>pbk</td><td>Bookman</td></tr><tr><td>ppl</td><td>Palatino</td></tr><tr><td>lmss</td><td>Latin Modern Roman Serif</td></tr><tr><td>phv</td><td>Helvetica</td></tr><tr><td>lmtt</td><td>Latin Modern</td></tr></tbody></table></div><p>以上可以这样使用</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">\newcommand&#123;\myfont&#125;[2]&#123;&#123;\fontfamily&#123;#1&#125;\selectfont #2&#125;&#125;<br>\renewcommand&#123;\rmdefault&#125;&#123;ptm&#125;% 可更改默认字体，同理可改sfdefault等<br>% 以上在导言区定义，在正文中：<br>Let&apos;s change font to \myfont&#123;pp1&#125;&#123;Palatino&#125;!<br></code></pre></td></tr></table></figure><h6 id="中文支持与CJK字体"><a href="#中文支持与CJK字体" class="headerlink" title="中文支持与CJK字体"></a>中文支持与CJK字体</h6><p>中文方面，<strong>ctex</strong>宏包直接定义了新的中文文档类ctexart，ctexrep，ctexbook，ctexbeamer</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex">\documentclass[a4paper,zihao=-4,linespread=1]&#123;ctexrep&#125;<br>\renewcommand&#123;\CTEXthechapter&#125;&#123;\thechapter&#125;<br></code></pre></td></tr></table></figure><p> 以上设置字号为小四，行距因子为1(故行距为1x1.2=1.2倍，其中1.2是LaTeX默认的基线间距)</p><p>a4paper选项继承与原生文档类report，可见ctex文档类还是很好地保留了原生文档类的特征</p><p>值得注意的是，<strong>ctex文档类会用<code>\CTEX</code>开头的计数器命令代替原有的</strong></p><p><strong>除非使用scheme=plain来让ctex文档类仅支持中文而不做任何文档细节更改</strong></p><p><strong>ctex</strong>宏包支持一下字体命令：</p><ul><li>宋体：<code>\songti</code></li><li>黑体：<code>\heiti</code></li><li>仿宋：<code>\fangsong</code></li><li>楷书：<code>\kaishu</code></li><li>雅黑：<code>\yahei</code></li><li>隶书：<code>\lishu</code></li><li>幼圆：<code>\youyuan</code></li></ul><h5 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h5><p>使用<strong>xcolor</strong>宏包来方便地调用颜色</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs latex">\usepackage&#123;xcolor&#125;<br>\definecolor&#123;keywordcolor&#125;&#123;RGB&#125;&#123;34,34,250&#125;<br><br>% 指定颜色的text<br>&#123;\color&#123;color-name&#125;&#123;text&#125;&#125;<br></code></pre></td></tr></table></figure><p><strong>xcolor</strong>宏包预定义的颜色：</p><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/image3.png" width="70%"></p><p>还可以通过”调色”做出新的效果</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex">&#123;\color&#123;red!70&#125;百分之70红色&#125;<br>&#123;\color&#123;blue!50!black!20!white!30&#125;50蓝20黑30白&#125;<br>&#123;\color&#123;-yellow&#125;黄色的互补色&#125;<br></code></pre></td></tr></table></figure><h3 id="引用与注释"><a href="#引用与注释" class="headerlink" title="引用与注释"></a>引用与注释</h3><p>电子文档最大优越性在于能够使用超链接，跳转标签、目录，甚至访问外部网站。这些功能都需要引用。</p><h4 id="标签和引用"><a href="#标签和引用" class="headerlink" title="标签和引用"></a>标签和引用</h4><p>使用<code>\label</code>命令插入标签(在MS Word中称为”题注”)，然后在其他地方用<code>\ref</code>或者<code>\pageref</code>命令进行引用，分别引用标签的序号、标签所在的页的页码。</p><figure class="hljs highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">\<span class="hljs-selector-tag">label</span>&#123;<span class="hljs-attribute">section</span>:this&#125;<br>\<span class="hljs-selector-tag">ref</span>&#123;<span class="hljs-attribute">section</span>:this&#125;<br>\<span class="hljs-selector-tag">pageref</span><br></code></pre></td></tr></table></figure><h3 id="中英文之间空格问题解决"><a href="#中英文之间空格问题解决" class="headerlink" title="中英文之间空格问题解决"></a>中英文之间空格问题解决</h3><p><code>&lt;\hspace{0em}变量\hspace{0em}&gt;</code></p><h3 id="空格设置"><a href="#空格设置" class="headerlink" title="空格设置"></a>空格设置</h3><p><code>\hspace{0em}</code></p><h3 id="空行距离"><a href="#空行距离" class="headerlink" title="空行距离"></a>空行距离</h3><p><code>\vspace{3mm}</code></p><h3 id="两端对齐"><a href="#两端对齐" class="headerlink" title="两端对齐"></a>两端对齐</h3><p><code>\usepackage{ragged2e}</code></p><p><code>\justifying</code></p><h3 id="分数"><a href="#分数" class="headerlink" title="分数"></a>分数</h3><p>分数小：$\tfrac{1}{2}$</p><p>分数大：$\dfrac{1}{2}$</p><h3 id="摄氏度"><a href="#摄氏度" class="headerlink" title="摄氏度"></a>摄氏度</h3><p>$^{\circ}$C</p><h3 id="max下面加限制范围"><a href="#max下面加限制范围" class="headerlink" title="max下面加限制范围"></a>max下面加限制范围</h3><p>$y_{N+1}=\arg \max \limits_{y_{N+1}} \hat{P}(y_{N+1}|x_{N+1})$</p><p><a herf="https://huris.oss-cn-hangzhou.aliyuncs.com/avatar.jpg"></a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机工具 </category>
          
          <category> LaTex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matlab画图总结</title>
      <link href="/2019/08/02/Matlab%E7%94%BB%E5%9B%BE%E6%80%BB%E7%BB%93/"/>
      <url>/2019/08/02/Matlab%E7%94%BB%E5%9B%BE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-built_in">plot</span><br>数据点: . o x + * S(正方形) H(六角星) D(菱形) p(五角星) V(倒三角) ^(三角形) &gt;(右三角) &lt;(左三角)<br>线型:  -  -.  --  : <br>颜色:r-red，g-green，b-blue，w-white，k-black，<span class="hljs-built_in">i</span>-invisible(无色)，y-yellow<br><br><span class="hljs-built_in">legend</span>(<span class="hljs-string">'a'</span>)<br>title(<span class="hljs-string">'a'</span>)<br>xlabel(<span class="hljs-string">'T'</span>)<br>ylabel(<span class="hljs-string">'a'</span>)<br><br>set(gca, <span class="hljs-string">'Box'</span>, <span class="hljs-string">'off'</span>, <span class="hljs-string">'TickDir'</span>, <span class="hljs-string">'out'</span>, <span class="hljs-string">'TickLength'</span>, [<span class="hljs-number">.02</span> <span class="hljs-number">.02</span>], ...<br>    <span class="hljs-string">'XMinorTick'</span>, <span class="hljs-string">'on'</span>, <span class="hljs-string">'YMinorTick'</span>, <span class="hljs-string">'on'</span>, <span class="hljs-string">'XGrid'</span>, <span class="hljs-string">'on'</span>, <span class="hljs-string">'YGrid'</span>, <span class="hljs-string">'on'</span>,...<br>    <span class="hljs-string">'box'</span>,<span class="hljs-string">'on'</span>, <span class="hljs-string">'XColor'</span>, [<span class="hljs-number">.3</span> <span class="hljs-number">.3</span> <span class="hljs-number">.3</span>], <span class="hljs-string">'YColor'</span>, [<span class="hljs-number">.3</span> <span class="hljs-number">.3</span> <span class="hljs-number">.3</span>],<span class="hljs-string">'LineWidth'</span>, <span class="hljs-number">1</span>)<br><br>LineWidth    线宽,数值,如<span class="hljs-number">0.5</span>,<span class="hljs-number">1</span>等,单位为points<br>MarkerEdgeColor   标记点边框线条颜色,颜色字符,如’g’,’b’等<br>MarkerFaceColor   标记点内部区域填充颜色,颜色字符<br>MarkerSize   标记点大小,数值,单位为points<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
            <tag> 画图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim速查表</title>
      <link href="/2019/08/02/vim%E9%80%9F%E6%9F%A5%E8%A1%A8/"/>
      <url>/2019/08/02/vim%E9%80%9F%E6%9F%A5%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>本文主要介绍了以下内容:</strong></p><p>本文主要介绍了vim的一些快捷键，方便自己要用的时候查找。</p><a id="more"></a><h2 id="VIM使用说明与快捷键"><a href="#VIM使用说明与快捷键" class="headerlink" title="VIM使用说明与快捷键"></a>VIM使用说明与快捷键</h2><p><img src="https://huris.oss-cn-hangzhou.aliyuncs.com/blog/vim%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E4%B8%8E%E5%BF%AB%E6%8D%B7%E9%94%AE.jpg"></p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><div class="table-container"><table><thead><tr><th style="text-align:center">移动方向</th><th style="text-align:center">快捷键</th></tr></thead><tbody><tr><td style="text-align:center">左</td><td style="text-align:center">h</td></tr><tr><td style="text-align:center">上</td><td style="text-align:center">j</td></tr><tr><td style="text-align:center">下</td><td style="text-align:center">k</td></tr><tr><td style="text-align:center">右</td><td style="text-align:center">l</td></tr></tbody></table></div><h3 id="进入插入模式"><a href="#进入插入模式" class="headerlink" title="进入插入模式"></a>进入插入模式</h3><div class="table-container"><table><thead><tr><th style="text-align:center">插入模式</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">i</td><td style="text-align:center">在光标前面插入</td></tr><tr><td style="text-align:center">I</td><td style="text-align:center">在光标所在行最前面插入</td></tr><tr><td style="text-align:center">a</td><td style="text-align:center">在光标后面插入</td></tr><tr><td style="text-align:center">A</td><td style="text-align:center">在光标所在行最后面插入</td></tr><tr><td style="text-align:center">o</td><td style="text-align:center">光标所在行的下一行插入</td></tr><tr><td style="text-align:center">O</td><td style="text-align:center">光标所在行的上一行插入</td></tr><tr><td style="text-align:center">s</td><td style="text-align:center">删除光标指向的字符并进入插入模式</td></tr><tr><td style="text-align:center">S</td><td style="text-align:center">删除光标所在的行并插入</td></tr></tbody></table></div><h3 id="操作范围"><a href="#操作范围" class="headerlink" title="操作范围"></a>操作范围</h3><div class="table-container"><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">将光标移到行首</td></tr><tr><td style="text-align:center">$</td><td style="text-align:center">将光标移到行尾</td></tr><tr><td style="text-align:center">b  (begin)</td><td style="text-align:center">将光标移到单词起始处</td></tr><tr><td style="text-align:center">e  (end)</td><td style="text-align:center">将光标移到单词末尾</td></tr><tr><td style="text-align:center">w</td><td style="text-align:center">将光标移到下一个单词的开头</td></tr><tr><td style="text-align:center">gg</td><td style="text-align:center">将光标移到文件的开头</td></tr><tr><td style="text-align:center">G</td><td style="text-align:center">将光标移到文件的末尾</td></tr></tbody></table></div><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><div class="table-container"><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">d0</td><td style="text-align:center">删除光标到行首的所有字符</td></tr><tr><td style="text-align:center">d$</td><td style="text-align:center">删除光标到行尾的所有字符</td></tr><tr><td style="text-align:center">db</td><td style="text-align:center">删除光标到该单词行首的所有字符</td></tr><tr><td style="text-align:center">de</td><td style="text-align:center">删除光标到该单词行尾的所有字符</td></tr><tr><td style="text-align:center">dw</td><td style="text-align:center">删除光标到下一个单词开头的所有字符</td></tr><tr><td style="text-align:center">dh</td><td style="text-align:center">删除光标所在字符的上一个字符</td></tr><tr><td style="text-align:center">dl</td><td style="text-align:center">删除光标所在字符</td></tr><tr><td style="text-align:center">dj</td><td style="text-align:center">删除光标所在行和下一行</td></tr><tr><td style="text-align:center">dk</td><td style="text-align:center">删除光标所在行和上一行</td></tr><tr><td style="text-align:center">dd</td><td style="text-align:center">删除光标所在行</td></tr><tr><td style="text-align:center">dgg</td><td style="text-align:center">删除光标所在行到文件开头所有字符</td></tr><tr><td style="text-align:center">dG</td><td style="text-align:center">删除光标所在行到文件末尾所有字符</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 计算机工具 </category>
          
          <category> vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
            <tag> 速查表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数阶乘</title>
      <link href="/2019/08/02/%E5%A4%A7%E6%95%B0%E9%98%B6%E4%B9%98/"/>
      <url>/2019/08/02/%E5%A4%A7%E6%95%B0%E9%98%B6%E4%B9%98/</url>
      
        <content type="html"><![CDATA[<p><strong>本文主要介绍了以下内容:</strong></p><p>求n!具体值c++实现</p><a id="more"></a><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;//大数N!  </span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;  </span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;  <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  <br></span>&#123;  <br>    <span class="hljs-keyword">int</span> n,a[<span class="hljs-number">100000</span>],i,j,wei,up;  <br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n)!=EOF)  <br>    &#123;  <br>        <span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(a));<span class="hljs-comment">//一定要清零  </span><br>        up=<span class="hljs-number">0</span>;  <br>        wei=<span class="hljs-number">1</span>;  <br>        a[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-comment">//当前结果的位数，便于相乘和最后输出   </span><br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>||n==<span class="hljs-number">0</span>)  <br>        &#123;  <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"1\n"</span>);  <br>            <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//如果为1!或0!则输出后直接进行下一个阶乘计算  </span><br>        &#125;  <br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>; i&lt;=n; i++)<span class="hljs-comment">//N!中的每个数  </span><br>        &#123;  <br>            <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>,up=<span class="hljs-number">0</span>; j&lt;=wei; j++)  <br>            &#123;  <br>                a[j]=a[j]*i+up; <span class="hljs-comment">//当前j数加 进位  </span><br>                up=a[j]/<span class="hljs-number">10</span>;<span class="hljs-comment">//进位整除10  </span><br>                a[j]=a[j]%<span class="hljs-number">10</span>;<span class="hljs-comment">//当前数取余存储  </span><br>            &#125;  <br>            <span class="hljs-keyword">while</span>(up&gt;<span class="hljs-number">0</span>)<span class="hljs-comment">//最后首位大于0则要取余进位  </span><br>            &#123;  <br>                a[j++]+=up%<span class="hljs-number">10</span>;<span class="hljs-comment">//j++的值为进位取余 注意 j++导致后面的j加了一  </span><br>                up=up/<span class="hljs-number">10</span>;  <br>            &#125;  <br>            wei=j<span class="hljs-number">-1</span>;<span class="hljs-comment">//减去上面的j++  </span><br>        &#125;  <br>        <span class="hljs-keyword">for</span>(i=wei; i&gt;=<span class="hljs-number">1</span>; i--)  <br>            (i!=<span class="hljs-number">1</span>)? <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,a[i]) : <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,a[i]);<span class="hljs-comment">//三目 判断是否为最后一位 则输出换行  </span><br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
          <category> 算法模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数 </tag>
            
            <tag> 算法模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++文件操作</title>
      <link href="/2018/05/11/c++%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/05/11/c++%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p><strong>本文主要介绍了以下内容:</strong></p><p>c++的读取文件/输入方式总结</p><a id="more"></a><p><strong>getline(istream &amp;in,string &amp;s)</strong></p><p>​    从输入流读入一行到string s</p><p>功能</p><ul><li>从输入流中读取字符，存到string 变量中</li><li>一直到出现以下情况为止<ul><li>读入了文件结束标志</li><li>读到了一个新行</li><li>达到字符串的最大长度</li></ul></li><li>如果getline没有读入字符，将返回false,可用于判断文件是否结束</li></ul><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;<br>    <span class="hljs-built_in">string</span> buff;<br>    ifstream infile;<br>    ofstream outfile;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Input file name: "</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;buff;<br>    infile.open(buff.c_str());<br><br>    <span class="hljs-keyword">if</span>(!infile)<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"error"</span>&lt;&lt;buff&lt;&lt;<span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Input outfile name: "</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;buff;<br>    outfile.open(buff.c_str());<br><br>    <span class="hljs-keyword">while</span>(getline(infile, buff))<br>        outfile&lt;&lt;buff&lt;&lt;<span class="hljs-built_in">endl</span>;<br><br>    infile.close();<br>    outfile.close();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab学习笔记(8)</title>
      <link href="/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-8/"/>
      <url>/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-8/</url>
      
        <content type="html"><![CDATA[<p><strong>本文主要介绍了以下内容:</strong></p><p>matlab程序流程控制:</p><ol><li>M文件的概念与基本操作</li><li>matlab程序控制结构</li><li>matlab函数文件</li><li>matlab程序调试与优化</li></ol><a id="more"></a><h1 id="M文件"><a href="#M文件" class="headerlink" title="M文件"></a>M文件</h1><p>用matlab语言编写的程序,称为M文件</p><p>M文件是由若干matlab命令组合在一起构成的,它可以完成某些操作,也可以实现某种算法</p><p>matlab提供的内部函数以及各种工具箱,都是利用matlab命令开发的M文件</p><p>用户可以根据自己的需要,开发具体的程序或工具箱</p><h2 id="M文件的分类"><a href="#M文件的分类" class="headerlink" title="M文件的分类"></a>M文件的分类</h2><p>通常,M文件可以根据调用方式的不同分为两类:<strong>命令文件(脚本文件)</strong>和<strong>函数文件</strong>,它们的扩展名均为<strong>.m</strong></p><p>主要区别:</p><ol><li><p>命令文件没有参数,也不会返回输出参数,而函数文件可以带参数,也可以返回输出参数</p></li><li><p>命令文件对matlab工作空间中的变量进行操作,文件中所有命令的执行结果也完全返回到工作空间中,而函数文件中定义的变量为<strong>局部变量</strong>,当函数文件执行完毕时,这些变量被清除</p></li><li><p>命令文件可以直接运行,在matlab命令行窗口输入命令文件的名字,就会顺序执行命令文件中的命令,而函数文件不能直接运行,要以函数调用的方式来调用</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab学习笔记(7)</title>
      <link href="/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-7/"/>
      <url>/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-7/</url>
      
        <content type="html"><![CDATA[<p><strong>本文主要介绍了以下内容:</strong></p><p>字符串</p><a id="more"></a><h3 id="字符串的表示"><a href="#字符串的表示" class="headerlink" title="字符串的表示"></a>字符串的表示</h3><p>在matlab中,字符串是用单撇号括起来的字符序列,例如:</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; s=<span class="hljs-string">'hello world'</span><br><br>s =<br><br>    <span class="hljs-string">'hello world'</span><br></code></pre></td></tr></table></figure><p>matlab将字符串当做一个行向量,每个元素对应一个字符,其标识方法和数值向量相同,也可以建立多行字符串矩阵,例如:</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; s=[<span class="hljs-string">'hello '</span>,<span class="hljs-string">'hu ben'</span>]<br><br>s =<br><br>    <span class="hljs-string">'hello hu ben'</span><br></code></pre></td></tr></table></figure><p>这里要求各行字符数要相等,为此,有时候必须添加几个空格来保证各行的长度相等</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; ch=<span class="hljs-string">'abcdefg1234567ABCDEFG'</span><br><br>ch =<br><br>    <span class="hljs-string">'abcdefg1234567ABCDEFG'</span><br><br>&gt;&gt; subch=ch(<span class="hljs-number">1</span>:<span class="hljs-number">5</span>)<span class="hljs-comment">%取子串</span><br><br>subch =<br><br>    <span class="hljs-string">'abcde'</span><br><br>&gt;&gt; revch=ch(<span class="hljs-keyword">end</span>:<span class="hljs-number">-1</span>:<span class="hljs-number">1</span>)<span class="hljs-comment">%反转字符串</span><br><br>revch =<br><br>    <span class="hljs-string">'GFEDCBA7654321gfedcba'</span><br> <br>&gt;&gt; k=<span class="hljs-built_in">find</span>(ch&gt;=<span class="hljs-string">'a'</span>&amp;ch&lt;=<span class="hljs-string">'z'</span>)<span class="hljs-comment">%找到特定字符</span><br><br>k =<br><br>     <span class="hljs-number">1</span>     <span class="hljs-number">2</span>     <span class="hljs-number">3</span>     <span class="hljs-number">4</span>     <span class="hljs-number">5</span>     <span class="hljs-number">6</span>     <span class="hljs-number">7</span><br><br>&gt;&gt; ch(k)=ch(k)-<span class="hljs-string">'a'</span>+<span class="hljs-string">'A'</span><span class="hljs-comment">%修改特定字符</span><br><br>ch =<br><br>    <span class="hljs-string">'ABCDEFG1234567ABCDEFG'</span><br><br>&gt;&gt; <span class="hljs-built_in">length</span>(ch)<span class="hljs-comment">%计算字符串ch的长度</span><br><br><span class="hljs-built_in">ans</span> =<br><br>    <span class="hljs-number">21</span><br></code></pre></td></tr></table></figure><h3 id="字符串的操作"><a href="#字符串的操作" class="headerlink" title="字符串的操作"></a>字符串的操作</h3><h4 id="字符串的执行"><a href="#字符串的执行" class="headerlink" title="字符串的执行"></a>字符串的执行</h4><p>与字符串有关的一个重要函数是<strong>eval</strong>,它的作用是把字符串的内容作为对应的matlab命令来执行,其调用格式为:<strong>eval(s)</strong></p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; t=<span class="hljs-built_in">pi</span><br><br>t =<br><br>   <span class="hljs-number">3.141592653589793</span><br><br>&gt;&gt; m=<span class="hljs-string">'[t,sin(t),cos(t)]'</span>;<br>&gt;&gt; y=eval(m)<br><br>y =<br><br>   <span class="hljs-number">3.141592653589793</span>   <span class="hljs-number">0.000000000000000</span>  <span class="hljs-number">-1.000000000000000</span><br></code></pre></td></tr></table></figure><h4 id="字符串与数值之间的转换"><a href="#字符串与数值之间的转换" class="headerlink" title="字符串与数值之间的转换"></a>字符串与数值之间的转换</h4><p>字符串是以ASCII码来保存的,<strong>abs</strong>和<strong>double</strong>函数都可以用来获取字符串矩阵对应的ASCII码数值矩阵</p><p>相反,<strong>char</strong>函数可以把ASCII码矩阵转换为字符串矩阵,例如:</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; s1=<span class="hljs-string">'matlab'</span><br><br>s1 =<br><br>    <span class="hljs-string">'matlab'</span><br><br>&gt;&gt; a=<span class="hljs-built_in">abs</span>(s1)<br><br>a =<br><br>   <span class="hljs-number">109</span>    <span class="hljs-number">97</span>   <span class="hljs-number">116</span>   <span class="hljs-number">108</span>    <span class="hljs-number">97</span>    <span class="hljs-number">98</span><br><br>&gt;&gt; char(a)<br><br><span class="hljs-built_in">ans</span> =<br><br>    <span class="hljs-string">'matlab'</span><br></code></pre></td></tr></table></figure><p>matlab还有很多用于字符串和数值数据之间转换的函数,例如,<strong>setstr</strong>函数将ASCII码值转换为对应的字符,<strong>str2num</strong>函数或<strong>str2double</strong>函数将数字字符串转换成数值,<strong>num2str</strong>函数将数值转换成字符串,<strong>int2str</strong>函数将整数转换成字符串</p><h4 id="字符串的连接"><a href="#字符串的连接" class="headerlink" title="字符串的连接"></a>字符串的连接</h4><p>用中括号将若干个字符串括起来,从而得到一个更大的字符串</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; a=<span class="hljs-string">'12345'</span>;<br>&gt;&gt; b=<span class="hljs-string">'4321'</span>;<br>&gt;&gt; [a,b]<br><br><span class="hljs-built_in">ans</span> =<br><br>    <span class="hljs-string">'123454321'</span><br></code></pre></td></tr></table></figure><h4 id="字符串的比较"><a href="#字符串的比较" class="headerlink" title="字符串的比较"></a>字符串的比较</h4><h5 id="利用关系运算符进行比较"><a href="#利用关系运算符进行比较" class="headerlink" title="利用关系运算符进行比较"></a>利用关系运算符进行比较</h5><p>当两个字符串长度相等时,可以<strong>直接</strong>利用关系运算符进行比较,比较的规则是按ASCII值大小进行比较的</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; a=<span class="hljs-string">'134567'</span>;<br>&gt;&gt; b=<span class="hljs-string">'213145'</span>;<br>&gt;&gt; a&gt;b<br><br><span class="hljs-built_in">ans</span> =<br><br>  <span class="hljs-number">1</span>×<span class="hljs-number">6</span> logical 数组<br><br>   <span class="hljs-number">0</span>   <span class="hljs-number">1</span>   <span class="hljs-number">1</span>   <span class="hljs-number">1</span>   <span class="hljs-number">1</span>   <span class="hljs-number">1</span><br><br>&gt;&gt; a&lt;b<br><br><span class="hljs-built_in">ans</span> =<br><br>  <span class="hljs-number">1</span>×<span class="hljs-number">6</span> logical 数组<br><br>   <span class="hljs-number">1</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span><br><br>&gt;&gt; a==b<br><br><span class="hljs-built_in">ans</span> =<br><br>  <span class="hljs-number">1</span>×<span class="hljs-number">6</span> logical 数组<br><br>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h5 id="利用字符串比较函数进行比较"><a href="#利用字符串比较函数进行比较" class="headerlink" title="利用字符串比较函数进行比较"></a>利用字符串比较函数进行比较</h5><ol><li><strong>strcmp(s1,s2)</strong>:比较s1和s2<strong>所有字符是否完全相等</strong></li><li><strong>strncmp(s1,s2)</strong>:比较s1和s2<strong>前n个字符是否完全相等</strong></li><li><strong>strcmpi(s1,s2)</strong>:<strong>在忽略字母大小写的情况下</strong>,比较s1和s2<strong>所有字符是否相等</strong></li><li><strong>strncmpi(s1,s2)</strong>:<strong>在忽略字母大小写的情况下</strong>,比较s1和s2<strong>前n个字符是否相等</strong></li></ol><h4 id="字符串的查找与替换"><a href="#字符串的查找与替换" class="headerlink" title="字符串的查找与替换"></a>字符串的查找与替换</h4><h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><p><strong>findstr(s1,s2)</strong>:返回短字符串s2在长字符串s1中出现的位置</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; a=<span class="hljs-string">'12321232123'</span>;<br>&gt;&gt; b=<span class="hljs-string">'123'</span>;<br>&gt;&gt; findstr(a,b)<br><br><span class="hljs-built_in">ans</span> =<br><br>     <span class="hljs-number">1</span>     <span class="hljs-number">5</span>     <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h5 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h5><p><strong>strrep(s1,s2,s3)</strong>:将字符串s1中<strong>所有</strong>子字符串s2替换为字符串s3</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; a=<span class="hljs-string">'12321232123'</span>;<br>&gt;&gt; b=<span class="hljs-string">'123'</span>;<br>&gt;&gt; findstr(a,b)<br><br><span class="hljs-built_in">ans</span> =<br><br>     <span class="hljs-number">1</span>     <span class="hljs-number">5</span>     <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab学习笔记(6)</title>
      <link href="/2018/04/30/matalb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6/"/>
      <url>/2018/04/30/matalb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6/</url>
      
        <content type="html"><![CDATA[<p><strong>matlab学习笔记(6)主要介绍了以下内容:</strong></p><p>矩阵分析</p><ol><li>对角阵与三角阵</li><li>矩阵的转置与旋转</li><li>矩阵的逆与伪逆</li><li>方阵的行列式</li><li>矩阵的秩与迹</li><li>向量和矩阵的范数</li><li>矩阵的条件数</li><li>矩阵的特征值与特征向量</li><li>矩阵的超越函数</li></ol><a id="more"></a><h3 id="对角阵与三角阵"><a href="#对角阵与三角阵" class="headerlink" title="对角阵与三角阵"></a>对角阵与三角阵</h3><h4 id="对角阵"><a href="#对角阵" class="headerlink" title="对角阵"></a>对角阵</h4><p>只有对角线上有非0元素的矩阵称为<strong>对角矩阵</strong>,对角线上的元素相等的对角矩阵称为<strong>数量矩阵</strong>,对角线上都为1的矩阵称为<strong>单位矩阵</strong></p><h5 id="提取矩阵的对角线元素"><a href="#提取矩阵的对角线元素" class="headerlink" title="提取矩阵的对角线元素"></a>提取矩阵的对角线元素</h5><p>调用函数diag(a)</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br><span class="hljs-built_in">diag</span>(a)=<br><span class="hljs-number">1.00</span><br><span class="hljs-number">5.00</span><br><span class="hljs-number">9.00</span><br></code></pre></td></tr></table></figure><ul><li>diag(a)函数还有一种形式diag(a,k),其功能是提取<strong>第k条对角线元素</strong></li><li>与主对角线平行,往上为第1条,第2条,…,第n条对角线,往下为第-1条,第-2条,…,第-n条</li><li>主对角线为第0条对角线</li></ul><h5 id="构造对角矩阵"><a href="#构造对角矩阵" class="headerlink" title="构造对角矩阵"></a>构造对角矩阵</h5><p>设<strong>V</strong>为具有m个元素的向量,diag(<strong>V</strong>)将产生一个m×m对角矩阵,其主对角线元素即为向量<strong>V</strong>的元素</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-built_in">diag</span>(<span class="hljs-number">1</span>:<span class="hljs-number">3</span>)=<br><span class="hljs-number">1.00</span>       <span class="hljs-number">0</span>       <span class="hljs-number">0</span><br>   <span class="hljs-number">0</span>    <span class="hljs-number">2.00</span>       <span class="hljs-number">0</span><br>   <span class="hljs-number">0</span>       <span class="hljs-number">0</span>    <span class="hljs-number">3.00</span><br></code></pre></td></tr></table></figure><p>diag(<strong>V</strong>,k)创建一个矩阵,对角线向上或者向下移动k个单位,<strong>还是形成方阵</strong></p><h5 id="三角阵"><a href="#三角阵" class="headerlink" title="三角阵"></a>三角阵</h5><p>三角阵分为<strong>上三角阵</strong>(矩阵对角线以下的元素全为0的矩阵)和<strong>下三角阵</strong>(矩阵对角线以上的元素全为0的矩阵)</p><h6 id="上三角矩阵"><a href="#上三角矩阵" class="headerlink" title="上三角矩阵"></a>上三角矩阵</h6><p>调用函数<strong>triu(a)</strong></p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br><span class="hljs-built_in">triu</span>(a)=<br>          <span class="hljs-number">1.00</span>          <span class="hljs-number">2.00</span>          <span class="hljs-number">3.00</span><br>             <span class="hljs-number">0</span>          <span class="hljs-number">5.00</span>          <span class="hljs-number">6.00</span><br>             <span class="hljs-number">0</span>             <span class="hljs-number">0</span>          <span class="hljs-number">9.00</span><br></code></pre></td></tr></table></figure><p><strong>triu(a,k)</strong>求矩阵a的第k条对角线以上的元素</p><h6 id="下三角矩阵"><a href="#下三角矩阵" class="headerlink" title="下三角矩阵"></a>下三角矩阵</h6><p>调用函数<strong>tril(a)</strong></p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br><span class="hljs-built_in">tril</span>(a)=<br>          <span class="hljs-number">1.00</span>             <span class="hljs-number">0</span>             <span class="hljs-number">0</span><br>          <span class="hljs-number">4.00</span>          <span class="hljs-number">5.00</span>             <span class="hljs-number">0</span><br>          <span class="hljs-number">7.00</span>          <span class="hljs-number">8.00</span>          <span class="hljs-number">9.00</span><br></code></pre></td></tr></table></figure><p><strong>tril(a,k)</strong>求矩阵a的第k条对角线以下的元素</p><h3 id="矩阵的转置与旋转"><a href="#矩阵的转置与旋转" class="headerlink" title="矩阵的转置与旋转"></a>矩阵的转置与旋转</h3><h4 id="矩阵的转置"><a href="#矩阵的转置" class="headerlink" title="矩阵的转置"></a>矩阵的转置</h4><p>把源矩阵的第1行变成目标矩阵的第1列,第2行变成第2列,…,以此类推</p><p>转置运算符是  <strong>.’</strong></p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">71</span>,<span class="hljs-number">3</span>,<span class="hljs-number">-8</span>;<span class="hljs-number">2</span>,<span class="hljs-number">-9</span>,<span class="hljs-number">8</span>;<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br>a.'=<br>         <span class="hljs-number">71.00</span>          <span class="hljs-number">2.00</span>             <span class="hljs-number">0</span><br>          <span class="hljs-number">3.00</span>         <span class="hljs-number">-9.00</span>          <span class="hljs-number">4.00</span><br>         <span class="hljs-number">-8.00</span>          <span class="hljs-number">8.00</span>          <span class="hljs-number">5.00</span><br></code></pre></td></tr></table></figure><p>还有一种转置叫做共轭转置,其运算符是单个引号  <strong>‘</strong>  ,它在转置的基础上还要取每个数的复共轭</p><p>例如: <strong>b=a’</strong>得到的b就是a的共轭转置矩阵,等价于<strong>b=conj(a).’</strong>或者<strong>b=conj(a.’)</strong></p><p>如果矩阵元素都是实数,那么转置和共轭转置得到的结果是一样的</p><h4 id="矩阵的旋转"><a href="#矩阵的旋转" class="headerlink" title="矩阵的旋转"></a>矩阵的旋转</h4><p>调用函数<strong>rot90(a,k)</strong></p><p>将矩阵a逆时针旋转90的k倍,当k=1时可省略不写</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br><span class="hljs-built_in">rot90</span>(a,<span class="hljs-number">2</span>)=<br>          <span class="hljs-number">9.00</span>          <span class="hljs-number">8.00</span>          <span class="hljs-number">7.00</span><br>          <span class="hljs-number">6.00</span>          <span class="hljs-number">5.00</span>          <span class="hljs-number">4.00</span><br>          <span class="hljs-number">3.00</span>          <span class="hljs-number">2.00</span>          <span class="hljs-number">1.00</span><br></code></pre></td></tr></table></figure><h4 id="矩阵的左右翻"><a href="#矩阵的左右翻" class="headerlink" title="矩阵的左右翻"></a>矩阵的左右翻</h4><p>对矩阵实施左右翻转是将矩阵的第1列和最后1列调换,第2列和倒数第2列调换,…,依次类推</p><p>matlab对矩阵a实施左右翻转的函数是fliplr(a)</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br><span class="hljs-built_in">fliplr</span>(a)=<br>          <span class="hljs-number">3.00</span>          <span class="hljs-number">2.00</span>          <span class="hljs-number">1.00</span><br>          <span class="hljs-number">6.00</span>          <span class="hljs-number">5.00</span>          <span class="hljs-number">4.00</span><br>          <span class="hljs-number">9.00</span>          <span class="hljs-number">8.00</span>          <span class="hljs-number">7.00</span><br></code></pre></td></tr></table></figure><h4 id="矩阵的上下翻转"><a href="#矩阵的上下翻转" class="headerlink" title="矩阵的上下翻转"></a>矩阵的上下翻转</h4><p>对矩阵实施上下翻转是将矩阵的第1行和最后1行调换,第2行和倒数第2行调换,…,依次类推</p><p>matlab对矩阵a实施上下翻转的函数是flipud(a)</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br><span class="hljs-built_in">flipud</span>(a)=<br>          <span class="hljs-number">7.00</span>          <span class="hljs-number">8.00</span>          <span class="hljs-number">9.00</span><br>          <span class="hljs-number">4.00</span>          <span class="hljs-number">5.00</span>          <span class="hljs-number">6.00</span><br>          <span class="hljs-number">1.00</span>          <span class="hljs-number">2.00</span>          <span class="hljs-number">3.00</span><br></code></pre></td></tr></table></figure><h3 id="矩阵的逆与伪逆"><a href="#矩阵的逆与伪逆" class="headerlink" title="矩阵的逆与伪逆"></a>矩阵的逆与伪逆</h3><h4 id="矩阵的逆"><a href="#矩阵的逆" class="headerlink" title="矩阵的逆"></a>矩阵的逆</h4><p>对于一个方阵a,如果存在一个与其同阶的方阵b,使得</p><script type="math/tex; mode=display">a·b=b·a=I(I为单位矩阵)</script><p>则称b为a的逆矩阵,当然,a也是b的逆矩阵</p><p>在matlab中求逆矩阵直接使用<strong>inv(a)</strong>即可</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>;<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>;<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br>inv(a)=<br>          <span class="hljs-number">5.22</span>          <span class="hljs-number">1.44</span>         <span class="hljs-number">-3.22</span><br>         <span class="hljs-number">-5.11</span>         <span class="hljs-number">-1.22</span>          <span class="hljs-number">3.11</span><br>          <span class="hljs-number">2.22</span>          <span class="hljs-number">0.44</span>         <span class="hljs-number">-1.22</span><br></code></pre></td></tr></table></figure><h4 id="矩阵的伪逆"><a href="#矩阵的伪逆" class="headerlink" title="矩阵的伪逆"></a>矩阵的伪逆</h4><p>如果矩阵a不是一个方阵,或者a是一个非满秩的方阵时,矩阵a没有逆矩阵,但可以找到一个与a的转置矩阵a’同型的矩阵b使得</p><script type="math/tex; mode=display">a·b·a=a\\\b·a·b=b</script><p>此时称矩阵b为矩阵a的伪逆,也称为广义逆矩阵,可以使用函数<strong>pinv(a)</strong>求解</p><figure class="hljs highlight Matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Matlab">a=[<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>];<br>pinv(a)=<br>          <span class="hljs-number">0.39</span>         <span class="hljs-number">-0.11</span>         <span class="hljs-number">-0.11</span><br>         <span class="hljs-number">-0.11</span>          <span class="hljs-number">0.39</span>         <span class="hljs-number">-0.11</span><br>         <span class="hljs-number">-0.11</span>         <span class="hljs-number">-0.11</span>          <span class="hljs-number">0.39</span><br>          <span class="hljs-number">0.04</span>          <span class="hljs-number">0.04</span>          <span class="hljs-number">0.04</span><br></code></pre></td></tr></table></figure><p>若a是一个奇异矩阵(行列式为0),无一般意义上的逆矩阵,但可以求a得伪逆矩阵,例如:</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>];<br>pinv(a)=<br>             <span class="hljs-number">0</span>             <span class="hljs-number">0</span>             <span class="hljs-number">0</span><br>             <span class="hljs-number">0</span>          <span class="hljs-number">1.00</span>             <span class="hljs-number">0</span><br>             <span class="hljs-number">0</span>             <span class="hljs-number">0</span>          <span class="hljs-number">1.00</span><br></code></pre></td></tr></table></figure><h3 id="方阵的行列式"><a href="#方阵的行列式" class="headerlink" title="方阵的行列式"></a>方阵的行列式</h3><p>调用函数det(a)求解</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>;<span class="hljs-number">-3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>];<br>det(a)=<br><span class="hljs-number">-10.00</span><br></code></pre></td></tr></table></figure><h3 id="矩阵的秩与迹"><a href="#矩阵的秩与迹" class="headerlink" title="矩阵的秩与迹"></a>矩阵的秩与迹</h3><h4 id="矩阵的秩"><a href="#矩阵的秩" class="headerlink" title="矩阵的秩"></a>矩阵的秩</h4><p>矩阵线性无关的行数与列数称为矩阵的秩</p><p>调用函数rank(a)</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>];<br>rank(a)=<br><span class="hljs-number">3.00</span><br></code></pre></td></tr></table></figure><h4 id="矩阵的迹"><a href="#矩阵的迹" class="headerlink" title="矩阵的迹"></a>矩阵的迹</h4><p>矩阵的迹等于矩阵的对角线元素之和,也等于矩阵的特征值之和</p><p>调用函数trace(a)</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>];<br>trace(a)=<br><span class="hljs-number">3.00</span><br></code></pre></td></tr></table></figure><h3 id="向量和矩阵范数"><a href="#向量和矩阵范数" class="headerlink" title="向量和矩阵范数"></a>向量和矩阵范数</h3><p>矩阵或向量的范数用来度量矩阵或向量在某种意义下的长度</p><p>范数有多种方法定义,其定义不同,范数值也就不同,因此,讨论范数时,一定要弄清是哪一种范数</p><h4 id="向量的三种常用范数及其计算函数"><a href="#向量的三种常用范数及其计算函数" class="headerlink" title="向量的三种常用范数及其计算函数"></a>向量的三种常用范数及其计算函数</h4><p>向量的1-范数:向量元素的绝对值之和     <strong>norm(V,1)</strong></p><script type="math/tex; mode=display">\\left\\| v\\right\\| \_{1}=\\sum ^{n}\_{i=1}\\left| v\_{i}\\right|</script><p>向量的2-范数:向量元素平方和的平方根    <strong>norm(V,2)</strong></p><script type="math/tex; mode=display">\\left\\| v\\right\\|\_{2} =\\sqrt {\\sum ^{n}\_{i=1}v^{2}\_{i}}</script><p>向量的∞-范数:所有向量元素绝对值中的最大值     <strong>norm(V,inf)</strong></p><script type="math/tex; mode=display">\\left\\|v\\right\\|\_{∞} =\\max \_{1\\leq i\\leq n}\\left\\{ \\left| V\_{i}\\right| \\right\\}</script><h4 id="矩阵的范数及其计算函数"><a href="#矩阵的范数及其计算函数" class="headerlink" title="矩阵的范数及其计算函数"></a>矩阵的范数及其计算函数</h4><p>设a是一个m×n的矩阵,V是一个含有n个元素的列向量,定义</p><script type="math/tex; mode=display">\\left\\| a\\right\\|=max\\left\\| a·V\\right\\| ,\\left\\| V\\right\\| =1</script><p>矩阵a的1-范数:所有矩阵列元素绝对值之和的最大值  <strong>norm(a,1)</strong></p><script type="math/tex; mode=display">\\left\\| a\\right\\| \_{1}=\\max \_{1\\leq j\\leq n}\\left\\{ \\sum ^{m}\_{i=1}\\left| a\_{ij}\\right|  \\right\\}</script><p>矩阵a的2-范数:a’a矩阵的最大特征值的平方根    <strong>norm(V,2)</strong></p><script type="math/tex; mode=display">\\left\\| a\\right\\|\_{2} =\\sqrt {\\lambda \_{1}}     (其中\\lambda \_{1}为a'a的最大特征值)</script><p>向量的∞-范数:所有向量元素绝对值中的最大值     <strong>norm(V,inf)</strong></p><script type="math/tex; mode=display">\\left\\| a\\right\\|\_{∞} =\\max\_{1\\leq i\\leq m}\\left\\{\\sum ^{n}\_{j=1}\\left| a\_{ij}\\right|  \\right\\}</script><h3 id="矩阵的条件数"><a href="#矩阵的条件数" class="headerlink" title="矩阵的条件数"></a>矩阵的条件数</h3><p>在求解线性方程组AX=B时,一般认为,系数矩阵A中个别元素的微小扰动不会引起解向量的很大变化</p><p>这样的假设在工程应用中非常重要,因为一般系数矩阵的数据是由实验数据获得的,并非精确值,但与精确值误差不大</p><p>由上面的假设可以得出如下结论:</p><p><strong>当参与运算的系数与实数精确值误差很小时,所获得的解与问题的准确解误差也很小</strong></p><p>遗憾的是,上述假设并非总是正确的</p><p>对于有的系数矩阵,个别元素的微小扰动会引起解的很大变化,在计算数学中,称这种矩阵为<strong>病态矩阵</strong>,而称解不因其系数矩阵的微小扰动而发生大的变化的矩阵为<strong>良性矩阵</strong></p><p>当然,<strong>良性</strong>与<strong>病态</strong>是相对的,需要一个参数来描述,条件数就是用来描述矩阵的这种性能的一个参数</p><p>矩阵a的条件数等于a的范数与a的逆矩阵的范数的乘积,这样定义的条件数总是大于1的</p><p>计算a的1-范数下的条件数    <strong>cond(a,1)</strong></p><script type="math/tex; mode=display">cond(a,1)=\\left\\| a\\right\\|\_{1}·\\left\\| a^{-1}\\right\\|\_{1}</script><p>计算a的2-范数下的条件数    <strong>cond(a,2)</strong></p><script type="math/tex; mode=display">cond(a,2)=\\left\\| a\\right\\|\_{2}·\\left\\| a^{-1}\\right\\|\_{2}</script><p>计算a的∞-范数下的条件数    <strong>cond(a,inf)</strong></p><script type="math/tex; mode=display">cond(a,∞)=\\left\\| a\\right\\|\_{∞}·\\left\\| a^{-1}\\right\\|\_{∞}</script><p><strong>条件数越接近于1,矩阵的性能越好,反之,矩阵的性能越差</strong></p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">-6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br>b=[<span class="hljs-number">2</span>,<span class="hljs-number">-5</span>,<span class="hljs-number">4</span>;<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">-2</span>;<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>];<br>cond(a)=<br>         <span class="hljs-number">87.98</span><br>cond(b)=<br>          <span class="hljs-number">3.75</span><br></code></pre></td></tr></table></figure><h3 id="矩阵的特征值与特征向量"><a href="#矩阵的特征值与特征向量" class="headerlink" title="矩阵的特征值与特征向量"></a>矩阵的特征值与特征向量</h3><p>对于n阶方阵a,求数λ和向量ξ,使得等式aξ=λξ成立</p><p>满足等式的数λ称为a的特征值,向量ξ称为a的特征向量</p><p>实际上,方程aξ=λξ和(a-λE)ξ=0是两个等价方程</p><p>要使方程(a-λE)ξ=0有非零解ξ,必须使其系数行列式为0,即|a-λE|=0</p><p>线性代数中已经证明,行列式|a-λE|是一个关于λ的n阶多项式,因而|a-λE|=0是一个n次方程,有n个根(含重根),就是矩阵a的n个特征值每一个特征值对应无穷多个特征向量</p><p><strong>矩阵的特征值问题有确定解,但特征向量问题没有确定解</strong></p><p>在matlab中,计算矩阵a的特征值和特征向量的函数是<strong>eig(a)</strong>,常用的调用格式有三种:</p><ol><li><strong>e=eig(a)</strong>:求矩阵a的全部特征值,构成<strong>向量e</strong></li><li><strong>[V,D]=eig(a)</strong>:求矩阵a的全部特征值,构成<strong>对角阵D</strong>,并求a得特征向量构成<strong>V</strong>的列向量</li><li><strong>[V,D]=eig(a,’nobalance’)</strong>:与2功能类似,第2种方法是先对a做相似变换后求矩阵a的特征值和特征向量,而第3种方法是直接求矩阵a的特征值和特征向量</li></ol><p>一个矩阵的特征向量有无穷多个,eig函数只找其中的n个,a的其他特征向量,均可由这n个特征向量的线性组合表示,例如:</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0.5</span>;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0.25</span>;<span class="hljs-number">0.5</span>,<span class="hljs-number">0.25</span>,<span class="hljs-number">2</span>];<br>[V,D]=eig(a)<br>V =<br>   <span class="hljs-number">0.721207129830347</span>   <span class="hljs-number">0.444281058188505</span>   <span class="hljs-number">0.531483411986466</span><br>  <span class="hljs-number">-0.686349287710169</span>   <span class="hljs-number">0.562109420455869</span>   <span class="hljs-number">0.461473352095774</span><br>  <span class="hljs-number">-0.093727963498713</span>  <span class="hljs-number">-0.697601133004864</span>   <span class="hljs-number">0.710329309608377</span><br>D =<br>  <span class="hljs-number">-0.016647283606310</span>                   <span class="hljs-number">0</span>                   <span class="hljs-number">0</span><br>                   <span class="hljs-number">0</span>   <span class="hljs-number">1.480121423189129</span>                   <span class="hljs-number">0</span><br>                   <span class="hljs-number">0</span>                   <span class="hljs-number">0</span>   <span class="hljs-number">2.536525860417180</span><br></code></pre></td></tr></table></figure><p>求得的三个特征值是-0.0166,1.4801和2.5365,各特征值对应的特征向量为V的各列构成的向量</p><h3 id="矩阵的超越函数"><a href="#矩阵的超越函数" class="headerlink" title="矩阵的超越函数"></a>矩阵的超越函数</h3><p>matlab的数学函数,如sqrt,exp,log等都是作用在矩阵的各元素上的</p><p>matlab还提供了一些直接作用于矩阵的超越函数,其函数名都是上述数学函数名之后缀以m,并规定输入参数a必须是方阵</p><h4 id="矩阵平方根sqrtm"><a href="#矩阵平方根sqrtm" class="headerlink" title="矩阵平方根sqrtm"></a>矩阵平方根sqrtm</h4><p><strong>sqrtm(a)</strong>计算矩阵a的平方根,这是在矩阵意义下的平方根,它与sqrt(a)的结果是不同的</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; a=[<span class="hljs-number">4</span>,<span class="hljs-number">2</span>;<span class="hljs-number">3</span>,<span class="hljs-number">6</span>];<br>&gt;&gt; b1=sqrtm(a)<br><br>b1 =<br><br>   <span class="hljs-number">1.917137824293506</span>   <span class="hljs-number">0.465175638988947</span><br>   <span class="hljs-number">0.697763458483421</span>   <span class="hljs-number">2.382313463282453</span><br><br>&gt;&gt; b1*b1<br><br><span class="hljs-built_in">ans</span> =<br><br>   <span class="hljs-number">4.000000000000000</span>   <span class="hljs-number">2.000000000000000</span><br>   <span class="hljs-number">3.000000000000000</span>   <span class="hljs-number">6.000000000000000</span><br><br>&gt;&gt; b2=<span class="hljs-built_in">sqrt</span>(a)<br><br>b2 =<br><br>   <span class="hljs-number">2.000000000000000</span>   <span class="hljs-number">1.414213562373095</span><br>   <span class="hljs-number">1.732050807568877</span>   <span class="hljs-number">2.449489742783178</span><br><br>&gt;&gt; b2*b2<br><br><span class="hljs-built_in">ans</span> =<br><br>   <span class="hljs-number">6.449489742783179</span>   <span class="hljs-number">6.292528739883945</span><br>   <span class="hljs-number">7.706742302257039</span>   <span class="hljs-number">8.449489742783177</span><br><br>&gt;&gt; b2.*b2<br><br><span class="hljs-built_in">ans</span> =<br><br>   <span class="hljs-number">4.000000000000000</span>   <span class="hljs-number">2.000000000000000</span><br>   <span class="hljs-number">3.000000000000000</span>   <span class="hljs-number">5.999999999999999</span><br></code></pre></td></tr></table></figure><p>若a为实对称<a href="https://en.wikipedia.org/wiki/Positive-definite_matrix" target="_blank" rel="noopener">正定矩阵</a>或复<a href="https://en.wikipedia.org/wiki/Hermitian_matrix" target="_blank" rel="noopener">埃尔米特(Hermitian)</a>正定阵,则一定能算出它的平方根</p><p><strong>但某些矩阵,如a=[0,1;0,0]就得不到平方根</strong></p><p>如果矩阵a含有负的特征值,则sqrtm(a)将会得到一个复矩阵,例如:</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; a=[<span class="hljs-number">4</span>,<span class="hljs-number">9</span>;<span class="hljs-number">16</span>,<span class="hljs-number">25</span>];<br>&gt;&gt; eig(a)<br><br><span class="hljs-built_in">ans</span> =<br><br>  <span class="hljs-number">-1.445218719101973</span><br>  <span class="hljs-number">30.445218719101973</span><br><br>&gt;&gt; b=sqrtm(a)<br><br>b =<br><br>  <span class="hljs-number">0.942137741124329</span> + <span class="hljs-number">0.996904315125749</span><span class="hljs-built_in">i</span>  <span class="hljs-number">1.557189914222098</span> - <span class="hljs-number">0.339272627367266</span><span class="hljs-built_in">i</span><br>  <span class="hljs-number">2.768337625283729</span> - <span class="hljs-number">0.603151337541807</span><span class="hljs-built_in">i</span>  <span class="hljs-number">4.575580874309223</span> + <span class="hljs-number">0.205268184602128</span><span class="hljs-built_in">i</span><br></code></pre></td></tr></table></figure><h4 id="矩阵对数logm"><a href="#矩阵对数logm" class="headerlink" title="矩阵对数logm"></a>矩阵对数logm</h4><p><strong>logm(a)</strong>计算矩阵a的自然对数</p><p>此函数输入参数的条件与输出结果间的关系和函数<strong>sqrtm(a)</strong>完全一样,例如:</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; a=[<span class="hljs-number">4</span>,<span class="hljs-number">9</span>;<span class="hljs-number">1</span>,<span class="hljs-number">5</span>];<br>&gt;&gt; l=logm(a)<br><br>l =<br><br>   <span class="hljs-number">1.063900819033590</span>   <span class="hljs-number">2.430842712580726</span><br>   <span class="hljs-number">0.270093634731192</span>   <span class="hljs-number">1.333994453764781</span><br></code></pre></td></tr></table></figure><h4 id="矩阵指数expm"><a href="#矩阵指数expm" class="headerlink" title="矩阵指数expm"></a>矩阵指数expm</h4><p><strong>expm(a)</strong>的功能就是求矩阵指数e^a^,例如,对上面计算所得到的a的自然对数l,求其矩阵指数b=e^l^</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; a=[<span class="hljs-number">4</span>,<span class="hljs-number">9</span>;<span class="hljs-number">1</span>,<span class="hljs-number">5</span>];<br>l=logm(a)<br><br>l =<br><br>   <span class="hljs-number">1.063900819033590</span>   <span class="hljs-number">2.430842712580726</span><br>   <span class="hljs-number">0.270093634731192</span>   <span class="hljs-number">1.333994453764781</span><br><br>&gt;&gt; expm(l)<br><br><span class="hljs-built_in">ans</span> =<br><br>   <span class="hljs-number">4.000000000000001</span>   <span class="hljs-number">9.000000000000002</span><br>   <span class="hljs-number">1.000000000000000</span>   <span class="hljs-number">5.000000000000000</span><br></code></pre></td></tr></table></figure><p>从这个结果可以看出,这里所得到的结果恰好和a相同,即<strong>expm函数</strong>和<strong>logm函数</strong>是互逆的</p><h4 id="普通矩阵函数funm"><a href="#普通矩阵函数funm" class="headerlink" title="普通矩阵函数funm"></a>普通矩阵函数funm</h4><p><strong>funm(a,@fun)</strong>对方阵a计算由fun定义的函数的矩阵函数值</p><p>例如,当fun取exp时,<strong>funm(a,@exp)</strong>可以计算矩阵a的指数,与<strong>expm(a)</strong>的计算结果是一样的</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs matlab">&gt;&gt; a=[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>;<span class="hljs-number">2</span>,<span class="hljs-number">-1</span>];<br>&gt;&gt; funm(a,@<span class="hljs-built_in">exp</span>)<br><br><span class="hljs-built_in">ans</span> =<br><br>   <span class="hljs-number">2.718281828459046</span>                   <span class="hljs-number">0</span><br>   <span class="hljs-number">2.350402387287603</span>   <span class="hljs-number">0.367879441171442</span><br><br>&gt;&gt; expm(a)<br><br><span class="hljs-built_in">ans</span> =<br><br>   <span class="hljs-number">2.718281828459046</span>                   <span class="hljs-number">0</span><br>   <span class="hljs-number">2.350402387287603</span>   <span class="hljs-number">0.367879441171442</span><br></code></pre></td></tr></table></figure><p><strong>funm函数</strong>可以用于<strong>exp</strong>,<strong>log</strong>,<strong>sin</strong>,<strong>cos</strong>,<strong>sinh</strong>和<strong>cosh</strong>等函数,但求矩阵的平方根只能使用<strong>sqrtm函数</strong></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab学习笔记(5)</title>
      <link href="/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/"/>
      <url>/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/</url>
      
        <content type="html"><![CDATA[<p><strong>matlab学习笔记(5)主要介绍了以下内容:</strong></p><ol><li>基本算术运算</li><li>点运算</li></ol><a id="more"></a><h4 id="基本算术运算"><a href="#基本算术运算" class="headerlink" title="基本算术运算"></a>基本算术运算</h4><p>matlab的基本算数运算有:+(加),-(减),*(乘),/(右除),\(左除),^(乘方)</p><h5 id="矩阵加减运算"><a href="#矩阵加减运算" class="headerlink" title="矩阵加减运算"></a>矩阵加减运算</h5><p>a和b必须同型(即大小相同)</p><h5 id="矩阵乘法运算"><a href="#矩阵乘法运算" class="headerlink" title="矩阵乘法运算"></a>矩阵乘法运算</h5><p>a为n×m矩阵,b为m×p矩阵才能进行乘法运算</p><h5 id="矩阵除法运算"><a href="#矩阵除法运算" class="headerlink" title="矩阵除法运算"></a>矩阵除法运算</h5><ul><li>在matlab中,有两种矩阵除法运算:/和\\,分别表示左除和右除</li><li>只有矩阵a的行列式不为零(即矩阵a为非奇异矩阵)才能进行实现</li><li>a\\b等效于a的逆左乘b矩阵,即inv(a)*b</li><li>b/a等效于a的逆右乘b矩阵,即b*inv(a)</li><li>对于标量的运算,两种除法运算的结果都相等</li><li>对于矩阵来说,左除和右除代表两种不同的除数矩阵和被除数矩阵的关系</li><li>对于矩阵来说,一般a\b不等于b/a</li></ul><h5 id="矩阵的乘方"><a href="#矩阵的乘方" class="headerlink" title="矩阵的乘方"></a>矩阵的乘方</h5><ul><li><p>a^x</p></li><li><p>要求a为方阵,x为标量</p></li><li><p>可以计算一个矩阵的方根,例如:</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br>a^<span class="hljs-number">0.1</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="点运算"><a href="#点运算" class="headerlink" title="点运算"></a>点运算</h4><p>在matlab中,有一种特殊的运算,因为其运算符是在有关算术运算符前面加点,所以叫点运算</p><p>点运算符有  .*  ,  ./  ,  .\  ,  .^</p><p>两矩阵进行点运算是指他们对应的对应元素进行相关运算,要求两矩阵的维数相同</p><h5 id="a-b"><a href="#a-b" class="headerlink" title="a.*b"></a>a.*b</h5><p>表示a和b单个元素之间对应相乘,例如</p><figure class="hljs highlight Matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br>b=[<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>;<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>;<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>];<br>a.*b=<br><span class="hljs-number">9</span> <span class="hljs-number">16</span> <span class="hljs-number">21</span><br><span class="hljs-number">24</span> <span class="hljs-number">25</span> <span class="hljs-number">24</span><br><span class="hljs-number">21</span> <span class="hljs-number">16</span> <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h5 id="a-b与b-a"><a href="#a-b与b-a" class="headerlink" title="a./b与b.\a"></a>a./b与b.\a</h5><p>a./b等价于b.\a,例如</p><figure class="hljs highlight Matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];<br>b=[<span class="hljs-number">-2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>;<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>];<br>a./b=<br><span class="hljs-number">-0.5</span> <span class="hljs-number">2.0</span> <span class="hljs-number">1.0</span><br><span class="hljs-number">-4.0</span> <span class="hljs-number">5.0</span> <span class="hljs-number">1.5</span><br>b.\a=<br><span class="hljs-number">-0.5</span> <span class="hljs-number">2.0</span> <span class="hljs-number">1.0</span><br><span class="hljs-number">-4.0</span> <span class="hljs-number">5.0</span> <span class="hljs-number">1.5</span><br></code></pre></td></tr></table></figure><h5 id="a-b-1"><a href="#a-b-1" class="headerlink" title="a.^b"></a>a.^b</h5><p>若两个矩阵同型,则<strong>a.^b</strong>表示两矩阵对应元素进行乘方运算,例如:</p><figure class="hljs highlight Matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>b=[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];<br>a.^b=<br><span class="hljs-number">1</span> <span class="hljs-number">32</span> <span class="hljs-number">729</span><br></code></pre></td></tr></table></figure><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>a.^<span class="hljs-number">2</span>=<br><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><figure class="hljs highlight Matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>b=[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];<br><span class="hljs-number">2.</span>^[a b]=<br><span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">8</span> <span class="hljs-number">16</span> <span class="hljs-number">32</span> <span class="hljs-number">64</span><br></code></pre></td></tr></table></figure><figure class="hljs highlight Matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Matlab"><span class="hljs-comment">%当x分别为0.1,0.4,0.7,1时,分别求y=sin(x)cos(x)的值</span><br>x=[<span class="hljs-number">0.1</span>,<span class="hljs-number">0.4</span>,<span class="hljs-number">0.7</span>,<span class="hljs-number">1</span>];<br><span class="hljs-built_in">sin</span>(x).*<span class="hljs-built_in">cos</span>(x)=<br> <span class="hljs-number">0.10</span>          <span class="hljs-number">0.36</span>          <span class="hljs-number">0.49</span>          <span class="hljs-number">0.45</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab学习笔记(4)</title>
      <link href="/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4/"/>
      <url>/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4/</url>
      
        <content type="html"><![CDATA[<p><strong>matlab学习笔记(4)主要介绍了以下内容:</strong></p><p>矩阵</p><a id="more"></a><h3 id="矩阵的建立"><a href="#矩阵的建立" class="headerlink" title="矩阵的建立"></a>矩阵的建立</h3><h4 id="直接输入法建立矩阵"><a href="#直接输入法建立矩阵" class="headerlink" title="直接输入法建立矩阵"></a>直接输入法建立矩阵</h4><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]<br></code></pre></td></tr></table></figure><h4 id="冒号表达式建立一个向量"><a href="#冒号表达式建立一个向量" class="headerlink" title="冒号表达式建立一个向量"></a>冒号表达式建立一个向量</h4><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=<span class="hljs-number">0</span>:<span class="hljs-number">1</span>:<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>如果冒号表达式中省略第二个冒号,则默认步长为1</p><h4 id="用linspace函数产生行向量"><a href="#用linspace函数产生行向量" class="headerlink" title="用linspace函数产生行向量"></a>用linspace函数产生行向量</h4><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-built_in">linspace</span>(l,r,n)<br></code></pre></td></tr></table></figure><p>其中l,r是生成向量的第一个元素和最后一个元素,n是元素总数,当n省略时,自动产生100个元素</p><h4 id="利用已建好的小矩阵拼接成大矩阵"><a href="#利用已建好的小矩阵拼接成大矩阵" class="headerlink" title="利用已建好的小矩阵拼接成大矩阵"></a>利用已建好的小矩阵拼接成大矩阵</h4><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>:<span class="hljs-number">2</span>:<span class="hljs-number">6</span>;<span class="hljs-number">2</span>:<span class="hljs-number">2</span>:<span class="hljs-number">6</span>];<br>b=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];<br>c=[a;b]<br></code></pre></td></tr></table></figure><h3 id="矩阵的拆分"><a href="#矩阵的拆分" class="headerlink" title="矩阵的拆分"></a>矩阵的拆分</h3><h4 id="直接通过下标来引用"><a href="#直接通过下标来引用" class="headerlink" title="直接通过下标来引用"></a>直接通过下标来引用</h4><p>如<code>a(3,2)</code>表示a矩阵第3行第2列元素,通常情况下,是对矩阵的单个元素进行赋值或其他操作</p><p><strong>如果给出的行下标或者列下标大于原矩阵的行数和列数,则matlab将自动扩展原来的矩阵,并将扩展后未赋值的元素置为0</strong></p><h4 id="通过冒号表达式获得子矩阵"><a href="#通过冒号表达式获得子矩阵" class="headerlink" title="通过冒号表达式获得子矩阵"></a>通过冒号表达式获得子矩阵</h4><ol><li>可以直接用单个的冒号来作为行下标或列下标<ul><li><strong>a(i,:)</strong>表示a矩阵第i行的全部元素</li><li><strong>a(:,j)</strong>表示a矩阵第j列的全部元素</li><li><strong>a(i:i+m,j:j+k)</strong>表示a矩阵第i~i+m行,第j ~j+k列所有的元素</li></ul></li><li>速度比循环结构快</li><li>此外还可以用<strong>end</strong>关键字来表示某一维的末尾元素下标</li></ol><h4 id="利用空矩阵删除矩阵的元素"><a href="#利用空矩阵删除矩阵的元素" class="headerlink" title="利用空矩阵删除矩阵的元素"></a>利用空矩阵删除矩阵的元素</h4><p>在matlab中,定义[]为空矩阵,给变量x赋空矩阵的语句为</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">x=[]<br></code></pre></td></tr></table></figure><p><strong>x=[]与clear x不同,clear是将x从工作空间中删除,而空矩阵则存在于工作空间中,只是维数为0</strong></p><p>将矩阵中的某些元素删除,可以采用空矩阵的方法,例如:</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>;<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>;<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>];<br>a(:,<span class="hljs-number">2</span>:<span class="hljs-number">4</span>)=[]       <span class="hljs-comment">%删除a的第2~4列元素</span><br>a(:,[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>])=[]      <span class="hljs-comment">%删除a的第2列和第4列元素</span><br></code></pre></td></tr></table></figure><h4 id="改变矩阵的形状"><a href="#改变矩阵的形状" class="headerlink" title="改变矩阵的形状"></a>改变矩阵的形状</h4><p>reshape(a,m,n)函数在矩阵总元素保持不变的前提下,将矩阵a重新排成m*n的二维矩阵</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab">x=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br>y=<span class="hljs-built_in">reshape</span>(a,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>);<br>y =<br><br>          <span class="hljs-number">1.00</span>          <span class="hljs-number">4.00</span>          <span class="hljs-number">7.00</span><br>          <span class="hljs-number">2.00</span>          <span class="hljs-number">5.00</span>          <span class="hljs-number">8.00</span><br>          <span class="hljs-number">3.00</span>          <span class="hljs-number">6.00</span>          <span class="hljs-number">9.00</span><br></code></pre></td></tr></table></figure><ol><li>在matlab中,矩阵元素<strong>按列存储</strong>,即首先存储矩阵第1列元素,然后存储第2列元素,…一直到矩阵的最后一列元素</li><li>reshape函数只是改变原矩阵的行数和列数,即改变其逻辑结构,但并不改变原矩阵元素的个数及其存储结构</li></ol><h3 id="特殊矩阵"><a href="#特殊矩阵" class="headerlink" title="特殊矩阵"></a>特殊矩阵</h3><h4 id="通用的特殊矩阵"><a href="#通用的特殊矩阵" class="headerlink" title="通用的特殊矩阵"></a>通用的特殊矩阵</h4><div class="table-container"><table><thead><tr><th style="text-align:center">函数名</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">zeros</td><td style="text-align:center">产生全0矩阵(零矩阵)</td></tr><tr><td style="text-align:center">ones</td><td style="text-align:center">产生全1矩阵(幺矩阵)</td></tr><tr><td style="text-align:center">eye</td><td style="text-align:center">产生单位矩阵</td></tr><tr><td style="text-align:center">rand</td><td style="text-align:center">产生(0,1)区间均匀分布的随机矩阵</td></tr><tr><td style="text-align:center">randn</td><td style="text-align:center">产生均值为0,方差为1的标准正态分布随机矩阵</td></tr></tbody></table></div><p><strong>调用方式</strong></p><ol><li><strong>zeros(m)</strong>:产生m×m零矩阵</li><li><strong>zeros(n,m)</strong>:产生n×m零矩阵</li><li><strong>zeros(size(a))</strong>:产生与矩阵a同样大小的零矩阵</li><li><strong>20+(50-20)*rand(4,5)</strong>:产生4行5列在区间[20,50]内均匀分布的随机矩阵</li><li><strong>0.6+sqrt(0.1)*randn(4,5)</strong>:产生4行5列均值为0.6,方差为0.1的正态分布随机矩阵</li></ol><h4 id="用于专门学科的特殊矩阵"><a href="#用于专门学科的特殊矩阵" class="headerlink" title="用于专门学科的特殊矩阵"></a>用于专门学科的特殊矩阵</h4><ol><li><p>魔方矩阵</p><ul><li>调用函数magic(n)</li><li>每行每列及两条对角线上的元素之和都相等</li><li>其元素由1,2,3,…,n^2^共n^2^个元素组成</li></ul></li><li><p>范德蒙矩阵</p><ul><li>调用函数vander(<strong>V</strong>)</li><li>范德蒙矩阵最后一列全为1,倒数第2列为一个指定的向量,其它各列是其后一列与倒数第2列对应元素的乘积</li><li><strong>V</strong>为一个指定的向量</li></ul></li><li><p>希尔伯特矩阵</p><ul><li>调用函数hilb(n)</li><li>求希尔伯特逆矩阵的函数 invhilb(n)</li><li>希尔伯特矩阵是一种数学变换矩阵,它的每个元素h~ij~=1/(i+j-1)</li><li>希尔伯特矩阵是一个高度病态的矩阵,即任何一个元素发生微小变动,整个矩阵的值和逆矩阵都会发生很大的变化,病态程度和阶数有关</li></ul></li><li><p>托普利兹矩阵</p><ul><li>调用函数toeplitz(x,y)</li><li>托普利兹矩阵除第1行和第1列外,其他每个元素都与左上角的元素相同</li><li>toeplitz(1:6)用向量[1:6]生成一个对称的托普利兹矩阵</li></ul></li><li><p>伴随矩阵</p><p>设多项式p(x)为:</p><script type="math/tex; mode=display">p\left( x\right) =a_{n}x^{n}+a_{n-1}x^{n-1}+...a_{1}x+a_{0}</script><ul><li>调用函数compan(p)</li><li>其中p是系数向量,高次幂系数排在前,低次幂排在后</li></ul></li><li><p>帕斯卡矩阵</p><ul><li>调用函数pascal(n)</li><li>杨辉三角形组成的矩阵称为帕斯卡矩阵</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab学习笔记(3)</title>
      <link href="/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3/"/>
      <url>/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3/</url>
      
        <content type="html"><![CDATA[<p><strong>matlab学习笔记(3)注意介绍了以下内容:</strong></p><ol><li>常用函数</li><li>常用数学函数</li><li>数据的输出格式</li><li>常用快捷键(mac系统)</li><li>预定义变量</li><li>注意点</li></ol><a id="more"></a><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><ol><li><p>画图函数</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-built_in">plot</span>(自变量,函数,自变量,函数)<br></code></pre></td></tr></table></figure></li><li><p>求根函数</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">roots(p)<br></code></pre></td></tr></table></figure></li></ol><ol><li>求积分<script type="math/tex; mode=display">\int ^{1}_{0}x\ln \left( 1+x\right) dx</script></li></ol><ul><li><p>方法一</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">f=@(x)x.*<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>+x);<br>integral(f,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></li><li><p>方法二</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">syms x<br>int(x*<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>+x),<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure></li></ul><ol><li>求解线性方程组</li></ol><script type="math/tex; mode=display">\begin{cases}2x-3y+z=4\\\8x+3y+2z=2\\\45x+y-9z=17\end{cases}</script><ul><li><p>方法一</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">a=[<span class="hljs-number">2</span>,<span class="hljs-number">-3</span>,<span class="hljs-number">1</span>;<span class="hljs-number">8</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>;<span class="hljs-number">45</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-9</span>];<br>b=[<span class="hljs-number">4</span>;<span class="hljs-number">2</span>;<span class="hljs-number">17</span>];<br>x=inv(a)*b<br></code></pre></td></tr></table></figure></li><li><p>方法二</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs matlab">syms x y z<br>[x,y,z]=solve(<span class="hljs-number">2</span>*x<span class="hljs-number">-3</span>*y+z<span class="hljs-number">-4</span>,<span class="hljs-number">8</span>*x+<span class="hljs-number">3</span>*y+<span class="hljs-number">2</span>*z<span class="hljs-number">-2</span>,<span class="hljs-number">45</span>*x+y<span class="hljs-number">-9</span>*z<span class="hljs-number">-17</span>)<br></code></pre></td></tr></table></figure></li></ul><h2 id="常用数学函数"><a href="#常用数学函数" class="headerlink" title="常用数学函数"></a>常用数学函数</h2><div class="table-container"><table><thead><tr><th style="text-align:center">函数名</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">sin/sind</td><td style="text-align:center">正弦函数,输入值为弧度/角度</td></tr><tr><td style="text-align:center">cos/cosd</td><td style="text-align:center">余弦函数,输入值为弧度/角度</td></tr><tr><td style="text-align:center">tan/tand</td><td style="text-align:center">正切函数,输入值为弧度/角度</td></tr><tr><td style="text-align:center">asin/asind</td><td style="text-align:center">反正弦函数,输入值为弧度/角度</td></tr><tr><td style="text-align:center">acos/acosd</td><td style="text-align:center">反余弦函数,输入值为弧度/角度</td></tr><tr><td style="text-align:center">atan/atand</td><td style="text-align:center">反正切函数,输入值为弧度/角度</td></tr><tr><td style="text-align:center">sinh/asinh</td><td style="text-align:center">双曲正弦函数/反双曲正弦函数</td></tr><tr><td style="text-align:center">cosh/acosh</td><td style="text-align:center">双曲余弦函数/反双曲余弦函数</td></tr><tr><td style="text-align:center">tanh/atanh</td><td style="text-align:center">双曲正切函数/反双曲正切函数</td></tr><tr><td style="text-align:center">sqrt</td><td style="text-align:center">平方根函数</td></tr><tr><td style="text-align:center">log</td><td style="text-align:center">自然对数函数</td></tr><tr><td style="text-align:center">log10</td><td style="text-align:center">以10为底的对数函数</td></tr><tr><td style="text-align:center">log2</td><td style="text-align:center">以2为底的对数函数</td></tr><tr><td style="text-align:center">exp</td><td style="text-align:center">自然指数函数</td></tr><tr><td style="text-align:center">pow2</td><td style="text-align:center">2的幂</td></tr><tr><td style="text-align:center">abs</td><td style="text-align:center">绝对值函数</td></tr><tr><td style="text-align:center">rem</td><td style="text-align:center">求余</td></tr><tr><td style="text-align:center">mod</td><td style="text-align:center">求模</td></tr><tr><td style="text-align:center">fix</td><td style="text-align:center">向零方向取整</td></tr><tr><td style="text-align:center">floor</td><td style="text-align:center">向下取整</td></tr><tr><td style="text-align:center">ceil</td><td style="text-align:center">向上取整</td></tr><tr><td style="text-align:center">round</td><td style="text-align:center">四舍五入到最邻近的整数</td></tr><tr><td style="text-align:center">sign</td><td style="text-align:center">符号函数</td></tr><tr><td style="text-align:center">gcd</td><td style="text-align:center">最大公约数</td></tr><tr><td style="text-align:center">lcm</td><td style="text-align:center">最小公倍数</td></tr><tr><td style="text-align:center">factorial</td><td style="text-align:center">阶乘</td></tr><tr><td style="text-align:center">isprime</td><td style="text-align:center">判断是否为素数</td></tr><tr><td style="text-align:center">primes</td><td style="text-align:center">生成素数序列</td></tr><tr><td style="text-align:center">perms</td><td style="text-align:center">生成所有排列</td></tr><tr><td style="text-align:center">randperm</td><td style="text-align:center">生成任意排列</td></tr></tbody></table></div><h2 id="数据的输出格式"><a href="#数据的输出格式" class="headerlink" title="数据的输出格式"></a>数据的输出格式</h2><p><strong>format命令只影响数据输出格式,而不影响数据的计算和存储</strong></p><p>format命令格式为:</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">format 格式符<br></code></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center">格式符</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">short</td><td style="text-align:center">输出小数点后4位,最多不超过7位有效数字<br>对于大于1000的实数,用5位有效数字的科学记数形式输出</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">15位有效数字形式输出</td></tr><tr><td style="text-align:center">short e</td><td style="text-align:center">5位有效数字的科学记数形式输出</td></tr><tr><td style="text-align:center">long e</td><td style="text-align:center">15位有效数字的科学记数形式输出</td></tr><tr><td style="text-align:center">short g</td><td style="text-align:center">从short到short e中自动选择最佳输出方式</td></tr><tr><td style="text-align:center">long g</td><td style="text-align:center">从long到long e中自动选择最佳输出方式</td></tr><tr><td style="text-align:center">rat</td><td style="text-align:center">近似有理数表示</td></tr><tr><td style="text-align:center">hex</td><td style="text-align:center">十六进制表示</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">正数,负数,零分别用+,-,空格表示</td></tr><tr><td style="text-align:center">bank</td><td style="text-align:center">银行格式,用元角分表示</td></tr><tr><td style="text-align:center">compact</td><td style="text-align:center">输出变量之间没有空行</td></tr><tr><td style="text-align:center">loose</td><td style="text-align:center">输出变量之间有空行</td></tr></tbody></table></div><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><div class="table-container"><table><thead><tr><th style="text-align:center">组合键</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">⌘ +k</td><td style="text-align:center">清除命令行窗口</td></tr><tr><td style="text-align:center">esc</td><td style="text-align:center">删除当前行命令</td></tr><tr><td style="text-align:center">control+c</td><td style="text-align:center">中断当前任务</td></tr><tr><td style="text-align:center">tab</td><td style="text-align:center">代码补全</td></tr></tbody></table></div><h2 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h2><div class="table-container"><table><thead><tr><th style="text-align:center">预定义变量</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">ans</td><td style="text-align:center">计算结果的默认赋值变量</td></tr><tr><td style="text-align:center">eps</td><td style="text-align:center">机器零阈值</td></tr><tr><td style="text-align:center">pi</td><td style="text-align:center">圆周率π的近似值</td></tr><tr><td style="text-align:center">i,j</td><td style="text-align:center">虚数单位</td></tr><tr><td style="text-align:center">inf,Inf</td><td style="text-align:center">无穷大</td></tr><tr><td style="text-align:center">NaN,nan</td><td style="text-align:center">非数</td></tr><tr><td style="text-align:center">nargin</td><td style="text-align:center">函数输入参数个数</td></tr><tr><td style="text-align:center">nargout</td><td style="text-align:center">函数输出参数个数</td></tr><tr><td style="text-align:center">realmax</td><td style="text-align:center">最大正实数</td></tr><tr><td style="text-align:center">realmin</td><td style="text-align:center">最小正实数</td></tr><tr><td style="text-align:center">lasterr</td><td style="text-align:center">存放最新的错误信息</td></tr><tr><td style="text-align:center">lastwarn</td><td style="text-align:center">存放最新的警告信息</td></tr></tbody></table></div><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ol><li><p>matlab变量名</p><p>变量名<strong>只能以字母开头</strong>,后接字母,数字或下划线,变量名区分大小写</p></li><li><p>注释</p><p>使用<strong>%</strong>进行注释</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab学习笔记(2)</title>
      <link href="/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/"/>
      <url>/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/</url>
      
        <content type="html"><![CDATA[<p><strong>matlab学习笔记(2)主要介绍了以下内容:</strong></p><ol><li>数值类型<ul><li>整数类型</li><li>浮点数类型</li><li>复数</li><li>无穷量和非数值量</li></ul></li><li>逻辑类型</li><li>字符和字符串</li><li>函数句柄</li><li>结构体</li><li>数组类型</li><li>单元数组类型</li></ol><a id="more"></a><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><div class="table-container"><table><thead><tr><th style="text-align:center">数据格式</th><th style="text-align:center">示例</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">int8,uint8<br>int16,uint16<br>int32,uint32<br>int64,uint64</td><td style="text-align:center">int8(20)</td><td style="text-align:left">有符号和无符号的整数类型<br>相同数值的整数类型比浮点数占更少内存<br>除了int64和uint64类型外的所有整数类型,都可以进行数学运算</td></tr><tr><td style="text-align:center">single</td><td style="text-align:center">single(128.1)</td><td style="text-align:left">单精度浮点数<br>相同数值的单精度浮点数比双精度浮点数占更少内存<br>单精度浮点数类型能够表示的范围和精度都比双精度浮点数少</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">333.77<br>1.000-1.000i</td><td style="text-align:left">双精度浮点数<br>matlab中默认的数值类型</td></tr></tbody></table></div><p><strong>说明</strong></p><ol><li>matlab中数值类型的数据包括<strong>有符号</strong>和<strong>无符号</strong>整数,<strong>单精度浮点数</strong>和<strong>双精度浮点数</strong></li><li>在未加说明与特殊定义时,<strong>matlab对所有数值按照双精度浮点数类型进行存储和操作</strong></li><li>相对于双精度浮点数,整数和单精度浮点数的优点在于节省变量占用的内存空间</li><li>matlab会自动进行记忆体的使用和回收,而不像c语言那样,必须由使用者一一指定</li></ol><h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><div class="table-container"><table><thead><tr><th style="text-align:center">转换函数</th><th style="text-align:center">数值范围</th></tr></thead><tbody><tr><td style="text-align:center">int8</td><td style="text-align:center">-2^7^~2^7^-1</td></tr><tr><td style="text-align:center">uint8</td><td style="text-align:center">0~2^8^-1</td></tr><tr><td style="text-align:center">int16</td><td style="text-align:center">-2^15^~2^15^-1</td></tr><tr><td style="text-align:center">uint16</td><td style="text-align:center">0~2^16^-1</td></tr><tr><td style="text-align:center">int32</td><td style="text-align:center">-2^31^~2^31^-1</td></tr><tr><td style="text-align:center">uint32</td><td style="text-align:center">0~2^32^-1</td></tr><tr><td style="text-align:center">int64</td><td style="text-align:center">-2^63^~2^63^-1</td></tr><tr><td style="text-align:center">uint64</td><td style="text-align:center">0~2^64^-1</td></tr></tbody></table></div><p><strong>注意</strong></p><ol><li>由于<strong>matlab默认是double类型</strong>,将数值转化为整数时,遵循四舍六入,当小数部分为0.5时,则会转化为绝对值较大的那个整数</li><li>这些转换函数也可以将其他数据类型转换为指定的整数类型</li><li>在不超过数值范围的情况下,任意两个整数类型之间也可以通过转换函数进行互相转换</li><li>由于不同的整数类型能够表示的数值范围不同,因此当结果超出相应的整数类型能够表示的范围时,就会出现一处错误,运算结果被置为该整数能够表示的最大值或最小值</li></ol><h5 id="取整函数"><a href="#取整函数" class="headerlink" title="取整函数"></a>取整函数</h5><div class="table-container"><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">运算法则</th><th style="text-align:center">示例</th></tr></thead><tbody><tr><td style="text-align:center">floor(x)</td><td style="text-align:center">向下取整</td><td style="text-align:center">floor(1.2)=1<br>floor(-1.2)=-2</td></tr><tr><td style="text-align:center">ceil(x)</td><td style="text-align:center">向上取整</td><td style="text-align:center">ceil(1.2)=2<br>ceil(-1.2)=-1</td></tr><tr><td style="text-align:center">round(x)</td><td style="text-align:center">取最接近的整数<br>如果小数部分是0.5,则向绝对值大的方向取整</td><td style="text-align:center">round(1.2)=1<br>round(1.6)=2<br>round(-1.2)=-1<br>round(-1.6)=-2<br>round(-1.5)=-2</td></tr><tr><td style="text-align:center">fix(x)</td><td style="text-align:center">向0取整</td><td style="text-align:center">fix(1.2)=1<br>fix(1.6)=1<br>fix(-1.2)=-1<br>fix(-1.6)=-1</td></tr></tbody></table></div><h4 id="浮点数类型"><a href="#浮点数类型" class="headerlink" title="浮点数类型"></a>浮点数类型</h4><div class="table-container"><table><thead><tr><th style="text-align:center">浮点类型</th><th style="text-align:center">存储位宽</th><th style="text-align:center">各数位的含义</th><th style="text-align:center">数值范围</th><th style="text-align:center">转换函数</th></tr></thead><tbody><tr><td style="text-align:center">单精度</td><td style="text-align:center">32</td><td style="text-align:center">0~22位表示小数部分 <br>23~30位表示指数部分<br>31位表示符号(0正1负)</td><td style="text-align:center">-3.40282e+038 ~ -1.17549e-038<br>1.17549e-038 ~ 3.40282e+038</td><td style="text-align:center">single</td></tr><tr><td style="text-align:center">双精度</td><td style="text-align:center">64</td><td style="text-align:center">0~51位表示小数部分 <br>52~62位表示指数部分<br>63位表示符号(0正1负)</td><td style="text-align:center">-1.79769e+308 ~ -2.22507e-308<br>2.22507e-308 ~ 1.79769+308</td><td style="text-align:center">Double</td></tr></tbody></table></div><p><strong>注意</strong></p><ol><li>matlab中默认数值类型为双精度浮点类型,因此与创建整数类型数值一样,也可以通过转换函数来实现创建单精度浮点类型</li><li>双精度浮点数参与运算时,返回值得类型依赖于参与运算的其他数据类型<ul><li>参与运算的其他数据为<strong>逻辑型</strong>,<strong>字符型</strong>时,返回<strong>双精度浮点型</strong></li><li>参与运算的其他数据为<strong>整数型</strong>时,返回相应的<strong>整数类型</strong></li><li>参与运算的其他数据为<strong>单精度浮点型</strong>时,返回相应的<strong>单精度浮点型</strong></li></ul></li><li><strong>matlab中,单精度浮点型不能与整数进行算数运算</strong></li><li>由于浮点数只占用一定的存储位宽,其中只有有限位分别用来存储指数部分和小数部分,因此,浮点类型能够表示的实际数值是有限且离散的,任何两个最近相邻的浮点数之间都有微小间隙,而处在间隙中的数值都只能用这两个相邻的浮点数之中的一个来表示(matlab中提供eps函数:可以获得一个数值和最接近该数值的浮点数之间的间隙)</li></ol><h4 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h4><p>复数包括<strong>实部和虚部</strong>两部分,matlab中<strong>默认使用字符i或j作为虚部标志</strong>,创建复数时,可以直接按照复数形式进行输入或者利用complex函数</p><div class="table-container"><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">real(z)</td><td style="text-align:center">返回复数z的实部</td></tr><tr><td style="text-align:center">imag(z)</td><td style="text-align:center">返回复数z的虚部</td></tr><tr><td style="text-align:center">abs(z)</td><td style="text-align:center">返回复数z的模</td></tr><tr><td style="text-align:center">angle(z)</td><td style="text-align:center">返回复数z的辐角</td></tr><tr><td style="text-align:center">conj(z)</td><td style="text-align:center">返回复数z的共轭复数</td></tr><tr><td style="text-align:center">complex(a,b)</td><td style="text-align:center">以a为实部,b为虚部创建复数</td></tr></tbody></table></div><h4 id="无穷量-Inf-和非数值量-NaN"><a href="#无穷量-Inf-和非数值量-NaN" class="headerlink" title="无穷量(Inf)和非数值量(NaN)"></a>无穷量(Inf)和非数值量(NaN)</h4><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">Inf</td><td style="text-align:center">正无穷量</td></tr><tr><td style="text-align:center">-Inf</td><td style="text-align:center">负无穷量</td></tr><tr><td style="text-align:center">NaN</td><td style="text-align:center">非数值量</td></tr></tbody></table></div><p><strong>注意</strong></p><ol><li>正负无穷量一般都是由于运算溢出,产生了超出双精度浮点数数值范围的结果</li><li>非数值量一般都是由于0/0,Inf/Inf或者Inf-Inf造成的,这三个NaN彼此不相等</li><li>除了异常运算结果外,matlab还提供了特定函数Inf和NaN来创建指定数值类型的无穷量和非数值量,生成结果默认为双精度浮点类型中还有一种特殊的指数类型的数据叫做非数,通常表示运算得到的数值结果超出了运算范围,非数的实部用NaN表示,虚部用Inf表示</li></ol><h3 id="逻辑类型"><a href="#逻辑类型" class="headerlink" title="逻辑类型"></a>逻辑类型</h3><p>matlab把任何非零数值当做真,把零当做假.</p><p>所有关系和逻辑表达式的输出:对于真,输出1;对于假,输出0</p><div class="table-container"><table><thead><tr><th style="text-align:center">关系操作符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">&lt;</td><td style="text-align:center">小于</td></tr><tr><td style="text-align:center">&lt;=</td><td style="text-align:center">小于等于</td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:center">大于</td></tr><tr><td style="text-align:center">&gt;=</td><td style="text-align:center">大于等于</td></tr><tr><td style="text-align:center">==</td><td style="text-align:center">等于</td></tr><tr><td style="text-align:center">~=</td><td style="text-align:center">不等于</td></tr></tbody></table></div><p>matlab关系操作符能用来比较两个同样大小的数组,或用来比较一个数组和一个标量,在后一种情况中,标量和数组中的每一个元素相比较,结果与数组大小一样</p><div class="table-container"><table><thead><tr><th style="text-align:center">逻辑运算符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">&amp;</td><td style="text-align:center">与</td></tr><tr><td style="text-align:center">丨</td><td style="text-align:center">或</td></tr><tr><td style="text-align:center">~</td><td style="text-align:center">非</td></tr><tr><td style="text-align:center">xor(x,y)</td><td style="text-align:center">异或</td></tr><tr><td style="text-align:center">any(x)</td><td style="text-align:center">判断是否为零向量或者零矩阵</td></tr></tbody></table></div><h3 id="字符和字符串"><a href="#字符和字符串" class="headerlink" title="字符和字符串"></a>字符和字符串</h3><ol><li>在matlab中,<strong>文本</strong>当做特征字符串或简单地当做字符串</li><li>字符串能够<strong>显示在屏幕上</strong>,也可以<strong>用来构成一些命令</strong>,这些命令在其他的命令中用于求值或者被执行</li><li>一个字符串是存储在一个行向量中的文本,这个行向量中的每一个元素代表一个字符,实际上,元素中存放的是字符的ASCII码</li><li>在屏幕上显示字符变量的值时,显示出来的是文本,而不是ASCII数字</li><li>由于字符串是以向量的形式来存储的,因此可以通过它的下标对字符串中的任何一个元素进行访问,字符矩阵也可以通过下标索引进行访问,但是矩阵的每行字符数必须相同</li><li>一个字符串是由<strong>单引号</strong>括起来的简单文本</li><li>在字符串里的每个字符是数组里的一个元素,字符串的存储要求<strong>每个字符占8个字节</strong></li><li>字符串基本操作(以s=‘123456789’ 为例)</li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:left">输出</th></tr></thead><tbody><tr><td style="text-align:center">u=abs(s)</td><td style="text-align:left">u =[49,50,51,52,53,54,55,56,57]</td></tr><tr><td style="text-align:center">s=s+0</td><td style="text-align:left">s =[49,50,51,52,53,54,55,56,57]</td></tr><tr><td style="text-align:center">u=s(4:9)</td><td style="text-align:left">u=‘456789’</td></tr><tr><td style="text-align:center">u=s(9:-2:3)</td><td style="text-align:left">u=‘9753’</td></tr><tr><td style="text-align:center">输入s=I’’am Bob.</td><td style="text-align:left">s=I’m Bob</td></tr><tr><td style="text-align:center">u=[s ‘87654321’]</td><td style="text-align:left">u=‘12345678987654321’</td></tr></tbody></table></div><h3 id="函数句柄"><a href="#函数句柄" class="headerlink" title="函数句柄"></a>函数句柄</h3><p>在matlab中调用函数分为直接调用和间接调用</p><ul><li><p>直接调用</p><ul><li>被调函数被称为子函数</li><li>子函数只能被与其M文件同名的主函数或在M文件中的其他函数所调用</li><li>在一个文件中只能有一个主函数</li></ul></li><li><p>间接调用(函数句柄)</p><ul><li>避免了直接调用的限制(第二条)</li><li>创建函数句柄时需要用到操作符@</li><li>对任意函数都可以创造函数句柄</li><li>创建函数句柄的一般语法格式<ul><li>Function_Handle = @Function_Filename</li><li>Function_Filename是函数所对应的M文件的名称或matlab内部函数的名称</li><li>@是句柄创建操作符</li><li>Function_Handle变量保存了这一函数句柄,并在后续的运算中作为数据流进行传递</li><li>例:F_Handle=@cos 就创建了matlab内部函数cos的句柄,并将其保存在F_Handle变量中,后续的运算过程中就可以通过F_Handle(x)来实现cos(x)的功能</li><li>通过函数句柄调用函数时,也需要指定函数的输入参数(跟原来的那个函数调用一致)</li></ul></li></ul></li><li>函数句柄的操作函数</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">函数名称</th><th style="text-align:left">函数功能</th></tr></thead><tbody><tr><td style="text-align:center">functions(funhandle)</td><td style="text-align:left">返回一个结构体<br>包含函数的名称(function),函数类型(type),以及函数M文件的位置(file)</td></tr><tr><td style="text-align:center">func2str(funhandle)</td><td style="text-align:left">将函数句柄转换为函数名称的字符串</td></tr><tr><td style="text-align:center">str2func(str)</td><td style="text-align:left">将字符串代表的函数转换为函数句柄</td></tr><tr><td style="text-align:center">save filename.mat funhandle</td><td style="text-align:left">将函数句柄保存在*.mat文件中</td></tr><tr><td style="text-align:center">load filename.mat funhandle</td><td style="text-align:left">把*.mat文件中存储的函数句柄加载到工作区</td></tr><tr><td style="text-align:center">isa(var,’function_handle’)</td><td style="text-align:left">检测变量var是否是函数句柄</td></tr><tr><td style="text-align:center">isequal(funhandle1,funhandle2)</td><td style="text-align:left">检测两个函数句柄是否对应于同一个函数</td></tr></tbody></table></div><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><ul><li><p>创建结构体</p><ul><li><p>直接通过赋值语句给结构体的字段赋值</p><figure class="hljs highlight Matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Matlab">student.name=<span class="hljs-string">'sam'</span>;<br>student.grade=<span class="hljs-number">6</span>;<br>student.subject=&#123;<span class="hljs-string">'Chinese'</span>,<span class="hljs-string">'Math'</span>,<span class="hljs-string">'English'</span>&#125;;<br>student.result=&#123;<span class="hljs-number">99</span>,<span class="hljs-number">99</span>,<span class="hljs-number">99</span>&#125;;<br></code></pre></td></tr></table></figure><p><strong>注意</strong></p></li></ul><ol><li>在进行字段赋值时,没有明确赋值的字段,matlab默认赋值为空数组</li><li>通过圆括号索引进行字段赋值,还可以创建任意尺寸的结构体数组</li><li>同一个结构体数组中所有结构体对象具有相同的字段组合</li></ol><ul><li>利用struct函数创建结构体<ul><li>node = struct(‘field1’,var1,’field2’,var2,…,’fieldn’,varn)</li><li>数组  node(2) =struct(‘field1’,var1,’field2’,var2,…,’fieldn’,varn)</li><li>重复写入node = repmat(struct(‘day’,’thursday’,’time’),==1,2==)</li></ul></li></ul></li></ul><h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><p>matlab中进行运算的所有数据类型,都是按照数组及矩阵的形式进行存储和运算的,而二者在matlab中的基本运算性质不同,陈列强调元素对元素的运算,而矩阵则采用线性代数的运算方式</p><ul><li>数组定义 a=[1 2 3 4 5]</li><li>冒号定义<ul><li>a=1:10<br>a=[1 2 3 4 5 6 7 8 9 10]</li><li>a=1:2:10<br>a=[1 3 5 7 9]</li><li>a=linspace(a,b,100)<br>在区间[a,b]上创建一个有100个元素的向量,这100个数把整个区间线性分隔</li></ul></li></ul><h3 id="单元数组类型"><a href="#单元数组类型" class="headerlink" title="单元数组类型"></a>单元数组类型</h3><p>单元(cell)数组是一种无所不包的广义矩阵,组成单元数组的每一个元素称为一个单元,每一个单元可以包括一个任意数组,如数值数组,字符串数组,结构体数组或另外一个单元数组,因而每一个单元可以具有不同的尺寸和内存占用空间.</p><p><strong>注意</strong>:<strong>和一般的数值数组一样,单元数组的维数不受限制,可以是一维,二维或多维</strong></p><h4 id="单元数组的创建"><a href="#单元数组的创建" class="headerlink" title="单元数组的创建"></a>单元数组的创建</h4><ol><li><p>使用赋值语句创建单元数组</p><p>单元数组使用花括号”{}”来创建,使用逗号”,”或空格来分隔每一个单元,使用”;”来分行</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">c=&#123;<span class="hljs-string">'haha'</span>,[<span class="hljs-number">1</span>;<span class="hljs-number">2</span>;<span class="hljs-number">3</span>];<span class="hljs-number">10</span>,<span class="hljs-built_in">pi</span>&#125;<br></code></pre></td></tr></table></figure></li><li><p>利用cell函数创建空单元数组</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">cellname=cell(m,n)<br></code></pre></td></tr></table></figure><p>该函数创建一个m*n的空单元数组,其每一个单元均为空矩阵</p></li></ol><h4 id="单元数组的寻访"><a href="#单元数组的寻访" class="headerlink" title="单元数组的寻访"></a>单元数组的寻访</h4><p>在单元数组中,单元和单元中的内容是两个不同范畴的东西,因此,寻访单元和单元中的内容是两个不同的操作,matlab为上述两种操作设计了相对应的操作对象:单元外标识(Cell Indexing)和单元内编址(Content Addressing)</p><p>对于单元数组c,c(m,n)指的是单元数组中第m行第n列的单元,而c{m,n}指的是单元数组中第m行第n列单元中的内容</p><h4 id="单元数组的操作"><a href="#单元数组的操作" class="headerlink" title="单元数组的操作"></a>单元数组的操作</h4><ol><li><p>单元数组的合并</p><p><code>c={a b}</code></p></li><li><p>单元数组的删除</p><p>如果要删除单元数组中指定的某个单元,只需把空矩阵赋给该单元即可</p><p><code>c{m,n}=[]</code></p></li><li><p>使用reshape函数改变单元数组的形状</p><p><code>trimc = reshape(c,M,N)</code></p><p>该函数将单元数组c改变成一个具有M行N列的新单元数组</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab学习笔记(1)</title>
      <link href="/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/"/>
      <url>/2018/04/30/matlab%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</url>
      
        <content type="html"><![CDATA[<p><strong>matlab学习笔记(1)主要介绍了以下内容</strong></p><ol><li>matlab的命令行通用命令</li><li>如何设置matlab调用文件的搜索路径</li><li>matlab的帮助系统</li></ol><a id="more"></a><h2 id="命令行通用命令"><a href="#命令行通用命令" class="headerlink" title="命令行通用命令"></a>命令行通用命令</h2><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">命令说明</th></tr></thead><tbody><tr><td style="text-align:center">cd</td><td style="text-align:center">显示或改变当前文件夹的地址</td></tr><tr><td style="text-align:center">dir</td><td style="text-align:center">显示当前文件夹或指定目录下的文件</td></tr><tr><td style="text-align:center">clc</td><td style="text-align:center">清除命令行中命令</td></tr><tr><td style="text-align:center">home</td><td style="text-align:center">将当前输入放到最上面</td></tr><tr><td style="text-align:center">clf</td><td style="text-align:center">清除图形窗口</td></tr><tr><td style="text-align:center">type</td><td style="text-align:center">显示文件内容</td></tr><tr><td style="text-align:center">clear</td><td style="text-align:center">清理工作区变量</td></tr><tr><td style="text-align:center">load</td><td style="text-align:center">加载指定文件的变量</td></tr><tr><td style="text-align:center">diary</td><td style="text-align:center">日志文件命令</td></tr><tr><td style="text-align:center">!</td><td style="text-align:center">调用dos命令</td></tr><tr><td style="text-align:center">exit</td><td style="text-align:center">退出matlab</td></tr><tr><td style="text-align:center">pack</td><td style="text-align:center">收集内存碎片</td></tr><tr><td style="text-align:center">hold</td><td style="text-align:center">图形保持开关</td></tr><tr><td style="text-align:center">path</td><td style="text-align:center">显示搜索目录</td></tr><tr><td style="text-align:center">save</td><td style="text-align:center">保存工作区变量到指定文件</td></tr></tbody></table></div><h3 id="标点"><a href="#标点" class="headerlink" title="标点"></a>标点</h3><div class="table-container"><table><thead><tr><th style="text-align:center">标点</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">:</td><td style="text-align:center">冒号,具有多种应用功能</td></tr><tr><td style="text-align:center">;</td><td style="text-align:center">分号,区分行及取消运行结果显示</td></tr><tr><td style="text-align:center">,</td><td style="text-align:center">逗号,区分列及函数参数分隔符</td></tr><tr><td style="text-align:center">()</td><td style="text-align:center">括号,指定运算的优先级</td></tr><tr><td style="text-align:center">[]</td><td style="text-align:center">方括号,定义矩阵</td></tr><tr><td style="text-align:center">{}</td><td style="text-align:center">大括号,构造单元数组</td></tr><tr><td style="text-align:center">%</td><td style="text-align:center">百分号,注释</td></tr><tr><td style="text-align:center">!</td><td style="text-align:center">感叹号,赋值标记</td></tr><tr><td style="text-align:center">=</td><td style="text-align:center">等号,赋值标记</td></tr><tr><td style="text-align:center">‘</td><td style="text-align:center">单引号,字符串的标识符</td></tr><tr><td style="text-align:center">.</td><td style="text-align:center">小数点及对象域访问</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">续行符号</td></tr></tbody></table></div><h2 id="设置matlab调用文件的搜索路径"><a href="#设置matlab调用文件的搜索路径" class="headerlink" title="设置matlab调用文件的搜索路径"></a>设置matlab调用文件的搜索路径</h2><ol><li><p>为什么要设置</p><p>一般情况下,matlab系统的函数,包括工具箱函数,都是在系统默认的搜索路径之中的,但是用户设计的函数有可能没有保存到搜索路径下,很多情况容易造成matlab误认为该函数不存在,因此需要把程序所在的目录扩展成matlab的搜索路径即可.</p></li><li><p>如何设置</p><p>点击主页窗口的<code>设置路径</code>,点击<code>添加文件夹</code>,然后选择你的函数文件夹即可,建议建立一个大的文件夹,把所有的函数都放进去.</p><p><strong>注意:只有在matlab搜索路径中的函数才能被识别(可以调用path命令来查看搜索路径).并且当某一文件夹的父文件夹在搜索路径中而其本身不在搜索路径中时,则此文件夹不会被搜索到.</strong></p></li></ol><h2 id="帮助系统"><a href="#帮助系统" class="headerlink" title="帮助系统"></a>帮助系统</h2><ol><li><p>help命令</p><p>调用格式(以sin函数作为例子)</p><figure class="hljs highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">help <span class="hljs-built_in">sin</span><br></code></pre></td></tr></table></figure><p>调用后会显示简洁用法,以及详细的参考页,可以调用的不单单只是函数,还可以调用<code>pi</code>等常数</p></li><li><p>demos帮助</p><p>直接在命令行中输入<code>demo</code>,用户可以更加直观,快速地学习matlab实用知识.</p></li><li><p>帮助导航浏览器</p><p>帮助导航浏览器是matlab专门提供的一个独立的帮助子系统,该系统包含的所有帮助文件都存储在matlab安装目录下的help子目录下</p><p>打开方式:命令行中直接输入<code>doc</code></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
